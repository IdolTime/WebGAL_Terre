var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node2 of mutation.addedNodes) {
        if (node2.tagName === "LINK" && node2.rel === "modulepreload")
          processPreload(node2);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$f = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i2 = 0; i2 < 10; i2++) {
      test2["_" + String.fromCharCode(i2)] = i2;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
      return test2[n2];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
  var from2;
  var to = toObject(target);
  var symbols;
  for (var s2 = 1; s2 < arguments.length; s2++) {
    from2 = Object(arguments[s2]);
    for (var key in from2) {
      if (hasOwnProperty$f.call(from2, key)) {
        to[key] = from2[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from2);
      for (var i2 = 0; i2 < symbols.length; i2++) {
        if (propIsEnumerable.call(from2, symbols[i2])) {
          to[symbols[i2]] = from2[symbols[i2]];
        }
      }
    }
  }
  return to;
};
const objectAssign$1 = /* @__PURE__ */ getDefaultExportFromCjs(objectAssign);
var react = { exports: {} };
var react_production_min = {};
/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$4 = objectAssign, n$7 = 60103, p$7 = 60106;
react_production_min.Fragment = 60107;
react_production_min.StrictMode = 60108;
react_production_min.Profiler = 60114;
var q$6 = 60109, r$6 = 60110, t$6 = 60112;
react_production_min.Suspense = 60113;
var u$5 = 60115, v$4 = 60116;
if ("function" === typeof Symbol && Symbol.for) {
  var w$3 = Symbol.for;
  n$7 = w$3("react.element");
  p$7 = w$3("react.portal");
  react_production_min.Fragment = w$3("react.fragment");
  react_production_min.StrictMode = w$3("react.strict_mode");
  react_production_min.Profiler = w$3("react.profiler");
  q$6 = w$3("react.provider");
  r$6 = w$3("react.context");
  t$6 = w$3("react.forward_ref");
  react_production_min.Suspense = w$3("react.suspense");
  u$5 = w$3("react.memo");
  v$4 = w$3("react.lazy");
}
var x$3 = "function" === typeof Symbol && Symbol.iterator;
function y$3(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = x$3 && a2[x$3] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
function z$2(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var A$2 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, B$2 = {};
function C(a2, b2, c2) {
  this.props = a2;
  this.context = b2;
  this.refs = B$2;
  this.updater = c2 || A$2;
}
C.prototype.isReactComponent = {};
C.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
    throw Error(z$2(85));
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
C.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function D$2() {
}
D$2.prototype = C.prototype;
function E$2(a2, b2, c2) {
  this.props = a2;
  this.context = b2;
  this.refs = B$2;
  this.updater = c2 || A$2;
}
var F$2 = E$2.prototype = new D$2();
F$2.constructor = E$2;
l$4(F$2, C.prototype);
F$2.isPureReactComponent = true;
var G$2 = { current: null }, H$2 = Object.prototype.hasOwnProperty, I$2 = { key: true, ref: true, __self: true, __source: true };
function J(a2, b2, c2) {
  var e2, d2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (e2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      H$2.call(b2, e2) && !I$2.hasOwnProperty(e2) && (d2[e2] = b2[e2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    d2.children = c2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    d2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (e2 in g2 = a2.defaultProps, g2)
      void 0 === d2[e2] && (d2[e2] = g2[e2]);
  return { $$typeof: n$7, type: a2, key: k2, ref: h2, props: d2, _owner: G$2.current };
}
function K(a2, b2) {
  return { $$typeof: n$7, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function L$1(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === n$7;
}
function escape$2(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var M$2 = /\/+/g;
function N$2(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape$2("" + a2.key) : b2.toString(36);
}
function O$2(a2, b2, c2, e2, d2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2)
    a2 = null;
  var h2 = false;
  if (null === a2)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case n$7:
          case p$7:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, d2 = d2(h2), a2 = "" === e2 ? "." + N$2(h2, 0) : e2, Array.isArray(d2) ? (c2 = "", null != a2 && (c2 = a2.replace(M$2, "$&/") + "/"), O$2(d2, b2, c2, "", function(a3) {
      return a3;
    })) : null != d2 && (L$1(d2) && (d2 = K(d2, c2 + (!d2.key || h2 && h2.key === d2.key ? "" : ("" + d2.key).replace(M$2, "$&/") + "/") + a2)), b2.push(d2)), 1;
  h2 = 0;
  e2 = "" === e2 ? "." : e2 + ":";
  if (Array.isArray(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = e2 + N$2(k2, g2);
      h2 += O$2(k2, b2, c2, f2, d2);
    }
  else if (f2 = y$3(a2), "function" === typeof f2)
    for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = e2 + N$2(k2, g2++), h2 += O$2(k2, b2, c2, f2, d2);
  else if ("object" === k2)
    throw b2 = "" + a2, Error(z$2(31, "[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2));
  return h2;
}
function P$2(a2, b2, c2) {
  if (null == a2)
    return a2;
  var e2 = [], d2 = 0;
  O$2(a2, e2, "", "", function(a3) {
    return b2.call(c2, a3, d2++);
  });
  return e2;
}
function Q$1(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    a2._status = 0;
    a2._result = b2;
    b2.then(function(b3) {
      0 === a2._status && (b3 = b3.default, a2._status = 1, a2._result = b3);
    }, function(b3) {
      0 === a2._status && (a2._status = 2, a2._result = b3);
    });
  }
  if (1 === a2._status)
    return a2._result;
  throw a2._result;
}
var R$2 = { current: null };
function S$2() {
  var a2 = R$2.current;
  if (null === a2)
    throw Error(z$2(321));
  return a2;
}
var T$1 = { ReactCurrentDispatcher: R$2, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: G$2, IsSomeRendererActing: { current: false }, assign: l$4 };
react_production_min.Children = { map: P$2, forEach: function(a2, b2, c2) {
  P$2(a2, function() {
    b2.apply(this, arguments);
  }, c2);
}, count: function(a2) {
  var b2 = 0;
  P$2(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return P$2(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!L$1(a2))
    throw Error(z$2(143));
  return a2;
} };
react_production_min.Component = C;
react_production_min.PureComponent = E$2;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T$1;
react_production_min.cloneElement = function(a2, b2, c2) {
  if (null === a2 || void 0 === a2)
    throw Error(z$2(267, a2));
  var e2 = l$4({}, a2.props), d2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = G$2.current);
    void 0 !== b2.key && (d2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f2 in b2)
      H$2.call(b2, f2) && !I$2.hasOwnProperty(f2) && (e2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    e2.children = c2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    e2.children = g2;
  }
  return {
    $$typeof: n$7,
    type: a2.type,
    key: d2,
    ref: k2,
    props: e2,
    _owner: h2
  };
};
react_production_min.createContext = function(a2, b2) {
  void 0 === b2 && (b2 = null);
  a2 = { $$typeof: r$6, _calculateChangedBits: b2, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null };
  a2.Provider = { $$typeof: q$6, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = J;
react_production_min.createFactory = function(a2) {
  var b2 = J.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: t$6, render: a2 };
};
react_production_min.isValidElement = L$1;
react_production_min.lazy = function(a2) {
  return { $$typeof: v$4, _payload: { _status: -1, _result: a2 }, _init: Q$1 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: u$5, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.useCallback = function(a2, b2) {
  return S$2().useCallback(a2, b2);
};
react_production_min.useContext = function(a2, b2) {
  return S$2().useContext(a2, b2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useEffect = function(a2, b2) {
  return S$2().useEffect(a2, b2);
};
react_production_min.useImperativeHandle = function(a2, b2, c2) {
  return S$2().useImperativeHandle(a2, b2, c2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return S$2().useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return S$2().useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, c2) {
  return S$2().useReducer(a2, b2, c2);
};
react_production_min.useRef = function(a2) {
  return S$2().useRef(a2);
};
react_production_min.useState = function(a2) {
  return S$2().useState(a2);
};
react_production_min.version = "17.0.2";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
/** @license React v17.0.2
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$3 = reactExports, g$3 = 60103;
reactJsxRuntime_production_min.Fragment = 60107;
if ("function" === typeof Symbol && Symbol.for) {
  var h$5 = Symbol.for;
  g$3 = h$5("react.element");
  reactJsxRuntime_production_min.Fragment = h$5("react.fragment");
}
var m$5 = f$3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, n$6 = Object.prototype.hasOwnProperty, p$6 = { key: true, ref: true, __self: true, __source: true };
function q$5(c2, a2, k2) {
  var b2, d2 = {}, e2 = null, l2 = null;
  void 0 !== k2 && (e2 = "" + k2);
  void 0 !== a2.key && (e2 = "" + a2.key);
  void 0 !== a2.ref && (l2 = a2.ref);
  for (b2 in a2)
    n$6.call(a2, b2) && !p$6.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: g$3, type: c2, key: e2, ref: l2, props: d2, _owner: m$5.current };
}
reactJsxRuntime_production_min.jsx = q$5;
reactJsxRuntime_production_min.jsxs = q$5;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/** @license React v0.20.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  var f2, g2, h2, k2;
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p = Date, q2 = p.now();
    exports.unstable_now = function() {
      return p.now() - q2;
    };
  }
  if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
    var t2 = null, u2 = null, w2 = function() {
      if (null !== t2)
        try {
          var a2 = exports.unstable_now();
          t2(true, a2);
          t2 = null;
        } catch (b2) {
          throw setTimeout(w2, 0), b2;
        }
    };
    f2 = function(a2) {
      null !== t2 ? setTimeout(f2, 0, a2) : (t2 = a2, setTimeout(w2, 0));
    };
    g2 = function(a2, b2) {
      u2 = setTimeout(a2, b2);
    };
    h2 = function() {
      clearTimeout(u2);
    };
    exports.unstable_shouldYield = function() {
      return false;
    };
    k2 = exports.unstable_forceFrameRate = function() {
    };
  } else {
    var x = window.setTimeout, y2 = window.clearTimeout;
    if ("undefined" !== typeof console) {
      var z2 = window.cancelAnimationFrame;
      "function" !== typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
      "function" !== typeof z2 && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    }
    var A2 = false, B2 = null, C2 = -1, D2 = 5, E2 = 0;
    exports.unstable_shouldYield = function() {
      return exports.unstable_now() >= E2;
    };
    k2 = function() {
    };
    exports.unstable_forceFrameRate = function(a2) {
      0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
    };
    var F2 = new MessageChannel(), G2 = F2.port2;
    F2.port1.onmessage = function() {
      if (null !== B2) {
        var a2 = exports.unstable_now();
        E2 = a2 + D2;
        try {
          B2(true, a2) ? G2.postMessage(null) : (A2 = false, B2 = null);
        } catch (b2) {
          throw G2.postMessage(null), b2;
        }
      } else
        A2 = false;
    };
    f2 = function(a2) {
      B2 = a2;
      A2 || (A2 = true, G2.postMessage(null));
    };
    g2 = function(a2, b2) {
      C2 = x(function() {
        a2(exports.unstable_now());
      }, b2);
    };
    h2 = function() {
      y2(C2);
      C2 = -1;
    };
  }
  function H2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; ; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (void 0 !== e2 && 0 < I2(e2, b2))
          a2[d2] = b2, a2[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function J2(a2) {
    a2 = a2[0];
    return void 0 === a2 ? null : a2;
  }
  function K2(a2) {
    var b2 = a2[0];
    if (void 0 !== b2) {
      var c2 = a2.pop();
      if (c2 !== b2) {
        a2[0] = c2;
        a:
          for (var d2 = 0, e2 = a2.length; d2 < e2; ) {
            var m2 = 2 * (d2 + 1) - 1, n2 = a2[m2], v2 = m2 + 1, r2 = a2[v2];
            if (void 0 !== n2 && 0 > I2(n2, c2))
              void 0 !== r2 && 0 > I2(r2, n2) ? (a2[d2] = r2, a2[v2] = c2, d2 = v2) : (a2[d2] = n2, a2[m2] = c2, d2 = m2);
            else if (void 0 !== r2 && 0 > I2(r2, c2))
              a2[d2] = r2, a2[v2] = c2, d2 = v2;
            else
              break a;
          }
      }
      return b2;
    }
    return null;
  }
  function I2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  var L2 = [], M2 = [], N2 = 1, O2 = null, P2 = 3, Q2 = false, R2 = false, S2 = false;
  function T2(a2) {
    for (var b2 = J2(M2); null !== b2; ) {
      if (null === b2.callback)
        K2(M2);
      else if (b2.startTime <= a2)
        K2(M2), b2.sortIndex = b2.expirationTime, H2(L2, b2);
      else
        break;
      b2 = J2(M2);
    }
  }
  function U2(a2) {
    S2 = false;
    T2(a2);
    if (!R2)
      if (null !== J2(L2))
        R2 = true, f2(V2);
      else {
        var b2 = J2(M2);
        null !== b2 && g2(U2, b2.startTime - a2);
      }
  }
  function V2(a2, b2) {
    R2 = false;
    S2 && (S2 = false, h2());
    Q2 = true;
    var c2 = P2;
    try {
      T2(b2);
      for (O2 = J2(L2); null !== O2 && (!(O2.expirationTime > b2) || a2 && !exports.unstable_shouldYield()); ) {
        var d2 = O2.callback;
        if ("function" === typeof d2) {
          O2.callback = null;
          P2 = O2.priorityLevel;
          var e2 = d2(O2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? O2.callback = e2 : O2 === J2(L2) && K2(L2);
          T2(b2);
        } else
          K2(L2);
        O2 = J2(L2);
      }
      if (null !== O2)
        var m2 = true;
      else {
        var n2 = J2(M2);
        null !== n2 && g2(U2, n2.startTime - b2);
        m2 = false;
      }
      return m2;
    } finally {
      O2 = null, P2 = c2, Q2 = false;
    }
  }
  var W2 = k2;
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    R2 || Q2 || (R2 = true, f2(V2));
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return P2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return J2(L2);
  };
  exports.unstable_next = function(a2) {
    switch (P2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = P2;
    }
    var c2 = P2;
    P2 = b2;
    try {
      return a2();
    } finally {
      P2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = W2;
  exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = P2;
    P2 = a2;
    try {
      return b2();
    } finally {
      P2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = { id: N2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, H2(M2, a2), null === J2(L2) && a2 === J2(M2) && (S2 ? h2() : S2 = true, g2(U2, c2 - d2))) : (a2.sortIndex = e2, H2(L2, a2), R2 || Q2 || (R2 = true, f2(V2)));
    return a2;
  };
  exports.unstable_wrapCallback = function(a2) {
    var b2 = P2;
    return function() {
      var c2 = P2;
      P2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        P2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/** @license React v17.0.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, m$4 = objectAssign, r$5 = schedulerExports;
function y$2(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
if (!aa)
  throw Error(y$2(227));
var ba = /* @__PURE__ */ new Set(), ca = {};
function da(a2, b2) {
  ea(a2, b2);
  ea(a2 + "Capture", b2);
}
function ea(a2, b2) {
  ca[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++)
    ba.add(b2[a2]);
}
var fa = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ia = Object.prototype.hasOwnProperty, ja = {}, ka = {};
function la(a2) {
  if (ia.call(ka, a2))
    return true;
  if (ia.call(ja, a2))
    return false;
  if (ha.test(a2))
    return ka[a2] = true;
  ja[a2] = true;
  return false;
}
function ma(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function na(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || ma(a2, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function B$1(a2, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var D$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  D$1[a2] = new B$1(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  D$1[b2] = new B$1(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  D$1[a2] = new B$1(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  D$1[a2] = new B$1(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  D$1[a2] = new B$1(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  D$1[a2] = new B$1(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  D$1[a2] = new B$1(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  D$1[a2] = new B$1(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  D$1[a2] = new B$1(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var oa = /[\-:]([a-z])/g;
function pa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    oa,
    pa
  );
  D$1[b2] = new B$1(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(oa, pa);
  D$1[b2] = new B$1(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(oa, pa);
  D$1[b2] = new B$1(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  D$1[a2] = new B$1(a2, 1, false, a2.toLowerCase(), null, false, false);
});
D$1.xlinkHref = new B$1("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  D$1[a2] = new B$1(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function qa(a2, b2, c2, d2) {
  var e2 = D$1.hasOwnProperty(b2) ? D$1[b2] : null;
  var f2 = null !== e2 ? 0 === e2.type : d2 ? false : !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1] ? false : true;
  f2 || (na(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? la(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2))));
}
var ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, sa = 60103, ta = 60106, ua = 60107, wa = 60108, xa = 60114, ya = 60109, za = 60110, Aa = 60112, Ba = 60113, Ca = 60120, Da = 60115, Ea = 60116, Fa = 60121, Ga = 60128, Ha = 60129, Ia = 60130, Ja = 60131;
if ("function" === typeof Symbol && Symbol.for) {
  var E$1 = Symbol.for;
  sa = E$1("react.element");
  ta = E$1("react.portal");
  ua = E$1("react.fragment");
  wa = E$1("react.strict_mode");
  xa = E$1("react.profiler");
  ya = E$1("react.provider");
  za = E$1("react.context");
  Aa = E$1("react.forward_ref");
  Ba = E$1("react.suspense");
  Ca = E$1("react.suspense_list");
  Da = E$1("react.memo");
  Ea = E$1("react.lazy");
  Fa = E$1("react.block");
  E$1("react.scope");
  Ga = E$1("react.opaque.id");
  Ha = E$1("react.debug_trace_mode");
  Ia = E$1("react.offscreen");
  Ja = E$1("react.legacy_hidden");
}
var Ka = "function" === typeof Symbol && Symbol.iterator;
function La(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ka && a2[Ka] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var Ma;
function Na(a2) {
  if (void 0 === Ma)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      Ma = b2 && b2[1] || "";
    }
  return "\n" + Ma + a2;
}
var Oa = false;
function Pa(a2, b2) {
  if (!a2 || Oa)
    return "";
  Oa = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (k2) {
          var d2 = k2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (k2) {
          d2 = k2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (k2) {
        d2 = k2;
      }
      a2();
    }
  } catch (k2) {
    if (k2 && d2 && "string" === typeof k2.stack) {
      for (var e2 = k2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2])
                return "\n" + e2[g2].replace(" at new ", " at ");
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Oa = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Na(a2) : "";
}
function Qa(a2) {
  switch (a2.tag) {
    case 5:
      return Na(a2.type);
    case 16:
      return Na("Lazy");
    case 13:
      return Na("Suspense");
    case 19:
      return Na("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Pa(a2.type, false), a2;
    case 11:
      return a2 = Pa(a2.type.render, false), a2;
    case 22:
      return a2 = Pa(a2.type._render, false), a2;
    case 1:
      return a2 = Pa(a2.type, true), a2;
    default:
      return "";
  }
}
function Ra(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ua:
      return "Fragment";
    case ta:
      return "Portal";
    case xa:
      return "Profiler";
    case wa:
      return "StrictMode";
    case Ba:
      return "Suspense";
    case Ca:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case za:
        return (a2.displayName || "Context") + ".Consumer";
      case ya:
        return (a2._context.displayName || "Context") + ".Provider";
      case Aa:
        var b2 = a2.render;
        b2 = b2.displayName || b2.name || "";
        return a2.displayName || ("" !== b2 ? "ForwardRef(" + b2 + ")" : "ForwardRef");
      case Da:
        return Ra(a2.type);
      case Fa:
        return Ra(a2._render);
      case Ea:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Ra(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "object":
    case "string":
    case "undefined":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2)
    return false;
  var b2 = a2._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return m$4({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function $a(a2, b2) {
  b2 = b2.checked;
  null != b2 && qa(a2, "checked", b2, false);
}
function ab(a2, b2) {
  $a(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? bb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && bb(a2, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function cb(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function bb(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
function db(a2) {
  var b2 = "";
  aa.Children.forEach(a2, function(a3) {
    null != a3 && (b2 += a3);
  });
  return b2;
}
function eb(a2, b2) {
  a2 = m$4({ children: void 0 }, b2);
  if (b2 = db(b2.children))
    a2.children = b2;
  return a2;
}
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d2 && (a2[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(y$2(91));
  return m$4({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(y$2(92));
      if (Array.isArray(c2)) {
        if (!(1 >= c2.length))
          throw Error(y$2(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
var kb = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
function lb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function mb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? lb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var nb, ob = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e2);
    });
  } : a2;
}(function(a2, b2) {
  if (a2.namespaceURI !== kb.svg || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    nb = nb || document.createElement("div");
    nb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = nb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function pb(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var qb = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, rb = ["Webkit", "ms", "Moz", "O"];
Object.keys(qb).forEach(function(a2) {
  rb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    qb[b2] = qb[a2];
  });
});
function sb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || qb.hasOwnProperty(a2) && qb[a2] ? ("" + b2).trim() : b2 + "px";
}
function tb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = sb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
}
var ub = m$4({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function vb(a2, b2) {
  if (b2) {
    if (ub[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(y$2(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(y$2(60));
      if (!("object" === typeof b2.dangerouslySetInnerHTML && "__html" in b2.dangerouslySetInnerHTML))
        throw Error(y$2(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(y$2(62));
  }
}
function wb(a2, b2) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb)
      throw Error(y$2(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb(a2, b2, c2, d2, e2) {
  return a2(b2, c2, d2, e2);
}
function Ib() {
}
var Jb = Gb, Kb = false, Lb = false;
function Mb() {
  if (null !== zb || null !== Ab)
    Ib(), Fb();
}
function Nb(a2, b2, c2) {
  if (Lb)
    return a2(b2, c2);
  Lb = true;
  try {
    return Jb(a2, b2, c2);
  } finally {
    Lb = false, Mb();
  }
}
function Ob(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(y$2(231, b2, typeof c2));
  return c2;
}
var Pb = false;
if (fa)
  try {
    var Qb = {};
    Object.defineProperty(Qb, "passive", { get: function() {
      Pb = true;
    } });
    window.addEventListener("test", Qb, Qb);
    window.removeEventListener("test", Qb, Qb);
  } catch (a2) {
    Pb = false;
  }
function Rb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (n2) {
    this.onError(n2);
  }
}
var Sb = false, Tb = null, Ub = false, Vb = null, Wb = { onError: function(a2) {
  Sb = true;
  Tb = a2;
} };
function Xb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Sb = false;
  Tb = null;
  Rb.apply(Wb, arguments);
}
function Yb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Xb.apply(this, arguments);
  if (Sb) {
    if (Sb) {
      var l2 = Tb;
      Sb = false;
      Tb = null;
    } else
      throw Error(y$2(198));
    Ub || (Ub = true, Vb = l2);
  }
}
function Zb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 1026) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function $b(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function ac(a2) {
  if (Zb(a2) !== a2)
    throw Error(y$2(188));
}
function bc(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Zb(a2);
    if (null === b2)
      throw Error(y$2(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return ac(e2), a2;
        if (f2 === d2)
          return ac(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(y$2(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(y$2(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(y$2(190));
  }
  if (3 !== c2.tag)
    throw Error(y$2(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function cc(a2) {
  a2 = bc(a2);
  if (!a2)
    return null;
  for (var b2 = a2; ; ) {
    if (5 === b2.tag || 6 === b2.tag)
      return b2;
    if (b2.child)
      b2.child.return = b2, b2 = b2.child;
    else {
      if (b2 === a2)
        break;
      for (; !b2.sibling; ) {
        if (!b2.return || b2.return === a2)
          return null;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return null;
}
function dc(a2, b2) {
  for (var c2 = a2.alternate; null !== b2; ) {
    if (b2 === a2 || b2 === c2)
      return true;
    b2 = b2.return;
  }
  return false;
}
var ec, fc, gc, hc, ic = false, jc = [], kc = null, lc = null, mc = null, nc = /* @__PURE__ */ new Map(), oc = /* @__PURE__ */ new Map(), pc = [], qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function rc(a2, b2, c2, d2, e2) {
  return { blockedOn: a2, domEventName: b2, eventSystemFlags: c2 | 16, nativeEvent: e2, targetContainers: [d2] };
}
function sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      kc = null;
      break;
    case "dragenter":
    case "dragleave":
      lc = null;
      break;
    case "mouseover":
    case "mouseout":
      mc = null;
      break;
    case "pointerover":
    case "pointerout":
      nc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      oc.delete(b2.pointerId);
  }
}
function tc(a2, b2, c2, d2, e2, f2) {
  if (null === a2 || a2.nativeEvent !== f2)
    return a2 = rc(b2, c2, d2, e2, f2), null !== b2 && (b2 = Cb(b2), null !== b2 && fc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a2;
}
function uc(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return kc = tc(kc, a2, b2, c2, d2, e2), true;
    case "dragenter":
      return lc = tc(lc, a2, b2, c2, d2, e2), true;
    case "mouseover":
      return mc = tc(mc, a2, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      nc.set(f2, tc(nc.get(f2) || null, a2, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, oc.set(f2, tc(oc.get(f2) || null, a2, b2, c2, d2, e2)), true;
  }
  return false;
}
function vc(a2) {
  var b2 = wc(a2.target);
  if (null !== b2) {
    var c2 = Zb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = $b(c2), null !== b2) {
          a2.blockedOn = b2;
          hc(a2.lanePriority, function() {
            r$5.unstable_runWithPriority(a2.priority, function() {
              gc(c2);
            });
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.hydrate) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function xc(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null !== c2)
      return b2 = Cb(c2), null !== b2 && fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function zc(a2, b2, c2) {
  xc(a2) && c2.delete(b2);
}
function Ac() {
  for (ic = false; 0 < jc.length; ) {
    var a2 = jc[0];
    if (null !== a2.blockedOn) {
      a2 = Cb(a2.blockedOn);
      null !== a2 && ec(a2);
      break;
    }
    for (var b2 = a2.targetContainers; 0 < b2.length; ) {
      var c2 = yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
      if (null !== c2) {
        a2.blockedOn = c2;
        break;
      }
      b2.shift();
    }
    null === a2.blockedOn && jc.shift();
  }
  null !== kc && xc(kc) && (kc = null);
  null !== lc && xc(lc) && (lc = null);
  null !== mc && xc(mc) && (mc = null);
  nc.forEach(zc);
  oc.forEach(zc);
}
function Bc(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, ic || (ic = true, r$5.unstable_scheduleCallback(r$5.unstable_NormalPriority, Ac)));
}
function Cc(a2) {
  function b2(b3) {
    return Bc(b3, a2);
  }
  if (0 < jc.length) {
    Bc(jc[0], a2);
    for (var c2 = 1; c2 < jc.length; c2++) {
      var d2 = jc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== kc && Bc(kc, a2);
  null !== lc && Bc(lc, a2);
  null !== mc && Bc(mc, a2);
  nc.forEach(b2);
  oc.forEach(b2);
  for (c2 = 0; c2 < pc.length; c2++)
    d2 = pc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < pc.length && (c2 = pc[0], null === c2.blockedOn); )
    vc(c2), null === c2.blockedOn && pc.shift();
}
function Dc(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var Ec = { animationend: Dc("Animation", "AnimationEnd"), animationiteration: Dc("Animation", "AnimationIteration"), animationstart: Dc("Animation", "AnimationStart"), transitionend: Dc("Transition", "TransitionEnd") }, Fc = {}, Gc = {};
fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);
function Hc(a2) {
  if (Fc[a2])
    return Fc[a2];
  if (!Ec[a2])
    return a2;
  var b2 = Ec[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Gc)
      return Fc[a2] = b2[c2];
  return a2;
}
var Ic = Hc("animationend"), Jc = Hc("animationiteration"), Kc = Hc("animationstart"), Lc = Hc("transitionend"), Mc = /* @__PURE__ */ new Map(), Nc = /* @__PURE__ */ new Map(), Oc = [
  "abort",
  "abort",
  Ic,
  "animationEnd",
  Jc,
  "animationIteration",
  Kc,
  "animationStart",
  "canplay",
  "canPlay",
  "canplaythrough",
  "canPlayThrough",
  "durationchange",
  "durationChange",
  "emptied",
  "emptied",
  "encrypted",
  "encrypted",
  "ended",
  "ended",
  "error",
  "error",
  "gotpointercapture",
  "gotPointerCapture",
  "load",
  "load",
  "loadeddata",
  "loadedData",
  "loadedmetadata",
  "loadedMetadata",
  "loadstart",
  "loadStart",
  "lostpointercapture",
  "lostPointerCapture",
  "playing",
  "playing",
  "progress",
  "progress",
  "seeking",
  "seeking",
  "stalled",
  "stalled",
  "suspend",
  "suspend",
  "timeupdate",
  "timeUpdate",
  Lc,
  "transitionEnd",
  "waiting",
  "waiting"
];
function Pc(a2, b2) {
  for (var c2 = 0; c2 < a2.length; c2 += 2) {
    var d2 = a2[c2], e2 = a2[c2 + 1];
    e2 = "on" + (e2[0].toUpperCase() + e2.slice(1));
    Nc.set(d2, b2);
    Mc.set(d2, e2);
    da(e2, [d2]);
  }
}
var Qc = r$5.unstable_now;
Qc();
var F$1 = 8;
function Rc(a2) {
  if (0 !== (1 & a2))
    return F$1 = 15, 1;
  if (0 !== (2 & a2))
    return F$1 = 14, 2;
  if (0 !== (4 & a2))
    return F$1 = 13, 4;
  var b2 = 24 & a2;
  if (0 !== b2)
    return F$1 = 12, b2;
  if (0 !== (a2 & 32))
    return F$1 = 11, 32;
  b2 = 192 & a2;
  if (0 !== b2)
    return F$1 = 10, b2;
  if (0 !== (a2 & 256))
    return F$1 = 9, 256;
  b2 = 3584 & a2;
  if (0 !== b2)
    return F$1 = 8, b2;
  if (0 !== (a2 & 4096))
    return F$1 = 7, 4096;
  b2 = 4186112 & a2;
  if (0 !== b2)
    return F$1 = 6, b2;
  b2 = 62914560 & a2;
  if (0 !== b2)
    return F$1 = 5, b2;
  if (a2 & 67108864)
    return F$1 = 4, 67108864;
  if (0 !== (a2 & 134217728))
    return F$1 = 3, 134217728;
  b2 = 805306368 & a2;
  if (0 !== b2)
    return F$1 = 2, b2;
  if (0 !== (1073741824 & a2))
    return F$1 = 1, 1073741824;
  F$1 = 8;
  return a2;
}
function Sc(a2) {
  switch (a2) {
    case 99:
      return 15;
    case 98:
      return 10;
    case 97:
    case 96:
      return 8;
    case 95:
      return 2;
    default:
      return 0;
  }
}
function Tc(a2) {
  switch (a2) {
    case 15:
    case 14:
      return 99;
    case 13:
    case 12:
    case 11:
    case 10:
      return 98;
    case 9:
    case 8:
    case 7:
    case 6:
    case 4:
    case 5:
      return 97;
    case 3:
    case 2:
    case 1:
      return 95;
    case 0:
      return 90;
    default:
      throw Error(y$2(358, a2));
  }
}
function Uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return F$1 = 0;
  var d2 = 0, e2 = 0, f2 = a2.expiredLanes, g2 = a2.suspendedLanes, h2 = a2.pingedLanes;
  if (0 !== f2)
    d2 = f2, e2 = F$1 = 15;
  else if (f2 = c2 & 134217727, 0 !== f2) {
    var k2 = f2 & ~g2;
    0 !== k2 ? (d2 = Rc(k2), e2 = F$1) : (h2 &= f2, 0 !== h2 && (d2 = Rc(h2), e2 = F$1));
  } else
    f2 = c2 & ~g2, 0 !== f2 ? (d2 = Rc(f2), e2 = F$1) : 0 !== h2 && (d2 = Rc(h2), e2 = F$1);
  if (0 === d2)
    return 0;
  d2 = 31 - Vc(d2);
  d2 = c2 & ((0 > d2 ? 0 : 1 << d2) << 1) - 1;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & g2)) {
    Rc(b2);
    if (e2 <= F$1)
      return b2;
    F$1 = e2;
  }
  b2 = a2.entangledLanes;
  if (0 !== b2)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - Vc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
function Wc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function Xc(a2, b2) {
  switch (a2) {
    case 15:
      return 1;
    case 14:
      return 2;
    case 12:
      return a2 = Yc(24 & ~b2), 0 === a2 ? Xc(10, b2) : a2;
    case 10:
      return a2 = Yc(192 & ~b2), 0 === a2 ? Xc(8, b2) : a2;
    case 8:
      return a2 = Yc(3584 & ~b2), 0 === a2 && (a2 = Yc(4186112 & ~b2), 0 === a2 && (a2 = 512)), a2;
    case 2:
      return b2 = Yc(805306368 & ~b2), 0 === b2 && (b2 = 268435456), b2;
  }
  throw Error(y$2(358, a2));
}
function Yc(a2) {
  return a2 & -a2;
}
function Zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
function $c(a2, b2, c2) {
  a2.pendingLanes |= b2;
  var d2 = b2 - 1;
  a2.suspendedLanes &= d2;
  a2.pingedLanes &= d2;
  a2 = a2.eventTimes;
  b2 = 31 - Vc(b2);
  a2[b2] = c2;
}
var Vc = Math.clz32 ? Math.clz32 : ad, bd = Math.log, cd = Math.LN2;
function ad(a2) {
  return 0 === a2 ? 32 : 31 - (bd(a2) / cd | 0) | 0;
}
var dd = r$5.unstable_UserBlockingPriority, ed = r$5.unstable_runWithPriority, fd = true;
function gd(a2, b2, c2, d2) {
  Kb || Ib();
  var e2 = hd, f2 = Kb;
  Kb = true;
  try {
    Hb(e2, a2, b2, c2, d2);
  } finally {
    (Kb = f2) || Mb();
  }
}
function id(a2, b2, c2, d2) {
  ed(dd, hd.bind(null, a2, b2, c2, d2));
}
function hd(a2, b2, c2, d2) {
  if (fd) {
    var e2;
    if ((e2 = 0 === (b2 & 4)) && 0 < jc.length && -1 < qc.indexOf(a2))
      a2 = rc(null, a2, b2, c2, d2), jc.push(a2);
    else {
      var f2 = yc(a2, b2, c2, d2);
      if (null === f2)
        e2 && sc(a2, d2);
      else {
        if (e2) {
          if (-1 < qc.indexOf(a2)) {
            a2 = rc(f2, a2, b2, c2, d2);
            jc.push(a2);
            return;
          }
          if (uc(f2, a2, b2, c2, d2))
            return;
          sc(a2, d2);
        }
        jd(a2, b2, d2, null, c2);
      }
    }
  }
}
function yc(a2, b2, c2, d2) {
  var e2 = xb(d2);
  e2 = wc(e2);
  if (null !== e2) {
    var f2 = Zb(e2);
    if (null === f2)
      e2 = null;
    else {
      var g2 = f2.tag;
      if (13 === g2) {
        e2 = $b(f2);
        if (null !== e2)
          return e2;
        e2 = null;
      } else if (3 === g2) {
        if (f2.stateNode.hydrate)
          return 3 === f2.tag ? f2.stateNode.containerInfo : null;
        e2 = null;
      } else
        f2 !== e2 && (e2 = null);
    }
  }
  jd(a2, b2, d2, e2, c2);
  return null;
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  m$4(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = m$4({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = m$4({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = m$4({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = m$4({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = m$4({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = m$4({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = m$4({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = m$4({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = m$4({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = m$4({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = m$4({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = m$4({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = fa && "CompositionEvent" in window, be = null;
fa && "documentMode" in document && (be = document.documentMode);
var ce = fa && "TextEvent" in window && !be, de$1 = fa && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie = false;
function je(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe = true;
      return ee;
    case "textInput":
      return a2 = b2.data, a2 === ee && fe ? null : a2;
    default:
      return null;
  }
}
function ke(a2, b2) {
  if (ie)
    return "compositionend" === a2 || !ae && ge(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$1 && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le[a2.type] : "textarea" === b2 ? true : false;
}
function ne(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe = null, qe = null;
function re(a2) {
  se(a2, 0);
}
function te(a2) {
  var b2 = ue(a2);
  if (Wa(b2))
    return a2;
}
function ve(a2, b2) {
  if ("change" === a2)
    return b2;
}
var we = false;
if (fa) {
  var xe;
  if (fa) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a2) {
  if ("value" === a2.propertyName && te(qe)) {
    var b2 = [];
    ne(b2, qe, a2, xb(a2));
    a2 = re;
    if (Kb)
      a2(b2);
    else {
      Kb = true;
      try {
        Gb(a2, b2);
      } finally {
        Kb = false, Mb();
      }
    }
  }
}
function Ce(a2, b2, c2) {
  "focusin" === a2 ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
}
function De(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te(qe);
}
function Ee(a2, b2) {
  if ("click" === a2)
    return te(b2);
}
function Fe(a2, b2) {
  if ("input" === a2 || "change" === a2)
    return te(b2);
}
function Ge(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge, Ie = Object.prototype.hasOwnProperty;
function Je(a2, b2) {
  if (He(a2, b2))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++)
    if (!Ie.call(b2, c2[d2]) || !He(a2[c2[d2]], b2[c2[d2]]))
      return false;
  return true;
}
function Ke(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Le(a2, b2) {
  var c2 = Ke(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Ke(c2);
  }
}
function Me(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Me(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Ne() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Oe(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
var Pe = fa && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Oe(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Je(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe)));
}
Pc(
  "cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
  0
);
Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
Pc(Oc, 2);
for (var Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++)
  Nc.set(Ve[We], 0);
ea("onMouseEnter", ["mouseout", "mouseover"]);
ea("onMouseLeave", ["mouseout", "mouseover"]);
ea("onPointerEnter", ["pointerout", "pointerover"]);
ea("onPointerLeave", ["pointerout", "pointerover"]);
da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
function Ze(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Yb(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          Ze(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          Ze(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Ub)
    throw a2 = Vb, Ub = false, Vb = null, a2;
}
function G$1(a2, b2) {
  var c2 = $e(b2), d2 = a2 + "__bubble";
  c2.has(d2) || (af(b2, a2, 2, false), c2.add(d2));
}
var bf = "_reactListening" + Math.random().toString(36).slice(2);
function cf(a2) {
  a2[bf] || (a2[bf] = true, ba.forEach(function(b2) {
    Ye.has(b2) || df(b2, false, a2, null);
    df(b2, true, a2, null);
  }));
}
function df(a2, b2, c2, d2) {
  var e2 = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, f2 = c2;
  "selectionchange" === a2 && 9 !== c2.nodeType && (f2 = c2.ownerDocument);
  if (null !== d2 && !b2 && Ye.has(a2)) {
    if ("scroll" !== a2)
      return;
    e2 |= 2;
    f2 = d2;
  }
  var g2 = $e(f2), h2 = a2 + "__" + (b2 ? "capture" : "bubble");
  g2.has(h2) || (b2 && (e2 |= 4), af(f2, a2, e2, b2), g2.add(h2));
}
function af(a2, b2, c2, d2) {
  var e2 = Nc.get(b2);
  switch (void 0 === e2 ? 2 : e2) {
    case 0:
      e2 = gd;
      break;
    case 1:
      e2 = id;
      break;
    default:
      e2 = hd;
  }
  c2 = e2.bind(null, b2, c2, a2);
  e2 = void 0;
  !Pb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
}
function jd(a2, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = wc(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Nb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = Mc.get(a2);
      if (void 0 !== h3) {
        var k3 = td, x = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            x = "focus";
            k3 = Fd;
            break;
          case "focusout":
            x = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case Ic:
          case Jc:
          case Kc:
            k3 = Hd;
            break;
          case Lc:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var w2 = 0 !== (b2 & 4), z2 = !w2 && "scroll" === a2, u2 = w2 ? null !== h3 ? h3 + "Capture" : null : h3;
        w2 = [];
        for (var t2 = d3, q2; null !== t2; ) {
          q2 = t2;
          var v2 = q2.stateNode;
          5 === q2.tag && null !== v2 && (q2 = v2, null !== u2 && (v2 = Ob(t2, u2), null != v2 && w2.push(ef(t2, v2, q2))));
          if (z2)
            break;
          t2 = t2.return;
        }
        0 < w2.length && (h3 = new k3(h3, x, null, c2, e3), g3.push({ event: h3, listeners: w2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && 0 === (b2 & 16) && (x = c2.relatedTarget || c2.fromElement) && (wc(x) || x[ff]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (x = c2.relatedTarget || c2.toElement, k3 = d3, x = x ? wc(x) : null, null !== x && (z2 = Zb(x), x !== z2 || 5 !== x.tag && 6 !== x.tag))
              x = null;
          } else
            k3 = null, x = d3;
          if (k3 !== x) {
            w2 = Bd;
            v2 = "onMouseLeave";
            u2 = "onMouseEnter";
            t2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              w2 = Td, v2 = "onPointerLeave", u2 = "onPointerEnter", t2 = "pointer";
            z2 = null == k3 ? h3 : ue(k3);
            q2 = null == x ? h3 : ue(x);
            h3 = new w2(v2, t2 + "leave", k3, c2, e3);
            h3.target = z2;
            h3.relatedTarget = q2;
            v2 = null;
            wc(e3) === d3 && (w2 = new w2(u2, t2 + "enter", x, c2, e3), w2.target = q2, w2.relatedTarget = z2, v2 = w2);
            z2 = v2;
            if (k3 && x)
              b: {
                w2 = k3;
                u2 = x;
                t2 = 0;
                for (q2 = w2; q2; q2 = gf(q2))
                  t2++;
                q2 = 0;
                for (v2 = u2; v2; v2 = gf(v2))
                  q2++;
                for (; 0 < t2 - q2; )
                  w2 = gf(w2), t2--;
                for (; 0 < q2 - t2; )
                  u2 = gf(u2), q2--;
                for (; t2--; ) {
                  if (w2 === u2 || null !== u2 && w2 === u2.alternate)
                    break b;
                  w2 = gf(w2);
                  u2 = gf(u2);
                }
                w2 = null;
              }
            else
              w2 = null;
            null !== k3 && hf(g3, h3, k3, w2, false);
            null !== x && null !== z2 && hf(g3, z2, x, w2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var J2 = ve;
        else if (me(h3))
          if (we)
            J2 = Fe;
          else {
            J2 = De;
            var K2 = Ce;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (J2 = Ee);
        if (J2 && (J2 = J2(a2, d3))) {
          ne(g3, J2, c2, e3);
          break a;
        }
        K2 && K2(a2, h3, d3);
        "focusout" === a2 && (K2 = h3._wrapperState) && K2.controlled && "number" === h3.type && bb(h3, "number", h3.value);
      }
      K2 = d3 ? ue(d3) : window;
      switch (a2) {
        case "focusin":
          if (me(K2) || "true" === K2.contentEditable)
            Qe = K2, Re = d3, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g3, c2, e3);
      }
      var Q2;
      if (ae)
        b: {
          switch (a2) {
            case "compositionstart":
              var L2 = "onCompositionStart";
              break b;
            case "compositionend":
              L2 = "onCompositionEnd";
              break b;
            case "compositionupdate":
              L2 = "onCompositionUpdate";
              break b;
          }
          L2 = void 0;
        }
      else
        ie ? ge(a2, c2) && (L2 = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (L2 = "onCompositionStart");
      L2 && (de$1 && "ko" !== c2.locale && (ie || "onCompositionStart" !== L2 ? "onCompositionEnd" === L2 && ie && (Q2 = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), K2 = oe(d3, L2), 0 < K2.length && (L2 = new Ld(L2, a2, null, c2, e3), g3.push({ event: L2, listeners: K2 }), Q2 ? L2.data = Q2 : (Q2 = he(c2), null !== Q2 && (L2.data = Q2))));
      if (Q2 = ce ? je(a2, c2) : ke(a2, c2))
        d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld(
          "onBeforeInput",
          "beforeinput",
          null,
          c2,
          e3
        ), g3.push({ event: e3, listeners: d3 }), e3.data = Q2);
    }
    se(g3, b2);
  });
}
function ef(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e2 = a2, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Ob(a2, c2), null != f2 && d2.unshift(ef(a2, f2, e2)), f2 = Ob(a2, b2), null != f2 && d2.push(ef(a2, f2, e2)));
    a2 = a2.return;
  }
  return d2;
}
function gf(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function hf(a2, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Ob(c2, f2), null != k2 && g2.unshift(ef(c2, k2, h2))) : e2 || (k2 = Ob(c2, f2), null != k2 && g2.push(ef(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b2, listeners: g2 });
}
function jf() {
}
var kf = null, lf = null;
function mf(a2, b2) {
  switch (a2) {
    case "button":
    case "input":
    case "select":
    case "textarea":
      return !!b2.autoFocus;
  }
  return false;
}
function nf(a2, b2) {
  return "textarea" === a2 || "option" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var of = "function" === typeof setTimeout ? setTimeout : void 0, pf = "function" === typeof clearTimeout ? clearTimeout : void 0;
function qf(a2) {
  1 === a2.nodeType ? a2.textContent = "" : 9 === a2.nodeType && (a2 = a2.body, null != a2 && (a2.textContent = ""));
}
function rf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2)
      break;
  }
  return a2;
}
function sf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a2;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var tf = 0;
function uf(a2) {
  return { $$typeof: Ga, toString: a2, valueOf: a2 };
}
var vf = Math.random().toString(36).slice(2), wf = "__reactFiber$" + vf, xf = "__reactProps$" + vf, ff = "__reactContainer$" + vf, yf = "__reactEvents$" + vf;
function wc(a2) {
  var b2 = a2[wf];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[ff] || c2[wf]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a2 = sf(a2); null !== a2; ) {
          if (c2 = a2[wf])
            return c2;
          a2 = sf(a2);
        }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[wf] || a2[ff];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(y$2(33));
}
function Db(a2) {
  return a2[xf] || null;
}
function $e(a2) {
  var b2 = a2[yf];
  void 0 === b2 && (b2 = a2[yf] = /* @__PURE__ */ new Set());
  return b2;
}
var zf = [], Af = -1;
function Bf(a2) {
  return { current: a2 };
}
function H$1(a2) {
  0 > Af || (a2.current = zf[Af], zf[Af] = null, Af--);
}
function I$1(a2, b2) {
  Af++;
  zf[Af] = a2.current;
  a2.current = b2;
}
var Cf = {}, M$1 = Bf(Cf), N$1 = Bf(false), Df = Cf;
function Ef(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Cf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Ff(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function Gf() {
  H$1(N$1);
  H$1(M$1);
}
function Hf(a2, b2, c2) {
  if (M$1.current !== Cf)
    throw Error(y$2(168));
  I$1(M$1, b2);
  I$1(N$1, c2);
}
function If(a2, b2, c2) {
  var d2 = a2.stateNode;
  a2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in a2))
      throw Error(y$2(108, Ra(b2) || "Unknown", e2));
  return m$4({}, c2, d2);
}
function Jf(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Cf;
  Df = M$1.current;
  I$1(M$1, a2);
  I$1(N$1, N$1.current);
  return true;
}
function Kf(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(y$2(169));
  c2 ? (a2 = If(a2, b2, Df), d2.__reactInternalMemoizedMergedChildContext = a2, H$1(N$1), H$1(M$1), I$1(M$1, a2)) : H$1(N$1);
  I$1(N$1, c2);
}
var Lf = null, Mf = null, Nf = r$5.unstable_runWithPriority, Of = r$5.unstable_scheduleCallback, Pf = r$5.unstable_cancelCallback, Qf = r$5.unstable_shouldYield, Rf = r$5.unstable_requestPaint, Sf = r$5.unstable_now, Tf = r$5.unstable_getCurrentPriorityLevel, Uf = r$5.unstable_ImmediatePriority, Vf = r$5.unstable_UserBlockingPriority, Wf = r$5.unstable_NormalPriority, Xf = r$5.unstable_LowPriority, Yf = r$5.unstable_IdlePriority, Zf = {}, $f = void 0 !== Rf ? Rf : function() {
}, ag = null, bg = null, cg = false, dg = Sf(), O$1 = 1e4 > dg ? Sf : function() {
  return Sf() - dg;
};
function eg() {
  switch (Tf()) {
    case Uf:
      return 99;
    case Vf:
      return 98;
    case Wf:
      return 97;
    case Xf:
      return 96;
    case Yf:
      return 95;
    default:
      throw Error(y$2(332));
  }
}
function fg(a2) {
  switch (a2) {
    case 99:
      return Uf;
    case 98:
      return Vf;
    case 97:
      return Wf;
    case 96:
      return Xf;
    case 95:
      return Yf;
    default:
      throw Error(y$2(332));
  }
}
function gg(a2, b2) {
  a2 = fg(a2);
  return Nf(a2, b2);
}
function hg(a2, b2, c2) {
  a2 = fg(a2);
  return Of(a2, b2, c2);
}
function ig() {
  if (null !== bg) {
    var a2 = bg;
    bg = null;
    Pf(a2);
  }
  jg();
}
function jg() {
  if (!cg && null !== ag) {
    cg = true;
    var a2 = 0;
    try {
      var b2 = ag;
      gg(99, function() {
        for (; a2 < b2.length; a2++) {
          var c2 = b2[a2];
          do
            c2 = c2(true);
          while (null !== c2);
        }
      });
      ag = null;
    } catch (c2) {
      throw null !== ag && (ag = ag.slice(a2 + 1)), Of(Uf, ig), c2;
    } finally {
      cg = false;
    }
  }
}
var kg = ra.ReactCurrentBatchConfig;
function lg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = m$4({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
var mg = Bf(null), ng = null, og = null, pg = null;
function qg() {
  pg = og = ng = null;
}
function rg(a2) {
  var b2 = mg.current;
  H$1(mg);
  a2.type._context._currentValue = b2;
}
function sg(a2, b2) {
  for (; null !== a2; ) {
    var c2 = a2.alternate;
    if ((a2.childLanes & b2) === b2)
      if (null === c2 || (c2.childLanes & b2) === b2)
        break;
      else
        c2.childLanes |= b2;
    else
      a2.childLanes |= b2, null !== c2 && (c2.childLanes |= b2);
    a2 = a2.return;
  }
}
function tg(a2, b2) {
  ng = a2;
  pg = og = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (ug = true), a2.firstContext = null);
}
function vg(a2, b2) {
  if (pg !== a2 && false !== b2 && 0 !== b2) {
    if ("number" !== typeof b2 || 1073741823 === b2)
      pg = a2, b2 = 1073741823;
    b2 = { context: a2, observedBits: b2, next: null };
    if (null === og) {
      if (null === ng)
        throw Error(y$2(308));
      og = b2;
      ng.dependencies = { lanes: 0, firstContext: b2, responders: null };
    } else
      og = og.next = b2;
  }
  return a2._currentValue;
}
var wg = false;
function xg(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };
}
function yg(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function zg(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function Ag(a2, b2) {
  a2 = a2.updateQueue;
  if (null !== a2) {
    a2 = a2.shared;
    var c2 = a2.pending;
    null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
    a2.pending = b2;
  }
}
function Bg(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function Cg(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  wg = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var n2 = a2.alternate;
    if (null !== n2) {
      n2 = n2.updateQueue;
      var A2 = n2.lastBaseUpdate;
      A2 !== g2 && (null === A2 ? n2.firstBaseUpdate = l2 : A2.next = l2, n2.lastBaseUpdate = k2);
    }
  }
  if (null !== f2) {
    A2 = e2.baseState;
    g2 = 0;
    n2 = l2 = k2 = null;
    do {
      h2 = f2.lane;
      var p = f2.eventTime;
      if ((d2 & h2) === h2) {
        null !== n2 && (n2 = n2.next = {
          eventTime: p,
          lane: 0,
          tag: f2.tag,
          payload: f2.payload,
          callback: f2.callback,
          next: null
        });
        a: {
          var C2 = a2, x = f2;
          h2 = b2;
          p = c2;
          switch (x.tag) {
            case 1:
              C2 = x.payload;
              if ("function" === typeof C2) {
                A2 = C2.call(p, A2, h2);
                break a;
              }
              A2 = C2;
              break a;
            case 3:
              C2.flags = C2.flags & -4097 | 64;
            case 0:
              C2 = x.payload;
              h2 = "function" === typeof C2 ? C2.call(p, A2, h2) : C2;
              if (null === h2 || void 0 === h2)
                break a;
              A2 = m$4({}, A2, h2);
              break a;
            case 2:
              wg = true;
          }
        }
        null !== f2.callback && (a2.flags |= 32, h2 = e2.effects, null === h2 ? e2.effects = [f2] : h2.push(f2));
      } else
        p = { eventTime: p, lane: h2, tag: f2.tag, payload: f2.payload, callback: f2.callback, next: null }, null === n2 ? (l2 = n2 = p, k2 = A2) : n2 = n2.next = p, g2 |= h2;
      f2 = f2.next;
      if (null === f2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          f2 = h2.next, h2.next = null, e2.lastBaseUpdate = h2, e2.shared.pending = null;
    } while (1);
    null === n2 && (k2 = A2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = n2;
    Dg |= g2;
    a2.lanes = g2;
    a2.memoizedState = A2;
  }
}
function Eg(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2)
          throw Error(y$2(191, e2));
        e2.call(d2);
      }
    }
}
var Fg = new aa.Component().refs;
function Gg(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : m$4({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var Kg = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Zb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = Hg(), e2 = Ig(a2), f2 = zg(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  Ag(a2, f2);
  Jg(a2, e2, d2);
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = Hg(), e2 = Ig(a2), f2 = zg(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  Ag(a2, f2);
  Jg(a2, e2, d2);
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = Hg(), d2 = Ig(a2), e2 = zg(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  Ag(a2, e2);
  Jg(a2, d2, c2);
} };
function Lg(a2, b2, c2, d2, e2, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Je(c2, d2) || !Je(e2, f2) : true;
}
function Mg(a2, b2, c2) {
  var d2 = false, e2 = Cf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = vg(f2) : (e2 = Ff(b2) ? Df : M$1.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Ef(a2, e2) : Cf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = Kg;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function Ng(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && Kg.enqueueReplaceState(b2, b2.state, null);
}
function Og(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = Fg;
  xg(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = vg(f2) : (f2 = Ff(b2) ? Df : M$1.current, e2.context = Ef(a2, f2));
  Cg(a2, c2, e2, d2);
  e2.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (Gg(a2, b2, f2, c2), e2.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Kg.enqueueReplaceState(e2, e2.state, null), Cg(a2, c2, e2, d2), e2.state = a2.memoizedState);
  "function" === typeof e2.componentDidMount && (a2.flags |= 4);
}
var Pg = Array.isArray;
function Qg(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(y$2(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(y$2(147, a2));
      var e2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === e2)
        return b2.ref;
      b2 = function(a3) {
        var b3 = d2.refs;
        b3 === Fg && (b3 = d2.refs = {});
        null === a3 ? delete b3[e2] : b3[e2] = a3;
      };
      b2._stringRef = e2;
      return b2;
    }
    if ("string" !== typeof a2)
      throw Error(y$2(284));
    if (!c2._owner)
      throw Error(y$2(290, a2));
  }
  return a2;
}
function Rg(a2, b2) {
  if ("textarea" !== a2.type)
    throw Error(y$2(31, "[object Object]" === Object.prototype.toString.call(b2) ? "object with keys {" + Object.keys(b2).join(", ") + "}" : b2));
}
function Sg(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.lastEffect;
      null !== d3 ? (d3.nextEffect = c3, b3.lastEffect = c3) : b3.firstEffect = b3.lastEffect = c3;
      c3.nextEffect = null;
      c3.flags = 8;
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e2(a3, b3) {
    a3 = Tg(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2)
      return c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags = 2, c3) : d3;
    b3.flags = 2;
    return c3;
  }
  function g2(b3) {
    a2 && null === b3.alternate && (b3.flags = 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = Ug(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    if (null !== b3 && b3.elementType === c3.type)
      return d3 = e2(b3, c3.props), d3.ref = Qg(a3, b3, c3), d3.return = a3, d3;
    d3 = Vg(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = Qg(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = Wg(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function n2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Xg(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function A2(a3, b3, c3) {
    if ("string" === typeof b3 || "number" === typeof b3)
      return b3 = Ug("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case sa:
          return c3 = Vg(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = Qg(a3, null, b3), c3.return = a3, c3;
        case ta:
          return b3 = Wg(b3, a3.mode, c3), b3.return = a3, b3;
      }
      if (Pg(b3) || La(b3))
        return b3 = Xg(
          b3,
          a3.mode,
          c3,
          null
        ), b3.return = a3, b3;
      Rg(a3, b3);
    }
    return null;
  }
  function p(a3, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 || "number" === typeof c3)
      return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case sa:
          return c3.key === e3 ? c3.type === ua ? n2(a3, b3, c3.props.children, d3, e3) : k2(a3, b3, c3, d3) : null;
        case ta:
          return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
      }
      if (Pg(c3) || La(c3))
        return null !== e3 ? null : n2(a3, b3, c3, d3, null);
      Rg(a3, c3);
    }
    return null;
  }
  function C2(a3, b3, c3, d3, e3) {
    if ("string" === typeof d3 || "number" === typeof d3)
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case sa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, d3.type === ua ? n2(b3, a3, d3.props.children, e3, d3.key) : k2(b3, a3, d3, e3);
        case ta:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
      }
      if (Pg(d3) || La(d3))
        return a3 = a3.get(c3) || null, n2(b3, a3, d3, e3, null);
      Rg(b3, d3);
    }
    return null;
  }
  function x(e3, g3, h3, k3) {
    for (var l3 = null, t2 = null, u2 = g3, z2 = g3 = 0, q2 = null; null !== u2 && z2 < h3.length; z2++) {
      u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
      var n3 = p(e3, u2, h3[z2], k3);
      if (null === n3) {
        null === u2 && (u2 = q2);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, z2);
      null === t2 ? l3 = n3 : t2.sibling = n3;
      t2 = n3;
      u2 = q2;
    }
    if (z2 === h3.length)
      return c2(e3, u2), l3;
    if (null === u2) {
      for (; z2 < h3.length; z2++)
        u2 = A2(e3, h3[z2], k3), null !== u2 && (g3 = f2(u2, g3, z2), null === t2 ? l3 = u2 : t2.sibling = u2, t2 = u2);
      return l3;
    }
    for (u2 = d2(e3, u2); z2 < h3.length; z2++)
      q2 = C2(u2, e3, z2, h3[z2], k3), null !== q2 && (a2 && null !== q2.alternate && u2.delete(null === q2.key ? z2 : q2.key), g3 = f2(q2, g3, z2), null === t2 ? l3 = q2 : t2.sibling = q2, t2 = q2);
    a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    });
    return l3;
  }
  function w2(e3, g3, h3, k3) {
    var l3 = La(h3);
    if ("function" !== typeof l3)
      throw Error(y$2(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(y$2(151));
    for (var t2 = l3 = null, u2 = g3, z2 = g3 = 0, q2 = null, n3 = h3.next(); null !== u2 && !n3.done; z2++, n3 = h3.next()) {
      u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
      var w3 = p(e3, u2, n3.value, k3);
      if (null === w3) {
        null === u2 && (u2 = q2);
        break;
      }
      a2 && u2 && null === w3.alternate && b2(e3, u2);
      g3 = f2(w3, g3, z2);
      null === t2 ? l3 = w3 : t2.sibling = w3;
      t2 = w3;
      u2 = q2;
    }
    if (n3.done)
      return c2(e3, u2), l3;
    if (null === u2) {
      for (; !n3.done; z2++, n3 = h3.next())
        n3 = A2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, z2), null === t2 ? l3 = n3 : t2.sibling = n3, t2 = n3);
      return l3;
    }
    for (u2 = d2(e3, u2); !n3.done; z2++, n3 = h3.next())
      n3 = C2(u2, e3, z2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && u2.delete(null === n3.key ? z2 : n3.key), g3 = f2(n3, g3, z2), null === t2 ? l3 = n3 : t2.sibling = n3, t2 = n3);
    a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    });
    return l3;
  }
  return function(a3, d3, f3, h3) {
    var k3 = "object" === typeof f3 && null !== f3 && f3.type === ua && null === f3.key;
    k3 && (f3 = f3.props.children);
    var l3 = "object" === typeof f3 && null !== f3;
    if (l3)
      switch (f3.$$typeof) {
        case sa:
          a: {
            l3 = f3.key;
            for (k3 = d3; null !== k3; ) {
              if (k3.key === l3) {
                switch (k3.tag) {
                  case 7:
                    if (f3.type === ua) {
                      c2(a3, k3.sibling);
                      d3 = e2(k3, f3.props.children);
                      d3.return = a3;
                      a3 = d3;
                      break a;
                    }
                    break;
                  default:
                    if (k3.elementType === f3.type) {
                      c2(a3, k3.sibling);
                      d3 = e2(k3, f3.props);
                      d3.ref = Qg(a3, k3, f3);
                      d3.return = a3;
                      a3 = d3;
                      break a;
                    }
                }
                c2(a3, k3);
                break;
              } else
                b2(a3, k3);
              k3 = k3.sibling;
            }
            f3.type === ua ? (d3 = Xg(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = Vg(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = Qg(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case ta:
          a: {
            for (k3 = f3.key; null !== d3; ) {
              if (d3.key === k3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = Wg(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
      }
    if ("string" === typeof f3 || "number" === typeof f3)
      return f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = Ug(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3);
    if (Pg(f3))
      return x(a3, d3, f3, h3);
    if (La(f3))
      return w2(a3, d3, f3, h3);
    l3 && Rg(a3, f3);
    if ("undefined" === typeof f3 && !k3)
      switch (a3.tag) {
        case 1:
        case 22:
        case 0:
        case 11:
        case 15:
          throw Error(y$2(152, Ra(a3.type) || "Component"));
      }
    return c2(a3, d3);
  };
}
var Yg = Sg(true), Zg = Sg(false), $g = {}, ah = Bf($g), bh = Bf($g), ch = Bf($g);
function dh(a2) {
  if (a2 === $g)
    throw Error(y$2(174));
  return a2;
}
function eh(a2, b2) {
  I$1(ch, b2);
  I$1(bh, a2);
  I$1(ah, $g);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : mb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = mb(b2, a2);
  }
  H$1(ah);
  I$1(ah, b2);
}
function fh() {
  H$1(ah);
  H$1(bh);
  H$1(ch);
}
function gh(a2) {
  dh(ch.current);
  var b2 = dh(ah.current);
  var c2 = mb(b2, a2.type);
  b2 !== c2 && (I$1(bh, a2), I$1(ah, c2));
}
function hh(a2) {
  bh.current === a2 && (H$1(ah), H$1(bh));
}
var P$1 = Bf(0);
function ih(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 64))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var jh = null, kh = null, lh = false;
function mh(a2, b2) {
  var c2 = nh(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.type = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  c2.flags = 8;
  null !== a2.lastEffect ? (a2.lastEffect.nextEffect = c2, a2.lastEffect = c2) : a2.firstEffect = a2.lastEffect = c2;
}
function oh(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, true) : false;
    case 13:
      return false;
    default:
      return false;
  }
}
function ph(a2) {
  if (lh) {
    var b2 = kh;
    if (b2) {
      var c2 = b2;
      if (!oh(a2, b2)) {
        b2 = rf(c2.nextSibling);
        if (!b2 || !oh(a2, b2)) {
          a2.flags = a2.flags & -1025 | 2;
          lh = false;
          jh = a2;
          return;
        }
        mh(jh, c2);
      }
      jh = a2;
      kh = rf(b2.firstChild);
    } else
      a2.flags = a2.flags & -1025 | 2, lh = false, jh = a2;
  }
}
function qh(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  jh = a2;
}
function rh(a2) {
  if (a2 !== jh)
    return false;
  if (!lh)
    return qh(a2), lh = true, false;
  var b2 = a2.type;
  if (5 !== a2.tag || "head" !== b2 && "body" !== b2 && !nf(b2, a2.memoizedProps))
    for (b2 = kh; b2; )
      mh(a2, b2), b2 = rf(b2.nextSibling);
  qh(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(y$2(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              kh = rf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      kh = null;
    }
  } else
    kh = jh ? rf(a2.stateNode.nextSibling) : null;
  return true;
}
function sh() {
  kh = jh = null;
  lh = false;
}
var th = [];
function uh() {
  for (var a2 = 0; a2 < th.length; a2++)
    th[a2]._workInProgressVersionPrimary = null;
  th.length = 0;
}
var vh = ra.ReactCurrentDispatcher, wh = ra.ReactCurrentBatchConfig, xh = 0, R$1 = null, S$1 = null, T = null, yh = false, zh = false;
function Ah() {
  throw Error(y$2(321));
}
function Bh(a2, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He(a2[c2], b2[c2]))
      return false;
  return true;
}
function Ch(a2, b2, c2, d2, e2, f2) {
  xh = f2;
  R$1 = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  vh.current = null === a2 || null === a2.memoizedState ? Dh : Eh;
  a2 = c2(d2, e2);
  if (zh) {
    f2 = 0;
    do {
      zh = false;
      if (!(25 > f2))
        throw Error(y$2(301));
      f2 += 1;
      T = S$1 = null;
      b2.updateQueue = null;
      vh.current = Fh;
      a2 = c2(d2, e2);
    } while (zh);
  }
  vh.current = Gh;
  b2 = null !== S$1 && null !== S$1.next;
  xh = 0;
  T = S$1 = R$1 = null;
  yh = false;
  if (b2)
    throw Error(y$2(300));
  return a2;
}
function Hh() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === T ? R$1.memoizedState = T = a2 : T = T.next = a2;
  return T;
}
function Ih() {
  if (null === S$1) {
    var a2 = R$1.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = S$1.next;
  var b2 = null === T ? R$1.memoizedState : T.next;
  if (null !== b2)
    T = b2, S$1 = a2;
  else {
    if (null === a2)
      throw Error(y$2(310));
    S$1 = a2;
    a2 = { memoizedState: S$1.memoizedState, baseState: S$1.baseState, baseQueue: S$1.baseQueue, queue: S$1.queue, next: null };
    null === T ? R$1.memoizedState = T = a2 : T = T.next = a2;
  }
  return T;
}
function Jh(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function Kh(a2) {
  var b2 = Ih(), c2 = b2.queue;
  if (null === c2)
    throw Error(y$2(311));
  c2.lastRenderedReducer = a2;
  var d2 = S$1, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    e2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = f2 = null, k2 = e2;
    do {
      var l2 = k2.lane;
      if ((xh & l2) === l2)
        null !== h2 && (h2 = h2.next = { lane: 0, action: k2.action, eagerReducer: k2.eagerReducer, eagerState: k2.eagerState, next: null }), d2 = k2.eagerReducer === a2 ? k2.eagerState : a2(d2, k2.action);
      else {
        var n2 = {
          lane: l2,
          action: k2.action,
          eagerReducer: k2.eagerReducer,
          eagerState: k2.eagerState,
          next: null
        };
        null === h2 ? (g2 = h2 = n2, f2 = d2) : h2 = h2.next = n2;
        R$1.lanes |= l2;
        Dg |= l2;
      }
      k2 = k2.next;
    } while (null !== k2 && k2 !== e2);
    null === h2 ? f2 = d2 : h2.next = g2;
    He(d2, b2.memoizedState) || (ug = true);
    b2.memoizedState = d2;
    b2.baseState = f2;
    b2.baseQueue = h2;
    c2.lastRenderedState = d2;
  }
  return [b2.memoizedState, c2.dispatch];
}
function Lh(a2) {
  var b2 = Ih(), c2 = b2.queue;
  if (null === c2)
    throw Error(y$2(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b2.memoizedState) || (ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function Mh(a2, b2, c2) {
  var d2 = b2._getVersion;
  d2 = d2(b2._source);
  var e2 = b2._workInProgressVersionPrimary;
  if (null !== e2)
    a2 = e2 === d2;
  else if (a2 = a2.mutableReadLanes, a2 = (xh & a2) === a2)
    b2._workInProgressVersionPrimary = d2, th.push(b2);
  if (a2)
    return c2(b2._source);
  th.push(b2);
  throw Error(y$2(350));
}
function Nh(a2, b2, c2, d2) {
  var e2 = U$1;
  if (null === e2)
    throw Error(y$2(349));
  var f2 = b2._getVersion, g2 = f2(b2._source), h2 = vh.current, k2 = h2.useState(function() {
    return Mh(e2, b2, c2);
  }), l2 = k2[1], n2 = k2[0];
  k2 = T;
  var A2 = a2.memoizedState, p = A2.refs, C2 = p.getSnapshot, x = A2.source;
  A2 = A2.subscribe;
  var w2 = R$1;
  a2.memoizedState = { refs: p, source: b2, subscribe: d2 };
  h2.useEffect(function() {
    p.getSnapshot = c2;
    p.setSnapshot = l2;
    var a3 = f2(b2._source);
    if (!He(g2, a3)) {
      a3 = c2(b2._source);
      He(n2, a3) || (l2(a3), a3 = Ig(w2), e2.mutableReadLanes |= a3 & e2.pendingLanes);
      a3 = e2.mutableReadLanes;
      e2.entangledLanes |= a3;
      for (var d3 = e2.entanglements, h3 = a3; 0 < h3; ) {
        var k3 = 31 - Vc(h3), v2 = 1 << k3;
        d3[k3] |= a3;
        h3 &= ~v2;
      }
    }
  }, [c2, b2, d2]);
  h2.useEffect(function() {
    return d2(b2._source, function() {
      var a3 = p.getSnapshot, c3 = p.setSnapshot;
      try {
        c3(a3(b2._source));
        var d3 = Ig(w2);
        e2.mutableReadLanes |= d3 & e2.pendingLanes;
      } catch (q2) {
        c3(function() {
          throw q2;
        });
      }
    });
  }, [b2, d2]);
  He(C2, c2) && He(x, b2) && He(A2, d2) || (a2 = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n2 }, a2.dispatch = l2 = Oh.bind(null, R$1, a2), k2.queue = a2, k2.baseQueue = null, n2 = Mh(e2, b2, c2), k2.memoizedState = k2.baseState = n2);
  return n2;
}
function Ph(a2, b2, c2) {
  var d2 = Ih();
  return Nh(d2, a2, b2, c2);
}
function Qh(a2) {
  var b2 = Hh();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = b2.queue = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a2 };
  a2 = a2.dispatch = Oh.bind(null, R$1, a2);
  return [b2.memoizedState, a2];
}
function Rh(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = R$1.updateQueue;
  null === b2 ? (b2 = { lastEffect: null }, R$1.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function Sh(a2) {
  var b2 = Hh();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}
function Th() {
  return Ih().memoizedState;
}
function Uh(a2, b2, c2, d2) {
  var e2 = Hh();
  R$1.flags |= a2;
  e2.memoizedState = Rh(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function Vh(a2, b2, c2, d2) {
  var e2 = Ih();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== S$1) {
    var g2 = S$1.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Bh(d2, g2.deps)) {
      Rh(b2, c2, f2, d2);
      return;
    }
  }
  R$1.flags |= a2;
  e2.memoizedState = Rh(1 | b2, c2, f2, d2);
}
function Wh(a2, b2) {
  return Uh(516, 4, a2, b2);
}
function Xh(a2, b2) {
  return Vh(516, 4, a2, b2);
}
function Yh(a2, b2) {
  return Vh(4, 2, a2, b2);
}
function Zh(a2, b2) {
  if ("function" === typeof b2)
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
function $h(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return Vh(4, 2, Zh.bind(null, b2, a2), c2);
}
function ai() {
}
function bi(a2, b2) {
  var c2 = Ih();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Bh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function ci(a2, b2) {
  var c2 = Ih();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Bh(b2, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function di(a2, b2) {
  var c2 = eg();
  gg(98 > c2 ? 98 : c2, function() {
    a2(true);
  });
  gg(97 < c2 ? 97 : c2, function() {
    var c3 = wh.transition;
    wh.transition = 1;
    try {
      a2(false), b2();
    } finally {
      wh.transition = c3;
    }
  });
}
function Oh(a2, b2, c2) {
  var d2 = Hg(), e2 = Ig(a2), f2 = { lane: e2, action: c2, eagerReducer: null, eagerState: null, next: null }, g2 = b2.pending;
  null === g2 ? f2.next = f2 : (f2.next = g2.next, g2.next = f2);
  b2.pending = f2;
  g2 = a2.alternate;
  if (a2 === R$1 || null !== g2 && g2 === R$1)
    zh = yh = true;
  else {
    if (0 === a2.lanes && (null === g2 || 0 === g2.lanes) && (g2 = b2.lastRenderedReducer, null !== g2))
      try {
        var h2 = b2.lastRenderedState, k2 = g2(h2, c2);
        f2.eagerReducer = g2;
        f2.eagerState = k2;
        if (He(k2, h2))
          return;
      } catch (l2) {
      } finally {
      }
    Jg(a2, e2, d2);
  }
}
var Gh = { readContext: vg, useCallback: Ah, useContext: Ah, useEffect: Ah, useImperativeHandle: Ah, useLayoutEffect: Ah, useMemo: Ah, useReducer: Ah, useRef: Ah, useState: Ah, useDebugValue: Ah, useDeferredValue: Ah, useTransition: Ah, useMutableSource: Ah, useOpaqueIdentifier: Ah, unstable_isNewReconciler: false }, Dh = { readContext: vg, useCallback: function(a2, b2) {
  Hh().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: vg, useEffect: Wh, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return Uh(4, 2, Zh.bind(
    null,
    b2,
    a2
  ), c2);
}, useLayoutEffect: function(a2, b2) {
  return Uh(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = Hh();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = Hh();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = d2.queue = { pending: null, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  a2 = a2.dispatch = Oh.bind(null, R$1, a2);
  return [d2.memoizedState, a2];
}, useRef: Sh, useState: Qh, useDebugValue: ai, useDeferredValue: function(a2) {
  var b2 = Qh(a2), c2 = b2[0], d2 = b2[1];
  Wh(function() {
    var b3 = wh.transition;
    wh.transition = 1;
    try {
      d2(a2);
    } finally {
      wh.transition = b3;
    }
  }, [a2]);
  return c2;
}, useTransition: function() {
  var a2 = Qh(false), b2 = a2[0];
  a2 = di.bind(null, a2[1]);
  Sh(a2);
  return [a2, b2];
}, useMutableSource: function(a2, b2, c2) {
  var d2 = Hh();
  d2.memoizedState = { refs: { getSnapshot: b2, setSnapshot: null }, source: a2, subscribe: c2 };
  return Nh(d2, a2, b2, c2);
}, useOpaqueIdentifier: function() {
  if (lh) {
    var a2 = false, b2 = uf(function() {
      a2 || (a2 = true, c2("r:" + (tf++).toString(36)));
      throw Error(y$2(355));
    }), c2 = Qh(b2)[1];
    0 === (R$1.mode & 2) && (R$1.flags |= 516, Rh(
      5,
      function() {
        c2("r:" + (tf++).toString(36));
      },
      void 0,
      null
    ));
    return b2;
  }
  b2 = "r:" + (tf++).toString(36);
  Qh(b2);
  return b2;
}, unstable_isNewReconciler: false }, Eh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh, useRef: Th, useState: function() {
  return Kh(Jh);
}, useDebugValue: ai, useDeferredValue: function(a2) {
  var b2 = Kh(Jh), c2 = b2[0], d2 = b2[1];
  Xh(function() {
    var b3 = wh.transition;
    wh.transition = 1;
    try {
      d2(a2);
    } finally {
      wh.transition = b3;
    }
  }, [a2]);
  return c2;
}, useTransition: function() {
  var a2 = Kh(Jh)[0];
  return [
    Th().current,
    a2
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Kh(Jh)[0];
}, unstable_isNewReconciler: false }, Fh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th, useState: function() {
  return Lh(Jh);
}, useDebugValue: ai, useDeferredValue: function(a2) {
  var b2 = Lh(Jh), c2 = b2[0], d2 = b2[1];
  Xh(function() {
    var b3 = wh.transition;
    wh.transition = 1;
    try {
      d2(a2);
    } finally {
      wh.transition = b3;
    }
  }, [a2]);
  return c2;
}, useTransition: function() {
  var a2 = Lh(Jh)[0];
  return [
    Th().current,
    a2
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Lh(Jh)[0];
}, unstable_isNewReconciler: false }, ei = ra.ReactCurrentOwner, ug = false;
function fi(a2, b2, c2, d2) {
  b2.child = null === a2 ? Zg(b2, null, c2, d2) : Yg(b2, a2.child, c2, d2);
}
function gi(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  tg(b2, e2);
  d2 = Ch(a2, b2, c2, d2, f2, e2);
  if (null !== a2 && !ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -517, a2.lanes &= ~e2, hi(a2, b2, e2);
  b2.flags |= 1;
  fi(a2, b2, d2, e2);
  return b2.child;
}
function ii(a2, b2, c2, d2, e2, f2) {
  if (null === a2) {
    var g2 = c2.type;
    if ("function" === typeof g2 && !ji(g2) && void 0 === g2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = g2, ki(a2, b2, g2, d2, e2, f2);
    a2 = Vg(c2.type, null, d2, b2, b2.mode, f2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  g2 = a2.child;
  if (0 === (e2 & f2) && (e2 = g2.memoizedProps, c2 = c2.compare, c2 = null !== c2 ? c2 : Je, c2(e2, d2) && a2.ref === b2.ref))
    return hi(a2, b2, f2);
  b2.flags |= 1;
  a2 = Tg(g2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function ki(a2, b2, c2, d2, e2, f2) {
  if (null !== a2 && Je(a2.memoizedProps, d2) && a2.ref === b2.ref)
    if (ug = false, 0 !== (f2 & e2))
      0 !== (a2.flags & 16384) && (ug = true);
    else
      return b2.lanes = a2.lanes, hi(a2, b2, f2);
  return li(a2, b2, c2, d2, f2);
}
function mi(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode || "unstable-defer-without-hiding" === d2.mode)
    if (0 === (b2.mode & 4))
      b2.memoizedState = { baseLanes: 0 }, ni(b2, c2);
    else if (0 !== (c2 & 1073741824))
      b2.memoizedState = { baseLanes: 0 }, ni(b2, null !== f2 ? f2.baseLanes : c2);
    else
      return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2 }, ni(b2, a2), null;
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, ni(b2, d2);
  fi(a2, b2, e2, c2);
  return b2.child;
}
function oi(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b2.flags |= 128;
}
function li(a2, b2, c2, d2, e2) {
  var f2 = Ff(c2) ? Df : M$1.current;
  f2 = Ef(b2, f2);
  tg(b2, e2);
  c2 = Ch(a2, b2, c2, d2, f2, e2);
  if (null !== a2 && !ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -517, a2.lanes &= ~e2, hi(a2, b2, e2);
  b2.flags |= 1;
  fi(a2, b2, c2, e2);
  return b2.child;
}
function pi(a2, b2, c2, d2, e2) {
  if (Ff(c2)) {
    var f2 = true;
    Jf(b2);
  } else
    f2 = false;
  tg(b2, e2);
  if (null === b2.stateNode)
    null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2), Mg(b2, c2, d2), Og(b2, c2, d2, e2), d2 = true;
  else if (null === a2) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = vg(l2) : (l2 = Ff(c2) ? Df : M$1.current, l2 = Ef(b2, l2));
    var n2 = c2.getDerivedStateFromProps, A2 = "function" === typeof n2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    A2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && Ng(b2, g2, d2, l2);
    wg = false;
    var p = b2.memoizedState;
    g2.state = p;
    Cg(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || p !== k2 || N$1.current || wg ? ("function" === typeof n2 && (Gg(b2, c2, n2, d2), k2 = b2.memoizedState), (h2 = wg || Lg(b2, c2, h2, d2, p, k2, l2)) ? (A2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4), d2 = false);
  } else {
    g2 = b2.stateNode;
    yg(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : lg(b2.type, h2);
    g2.props = l2;
    A2 = b2.pendingProps;
    p = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = vg(k2) : (k2 = Ff(c2) ? Df : M$1.current, k2 = Ef(b2, k2));
    var C2 = c2.getDerivedStateFromProps;
    (n2 = "function" === typeof C2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== A2 || p !== k2) && Ng(b2, g2, d2, k2);
    wg = false;
    p = b2.memoizedState;
    g2.state = p;
    Cg(b2, d2, g2, e2);
    var x = b2.memoizedState;
    h2 !== A2 || p !== x || N$1.current || wg ? ("function" === typeof C2 && (Gg(b2, c2, C2, d2), x = b2.memoizedState), (l2 = wg || Lg(b2, c2, l2, d2, p, x, k2)) ? (n2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(
      d2,
      x,
      k2
    ), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, x, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 256)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && p === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && p === a2.memoizedState || (b2.flags |= 256), b2.memoizedProps = d2, b2.memoizedState = x), g2.props = d2, g2.state = x, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && p === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && p === a2.memoizedState || (b2.flags |= 256), d2 = false);
  }
  return qi(a2, b2, c2, d2, f2, e2);
}
function qi(a2, b2, c2, d2, e2, f2) {
  oi(a2, b2);
  var g2 = 0 !== (b2.flags & 64);
  if (!d2 && !g2)
    return e2 && Kf(b2, c2, false), hi(a2, b2, f2);
  d2 = b2.stateNode;
  ei.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g2 ? (b2.child = Yg(b2, a2.child, null, f2), b2.child = Yg(b2, null, h2, f2)) : fi(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && Kf(b2, c2, true);
  return b2.child;
}
function ri(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? Hf(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && Hf(a2, b2.context, false);
  eh(a2, b2.containerInfo);
}
var si = { dehydrated: null, retryLane: 0 };
function ti(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = P$1.current, f2 = false, g2;
  (g2 = 0 !== (b2.flags & 64)) || (g2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
  g2 ? (f2 = true, b2.flags &= -65) : null !== a2 && null === a2.memoizedState || void 0 === d2.fallback || true === d2.unstable_avoidThisFallback || (e2 |= 1);
  I$1(P$1, e2 & 1);
  if (null === a2) {
    void 0 !== d2.fallback && ph(b2);
    a2 = d2.children;
    e2 = d2.fallback;
    if (f2)
      return a2 = ui(b2, a2, e2, c2), b2.child.memoizedState = { baseLanes: c2 }, b2.memoizedState = si, a2;
    if ("number" === typeof d2.unstable_expectedLoadTime)
      return a2 = ui(b2, a2, e2, c2), b2.child.memoizedState = { baseLanes: c2 }, b2.memoizedState = si, b2.lanes = 33554432, a2;
    c2 = vi({ mode: "visible", children: a2 }, b2.mode, c2, null);
    c2.return = b2;
    return b2.child = c2;
  }
  if (null !== a2.memoizedState) {
    if (f2)
      return d2 = wi(a2, b2, d2.children, d2.fallback, c2), f2 = b2.child, e2 = a2.child.memoizedState, f2.memoizedState = null === e2 ? { baseLanes: c2 } : { baseLanes: e2.baseLanes | c2 }, f2.childLanes = a2.childLanes & ~c2, b2.memoizedState = si, d2;
    c2 = xi(a2, b2, d2.children, c2);
    b2.memoizedState = null;
    return c2;
  }
  if (f2)
    return d2 = wi(a2, b2, d2.children, d2.fallback, c2), f2 = b2.child, e2 = a2.child.memoizedState, f2.memoizedState = null === e2 ? { baseLanes: c2 } : { baseLanes: e2.baseLanes | c2 }, f2.childLanes = a2.childLanes & ~c2, b2.memoizedState = si, d2;
  c2 = xi(a2, b2, d2.children, c2);
  b2.memoizedState = null;
  return c2;
}
function ui(a2, b2, c2, d2) {
  var e2 = a2.mode, f2 = a2.child;
  b2 = { mode: "hidden", children: b2 };
  0 === (e2 & 2) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = b2) : f2 = vi(b2, e2, 0, null);
  c2 = Xg(c2, e2, d2, null);
  f2.return = a2;
  c2.return = a2;
  f2.sibling = c2;
  a2.child = f2;
  return c2;
}
function xi(a2, b2, c2, d2) {
  var e2 = a2.child;
  a2 = e2.sibling;
  c2 = Tg(e2, { mode: "visible", children: c2 });
  0 === (b2.mode & 2) && (c2.lanes = d2);
  c2.return = b2;
  c2.sibling = null;
  null !== a2 && (a2.nextEffect = null, a2.flags = 8, b2.firstEffect = b2.lastEffect = a2);
  return b2.child = c2;
}
function wi(a2, b2, c2, d2, e2) {
  var f2 = b2.mode, g2 = a2.child;
  a2 = g2.sibling;
  var h2 = { mode: "hidden", children: c2 };
  0 === (f2 & 2) && b2.child !== g2 ? (c2 = b2.child, c2.childLanes = 0, c2.pendingProps = h2, g2 = c2.lastEffect, null !== g2 ? (b2.firstEffect = c2.firstEffect, b2.lastEffect = g2, g2.nextEffect = null) : b2.firstEffect = b2.lastEffect = null) : c2 = Tg(g2, h2);
  null !== a2 ? d2 = Tg(a2, d2) : (d2 = Xg(d2, f2, e2, null), d2.flags |= 2);
  d2.return = b2;
  c2.return = b2;
  c2.sibling = d2;
  b2.child = c2;
  return d2;
}
function yi(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  sg(a2.return, b2);
}
function zi(a2, b2, c2, d2, e2, f2) {
  var g2 = a2.memoizedState;
  null === g2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2, lastEffect: f2 } : (g2.isBackwards = b2, g2.rendering = null, g2.renderingStartTime = 0, g2.last = d2, g2.tail = c2, g2.tailMode = e2, g2.lastEffect = f2);
}
function Ai(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  fi(a2, b2, d2.children, c2);
  d2 = P$1.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 64;
  else {
    if (null !== a2 && 0 !== (a2.flags & 64))
      a:
        for (a2 = b2.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && yi(a2, c2);
          else if (19 === a2.tag)
            yi(a2, c2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  I$1(P$1, d2);
  if (0 === (b2.mode & 2))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === ih(a2) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        zi(b2, false, e2, c2, f2, b2.lastEffect);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a2 = e2.alternate;
          if (null !== a2 && null === ih(a2)) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        zi(b2, true, c2, null, f2, b2.lastEffect);
        break;
      case "together":
        zi(b2, false, null, null, void 0, b2.lastEffect);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function hi(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  Dg |= b2.lanes;
  if (0 !== (c2 & b2.childLanes)) {
    if (null !== a2 && b2.child !== a2.child)
      throw Error(y$2(153));
    if (null !== b2.child) {
      a2 = b2.child;
      c2 = Tg(a2, a2.pendingProps);
      b2.child = c2;
      for (c2.return = b2; null !== a2.sibling; )
        a2 = a2.sibling, c2 = c2.sibling = Tg(a2, a2.pendingProps), c2.return = b2;
      c2.sibling = null;
    }
    return b2.child;
  }
  return null;
}
var Bi, Ci, Di, Ei;
Bi = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Ci = function() {
};
Di = function(a2, b2, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b2.stateNode;
    dh(ah.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a2, e2);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "option":
        e2 = eb(a2, e2);
        d2 = eb(a2, d2);
        f2 = [];
        break;
      case "select":
        e2 = m$4({}, e2, { value: void 0 });
        d2 = m$4({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a2, e2);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = jf);
    }
    vb(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ca.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(l2, c2)), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ca.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && G$1("scroll", a2), f2 || h2 === k2 || (f2 = [])) : "object" === typeof k2 && null !== k2 && k2.$$typeof === Ga ? k2.toString() : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push(
      "style",
      c2
    );
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Ei = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Fi(a2, b2) {
  if (!lh)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function Gi(a2, b2, c2) {
  var d2 = b2.pendingProps;
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return null;
    case 1:
      return Ff(b2.type) && Gf(), null;
    case 3:
      fh();
      H$1(N$1);
      H$1(M$1);
      uh();
      d2 = b2.stateNode;
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child)
        rh(b2) ? b2.flags |= 4 : d2.hydrate || (b2.flags |= 256);
      Ci(b2);
      return null;
    case 5:
      hh(b2);
      var e2 = dh(ch.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode)
        Di(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 128);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(y$2(166));
          return null;
        }
        a2 = dh(ah.current);
        if (rh(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[wf] = b2;
          d2[xf] = f2;
          switch (c2) {
            case "dialog":
              G$1("cancel", d2);
              G$1("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              G$1("load", d2);
              break;
            case "video":
            case "audio":
              for (a2 = 0; a2 < Xe.length; a2++)
                G$1(Xe[a2], d2);
              break;
            case "source":
              G$1("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              G$1("error", d2);
              G$1("load", d2);
              break;
            case "details":
              G$1("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              G$1("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              G$1("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), G$1("invalid", d2);
          }
          vb(c2, f2);
          a2 = null;
          for (var g2 in f2)
            f2.hasOwnProperty(g2) && (e2 = f2[g2], "children" === g2 ? "string" === typeof e2 ? d2.textContent !== e2 && (a2 = ["children", e2]) : "number" === typeof e2 && d2.textContent !== "" + e2 && (a2 = ["children", "" + e2]) : ca.hasOwnProperty(g2) && null != e2 && "onScroll" === g2 && G$1("scroll", d2));
          switch (c2) {
            case "input":
              Va(d2);
              cb(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = jf);
          }
          d2 = a2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          a2 === kb.html && (a2 = lb(c2));
          a2 === kb.html ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[wf] = b2;
          a2[xf] = d2;
          Bi(a2, b2, false, false);
          b2.stateNode = a2;
          g2 = wb(c2, d2);
          switch (c2) {
            case "dialog":
              G$1("cancel", a2);
              G$1("close", a2);
              e2 = d2;
              break;
            case "iframe":
            case "object":
            case "embed":
              G$1("load", a2);
              e2 = d2;
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < Xe.length; e2++)
                G$1(Xe[e2], a2);
              e2 = d2;
              break;
            case "source":
              G$1("error", a2);
              e2 = d2;
              break;
            case "img":
            case "image":
            case "link":
              G$1("error", a2);
              G$1("load", a2);
              e2 = d2;
              break;
            case "details":
              G$1("toggle", a2);
              e2 = d2;
              break;
            case "input":
              Za(a2, d2);
              e2 = Ya(a2, d2);
              G$1("invalid", a2);
              break;
            case "option":
              e2 = eb(a2, d2);
              break;
            case "select":
              a2._wrapperState = { wasMultiple: !!d2.multiple };
              e2 = m$4({}, d2, { value: void 0 });
              G$1("invalid", a2);
              break;
            case "textarea":
              hb(a2, d2);
              e2 = gb(a2, d2);
              G$1("invalid", a2);
              break;
            default:
              e2 = d2;
          }
          vb(c2, e2);
          var h2 = e2;
          for (f2 in h2)
            if (h2.hasOwnProperty(f2)) {
              var k2 = h2[f2];
              "style" === f2 ? tb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && ob(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && pb(a2, k2) : "number" === typeof k2 && pb(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ca.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && G$1("scroll", a2) : null != k2 && qa(a2, f2, k2, g2));
            }
          switch (c2) {
            case "input":
              Va(a2);
              cb(a2, d2, false);
              break;
            case "textarea":
              Va(a2);
              jb(a2);
              break;
            case "option":
              null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
              break;
            case "select":
              a2.multiple = !!d2.multiple;
              f2 = d2.value;
              null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(a2, !!d2.multiple, d2.defaultValue, true);
              break;
            default:
              "function" === typeof e2.onClick && (a2.onclick = jf);
          }
          mf(c2, d2) && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 128);
      }
      return null;
    case 6:
      if (a2 && null != b2.stateNode)
        Ei(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(y$2(166));
        c2 = dh(ch.current);
        dh(ah.current);
        rh(b2) ? (d2 = b2.stateNode, c2 = b2.memoizedProps, d2[wf] = b2, d2.nodeValue !== c2 && (b2.flags |= 4)) : (d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[wf] = b2, b2.stateNode = d2);
      }
      return null;
    case 13:
      H$1(P$1);
      d2 = b2.memoizedState;
      if (0 !== (b2.flags & 64))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      c2 = false;
      null === a2 ? void 0 !== b2.memoizedProps.fallback && rh(b2) : c2 = null !== a2.memoizedState;
      if (d2 && !c2 && 0 !== (b2.mode & 2))
        if (null === a2 && true !== b2.memoizedProps.unstable_avoidThisFallback || 0 !== (P$1.current & 1))
          0 === V && (V = 3);
        else {
          if (0 === V || 3 === V)
            V = 4;
          null === U$1 || 0 === (Dg & 134217727) && 0 === (Hi & 134217727) || Ii(U$1, W$1);
        }
      if (d2 || c2)
        b2.flags |= 4;
      return null;
    case 4:
      return fh(), Ci(b2), null === a2 && cf(b2.stateNode.containerInfo), null;
    case 10:
      return rg(b2), null;
    case 17:
      return Ff(b2.type) && Gf(), null;
    case 19:
      H$1(P$1);
      d2 = b2.memoizedState;
      if (null === d2)
        return null;
      f2 = 0 !== (b2.flags & 64);
      g2 = d2.rendering;
      if (null === g2)
        if (f2)
          Fi(d2, false);
        else {
          if (0 !== V || null !== a2 && 0 !== (a2.flags & 64))
            for (a2 = b2.child; null !== a2; ) {
              g2 = ih(a2);
              if (null !== g2) {
                b2.flags |= 64;
                Fi(d2, false);
                f2 = g2.updateQueue;
                null !== f2 && (b2.updateQueue = f2, b2.flags |= 4);
                null === d2.lastEffect && (b2.firstEffect = null);
                b2.lastEffect = d2.lastEffect;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a2 = d2, f2.flags &= 2, f2.nextEffect = null, f2.firstEffect = null, f2.lastEffect = null, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                I$1(P$1, P$1.current & 1 | 2);
                return b2.child;
              }
              a2 = a2.sibling;
            }
          null !== d2.tail && O$1() > Ji && (b2.flags |= 64, f2 = true, Fi(d2, false), b2.lanes = 33554432);
        }
      else {
        if (!f2)
          if (a2 = ih(g2), null !== a2) {
            if (b2.flags |= 64, f2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Fi(d2, true), null === d2.tail && "hidden" === d2.tailMode && !g2.alternate && !lh)
              return b2 = b2.lastEffect = d2.lastEffect, null !== b2 && (b2.nextEffect = null), null;
          } else
            2 * O$1() - d2.renderingStartTime > Ji && 1073741824 !== c2 && (b2.flags |= 64, f2 = true, Fi(d2, false), b2.lanes = 33554432);
        d2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = d2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, d2.last = g2);
      }
      return null !== d2.tail ? (c2 = d2.tail, d2.rendering = c2, d2.tail = c2.sibling, d2.lastEffect = b2.lastEffect, d2.renderingStartTime = O$1(), c2.sibling = null, b2 = P$1.current, I$1(P$1, f2 ? b2 & 1 | 2 : b2 & 1), c2) : null;
    case 23:
    case 24:
      return Ki(), null !== a2 && null !== a2.memoizedState !== (null !== b2.memoizedState) && "unstable-defer-without-hiding" !== d2.mode && (b2.flags |= 4), null;
  }
  throw Error(y$2(156, b2.tag));
}
function Li(a2) {
  switch (a2.tag) {
    case 1:
      Ff(a2.type) && Gf();
      var b2 = a2.flags;
      return b2 & 4096 ? (a2.flags = b2 & -4097 | 64, a2) : null;
    case 3:
      fh();
      H$1(N$1);
      H$1(M$1);
      uh();
      b2 = a2.flags;
      if (0 !== (b2 & 64))
        throw Error(y$2(285));
      a2.flags = b2 & -4097 | 64;
      return a2;
    case 5:
      return hh(a2), null;
    case 13:
      return H$1(P$1), b2 = a2.flags, b2 & 4096 ? (a2.flags = b2 & -4097 | 64, a2) : null;
    case 19:
      return H$1(P$1), null;
    case 4:
      return fh(), null;
    case 10:
      return rg(a2), null;
    case 23:
    case 24:
      return Ki(), null;
    default:
      return null;
  }
}
function Mi(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Qa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e2 };
}
function Ni(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Oi = "function" === typeof WeakMap ? WeakMap : Map;
function Pi(a2, b2, c2) {
  c2 = zg(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Qi || (Qi = true, Ri = d2);
    Ni(a2, b2);
  };
  return c2;
}
function Si(a2, b2, c2) {
  c2 = zg(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      Ni(a2, b2);
      return d2(e2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    "function" !== typeof d2 && (null === Ti ? Ti = /* @__PURE__ */ new Set([this]) : Ti.add(this), Ni(a2, b2));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
var Ui = "function" === typeof WeakSet ? WeakSet : Set;
function Vi(a2) {
  var b2 = a2.ref;
  if (null !== b2)
    if ("function" === typeof b2)
      try {
        b2(null);
      } catch (c2) {
        Wi(a2, c2);
      }
    else
      b2.current = null;
}
function Xi(a2, b2) {
  switch (b2.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      return;
    case 1:
      if (b2.flags & 256 && null !== a2) {
        var c2 = a2.memoizedProps, d2 = a2.memoizedState;
        a2 = b2.stateNode;
        b2 = a2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? c2 : lg(b2.type, c2), d2);
        a2.__reactInternalSnapshotBeforeUpdate = b2;
      }
      return;
    case 3:
      b2.flags & 256 && qf(b2.stateNode.containerInfo);
      return;
    case 5:
    case 6:
    case 4:
    case 17:
      return;
  }
  throw Error(y$2(163));
}
function Yi(a2, b2, c2) {
  switch (c2.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      b2 = c2.updateQueue;
      b2 = null !== b2 ? b2.lastEffect : null;
      if (null !== b2) {
        a2 = b2 = b2.next;
        do {
          if (3 === (a2.tag & 3)) {
            var d2 = a2.create;
            a2.destroy = d2();
          }
          a2 = a2.next;
        } while (a2 !== b2);
      }
      b2 = c2.updateQueue;
      b2 = null !== b2 ? b2.lastEffect : null;
      if (null !== b2) {
        a2 = b2 = b2.next;
        do {
          var e2 = a2;
          d2 = e2.next;
          e2 = e2.tag;
          0 !== (e2 & 4) && 0 !== (e2 & 1) && (Zi(c2, a2), $i(c2, a2));
          a2 = d2;
        } while (a2 !== b2);
      }
      return;
    case 1:
      a2 = c2.stateNode;
      c2.flags & 4 && (null === b2 ? a2.componentDidMount() : (d2 = c2.elementType === c2.type ? b2.memoizedProps : lg(c2.type, b2.memoizedProps), a2.componentDidUpdate(
        d2,
        b2.memoizedState,
        a2.__reactInternalSnapshotBeforeUpdate
      )));
      b2 = c2.updateQueue;
      null !== b2 && Eg(c2, b2, a2);
      return;
    case 3:
      b2 = c2.updateQueue;
      if (null !== b2) {
        a2 = null;
        if (null !== c2.child)
          switch (c2.child.tag) {
            case 5:
              a2 = c2.child.stateNode;
              break;
            case 1:
              a2 = c2.child.stateNode;
          }
        Eg(c2, b2, a2);
      }
      return;
    case 5:
      a2 = c2.stateNode;
      null === b2 && c2.flags & 4 && mf(c2.type, c2.memoizedProps) && a2.focus();
      return;
    case 6:
      return;
    case 4:
      return;
    case 12:
      return;
    case 13:
      null === c2.memoizedState && (c2 = c2.alternate, null !== c2 && (c2 = c2.memoizedState, null !== c2 && (c2 = c2.dehydrated, null !== c2 && Cc(c2))));
      return;
    case 19:
    case 17:
    case 20:
    case 21:
    case 23:
    case 24:
      return;
  }
  throw Error(y$2(163));
}
function aj(a2, b2) {
  for (var c2 = a2; ; ) {
    if (5 === c2.tag) {
      var d2 = c2.stateNode;
      if (b2)
        d2 = d2.style, "function" === typeof d2.setProperty ? d2.setProperty("display", "none", "important") : d2.display = "none";
      else {
        d2 = c2.stateNode;
        var e2 = c2.memoizedProps.style;
        e2 = void 0 !== e2 && null !== e2 && e2.hasOwnProperty("display") ? e2.display : null;
        d2.style.display = sb("display", e2);
      }
    } else if (6 === c2.tag)
      c2.stateNode.nodeValue = b2 ? "" : c2.memoizedProps;
    else if ((23 !== c2.tag && 24 !== c2.tag || null === c2.memoizedState || c2 === a2) && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === a2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === a2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
}
function bj(a2, b2) {
  if (Mf && "function" === typeof Mf.onCommitFiberUnmount)
    try {
      Mf.onCommitFiberUnmount(Lf, b2);
    } catch (f2) {
    }
  switch (b2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      a2 = b2.updateQueue;
      if (null !== a2 && (a2 = a2.lastEffect, null !== a2)) {
        var c2 = a2 = a2.next;
        do {
          var d2 = c2, e2 = d2.destroy;
          d2 = d2.tag;
          if (void 0 !== e2)
            if (0 !== (d2 & 4))
              Zi(b2, c2);
            else {
              d2 = b2;
              try {
                e2();
              } catch (f2) {
                Wi(d2, f2);
              }
            }
          c2 = c2.next;
        } while (c2 !== a2);
      }
      break;
    case 1:
      Vi(b2);
      a2 = b2.stateNode;
      if ("function" === typeof a2.componentWillUnmount)
        try {
          a2.props = b2.memoizedProps, a2.state = b2.memoizedState, a2.componentWillUnmount();
        } catch (f2) {
          Wi(
            b2,
            f2
          );
        }
      break;
    case 5:
      Vi(b2);
      break;
    case 4:
      cj(a2, b2);
  }
}
function dj(a2) {
  a2.alternate = null;
  a2.child = null;
  a2.dependencies = null;
  a2.firstEffect = null;
  a2.lastEffect = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.return = null;
  a2.updateQueue = null;
}
function ej(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function fj(a2) {
  a: {
    for (var b2 = a2.return; null !== b2; ) {
      if (ej(b2))
        break a;
      b2 = b2.return;
    }
    throw Error(y$2(160));
  }
  var c2 = b2;
  b2 = c2.stateNode;
  switch (c2.tag) {
    case 5:
      var d2 = false;
      break;
    case 3:
      b2 = b2.containerInfo;
      d2 = true;
      break;
    case 4:
      b2 = b2.containerInfo;
      d2 = true;
      break;
    default:
      throw Error(y$2(161));
  }
  c2.flags & 16 && (pb(b2, ""), c2.flags &= -17);
  a:
    b:
      for (c2 = a2; ; ) {
        for (; null === c2.sibling; ) {
          if (null === c2.return || ej(c2.return)) {
            c2 = null;
            break a;
          }
          c2 = c2.return;
        }
        c2.sibling.return = c2.return;
        for (c2 = c2.sibling; 5 !== c2.tag && 6 !== c2.tag && 18 !== c2.tag; ) {
          if (c2.flags & 2)
            continue b;
          if (null === c2.child || 4 === c2.tag)
            continue b;
          else
            c2.child.return = c2, c2 = c2.child;
        }
        if (!(c2.flags & 2)) {
          c2 = c2.stateNode;
          break a;
        }
      }
  d2 ? gj(a2, c2, b2) : hj(a2, c2, b2);
}
function gj(a2, b2, c2) {
  var d2 = a2.tag, e2 = 5 === d2 || 6 === d2;
  if (e2)
    a2 = e2 ? a2.stateNode : a2.stateNode.instance, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = jf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (gj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      gj(a2, b2, c2), a2 = a2.sibling;
}
function hj(a2, b2, c2) {
  var d2 = a2.tag, e2 = 5 === d2 || 6 === d2;
  if (e2)
    a2 = e2 ? a2.stateNode : a2.stateNode.instance, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (hj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      hj(a2, b2, c2), a2 = a2.sibling;
}
function cj(a2, b2) {
  for (var c2 = b2, d2 = false, e2, f2; ; ) {
    if (!d2) {
      d2 = c2.return;
      a:
        for (; ; ) {
          if (null === d2)
            throw Error(y$2(160));
          e2 = d2.stateNode;
          switch (d2.tag) {
            case 5:
              f2 = false;
              break a;
            case 3:
              e2 = e2.containerInfo;
              f2 = true;
              break a;
            case 4:
              e2 = e2.containerInfo;
              f2 = true;
              break a;
          }
          d2 = d2.return;
        }
      d2 = true;
    }
    if (5 === c2.tag || 6 === c2.tag) {
      a:
        for (var g2 = a2, h2 = c2, k2 = h2; ; )
          if (bj(g2, k2), null !== k2.child && 4 !== k2.tag)
            k2.child.return = k2, k2 = k2.child;
          else {
            if (k2 === h2)
              break a;
            for (; null === k2.sibling; ) {
              if (null === k2.return || k2.return === h2)
                break a;
              k2 = k2.return;
            }
            k2.sibling.return = k2.return;
            k2 = k2.sibling;
          }
      f2 ? (g2 = e2, h2 = c2.stateNode, 8 === g2.nodeType ? g2.parentNode.removeChild(h2) : g2.removeChild(h2)) : e2.removeChild(c2.stateNode);
    } else if (4 === c2.tag) {
      if (null !== c2.child) {
        e2 = c2.stateNode.containerInfo;
        f2 = true;
        c2.child.return = c2;
        c2 = c2.child;
        continue;
      }
    } else if (bj(a2, c2), null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
      4 === c2.tag && (d2 = false);
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
}
function ij(a2, b2) {
  switch (b2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      var c2 = b2.updateQueue;
      c2 = null !== c2 ? c2.lastEffect : null;
      if (null !== c2) {
        var d2 = c2 = c2.next;
        do
          3 === (d2.tag & 3) && (a2 = d2.destroy, d2.destroy = void 0, void 0 !== a2 && a2()), d2 = d2.next;
        while (d2 !== c2);
      }
      return;
    case 1:
      return;
    case 5:
      c2 = b2.stateNode;
      if (null != c2) {
        d2 = b2.memoizedProps;
        var e2 = null !== a2 ? a2.memoizedProps : d2;
        a2 = b2.type;
        var f2 = b2.updateQueue;
        b2.updateQueue = null;
        if (null !== f2) {
          c2[xf] = d2;
          "input" === a2 && "radio" === d2.type && null != d2.name && $a(c2, d2);
          wb(a2, e2);
          b2 = wb(a2, d2);
          for (e2 = 0; e2 < f2.length; e2 += 2) {
            var g2 = f2[e2], h2 = f2[e2 + 1];
            "style" === g2 ? tb(c2, h2) : "dangerouslySetInnerHTML" === g2 ? ob(c2, h2) : "children" === g2 ? pb(c2, h2) : qa(c2, g2, h2, b2);
          }
          switch (a2) {
            case "input":
              ab(c2, d2);
              break;
            case "textarea":
              ib(c2, d2);
              break;
            case "select":
              a2 = c2._wrapperState.wasMultiple, c2._wrapperState.wasMultiple = !!d2.multiple, f2 = d2.value, null != f2 ? fb(c2, !!d2.multiple, f2, false) : a2 !== !!d2.multiple && (null != d2.defaultValue ? fb(c2, !!d2.multiple, d2.defaultValue, true) : fb(c2, !!d2.multiple, d2.multiple ? [] : "", false));
          }
        }
      }
      return;
    case 6:
      if (null === b2.stateNode)
        throw Error(y$2(162));
      b2.stateNode.nodeValue = b2.memoizedProps;
      return;
    case 3:
      c2 = b2.stateNode;
      c2.hydrate && (c2.hydrate = false, Cc(c2.containerInfo));
      return;
    case 12:
      return;
    case 13:
      null !== b2.memoizedState && (jj = O$1(), aj(b2.child, true));
      kj(b2);
      return;
    case 19:
      kj(b2);
      return;
    case 17:
      return;
    case 23:
    case 24:
      aj(b2, null !== b2.memoizedState);
      return;
  }
  throw Error(y$2(163));
}
function kj(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Ui());
    b2.forEach(function(b3) {
      var d2 = lj.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function mj(a2, b2) {
  return null !== a2 && (a2 = a2.memoizedState, null === a2 || null !== a2.dehydrated) ? (b2 = b2.memoizedState, null !== b2 && null === b2.dehydrated) : false;
}
var nj = Math.ceil, oj = ra.ReactCurrentDispatcher, pj = ra.ReactCurrentOwner, X$1 = 0, U$1 = null, Y = null, W$1 = 0, qj = 0, rj = Bf(0), V = 0, sj = null, tj = 0, Dg = 0, Hi = 0, uj = 0, vj = null, jj = 0, Ji = Infinity;
function wj() {
  Ji = O$1() + 500;
}
var Z$1 = null, Qi = false, Ri = null, Ti = null, xj = false, yj = null, zj = 90, Aj = [], Bj = [], Cj = null, Dj = 0, Ej = null, Fj = -1, Gj = 0, Hj = 0, Ij = null, Jj = false;
function Hg() {
  return 0 !== (X$1 & 48) ? O$1() : -1 !== Fj ? Fj : Fj = O$1();
}
function Ig(a2) {
  a2 = a2.mode;
  if (0 === (a2 & 2))
    return 1;
  if (0 === (a2 & 4))
    return 99 === eg() ? 1 : 2;
  0 === Gj && (Gj = tj);
  if (0 !== kg.transition) {
    0 !== Hj && (Hj = null !== vj ? vj.pendingLanes : 0);
    a2 = Gj;
    var b2 = 4186112 & ~Hj;
    b2 &= -b2;
    0 === b2 && (a2 = 4186112 & ~a2, b2 = a2 & -a2, 0 === b2 && (b2 = 8192));
    return b2;
  }
  a2 = eg();
  0 !== (X$1 & 4) && 98 === a2 ? a2 = Xc(12, Gj) : (a2 = Sc(a2), a2 = Xc(a2, Gj));
  return a2;
}
function Jg(a2, b2, c2) {
  if (50 < Dj)
    throw Dj = 0, Ej = null, Error(y$2(185));
  a2 = Kj(a2, b2);
  if (null === a2)
    return null;
  $c(a2, b2, c2);
  a2 === U$1 && (Hi |= b2, 4 === V && Ii(a2, W$1));
  var d2 = eg();
  1 === b2 ? 0 !== (X$1 & 8) && 0 === (X$1 & 48) ? Lj(a2) : (Mj(a2, c2), 0 === X$1 && (wj(), ig())) : (0 === (X$1 & 4) || 98 !== d2 && 99 !== d2 || (null === Cj ? Cj = /* @__PURE__ */ new Set([a2]) : Cj.add(a2)), Mj(a2, c2));
  vj = a2;
}
function Kj(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
function Mj(a2, b2) {
  for (var c2 = a2.callbackNode, d2 = a2.suspendedLanes, e2 = a2.pingedLanes, f2 = a2.expirationTimes, g2 = a2.pendingLanes; 0 < g2; ) {
    var h2 = 31 - Vc(g2), k2 = 1 << h2, l2 = f2[h2];
    if (-1 === l2) {
      if (0 === (k2 & d2) || 0 !== (k2 & e2)) {
        l2 = b2;
        Rc(k2);
        var n2 = F$1;
        f2[h2] = 10 <= n2 ? l2 + 250 : 6 <= n2 ? l2 + 5e3 : -1;
      }
    } else
      l2 <= b2 && (a2.expiredLanes |= k2);
    g2 &= ~k2;
  }
  d2 = Uc(a2, a2 === U$1 ? W$1 : 0);
  b2 = F$1;
  if (0 === d2)
    null !== c2 && (c2 !== Zf && Pf(c2), a2.callbackNode = null, a2.callbackPriority = 0);
  else {
    if (null !== c2) {
      if (a2.callbackPriority === b2)
        return;
      c2 !== Zf && Pf(c2);
    }
    15 === b2 ? (c2 = Lj.bind(null, a2), null === ag ? (ag = [c2], bg = Of(Uf, jg)) : ag.push(c2), c2 = Zf) : 14 === b2 ? c2 = hg(99, Lj.bind(null, a2)) : (c2 = Tc(b2), c2 = hg(c2, Nj.bind(null, a2)));
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Nj(a2) {
  Fj = -1;
  Hj = Gj = 0;
  if (0 !== (X$1 & 48))
    throw Error(y$2(327));
  var b2 = a2.callbackNode;
  if (Oj() && a2.callbackNode !== b2)
    return null;
  var c2 = Uc(a2, a2 === U$1 ? W$1 : 0);
  if (0 === c2)
    return null;
  var d2 = c2;
  var e2 = X$1;
  X$1 |= 16;
  var f2 = Pj();
  if (U$1 !== a2 || W$1 !== d2)
    wj(), Qj(a2, d2);
  do
    try {
      Rj();
      break;
    } catch (h2) {
      Sj(a2, h2);
    }
  while (1);
  qg();
  oj.current = f2;
  X$1 = e2;
  null !== Y ? d2 = 0 : (U$1 = null, W$1 = 0, d2 = V);
  if (0 !== (tj & Hi))
    Qj(a2, 0);
  else if (0 !== d2) {
    2 === d2 && (X$1 |= 64, a2.hydrate && (a2.hydrate = false, qf(a2.containerInfo)), c2 = Wc(a2), 0 !== c2 && (d2 = Tj(a2, c2)));
    if (1 === d2)
      throw b2 = sj, Qj(a2, 0), Ii(a2, c2), Mj(a2, O$1()), b2;
    a2.finishedWork = a2.current.alternate;
    a2.finishedLanes = c2;
    switch (d2) {
      case 0:
      case 1:
        throw Error(y$2(345));
      case 2:
        Uj(a2);
        break;
      case 3:
        Ii(a2, c2);
        if ((c2 & 62914560) === c2 && (d2 = jj + 500 - O$1(), 10 < d2)) {
          if (0 !== Uc(a2, 0))
            break;
          e2 = a2.suspendedLanes;
          if ((e2 & c2) !== c2) {
            Hg();
            a2.pingedLanes |= a2.suspendedLanes & e2;
            break;
          }
          a2.timeoutHandle = of(Uj.bind(null, a2), d2);
          break;
        }
        Uj(a2);
        break;
      case 4:
        Ii(a2, c2);
        if ((c2 & 4186112) === c2)
          break;
        d2 = a2.eventTimes;
        for (e2 = -1; 0 < c2; ) {
          var g2 = 31 - Vc(c2);
          f2 = 1 << g2;
          g2 = d2[g2];
          g2 > e2 && (e2 = g2);
          c2 &= ~f2;
        }
        c2 = e2;
        c2 = O$1() - c2;
        c2 = (120 > c2 ? 120 : 480 > c2 ? 480 : 1080 > c2 ? 1080 : 1920 > c2 ? 1920 : 3e3 > c2 ? 3e3 : 4320 > c2 ? 4320 : 1960 * nj(c2 / 1960)) - c2;
        if (10 < c2) {
          a2.timeoutHandle = of(Uj.bind(null, a2), c2);
          break;
        }
        Uj(a2);
        break;
      case 5:
        Uj(a2);
        break;
      default:
        throw Error(y$2(329));
    }
  }
  Mj(a2, O$1());
  return a2.callbackNode === b2 ? Nj.bind(null, a2) : null;
}
function Ii(a2, b2) {
  b2 &= ~uj;
  b2 &= ~Hi;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - Vc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Lj(a2) {
  if (0 !== (X$1 & 48))
    throw Error(y$2(327));
  Oj();
  if (a2 === U$1 && 0 !== (a2.expiredLanes & W$1)) {
    var b2 = W$1;
    var c2 = Tj(a2, b2);
    0 !== (tj & Hi) && (b2 = Uc(a2, b2), c2 = Tj(a2, b2));
  } else
    b2 = Uc(a2, 0), c2 = Tj(a2, b2);
  0 !== a2.tag && 2 === c2 && (X$1 |= 64, a2.hydrate && (a2.hydrate = false, qf(a2.containerInfo)), b2 = Wc(a2), 0 !== b2 && (c2 = Tj(a2, b2)));
  if (1 === c2)
    throw c2 = sj, Qj(a2, 0), Ii(a2, b2), Mj(a2, O$1()), c2;
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Uj(a2);
  Mj(a2, O$1());
  return null;
}
function Vj() {
  if (null !== Cj) {
    var a2 = Cj;
    Cj = null;
    a2.forEach(function(a3) {
      a3.expiredLanes |= 24 & a3.pendingLanes;
      Mj(a3, O$1());
    });
  }
  ig();
}
function Wj(a2, b2) {
  var c2 = X$1;
  X$1 |= 1;
  try {
    return a2(b2);
  } finally {
    X$1 = c2, 0 === X$1 && (wj(), ig());
  }
}
function Xj(a2, b2) {
  var c2 = X$1;
  X$1 &= -2;
  X$1 |= 8;
  try {
    return a2(b2);
  } finally {
    X$1 = c2, 0 === X$1 && (wj(), ig());
  }
}
function ni(a2, b2) {
  I$1(rj, qj);
  qj |= b2;
  tj |= b2;
}
function Ki() {
  qj = rj.current;
  H$1(rj);
}
function Qj(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, pf(c2));
  if (null !== Y)
    for (c2 = Y.return; null !== c2; ) {
      var d2 = c2;
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && Gf();
          break;
        case 3:
          fh();
          H$1(N$1);
          H$1(M$1);
          uh();
          break;
        case 5:
          hh(d2);
          break;
        case 4:
          fh();
          break;
        case 13:
          H$1(P$1);
          break;
        case 19:
          H$1(P$1);
          break;
        case 10:
          rg(d2);
          break;
        case 23:
        case 24:
          Ki();
      }
      c2 = c2.return;
    }
  U$1 = a2;
  Y = Tg(a2.current, null);
  W$1 = qj = tj = b2;
  V = 0;
  sj = null;
  uj = Hi = Dg = 0;
}
function Sj(a2, b2) {
  do {
    var c2 = Y;
    try {
      qg();
      vh.current = Gh;
      if (yh) {
        for (var d2 = R$1.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        yh = false;
      }
      xh = 0;
      T = S$1 = R$1 = null;
      zh = false;
      pj.current = null;
      if (null === c2 || null === c2.return) {
        V = 1;
        sj = b2;
        Y = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = W$1;
        h2.flags |= 2048;
        h2.firstEffect = h2.lastEffect = null;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2;
          if (0 === (h2.mode & 2)) {
            var n2 = h2.alternate;
            n2 ? (h2.updateQueue = n2.updateQueue, h2.memoizedState = n2.memoizedState, h2.lanes = n2.lanes) : (h2.updateQueue = null, h2.memoizedState = null);
          }
          var A2 = 0 !== (P$1.current & 1), p = g2;
          do {
            var C2;
            if (C2 = 13 === p.tag) {
              var x = p.memoizedState;
              if (null !== x)
                C2 = null !== x.dehydrated ? true : false;
              else {
                var w2 = p.memoizedProps;
                C2 = void 0 === w2.fallback ? false : true !== w2.unstable_avoidThisFallback ? true : A2 ? false : true;
              }
            }
            if (C2) {
              var z2 = p.updateQueue;
              if (null === z2) {
                var u2 = /* @__PURE__ */ new Set();
                u2.add(l2);
                p.updateQueue = u2;
              } else
                z2.add(l2);
              if (0 === (p.mode & 2)) {
                p.flags |= 64;
                h2.flags |= 16384;
                h2.flags &= -2981;
                if (1 === h2.tag)
                  if (null === h2.alternate)
                    h2.tag = 17;
                  else {
                    var t2 = zg(-1, 1);
                    t2.tag = 2;
                    Ag(h2, t2);
                  }
                h2.lanes |= 1;
                break a;
              }
              k2 = void 0;
              h2 = b2;
              var q2 = f2.pingCache;
              null === q2 ? (q2 = f2.pingCache = new Oi(), k2 = /* @__PURE__ */ new Set(), q2.set(l2, k2)) : (k2 = q2.get(l2), void 0 === k2 && (k2 = /* @__PURE__ */ new Set(), q2.set(l2, k2)));
              if (!k2.has(h2)) {
                k2.add(h2);
                var v2 = Yj.bind(null, f2, l2, h2);
                l2.then(v2, v2);
              }
              p.flags |= 4096;
              p.lanes = b2;
              break a;
            }
            p = p.return;
          } while (null !== p);
          k2 = Error((Ra(h2.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
        }
        5 !== V && (V = 2);
        k2 = Mi(k2, h2);
        p = g2;
        do {
          switch (p.tag) {
            case 3:
              f2 = k2;
              p.flags |= 4096;
              b2 &= -b2;
              p.lanes |= b2;
              var J2 = Pi(p, f2, b2);
              Bg(p, J2);
              break a;
            case 1:
              f2 = k2;
              var K2 = p.type, Q2 = p.stateNode;
              if (0 === (p.flags & 64) && ("function" === typeof K2.getDerivedStateFromError || null !== Q2 && "function" === typeof Q2.componentDidCatch && (null === Ti || !Ti.has(Q2)))) {
                p.flags |= 4096;
                b2 &= -b2;
                p.lanes |= b2;
                var L2 = Si(p, f2, b2);
                Bg(p, L2);
                break a;
              }
          }
          p = p.return;
        } while (null !== p);
      }
      Zj(c2);
    } catch (va) {
      b2 = va;
      Y === c2 && null !== c2 && (Y = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Pj() {
  var a2 = oj.current;
  oj.current = Gh;
  return null === a2 ? Gh : a2;
}
function Tj(a2, b2) {
  var c2 = X$1;
  X$1 |= 16;
  var d2 = Pj();
  U$1 === a2 && W$1 === b2 || Qj(a2, b2);
  do
    try {
      ak();
      break;
    } catch (e2) {
      Sj(a2, e2);
    }
  while (1);
  qg();
  X$1 = c2;
  oj.current = d2;
  if (null !== Y)
    throw Error(y$2(261));
  U$1 = null;
  W$1 = 0;
  return V;
}
function ak() {
  for (; null !== Y; )
    bk(Y);
}
function Rj() {
  for (; null !== Y && !Qf(); )
    bk(Y);
}
function bk(a2) {
  var b2 = ck(a2.alternate, a2, qj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Zj(a2) : Y = b2;
  pj.current = null;
}
function Zj(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 2048)) {
      c2 = Gi(c2, b2, qj);
      if (null !== c2) {
        Y = c2;
        return;
      }
      c2 = b2;
      if (24 !== c2.tag && 23 !== c2.tag || null === c2.memoizedState || 0 !== (qj & 1073741824) || 0 === (c2.mode & 4)) {
        for (var d2 = 0, e2 = c2.child; null !== e2; )
          d2 |= e2.lanes | e2.childLanes, e2 = e2.sibling;
        c2.childLanes = d2;
      }
      null !== a2 && 0 === (a2.flags & 2048) && (null === a2.firstEffect && (a2.firstEffect = b2.firstEffect), null !== b2.lastEffect && (null !== a2.lastEffect && (a2.lastEffect.nextEffect = b2.firstEffect), a2.lastEffect = b2.lastEffect), 1 < b2.flags && (null !== a2.lastEffect ? a2.lastEffect.nextEffect = b2 : a2.firstEffect = b2, a2.lastEffect = b2));
    } else {
      c2 = Li(b2);
      if (null !== c2) {
        c2.flags &= 2047;
        Y = c2;
        return;
      }
      null !== a2 && (a2.firstEffect = a2.lastEffect = null, a2.flags |= 2048);
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y = b2;
      return;
    }
    Y = b2 = a2;
  } while (null !== b2);
  0 === V && (V = 5);
}
function Uj(a2) {
  var b2 = eg();
  gg(99, dk.bind(null, a2, b2));
  return null;
}
function dk(a2, b2) {
  do
    Oj();
  while (null !== yj);
  if (0 !== (X$1 & 48))
    throw Error(y$2(327));
  var c2 = a2.finishedWork;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(y$2(177));
  a2.callbackNode = null;
  var d2 = c2.lanes | c2.childLanes, e2 = d2, f2 = a2.pendingLanes & ~e2;
  a2.pendingLanes = e2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= e2;
  a2.mutableReadLanes &= e2;
  a2.entangledLanes &= e2;
  e2 = a2.entanglements;
  for (var g2 = a2.eventTimes, h2 = a2.expirationTimes; 0 < f2; ) {
    var k2 = 31 - Vc(f2), l2 = 1 << k2;
    e2[k2] = 0;
    g2[k2] = -1;
    h2[k2] = -1;
    f2 &= ~l2;
  }
  null !== Cj && 0 === (d2 & 24) && Cj.has(a2) && Cj.delete(a2);
  a2 === U$1 && (Y = U$1 = null, W$1 = 0);
  1 < c2.flags ? null !== c2.lastEffect ? (c2.lastEffect.nextEffect = c2, d2 = c2.firstEffect) : d2 = c2 : d2 = c2.firstEffect;
  if (null !== d2) {
    e2 = X$1;
    X$1 |= 32;
    pj.current = null;
    kf = fd;
    g2 = Ne();
    if (Oe(g2)) {
      if ("selectionStart" in g2)
        h2 = { start: g2.selectionStart, end: g2.selectionEnd };
      else
        a:
          if (h2 = (h2 = g2.ownerDocument) && h2.defaultView || window, (l2 = h2.getSelection && h2.getSelection()) && 0 !== l2.rangeCount) {
            h2 = l2.anchorNode;
            f2 = l2.anchorOffset;
            k2 = l2.focusNode;
            l2 = l2.focusOffset;
            try {
              h2.nodeType, k2.nodeType;
            } catch (va) {
              h2 = null;
              break a;
            }
            var n2 = 0, A2 = -1, p = -1, C2 = 0, x = 0, w2 = g2, z2 = null;
            b:
              for (; ; ) {
                for (var u2; ; ) {
                  w2 !== h2 || 0 !== f2 && 3 !== w2.nodeType || (A2 = n2 + f2);
                  w2 !== k2 || 0 !== l2 && 3 !== w2.nodeType || (p = n2 + l2);
                  3 === w2.nodeType && (n2 += w2.nodeValue.length);
                  if (null === (u2 = w2.firstChild))
                    break;
                  z2 = w2;
                  w2 = u2;
                }
                for (; ; ) {
                  if (w2 === g2)
                    break b;
                  z2 === h2 && ++C2 === f2 && (A2 = n2);
                  z2 === k2 && ++x === l2 && (p = n2);
                  if (null !== (u2 = w2.nextSibling))
                    break;
                  w2 = z2;
                  z2 = w2.parentNode;
                }
                w2 = u2;
              }
            h2 = -1 === A2 || -1 === p ? null : { start: A2, end: p };
          } else
            h2 = null;
      h2 = h2 || { start: 0, end: 0 };
    } else
      h2 = null;
    lf = { focusedElem: g2, selectionRange: h2 };
    fd = false;
    Ij = null;
    Jj = false;
    Z$1 = d2;
    do
      try {
        ek();
      } catch (va) {
        if (null === Z$1)
          throw Error(y$2(330));
        Wi(Z$1, va);
        Z$1 = Z$1.nextEffect;
      }
    while (null !== Z$1);
    Ij = null;
    Z$1 = d2;
    do
      try {
        for (g2 = a2; null !== Z$1; ) {
          var t2 = Z$1.flags;
          t2 & 16 && pb(Z$1.stateNode, "");
          if (t2 & 128) {
            var q2 = Z$1.alternate;
            if (null !== q2) {
              var v2 = q2.ref;
              null !== v2 && ("function" === typeof v2 ? v2(null) : v2.current = null);
            }
          }
          switch (t2 & 1038) {
            case 2:
              fj(Z$1);
              Z$1.flags &= -3;
              break;
            case 6:
              fj(Z$1);
              Z$1.flags &= -3;
              ij(Z$1.alternate, Z$1);
              break;
            case 1024:
              Z$1.flags &= -1025;
              break;
            case 1028:
              Z$1.flags &= -1025;
              ij(Z$1.alternate, Z$1);
              break;
            case 4:
              ij(Z$1.alternate, Z$1);
              break;
            case 8:
              h2 = Z$1;
              cj(g2, h2);
              var J2 = h2.alternate;
              dj(h2);
              null !== J2 && dj(J2);
          }
          Z$1 = Z$1.nextEffect;
        }
      } catch (va) {
        if (null === Z$1)
          throw Error(y$2(330));
        Wi(Z$1, va);
        Z$1 = Z$1.nextEffect;
      }
    while (null !== Z$1);
    v2 = lf;
    q2 = Ne();
    t2 = v2.focusedElem;
    g2 = v2.selectionRange;
    if (q2 !== t2 && t2 && t2.ownerDocument && Me(t2.ownerDocument.documentElement, t2)) {
      null !== g2 && Oe(t2) && (q2 = g2.start, v2 = g2.end, void 0 === v2 && (v2 = q2), "selectionStart" in t2 ? (t2.selectionStart = q2, t2.selectionEnd = Math.min(v2, t2.value.length)) : (v2 = (q2 = t2.ownerDocument || document) && q2.defaultView || window, v2.getSelection && (v2 = v2.getSelection(), h2 = t2.textContent.length, J2 = Math.min(g2.start, h2), g2 = void 0 === g2.end ? J2 : Math.min(g2.end, h2), !v2.extend && J2 > g2 && (h2 = g2, g2 = J2, J2 = h2), h2 = Le(t2, J2), f2 = Le(t2, g2), h2 && f2 && (1 !== v2.rangeCount || v2.anchorNode !== h2.node || v2.anchorOffset !== h2.offset || v2.focusNode !== f2.node || v2.focusOffset !== f2.offset) && (q2 = q2.createRange(), q2.setStart(h2.node, h2.offset), v2.removeAllRanges(), J2 > g2 ? (v2.addRange(q2), v2.extend(f2.node, f2.offset)) : (q2.setEnd(f2.node, f2.offset), v2.addRange(q2))))));
      q2 = [];
      for (v2 = t2; v2 = v2.parentNode; )
        1 === v2.nodeType && q2.push({ element: v2, left: v2.scrollLeft, top: v2.scrollTop });
      "function" === typeof t2.focus && t2.focus();
      for (t2 = 0; t2 < q2.length; t2++)
        v2 = q2[t2], v2.element.scrollLeft = v2.left, v2.element.scrollTop = v2.top;
    }
    fd = !!kf;
    lf = kf = null;
    a2.current = c2;
    Z$1 = d2;
    do
      try {
        for (t2 = a2; null !== Z$1; ) {
          var K2 = Z$1.flags;
          K2 & 36 && Yi(t2, Z$1.alternate, Z$1);
          if (K2 & 128) {
            q2 = void 0;
            var Q2 = Z$1.ref;
            if (null !== Q2) {
              var L2 = Z$1.stateNode;
              switch (Z$1.tag) {
                case 5:
                  q2 = L2;
                  break;
                default:
                  q2 = L2;
              }
              "function" === typeof Q2 ? Q2(q2) : Q2.current = q2;
            }
          }
          Z$1 = Z$1.nextEffect;
        }
      } catch (va) {
        if (null === Z$1)
          throw Error(y$2(330));
        Wi(Z$1, va);
        Z$1 = Z$1.nextEffect;
      }
    while (null !== Z$1);
    Z$1 = null;
    $f();
    X$1 = e2;
  } else
    a2.current = c2;
  if (xj)
    xj = false, yj = a2, zj = b2;
  else
    for (Z$1 = d2; null !== Z$1; )
      b2 = Z$1.nextEffect, Z$1.nextEffect = null, Z$1.flags & 8 && (K2 = Z$1, K2.sibling = null, K2.stateNode = null), Z$1 = b2;
  d2 = a2.pendingLanes;
  0 === d2 && (Ti = null);
  1 === d2 ? a2 === Ej ? Dj++ : (Dj = 0, Ej = a2) : Dj = 0;
  c2 = c2.stateNode;
  if (Mf && "function" === typeof Mf.onCommitFiberRoot)
    try {
      Mf.onCommitFiberRoot(Lf, c2, void 0, 64 === (c2.current.flags & 64));
    } catch (va) {
    }
  Mj(a2, O$1());
  if (Qi)
    throw Qi = false, a2 = Ri, Ri = null, a2;
  if (0 !== (X$1 & 8))
    return null;
  ig();
  return null;
}
function ek() {
  for (; null !== Z$1; ) {
    var a2 = Z$1.alternate;
    Jj || null === Ij || (0 !== (Z$1.flags & 8) ? dc(Z$1, Ij) && (Jj = true) : 13 === Z$1.tag && mj(a2, Z$1) && dc(Z$1, Ij) && (Jj = true));
    var b2 = Z$1.flags;
    0 !== (b2 & 256) && Xi(a2, Z$1);
    0 === (b2 & 512) || xj || (xj = true, hg(97, function() {
      Oj();
      return null;
    }));
    Z$1 = Z$1.nextEffect;
  }
}
function Oj() {
  if (90 !== zj) {
    var a2 = 97 < zj ? 97 : zj;
    zj = 90;
    return gg(a2, fk);
  }
  return false;
}
function $i(a2, b2) {
  Aj.push(b2, a2);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function Zi(a2, b2) {
  Bj.push(b2, a2);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function fk() {
  if (null === yj)
    return false;
  var a2 = yj;
  yj = null;
  if (0 !== (X$1 & 48))
    throw Error(y$2(331));
  var b2 = X$1;
  X$1 |= 32;
  var c2 = Bj;
  Bj = [];
  for (var d2 = 0; d2 < c2.length; d2 += 2) {
    var e2 = c2[d2], f2 = c2[d2 + 1], g2 = e2.destroy;
    e2.destroy = void 0;
    if ("function" === typeof g2)
      try {
        g2();
      } catch (k2) {
        if (null === f2)
          throw Error(y$2(330));
        Wi(f2, k2);
      }
  }
  c2 = Aj;
  Aj = [];
  for (d2 = 0; d2 < c2.length; d2 += 2) {
    e2 = c2[d2];
    f2 = c2[d2 + 1];
    try {
      var h2 = e2.create;
      e2.destroy = h2();
    } catch (k2) {
      if (null === f2)
        throw Error(y$2(330));
      Wi(f2, k2);
    }
  }
  for (h2 = a2.current.firstEffect; null !== h2; )
    a2 = h2.nextEffect, h2.nextEffect = null, h2.flags & 8 && (h2.sibling = null, h2.stateNode = null), h2 = a2;
  X$1 = b2;
  ig();
  return true;
}
function gk(a2, b2, c2) {
  b2 = Mi(c2, b2);
  b2 = Pi(a2, b2, 1);
  Ag(a2, b2);
  b2 = Hg();
  a2 = Kj(a2, 1);
  null !== a2 && ($c(a2, 1, b2), Mj(a2, b2));
}
function Wi(a2, b2) {
  if (3 === a2.tag)
    gk(a2, a2, b2);
  else
    for (var c2 = a2.return; null !== c2; ) {
      if (3 === c2.tag) {
        gk(c2, a2, b2);
        break;
      } else if (1 === c2.tag) {
        var d2 = c2.stateNode;
        if ("function" === typeof c2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ti || !Ti.has(d2))) {
          a2 = Mi(b2, a2);
          var e2 = Si(c2, a2, 1);
          Ag(c2, e2);
          e2 = Hg();
          c2 = Kj(c2, 1);
          if (null !== c2)
            $c(c2, 1, e2), Mj(c2, e2);
          else if ("function" === typeof d2.componentDidCatch && (null === Ti || !Ti.has(d2)))
            try {
              d2.componentDidCatch(b2, a2);
            } catch (f2) {
            }
          break;
        }
      }
      c2 = c2.return;
    }
}
function Yj(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = Hg();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  U$1 === a2 && (W$1 & c2) === c2 && (4 === V || 3 === V && (W$1 & 62914560) === W$1 && 500 > O$1() - jj ? Qj(a2, 0) : uj |= c2);
  Mj(a2, b2);
}
function lj(a2, b2) {
  var c2 = a2.stateNode;
  null !== c2 && c2.delete(b2);
  b2 = 0;
  0 === b2 && (b2 = a2.mode, 0 === (b2 & 2) ? b2 = 1 : 0 === (b2 & 4) ? b2 = 99 === eg() ? 1 : 2 : (0 === Gj && (Gj = tj), b2 = Yc(62914560 & ~Gj), 0 === b2 && (b2 = 4194304)));
  c2 = Hg();
  a2 = Kj(a2, b2);
  null !== a2 && ($c(a2, b2, c2), Mj(a2, c2));
}
var ck;
ck = function(a2, b2, c2) {
  var d2 = b2.lanes;
  if (null !== a2)
    if (a2.memoizedProps !== b2.pendingProps || N$1.current)
      ug = true;
    else if (0 !== (c2 & d2))
      ug = 0 !== (a2.flags & 16384) ? true : false;
    else {
      ug = false;
      switch (b2.tag) {
        case 3:
          ri(b2);
          sh();
          break;
        case 5:
          gh(b2);
          break;
        case 1:
          Ff(b2.type) && Jf(b2);
          break;
        case 4:
          eh(b2, b2.stateNode.containerInfo);
          break;
        case 10:
          d2 = b2.memoizedProps.value;
          var e2 = b2.type._context;
          I$1(mg, e2._currentValue);
          e2._currentValue = d2;
          break;
        case 13:
          if (null !== b2.memoizedState) {
            if (0 !== (c2 & b2.child.childLanes))
              return ti(a2, b2, c2);
            I$1(P$1, P$1.current & 1);
            b2 = hi(a2, b2, c2);
            return null !== b2 ? b2.sibling : null;
          }
          I$1(P$1, P$1.current & 1);
          break;
        case 19:
          d2 = 0 !== (c2 & b2.childLanes);
          if (0 !== (a2.flags & 64)) {
            if (d2)
              return Ai(a2, b2, c2);
            b2.flags |= 64;
          }
          e2 = b2.memoizedState;
          null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
          I$1(P$1, P$1.current);
          if (d2)
            break;
          else
            return null;
        case 23:
        case 24:
          return b2.lanes = 0, mi(a2, b2, c2);
      }
      return hi(a2, b2, c2);
    }
  else
    ug = false;
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      d2 = b2.type;
      null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
      a2 = b2.pendingProps;
      e2 = Ef(b2, M$1.current);
      tg(b2, c2);
      e2 = Ch(null, b2, d2, a2, e2, c2);
      b2.flags |= 1;
      if ("object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof) {
        b2.tag = 1;
        b2.memoizedState = null;
        b2.updateQueue = null;
        if (Ff(d2)) {
          var f2 = true;
          Jf(b2);
        } else
          f2 = false;
        b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null;
        xg(b2);
        var g2 = d2.getDerivedStateFromProps;
        "function" === typeof g2 && Gg(b2, d2, g2, a2);
        e2.updater = Kg;
        b2.stateNode = e2;
        e2._reactInternals = b2;
        Og(b2, d2, a2, c2);
        b2 = qi(null, b2, d2, true, f2, c2);
      } else
        b2.tag = 0, fi(null, b2, e2, c2), b2 = b2.child;
      return b2;
    case 16:
      e2 = b2.elementType;
      a: {
        null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
        a2 = b2.pendingProps;
        f2 = e2._init;
        e2 = f2(e2._payload);
        b2.type = e2;
        f2 = b2.tag = hk(e2);
        a2 = lg(e2, a2);
        switch (f2) {
          case 0:
            b2 = li(null, b2, e2, a2, c2);
            break a;
          case 1:
            b2 = pi(null, b2, e2, a2, c2);
            break a;
          case 11:
            b2 = gi(null, b2, e2, a2, c2);
            break a;
          case 14:
            b2 = ii(null, b2, e2, lg(e2.type, a2), d2, c2);
            break a;
        }
        throw Error(y$2(306, e2, ""));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : lg(d2, e2), li(a2, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : lg(d2, e2), pi(a2, b2, d2, e2, c2);
    case 3:
      ri(b2);
      d2 = b2.updateQueue;
      if (null === a2 || null === d2)
        throw Error(y$2(282));
      d2 = b2.pendingProps;
      e2 = b2.memoizedState;
      e2 = null !== e2 ? e2.element : null;
      yg(a2, b2);
      Cg(b2, d2, null, c2);
      d2 = b2.memoizedState.element;
      if (d2 === e2)
        sh(), b2 = hi(a2, b2, c2);
      else {
        e2 = b2.stateNode;
        if (f2 = e2.hydrate)
          kh = rf(b2.stateNode.containerInfo.firstChild), jh = b2, f2 = lh = true;
        if (f2) {
          a2 = e2.mutableSourceEagerHydrationData;
          if (null != a2)
            for (e2 = 0; e2 < a2.length; e2 += 2)
              f2 = a2[e2], f2._workInProgressVersionPrimary = a2[e2 + 1], th.push(f2);
          c2 = Zg(b2, null, d2, c2);
          for (b2.child = c2; c2; )
            c2.flags = c2.flags & -3 | 1024, c2 = c2.sibling;
        } else
          fi(a2, b2, d2, c2), sh();
        b2 = b2.child;
      }
      return b2;
    case 5:
      return gh(b2), null === a2 && ph(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, nf(d2, e2) ? g2 = null : null !== f2 && nf(d2, f2) && (b2.flags |= 16), oi(a2, b2), fi(a2, b2, g2, c2), b2.child;
    case 6:
      return null === a2 && ph(b2), null;
    case 13:
      return ti(a2, b2, c2);
    case 4:
      return eh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Yg(b2, null, d2, c2) : fi(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : lg(d2, e2), gi(a2, b2, d2, e2, c2);
    case 7:
      return fi(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return fi(
        a2,
        b2,
        b2.pendingProps.children,
        c2
      ), b2.child;
    case 12:
      return fi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        g2 = b2.memoizedProps;
        f2 = e2.value;
        var h2 = b2.type._context;
        I$1(mg, h2._currentValue);
        h2._currentValue = f2;
        if (null !== g2)
          if (h2 = g2.value, f2 = He(h2, f2) ? 0 : ("function" === typeof d2._calculateChangedBits ? d2._calculateChangedBits(h2, f2) : 1073741823) | 0, 0 === f2) {
            if (g2.children === e2.children && !N$1.current) {
              b2 = hi(a2, b2, c2);
              break a;
            }
          } else
            for (h2 = b2.child, null !== h2 && (h2.return = b2); null !== h2; ) {
              var k2 = h2.dependencies;
              if (null !== k2) {
                g2 = h2.child;
                for (var l2 = k2.firstContext; null !== l2; ) {
                  if (l2.context === d2 && 0 !== (l2.observedBits & f2)) {
                    1 === h2.tag && (l2 = zg(-1, c2 & -c2), l2.tag = 2, Ag(h2, l2));
                    h2.lanes |= c2;
                    l2 = h2.alternate;
                    null !== l2 && (l2.lanes |= c2);
                    sg(h2.return, c2);
                    k2.lanes |= c2;
                    break;
                  }
                  l2 = l2.next;
                }
              } else
                g2 = 10 === h2.tag ? h2.type === b2.type ? null : h2.child : h2.child;
              if (null !== g2)
                g2.return = h2;
              else
                for (g2 = h2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  h2 = g2.sibling;
                  if (null !== h2) {
                    h2.return = g2.return;
                    g2 = h2;
                    break;
                  }
                  g2 = g2.return;
                }
              h2 = g2;
            }
        fi(a2, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, f2 = b2.pendingProps, d2 = f2.children, tg(b2, c2), e2 = vg(
        e2,
        f2.unstable_observedBits
      ), d2 = d2(e2), b2.flags |= 1, fi(a2, b2, d2, c2), b2.child;
    case 14:
      return e2 = b2.type, f2 = lg(e2, b2.pendingProps), f2 = lg(e2.type, f2), ii(a2, b2, e2, f2, d2, c2);
    case 15:
      return ki(a2, b2, b2.type, b2.pendingProps, d2, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : lg(d2, e2), null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2), b2.tag = 1, Ff(d2) ? (a2 = true, Jf(b2)) : a2 = false, tg(b2, c2), Mg(b2, d2, e2), Og(b2, d2, e2, c2), qi(null, b2, d2, true, a2, c2);
    case 19:
      return Ai(a2, b2, c2);
    case 23:
      return mi(a2, b2, c2);
    case 24:
      return mi(a2, b2, c2);
  }
  throw Error(y$2(156, b2.tag));
};
function ik(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.flags = 0;
  this.lastEffect = this.firstEffect = this.nextEffect = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function nh(a2, b2, c2, d2) {
  return new ik(a2, b2, c2, d2);
}
function ji(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function hk(a2) {
  if ("function" === typeof a2)
    return ji(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Aa)
      return 11;
    if (a2 === Da)
      return 14;
  }
  return 2;
}
function Tg(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = nh(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.nextEffect = null, c2.firstEffect = null, c2.lastEffect = null);
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function Vg(a2, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2)
    ji(a2) && (g2 = 1);
  else if ("string" === typeof a2)
    g2 = 5;
  else
    a:
      switch (a2) {
        case ua:
          return Xg(c2.children, e2, f2, b2);
        case Ha:
          g2 = 8;
          e2 |= 16;
          break;
        case wa:
          g2 = 8;
          e2 |= 1;
          break;
        case xa:
          return a2 = nh(12, c2, b2, e2 | 8), a2.elementType = xa, a2.type = xa, a2.lanes = f2, a2;
        case Ba:
          return a2 = nh(13, c2, b2, e2), a2.type = Ba, a2.elementType = Ba, a2.lanes = f2, a2;
        case Ca:
          return a2 = nh(19, c2, b2, e2), a2.elementType = Ca, a2.lanes = f2, a2;
        case Ia:
          return vi(c2, e2, f2, b2);
        case Ja:
          return a2 = nh(24, c2, b2, e2), a2.elementType = Ja, a2.lanes = f2, a2;
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case ya:
                g2 = 10;
                break a;
              case za:
                g2 = 9;
                break a;
              case Aa:
                g2 = 11;
                break a;
              case Da:
                g2 = 14;
                break a;
              case Ea:
                g2 = 16;
                d2 = null;
                break a;
              case Fa:
                g2 = 22;
                break a;
            }
          throw Error(y$2(130, null == a2 ? a2 : typeof a2, ""));
      }
  b2 = nh(g2, c2, b2, e2);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Xg(a2, b2, c2, d2) {
  a2 = nh(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function vi(a2, b2, c2, d2) {
  a2 = nh(23, a2, d2, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  return a2;
}
function Ug(a2, b2, c2) {
  a2 = nh(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function Wg(a2, b2, c2) {
  b2 = nh(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function jk(a2, b2, c2) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.pendingContext = this.context = null;
  this.hydrate = c2;
  this.callbackNode = null;
  this.callbackPriority = 0;
  this.eventTimes = Zc(0);
  this.expirationTimes = Zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = Zc(0);
  this.mutableSourceEagerHydrationData = null;
}
function kk(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: ta, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function lk(a2, b2, c2, d2) {
  var e2 = b2.current, f2 = Hg(), g2 = Ig(e2);
  a:
    if (c2) {
      c2 = c2._reactInternals;
      b: {
        if (Zb(c2) !== c2 || 1 !== c2.tag)
          throw Error(y$2(170));
        var h2 = c2;
        do {
          switch (h2.tag) {
            case 3:
              h2 = h2.stateNode.context;
              break b;
            case 1:
              if (Ff(h2.type)) {
                h2 = h2.stateNode.__reactInternalMemoizedMergedChildContext;
                break b;
              }
          }
          h2 = h2.return;
        } while (null !== h2);
        throw Error(y$2(171));
      }
      if (1 === c2.tag) {
        var k2 = c2.type;
        if (Ff(k2)) {
          c2 = If(c2, k2, h2);
          break a;
        }
      }
      c2 = h2;
    } else
      c2 = Cf;
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = zg(f2, g2);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  Ag(e2, b2);
  Jg(e2, g2, f2);
  return g2;
}
function mk(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function nk(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function ok(a2, b2) {
  nk(a2, b2);
  (a2 = a2.alternate) && nk(a2, b2);
}
function pk() {
  return null;
}
function qk(a2, b2, c2) {
  var d2 = null != c2 && null != c2.hydrationOptions && c2.hydrationOptions.mutableSources || null;
  c2 = new jk(a2, b2, null != c2 && true === c2.hydrate);
  b2 = nh(3, null, null, 2 === b2 ? 7 : 1 === b2 ? 3 : 0);
  c2.current = b2;
  b2.stateNode = c2;
  xg(b2);
  a2[ff] = c2.current;
  cf(8 === a2.nodeType ? a2.parentNode : a2);
  if (d2)
    for (a2 = 0; a2 < d2.length; a2++) {
      b2 = d2[a2];
      var e2 = b2._getVersion;
      e2 = e2(b2._source);
      null == c2.mutableSourceEagerHydrationData ? c2.mutableSourceEagerHydrationData = [b2, e2] : c2.mutableSourceEagerHydrationData.push(b2, e2);
    }
  this._internalRoot = c2;
}
qk.prototype.render = function(a2) {
  lk(a2, this._internalRoot, null, null);
};
qk.prototype.unmount = function() {
  var a2 = this._internalRoot, b2 = a2.containerInfo;
  lk(null, a2, null, function() {
    b2[ff] = null;
  });
};
function rk(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function sk(a2, b2) {
  b2 || (b2 = a2 ? 9 === a2.nodeType ? a2.documentElement : a2.firstChild : null, b2 = !(!b2 || 1 !== b2.nodeType || !b2.hasAttribute("data-reactroot")));
  if (!b2)
    for (var c2; c2 = a2.lastChild; )
      a2.removeChild(c2);
  return new qk(a2, 0, b2 ? { hydrate: true } : void 0);
}
function tk(a2, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2._internalRoot;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a3 = mk(g2);
        h2.call(a3);
      };
    }
    lk(b2, g2, a2, e2);
  } else {
    f2 = c2._reactRootContainer = sk(c2, d2);
    g2 = f2._internalRoot;
    if ("function" === typeof e2) {
      var k2 = e2;
      e2 = function() {
        var a3 = mk(g2);
        k2.call(a3);
      };
    }
    Xj(function() {
      lk(b2, g2, a2, e2);
    });
  }
  return mk(g2);
}
ec = function(a2) {
  if (13 === a2.tag) {
    var b2 = Hg();
    Jg(a2, 4, b2);
    ok(a2, 4);
  }
};
fc = function(a2) {
  if (13 === a2.tag) {
    var b2 = Hg();
    Jg(a2, 67108864, b2);
    ok(a2, 67108864);
  }
};
gc = function(a2) {
  if (13 === a2.tag) {
    var b2 = Hg(), c2 = Ig(a2);
    Jg(a2, c2, b2);
    ok(a2, c2);
  }
};
hc = function(a2, b2) {
  return b2();
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      ab(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(y$2(90));
            Wa(d2);
            ab(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Wj;
Hb = function(a2, b2, c2, d2, e2) {
  var f2 = X$1;
  X$1 |= 4;
  try {
    return gg(98, a2.bind(null, b2, c2, d2, e2));
  } finally {
    X$1 = f2, 0 === X$1 && (wj(), ig());
  }
};
Ib = function() {
  0 === (X$1 & 49) && (Vj(), Oj());
};
Jb = function(a2, b2) {
  var c2 = X$1;
  X$1 |= 2;
  try {
    return a2(b2);
  } finally {
    X$1 = c2, 0 === X$1 && (wj(), ig());
  }
};
function uk(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!rk(b2))
    throw Error(y$2(200));
  return kk(a2, b2, null, c2);
}
var vk = { Events: [Cb, ue, Db, Eb, Fb, Oj, { current: false }] }, wk = { findFiberByHostInstance: wc, bundleType: 0, version: "17.0.2", rendererPackageName: "react-dom" };
var xk = { bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = cc(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!yk.isDisabled && yk.supportsFiber)
    try {
      Lf = yk.inject(xk), Mf = yk;
    } catch (a2) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
reactDom_production_min.createPortal = uk;
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2)
    return null;
  if (1 === a2.nodeType)
    return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render)
      throw Error(y$2(188));
    throw Error(y$2(268, Object.keys(a2)));
  }
  a2 = cc(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2, b2) {
  var c2 = X$1;
  if (0 !== (c2 & 48))
    return a2(b2);
  X$1 |= 1;
  try {
    if (a2)
      return gg(99, a2.bind(null, b2));
  } finally {
    X$1 = c2, ig();
  }
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!rk(b2))
    throw Error(y$2(200));
  return tk(null, a2, b2, true, c2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!rk(b2))
    throw Error(y$2(200));
  return tk(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!rk(a2))
    throw Error(y$2(40));
  return a2._reactRootContainer ? (Xj(function() {
    tk(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[ff] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Wj;
reactDom_production_min.unstable_createPortal = function(a2, b2) {
  return uk(a2, b2, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null);
};
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!rk(c2))
    throw Error(y$2(200));
  if (null == a2 || void 0 === a2._reactInternals)
    throw Error(y$2(38));
  return tk(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "17.0.2";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
const index = "";
const Title_main = "_Title_main_tu3zs_1";
const Title_buttonList = "_Title_buttonList_tu3zs_8";
const Title_button = "_Title_button_tu3zs_8";
const Title_button_text = "_Title_button_text_tu3zs_55";
const Title_backup_background = "_Title_backup_background_tu3zs_61";
const styles$m = {
  Title_main,
  Title_buttonList,
  Title_button,
  Title_button_text,
  Title_backup_background
};
function n$5(n2) {
  for (var r2 = arguments.length, t2 = Array(r2 > 1 ? r2 - 1 : 0), e2 = 1; e2 < r2; e2++)
    t2[e2 - 1] = arguments[e2];
  throw Error("[Immer] minified error nr: " + n2 + (t2.length ? " " + t2.map(function(n3) {
    return "'" + n3 + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function r$4(n2) {
  return !!n2 && !!n2[Q];
}
function t$5(n2) {
  var r2;
  return !!n2 && (function(n3) {
    if (!n3 || "object" != typeof n3)
      return false;
    var r3 = Object.getPrototypeOf(n3);
    if (null === r3)
      return true;
    var t2 = Object.hasOwnProperty.call(r3, "constructor") && r3.constructor;
    return t2 === Object || "function" == typeof t2 && Function.toString.call(t2) === Z;
  }(n2) || Array.isArray(n2) || !!n2[L] || !!(null === (r2 = n2.constructor) || void 0 === r2 ? void 0 : r2[L]) || s$2(n2) || v$3(n2));
}
function i$1(n2, r2, t2) {
  void 0 === t2 && (t2 = false), 0 === o(n2) ? (t2 ? Object.keys : nn)(n2).forEach(function(e2) {
    t2 && "symbol" == typeof e2 || r2(e2, n2[e2], n2);
  }) : n2.forEach(function(t3, e2) {
    return r2(e2, t3, n2);
  });
}
function o(n2) {
  var r2 = n2[Q];
  return r2 ? r2.i > 3 ? r2.i - 4 : r2.i : Array.isArray(n2) ? 1 : s$2(n2) ? 2 : v$3(n2) ? 3 : 0;
}
function u$4(n2, r2) {
  return 2 === o(n2) ? n2.has(r2) : Object.prototype.hasOwnProperty.call(n2, r2);
}
function a$1(n2, r2) {
  return 2 === o(n2) ? n2.get(r2) : n2[r2];
}
function f$2(n2, r2, t2) {
  var e2 = o(n2);
  2 === e2 ? n2.set(r2, t2) : 3 === e2 ? n2.add(t2) : n2[r2] = t2;
}
function c$3(n2, r2) {
  return n2 === r2 ? 0 !== n2 || 1 / n2 == 1 / r2 : n2 != n2 && r2 != r2;
}
function s$2(n2) {
  return X && n2 instanceof Map;
}
function v$3(n2) {
  return q$4 && n2 instanceof Set;
}
function p$5(n2) {
  return n2.o || n2.t;
}
function l$3(n2) {
  if (Array.isArray(n2))
    return Array.prototype.slice.call(n2);
  var r2 = rn(n2);
  delete r2[Q];
  for (var t2 = nn(r2), e2 = 0; e2 < t2.length; e2++) {
    var i2 = t2[e2], o2 = r2[i2];
    false === o2.writable && (o2.writable = true, o2.configurable = true), (o2.get || o2.set) && (r2[i2] = { configurable: true, writable: true, enumerable: o2.enumerable, value: n2[i2] });
  }
  return Object.create(Object.getPrototypeOf(n2), r2);
}
function d$2(n2, e2) {
  return void 0 === e2 && (e2 = false), y$1(n2) || r$4(n2) || !t$5(n2) || (o(n2) > 1 && (n2.set = n2.add = n2.clear = n2.delete = h$4), Object.freeze(n2), e2 && i$1(n2, function(n3, r2) {
    return d$2(r2, true);
  }, true)), n2;
}
function h$4() {
  n$5(2);
}
function y$1(n2) {
  return null == n2 || "object" != typeof n2 || Object.isFrozen(n2);
}
function b$2(r2) {
  var t2 = tn[r2];
  return t2 || n$5(18, r2), t2;
}
function m$3(n2, r2) {
  tn[n2] || (tn[n2] = r2);
}
function _() {
  return U;
}
function j(n2, r2) {
  r2 && (b$2("Patches"), n2.u = [], n2.s = [], n2.v = r2);
}
function g$2(n2) {
  O(n2), n2.p.forEach(S), n2.p = null;
}
function O(n2) {
  n2 === U && (U = n2.l);
}
function w$2(n2) {
  return U = { p: [], l: U, h: n2, m: true, _: 0 };
}
function S(n2) {
  var r2 = n2[Q];
  0 === r2.i || 1 === r2.i ? r2.j() : r2.g = true;
}
function P(r2, e2) {
  e2._ = e2.p.length;
  var i2 = e2.p[0], o2 = void 0 !== r2 && r2 !== i2;
  return e2.h.O || b$2("ES5").S(e2, r2, o2), o2 ? (i2[Q].P && (g$2(e2), n$5(4)), t$5(r2) && (r2 = M(e2, r2), e2.l || x$2(e2, r2)), e2.u && b$2("Patches").M(i2[Q].t, r2, e2.u, e2.s)) : r2 = M(e2, i2, []), g$2(e2), e2.u && e2.v(e2.u, e2.s), r2 !== H ? r2 : void 0;
}
function M(n2, r2, t2) {
  if (y$1(r2))
    return r2;
  var e2 = r2[Q];
  if (!e2)
    return i$1(r2, function(i2, o3) {
      return A$1(n2, e2, r2, i2, o3, t2);
    }, true), r2;
  if (e2.A !== n2)
    return r2;
  if (!e2.P)
    return x$2(n2, e2.t, true), e2.t;
  if (!e2.I) {
    e2.I = true, e2.A._--;
    var o2 = 4 === e2.i || 5 === e2.i ? e2.o = l$3(e2.k) : e2.o, u2 = o2, a2 = false;
    3 === e2.i && (u2 = new Set(o2), o2.clear(), a2 = true), i$1(u2, function(r3, i2) {
      return A$1(n2, e2, o2, r3, i2, t2, a2);
    }), x$2(n2, o2, false), t2 && n2.u && b$2("Patches").N(e2, t2, n2.u, n2.s);
  }
  return e2.o;
}
function A$1(e2, i2, o2, a2, c2, s2, v2) {
  if (r$4(c2)) {
    var p = M(e2, c2, s2 && i2 && 3 !== i2.i && !u$4(i2.R, a2) ? s2.concat(a2) : void 0);
    if (f$2(o2, a2, p), !r$4(p))
      return;
    e2.m = false;
  } else
    v2 && o2.add(c2);
  if (t$5(c2) && !y$1(c2)) {
    if (!e2.h.D && e2._ < 1)
      return;
    M(e2, c2), i2 && i2.A.l || x$2(e2, c2);
  }
}
function x$2(n2, r2, t2) {
  void 0 === t2 && (t2 = false), !n2.l && n2.h.D && n2.m && d$2(r2, t2);
}
function z$1(n2, r2) {
  var t2 = n2[Q];
  return (t2 ? p$5(t2) : n2)[r2];
}
function I(n2, r2) {
  if (r2 in n2)
    for (var t2 = Object.getPrototypeOf(n2); t2; ) {
      var e2 = Object.getOwnPropertyDescriptor(t2, r2);
      if (e2)
        return e2;
      t2 = Object.getPrototypeOf(t2);
    }
}
function k$3(n2) {
  n2.P || (n2.P = true, n2.l && k$3(n2.l));
}
function E(n2) {
  n2.o || (n2.o = l$3(n2.t));
}
function N(n2, r2, t2) {
  var e2 = s$2(r2) ? b$2("MapSet").F(r2, t2) : v$3(r2) ? b$2("MapSet").T(r2, t2) : n2.O ? function(n3, r3) {
    var t3 = Array.isArray(n3), e3 = { i: t3 ? 1 : 0, A: r3 ? r3.A : _(), P: false, I: false, R: {}, l: r3, t: n3, k: null, o: null, j: null, C: false }, i2 = e3, o2 = en$1;
    t3 && (i2 = [e3], o2 = on);
    var u2 = Proxy.revocable(i2, o2), a2 = u2.revoke, f2 = u2.proxy;
    return e3.k = f2, e3.j = a2, f2;
  }(r2, t2) : b$2("ES5").J(r2, t2);
  return (t2 ? t2.A : _()).p.push(e2), e2;
}
function R(e2) {
  return r$4(e2) || n$5(22, e2), function n2(r2) {
    if (!t$5(r2))
      return r2;
    var e3, u2 = r2[Q], c2 = o(r2);
    if (u2) {
      if (!u2.P && (u2.i < 4 || !b$2("ES5").K(u2)))
        return u2.t;
      u2.I = true, e3 = D(r2, c2), u2.I = false;
    } else
      e3 = D(r2, c2);
    return i$1(e3, function(r3, t2) {
      u2 && a$1(u2.t, r3) === t2 || f$2(e3, r3, n2(t2));
    }), 3 === c2 ? new Set(e3) : e3;
  }(e2);
}
function D(n2, r2) {
  switch (r2) {
    case 2:
      return new Map(n2);
    case 3:
      return Array.from(n2);
  }
  return l$3(n2);
}
function F() {
  function t2(n2, r2) {
    var t3 = s2[n2];
    return t3 ? t3.enumerable = r2 : s2[n2] = t3 = { configurable: true, enumerable: r2, get: function() {
      var r3 = this[Q];
      return en$1.get(r3, n2);
    }, set: function(r3) {
      var t4 = this[Q];
      en$1.set(t4, n2, r3);
    } }, t3;
  }
  function e2(n2) {
    for (var r2 = n2.length - 1; r2 >= 0; r2--) {
      var t3 = n2[r2][Q];
      if (!t3.P)
        switch (t3.i) {
          case 5:
            a2(t3) && k$3(t3);
            break;
          case 4:
            o2(t3) && k$3(t3);
        }
    }
  }
  function o2(n2) {
    for (var r2 = n2.t, t3 = n2.k, e3 = nn(t3), i2 = e3.length - 1; i2 >= 0; i2--) {
      var o3 = e3[i2];
      if (o3 !== Q) {
        var a3 = r2[o3];
        if (void 0 === a3 && !u$4(r2, o3))
          return true;
        var f2 = t3[o3], s3 = f2 && f2[Q];
        if (s3 ? s3.t !== a3 : !c$3(f2, a3))
          return true;
      }
    }
    var v2 = !!r2[Q];
    return e3.length !== nn(r2).length + (v2 ? 0 : 1);
  }
  function a2(n2) {
    var r2 = n2.k;
    if (r2.length !== n2.t.length)
      return true;
    var t3 = Object.getOwnPropertyDescriptor(r2, r2.length - 1);
    if (t3 && !t3.get)
      return true;
    for (var e3 = 0; e3 < r2.length; e3++)
      if (!r2.hasOwnProperty(e3))
        return true;
    return false;
  }
  var s2 = {};
  m$3("ES5", { J: function(n2, r2) {
    var e3 = Array.isArray(n2), i2 = function(n3, r3) {
      if (n3) {
        for (var e4 = Array(r3.length), i3 = 0; i3 < r3.length; i3++)
          Object.defineProperty(e4, "" + i3, t2(i3, true));
        return e4;
      }
      var o4 = rn(r3);
      delete o4[Q];
      for (var u2 = nn(o4), a3 = 0; a3 < u2.length; a3++) {
        var f2 = u2[a3];
        o4[f2] = t2(f2, n3 || !!o4[f2].enumerable);
      }
      return Object.create(Object.getPrototypeOf(r3), o4);
    }(e3, n2), o3 = { i: e3 ? 5 : 4, A: r2 ? r2.A : _(), P: false, I: false, R: {}, l: r2, t: n2, k: i2, o: null, g: false, C: false };
    return Object.defineProperty(i2, Q, { value: o3, writable: true }), i2;
  }, S: function(n2, t3, o3) {
    o3 ? r$4(t3) && t3[Q].A === n2 && e2(n2.p) : (n2.u && function n3(r2) {
      if (r2 && "object" == typeof r2) {
        var t4 = r2[Q];
        if (t4) {
          var e3 = t4.t, o4 = t4.k, f2 = t4.R, c2 = t4.i;
          if (4 === c2)
            i$1(o4, function(r3) {
              r3 !== Q && (void 0 !== e3[r3] || u$4(e3, r3) ? f2[r3] || n3(o4[r3]) : (f2[r3] = true, k$3(t4)));
            }), i$1(e3, function(n4) {
              void 0 !== o4[n4] || u$4(o4, n4) || (f2[n4] = false, k$3(t4));
            });
          else if (5 === c2) {
            if (a2(t4) && (k$3(t4), f2.length = true), o4.length < e3.length)
              for (var s3 = o4.length; s3 < e3.length; s3++)
                f2[s3] = false;
            else
              for (var v2 = e3.length; v2 < o4.length; v2++)
                f2[v2] = true;
            for (var p = Math.min(o4.length, e3.length), l2 = 0; l2 < p; l2++)
              o4.hasOwnProperty(l2) || (f2[l2] = true), void 0 === f2[l2] && n3(o4[l2]);
          }
        }
      }
    }(n2.p[0]), e2(n2.p));
  }, K: function(n2) {
    return 4 === n2.i ? o2(n2) : a2(n2);
  } });
}
var G, U, W = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"), X = "undefined" != typeof Map, q$4 = "undefined" != typeof Set, B = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect, H = W ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = true, G), L = W ? Symbol.for("immer-draftable") : "__$immer_draftable", Q = W ? Symbol.for("immer-state") : "__$immer_state", Z = "" + Object.prototype.constructor, nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n2) {
  return Object.getOwnPropertyNames(n2).concat(Object.getOwnPropertySymbols(n2));
} : Object.getOwnPropertyNames, rn = Object.getOwnPropertyDescriptors || function(n2) {
  var r2 = {};
  return nn(n2).forEach(function(t2) {
    r2[t2] = Object.getOwnPropertyDescriptor(n2, t2);
  }), r2;
}, tn = {}, en$1 = { get: function(n2, r2) {
  if (r2 === Q)
    return n2;
  var e2 = p$5(n2);
  if (!u$4(e2, r2))
    return function(n3, r3, t2) {
      var e3, i3 = I(r3, t2);
      return i3 ? "value" in i3 ? i3.value : null === (e3 = i3.get) || void 0 === e3 ? void 0 : e3.call(n3.k) : void 0;
    }(n2, e2, r2);
  var i2 = e2[r2];
  return n2.I || !t$5(i2) ? i2 : i2 === z$1(n2.t, r2) ? (E(n2), n2.o[r2] = N(n2.A.h, i2, n2)) : i2;
}, has: function(n2, r2) {
  return r2 in p$5(n2);
}, ownKeys: function(n2) {
  return Reflect.ownKeys(p$5(n2));
}, set: function(n2, r2, t2) {
  var e2 = I(p$5(n2), r2);
  if (null == e2 ? void 0 : e2.set)
    return e2.set.call(n2.k, t2), true;
  if (!n2.P) {
    var i2 = z$1(p$5(n2), r2), o2 = null == i2 ? void 0 : i2[Q];
    if (o2 && o2.t === t2)
      return n2.o[r2] = t2, n2.R[r2] = false, true;
    if (c$3(t2, i2) && (void 0 !== t2 || u$4(n2.t, r2)))
      return true;
    E(n2), k$3(n2);
  }
  return n2.o[r2] === t2 && (void 0 !== t2 || r2 in n2.o) || Number.isNaN(t2) && Number.isNaN(n2.o[r2]) || (n2.o[r2] = t2, n2.R[r2] = true), true;
}, deleteProperty: function(n2, r2) {
  return void 0 !== z$1(n2.t, r2) || r2 in n2.t ? (n2.R[r2] = false, E(n2), k$3(n2)) : delete n2.R[r2], n2.o && delete n2.o[r2], true;
}, getOwnPropertyDescriptor: function(n2, r2) {
  var t2 = p$5(n2), e2 = Reflect.getOwnPropertyDescriptor(t2, r2);
  return e2 ? { writable: true, configurable: 1 !== n2.i || "length" !== r2, enumerable: e2.enumerable, value: t2[r2] } : e2;
}, defineProperty: function() {
  n$5(11);
}, getPrototypeOf: function(n2) {
  return Object.getPrototypeOf(n2.t);
}, setPrototypeOf: function() {
  n$5(12);
} }, on = {};
i$1(en$1, function(n2, r2) {
  on[n2] = function() {
    return arguments[0] = arguments[0][0], r2.apply(this, arguments);
  };
}), on.deleteProperty = function(r2, t2) {
  return on.set.call(this, r2, t2, void 0);
}, on.set = function(r2, t2, e2) {
  return en$1.set.call(this, r2[0], t2, e2, r2[0]);
};
var un = function() {
  function e2(r2) {
    var e3 = this;
    this.O = B, this.D = true, this.produce = function(r3, i3, o2) {
      if ("function" == typeof r3 && "function" != typeof i3) {
        var u2 = i3;
        i3 = r3;
        var a2 = e3;
        return function(n2) {
          var r4 = this;
          void 0 === n2 && (n2 = u2);
          for (var t2 = arguments.length, e4 = Array(t2 > 1 ? t2 - 1 : 0), o3 = 1; o3 < t2; o3++)
            e4[o3 - 1] = arguments[o3];
          return a2.produce(n2, function(n3) {
            var t3;
            return (t3 = i3).call.apply(t3, [r4, n3].concat(e4));
          });
        };
      }
      var f2;
      if ("function" != typeof i3 && n$5(6), void 0 !== o2 && "function" != typeof o2 && n$5(7), t$5(r3)) {
        var c2 = w$2(e3), s2 = N(e3, r3, void 0), v2 = true;
        try {
          f2 = i3(s2), v2 = false;
        } finally {
          v2 ? g$2(c2) : O(c2);
        }
        return "undefined" != typeof Promise && f2 instanceof Promise ? f2.then(function(n2) {
          return j(c2, o2), P(n2, c2);
        }, function(n2) {
          throw g$2(c2), n2;
        }) : (j(c2, o2), P(f2, c2));
      }
      if (!r3 || "object" != typeof r3) {
        if (void 0 === (f2 = i3(r3)) && (f2 = r3), f2 === H && (f2 = void 0), e3.D && d$2(f2, true), o2) {
          var p = [], l2 = [];
          b$2("Patches").M(r3, f2, p, l2), o2(p, l2);
        }
        return f2;
      }
      n$5(21, r3);
    }, this.produceWithPatches = function(n2, r3) {
      if ("function" == typeof n2)
        return function(r4) {
          for (var t3 = arguments.length, i4 = Array(t3 > 1 ? t3 - 1 : 0), o3 = 1; o3 < t3; o3++)
            i4[o3 - 1] = arguments[o3];
          return e3.produceWithPatches(r4, function(r5) {
            return n2.apply(void 0, [r5].concat(i4));
          });
        };
      var t2, i3, o2 = e3.produce(n2, r3, function(n3, r4) {
        t2 = n3, i3 = r4;
      });
      return "undefined" != typeof Promise && o2 instanceof Promise ? o2.then(function(n3) {
        return [n3, t2, i3];
      }) : [o2, t2, i3];
    }, "boolean" == typeof (null == r2 ? void 0 : r2.useProxies) && this.setUseProxies(r2.useProxies), "boolean" == typeof (null == r2 ? void 0 : r2.autoFreeze) && this.setAutoFreeze(r2.autoFreeze);
  }
  var i2 = e2.prototype;
  return i2.createDraft = function(e3) {
    t$5(e3) || n$5(8), r$4(e3) && (e3 = R(e3));
    var i3 = w$2(this), o2 = N(this, e3, void 0);
    return o2[Q].C = true, O(i3), o2;
  }, i2.finishDraft = function(r2, t2) {
    var e3 = r2 && r2[Q];
    var i3 = e3.A;
    return j(i3, t2), P(void 0, i3);
  }, i2.setAutoFreeze = function(n2) {
    this.D = n2;
  }, i2.setUseProxies = function(r2) {
    r2 && !B && n$5(20), this.O = r2;
  }, i2.applyPatches = function(n2, t2) {
    var e3;
    for (e3 = t2.length - 1; e3 >= 0; e3--) {
      var i3 = t2[e3];
      if (0 === i3.path.length && "replace" === i3.op) {
        n2 = i3.value;
        break;
      }
    }
    e3 > -1 && (t2 = t2.slice(e3 + 1));
    var o2 = b$2("Patches").$;
    return r$4(n2) ? o2(n2, t2) : this.produce(n2, function(n3) {
      return o2(n3, t2);
    });
  }, e2;
}(), an = new un(), fn = an.produce;
an.produceWithPatches.bind(an);
an.setAutoFreeze.bind(an);
an.setUseProxies.bind(an);
an.applyPatches.bind(an);
an.createDraft.bind(an);
an.finishDraft.bind(an);
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
function toPrimitive(t2, r2) {
  if ("object" != _typeof(t2) || !t2)
    return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof(i2))
      return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function toPropertyKey(t2) {
  var i2 = toPrimitive(t2, "string");
  return "symbol" == _typeof(i2) ? i2 : i2 + "";
}
function _defineProperty$2(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys$c(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$c(Object(t2), true).forEach(function(r3) {
      _defineProperty$2(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$c(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function formatProdErrorMessage(code) {
  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or use the non-minified dev environment for full errors. ";
}
var $$observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var randomString = function randomString2() {
  return Math.random().toString(36).substring(7).split("").join(".");
};
var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};
function isPlainObject$3(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  var proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto;
}
function createStore(reducer, preloadedState, enhancer) {
  var _ref2;
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(formatProdErrorMessage(0));
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(formatProdErrorMessage(1));
    }
    return enhancer(createStore)(reducer, preloadedState);
  }
  if (typeof reducer !== "function") {
    throw new Error(formatProdErrorMessage(2));
  }
  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(3));
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(formatProdErrorMessage(4));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(5));
    }
    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(formatProdErrorMessage(6));
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index2 = nextListeners.indexOf(listener);
      nextListeners.splice(index2, 1);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject$3(action)) {
      throw new Error(formatProdErrorMessage(7));
    }
    if (typeof action.type === "undefined") {
      throw new Error(formatProdErrorMessage(8));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(9));
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    var listeners = currentListeners = nextListeners;
    for (var i2 = 0; i2 < listeners.length; i2++) {
      var listener = listeners[i2];
      listener();
    }
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(formatProdErrorMessage(10));
    }
    currentReducer = nextReducer;
    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  function observable() {
    var _ref;
    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe2(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(formatProdErrorMessage(11));
        }
        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }
        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      }
    }, _ref[$$observable] = function() {
      return this;
    }, _ref;
  }
  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch,
    subscribe,
    getState,
    replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function(key) {
    var reducer = reducers[key];
    var initialState = reducer(void 0, {
      type: ActionTypes.INIT
    });
    if (typeof initialState === "undefined") {
      throw new Error(formatProdErrorMessage(12));
    }
    if (typeof reducer(void 0, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error(formatProdErrorMessage(13));
    }
  });
}
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i2 = 0; i2 < reducerKeys.length; i2++) {
    var key = reducerKeys[i2];
    if (typeof reducers[key] === "function") {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);
  var shapeAssertionError;
  try {
    assertReducerShape(finalReducers);
  } catch (e2) {
    shapeAssertionError = e2;
  }
  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }
    if (shapeAssertionError) {
      throw shapeAssertionError;
    }
    var hasChanged = false;
    var nextState = {};
    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === "undefined") {
        action && action.type;
        throw new Error(formatProdErrorMessage(14));
      }
      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  if (funcs.length === 0) {
    return function(arg) {
      return arg;
    };
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce(function(a2, b2) {
    return function() {
      return a2(b2.apply(void 0, arguments));
    };
  });
}
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }
  return function(createStore2) {
    return function() {
      var store = createStore2.apply(void 0, arguments);
      var _dispatch = function dispatch() {
        throw new Error(formatProdErrorMessage(15));
      };
      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function(middleware2) {
        return middleware2(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread2(_objectSpread2({}, store), {}, {
        dispatch: _dispatch
      });
    };
  };
}
function createThunkMiddleware(extraArgument) {
  var middleware2 = function middleware3(_ref) {
    var dispatch = _ref.dispatch, getState = _ref.getState;
    return function(next2) {
      return function(action) {
        if (typeof action === "function") {
          return action(dispatch, getState, extraArgument);
        }
        return next2(action);
      };
    };
  };
  return middleware2;
}
var thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;
const thunkMiddleware = thunk;
var __extends$X = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p))
          d3[p] = b3[p];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __generator$1 = globalThis && globalThis.__generator || function(thisArg, body) {
  var _24 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_24)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _24.label++;
            return { value: op[1], done: false };
          case 5:
            _24.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _24.ops.pop();
            _24.trys.pop();
            continue;
          default:
            if (!(t2 = _24.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _24 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _24.label = op[1];
              break;
            }
            if (op[0] === 6 && _24.label < t2[1]) {
              _24.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _24.label < t2[2]) {
              _24.label = t2[2];
              _24.ops.push(op);
              break;
            }
            if (t2[2])
              _24.ops.pop();
            _24.trys.pop();
            continue;
        }
        op = body.call(thisArg, _24);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __spreadArray = globalThis && globalThis.__spreadArray || function(to, from2) {
  for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
    to[j2] = from2[i2];
  return to;
};
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = function(obj, key, value) {
  return key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
};
var __spreadValues = function(a2, b2) {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var _i = 0, _c2 = __getOwnPropSymbols(b2); _i < _c2.length; _i++) {
      var prop = _c2[_i];
      if (__propIsEnum.call(b2, prop))
        __defNormalProp2(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = function(a2, b2) {
  return __defProps(a2, __getOwnPropDescs(b2));
};
var __async = function(__this, __arguments, generator) {
  return new Promise(function(resolve2, reject2) {
    var fulfilled = function(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject2(e2);
      }
    };
    var rejected = function(value) {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject2(e2);
      }
    };
    var step = function(x) {
      return x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    };
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length === 0)
    return void 0;
  if (typeof arguments[0] === "object")
    return compose;
  return compose.apply(null, arguments);
};
function isPlainObject$2(value) {
  if (typeof value !== "object" || value === null)
    return false;
  var proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  var baseProto = proto;
  while (Object.getPrototypeOf(baseProto) !== null) {
    baseProto = Object.getPrototypeOf(baseProto);
  }
  return proto === baseProto;
}
function createAction(type2, prepareAction) {
  function actionCreator() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (prepareAction) {
      var prepared = prepareAction.apply(void 0, args);
      if (!prepared) {
        throw new Error("prepareAction did not return an object");
      }
      return __spreadValues(__spreadValues({
        type: type2,
        payload: prepared.payload
      }, "meta" in prepared && { meta: prepared.meta }), "error" in prepared && { error: prepared.error });
    }
    return { type: type2, payload: args[0] };
  }
  actionCreator.toString = function() {
    return "" + type2;
  };
  actionCreator.type = type2;
  actionCreator.match = function(action) {
    return action.type === type2;
  };
  return actionCreator;
}
var MiddlewareArray = (
  /** @class */
  function(_super) {
    __extends$X(MiddlewareArray2, _super);
    function MiddlewareArray2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var _this = _super.apply(this, args) || this;
      Object.setPrototypeOf(_this, MiddlewareArray2.prototype);
      return _this;
    }
    Object.defineProperty(MiddlewareArray2, Symbol.species, {
      get: function() {
        return MiddlewareArray2;
      },
      enumerable: false,
      configurable: true
    });
    MiddlewareArray2.prototype.concat = function() {
      var arr = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
      }
      return _super.prototype.concat.apply(this, arr);
    };
    MiddlewareArray2.prototype.prepend = function() {
      var arr = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
      }
      if (arr.length === 1 && Array.isArray(arr[0])) {
        return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray([void 0], arr[0].concat(this))))();
      }
      return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray([void 0], arr.concat(this))))();
    };
    return MiddlewareArray2;
  }(Array)
);
var EnhancerArray = (
  /** @class */
  function(_super) {
    __extends$X(EnhancerArray2, _super);
    function EnhancerArray2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var _this = _super.apply(this, args) || this;
      Object.setPrototypeOf(_this, EnhancerArray2.prototype);
      return _this;
    }
    Object.defineProperty(EnhancerArray2, Symbol.species, {
      get: function() {
        return EnhancerArray2;
      },
      enumerable: false,
      configurable: true
    });
    EnhancerArray2.prototype.concat = function() {
      var arr = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
      }
      return _super.prototype.concat.apply(this, arr);
    };
    EnhancerArray2.prototype.prepend = function() {
      var arr = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
      }
      if (arr.length === 1 && Array.isArray(arr[0])) {
        return new (EnhancerArray2.bind.apply(EnhancerArray2, __spreadArray([void 0], arr[0].concat(this))))();
      }
      return new (EnhancerArray2.bind.apply(EnhancerArray2, __spreadArray([void 0], arr.concat(this))))();
    };
    return EnhancerArray2;
  }(Array)
);
function freezeDraftable(val) {
  return t$5(val) ? fn(val, function() {
  }) : val;
}
function isBoolean$1(x) {
  return typeof x === "boolean";
}
function curryGetDefaultMiddleware() {
  return function curriedGetDefaultMiddleware(options) {
    return getDefaultMiddleware(options);
  };
}
function getDefaultMiddleware(options) {
  if (options === void 0) {
    options = {};
  }
  var _c2 = options.thunk, thunk2 = _c2 === void 0 ? true : _c2;
  options.immutableCheck;
  options.serializableCheck;
  options.actionCreatorCheck;
  var middlewareArray = new MiddlewareArray();
  if (thunk2) {
    if (isBoolean$1(thunk2)) {
      middlewareArray.push(thunkMiddleware);
    } else {
      middlewareArray.push(thunkMiddleware.withExtraArgument(thunk2.extraArgument));
    }
  }
  return middlewareArray;
}
var IS_PRODUCTION = true;
function configureStore(options) {
  var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();
  var _c2 = options || {}, _d = _c2.reducer, reducer = _d === void 0 ? void 0 : _d, _e = _c2.middleware, middleware2 = _e === void 0 ? curriedGetDefaultMiddleware() : _e, _f = _c2.devTools, devTools = _f === void 0 ? true : _f, _g = _c2.preloadedState, preloadedState = _g === void 0 ? void 0 : _g, _h = _c2.enhancers, enhancers = _h === void 0 ? void 0 : _h;
  var rootReducer;
  if (typeof reducer === "function") {
    rootReducer = reducer;
  } else if (isPlainObject$2(reducer)) {
    rootReducer = combineReducers(reducer);
  } else {
    throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
  }
  var finalMiddleware = middleware2;
  if (typeof finalMiddleware === "function") {
    finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);
  }
  var middlewareEnhancer = applyMiddleware.apply(void 0, finalMiddleware);
  var finalCompose = compose;
  if (devTools) {
    finalCompose = composeWithDevTools(__spreadValues({
      trace: !IS_PRODUCTION
    }, typeof devTools === "object" && devTools));
  }
  var defaultEnhancers = new EnhancerArray(middlewareEnhancer);
  var storeEnhancers = defaultEnhancers;
  if (Array.isArray(enhancers)) {
    storeEnhancers = __spreadArray([middlewareEnhancer], enhancers);
  } else if (typeof enhancers === "function") {
    storeEnhancers = enhancers(defaultEnhancers);
  }
  var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);
  return createStore(rootReducer, preloadedState, composedEnhancer);
}
function executeReducerBuilderCallback(builderCallback) {
  var actionsMap = {};
  var actionMatchers = [];
  var defaultCaseReducer;
  var builder = {
    addCase: function(typeOrActionCreator, reducer) {
      var type2 = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
      if (!type2) {
        throw new Error("`builder.addCase` cannot be called with an empty action type");
      }
      if (type2 in actionsMap) {
        throw new Error("`builder.addCase` cannot be called with two reducers for the same action type");
      }
      actionsMap[type2] = reducer;
      return builder;
    },
    addMatcher: function(matcher, reducer) {
      actionMatchers.push({ matcher, reducer });
      return builder;
    },
    addDefaultCase: function(reducer) {
      defaultCaseReducer = reducer;
      return builder;
    }
  };
  builderCallback(builder);
  return [actionsMap, actionMatchers, defaultCaseReducer];
}
function isStateFunction(x) {
  return typeof x === "function";
}
function createReducer(initialState, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {
  if (actionMatchers === void 0) {
    actionMatchers = [];
  }
  var _c2 = typeof mapOrBuilderCallback === "function" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer], actionsMap = _c2[0], finalActionMatchers = _c2[1], finalDefaultCaseReducer = _c2[2];
  var getInitialState;
  if (isStateFunction(initialState)) {
    getInitialState = function() {
      return freezeDraftable(initialState());
    };
  } else {
    var frozenInitialState_1 = freezeDraftable(initialState);
    getInitialState = function() {
      return frozenInitialState_1;
    };
  }
  function reducer(state, action) {
    if (state === void 0) {
      state = getInitialState();
    }
    var caseReducers = __spreadArray([
      actionsMap[action.type]
    ], finalActionMatchers.filter(function(_c3) {
      var matcher = _c3.matcher;
      return matcher(action);
    }).map(function(_c3) {
      var reducer2 = _c3.reducer;
      return reducer2;
    }));
    if (caseReducers.filter(function(cr) {
      return !!cr;
    }).length === 0) {
      caseReducers = [finalDefaultCaseReducer];
    }
    return caseReducers.reduce(function(previousState, caseReducer) {
      if (caseReducer) {
        if (r$4(previousState)) {
          var draft = previousState;
          var result = caseReducer(draft, action);
          if (result === void 0) {
            return previousState;
          }
          return result;
        } else if (!t$5(previousState)) {
          var result = caseReducer(previousState, action);
          if (result === void 0) {
            if (previousState === null) {
              return previousState;
            }
            throw Error("A case reducer on a non-draftable value must not return undefined");
          }
          return result;
        } else {
          return fn(previousState, function(draft2) {
            return caseReducer(draft2, action);
          });
        }
      }
      return previousState;
    }, state);
  }
  reducer.getInitialState = getInitialState;
  return reducer;
}
function getType2(slice2, actionKey) {
  return slice2 + "/" + actionKey;
}
function createSlice(options) {
  var name = options.name;
  if (!name) {
    throw new Error("`name` is a required option for createSlice");
  }
  if (typeof process !== "undefined" && false) {
    if (options.initialState === void 0) {
      console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
    }
  }
  var initialState = typeof options.initialState == "function" ? options.initialState : freezeDraftable(options.initialState);
  var reducers = options.reducers || {};
  var reducerNames = Object.keys(reducers);
  var sliceCaseReducersByName = {};
  var sliceCaseReducersByType = {};
  var actionCreators = {};
  reducerNames.forEach(function(reducerName) {
    var maybeReducerWithPrepare = reducers[reducerName];
    var type2 = getType2(name, reducerName);
    var caseReducer;
    var prepareCallback;
    if ("reducer" in maybeReducerWithPrepare) {
      caseReducer = maybeReducerWithPrepare.reducer;
      prepareCallback = maybeReducerWithPrepare.prepare;
    } else {
      caseReducer = maybeReducerWithPrepare;
    }
    sliceCaseReducersByName[reducerName] = caseReducer;
    sliceCaseReducersByType[type2] = caseReducer;
    actionCreators[reducerName] = prepareCallback ? createAction(type2, prepareCallback) : createAction(type2);
  });
  function buildReducer() {
    var _c2 = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers], _d = _c2[0], extraReducers = _d === void 0 ? {} : _d, _e = _c2[1], actionMatchers = _e === void 0 ? [] : _e, _f = _c2[2], defaultCaseReducer = _f === void 0 ? void 0 : _f;
    var finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), sliceCaseReducersByType);
    return createReducer(initialState, function(builder) {
      for (var key in finalCaseReducers) {
        builder.addCase(key, finalCaseReducers[key]);
      }
      for (var _i = 0, actionMatchers_1 = actionMatchers; _i < actionMatchers_1.length; _i++) {
        var m2 = actionMatchers_1[_i];
        builder.addMatcher(m2.matcher, m2.reducer);
      }
      if (defaultCaseReducer) {
        builder.addDefaultCase(defaultCaseReducer);
      }
    });
  }
  var _reducer;
  return {
    name,
    reducer: function(state, action) {
      if (!_reducer)
        _reducer = buildReducer();
      return _reducer(state, action);
    },
    actions: actionCreators,
    caseReducers: sliceCaseReducersByName,
    getInitialState: function() {
      if (!_reducer)
        _reducer = buildReducer();
      return _reducer.getInitialState();
    }
  };
}
var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
var nanoid = function(size) {
  if (size === void 0) {
    size = 21;
  }
  var id2 = "";
  var i2 = size;
  while (i2--) {
    id2 += urlAlphabet[Math.random() * 64 | 0];
  }
  return id2;
};
var commonProperties = [
  "name",
  "message",
  "stack",
  "code"
];
var RejectWithValue = (
  /** @class */
  function() {
    function RejectWithValue2(payload, meta) {
      this.payload = payload;
      this.meta = meta;
    }
    return RejectWithValue2;
  }()
);
var FulfillWithMeta = (
  /** @class */
  function() {
    function FulfillWithMeta2(payload, meta) {
      this.payload = payload;
      this.meta = meta;
    }
    return FulfillWithMeta2;
  }()
);
var miniSerializeError = function(value) {
  if (typeof value === "object" && value !== null) {
    var simpleError = {};
    for (var _i = 0, commonProperties_1 = commonProperties; _i < commonProperties_1.length; _i++) {
      var property2 = commonProperties_1[_i];
      if (typeof value[property2] === "string") {
        simpleError[property2] = value[property2];
      }
    }
    return simpleError;
  }
  return { message: String(value) };
};
(function() {
  function createAsyncThunk2(typePrefix, payloadCreator, options) {
    var fulfilled = createAction(typePrefix + "/fulfilled", function(payload, requestId, arg, meta) {
      return {
        payload,
        meta: __spreadProps(__spreadValues({}, meta || {}), {
          arg,
          requestId,
          requestStatus: "fulfilled"
        })
      };
    });
    var pending = createAction(typePrefix + "/pending", function(requestId, arg, meta) {
      return {
        payload: void 0,
        meta: __spreadProps(__spreadValues({}, meta || {}), {
          arg,
          requestId,
          requestStatus: "pending"
        })
      };
    });
    var rejected = createAction(typePrefix + "/rejected", function(error2, requestId, arg, payload, meta) {
      return {
        payload,
        error: (options && options.serializeError || miniSerializeError)(error2 || "Rejected"),
        meta: __spreadProps(__spreadValues({}, meta || {}), {
          arg,
          requestId,
          rejectedWithValue: !!payload,
          requestStatus: "rejected",
          aborted: (error2 == null ? void 0 : error2.name) === "AbortError",
          condition: (error2 == null ? void 0 : error2.name) === "ConditionError"
        })
      };
    });
    var AC = typeof AbortController !== "undefined" ? AbortController : (
      /** @class */
      function() {
        function class_1() {
          this.signal = {
            aborted: false,
            addEventListener: function() {
            },
            dispatchEvent: function() {
              return false;
            },
            onabort: function() {
            },
            removeEventListener: function() {
            },
            reason: void 0,
            throwIfAborted: function() {
            }
          };
        }
        class_1.prototype.abort = function() {
        };
        return class_1;
      }()
    );
    function actionCreator(arg) {
      return function(dispatch, getState, extra2) {
        var requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();
        var abortController = new AC();
        var abortReason;
        function abort(reason) {
          abortReason = reason;
          abortController.abort();
        }
        var promise2 = function() {
          return __async(this, null, function() {
            var _a2, _b2, finalAction, conditionResult, abortedPromise, err_1, skipDispatch;
            return __generator$1(this, function(_c2) {
              switch (_c2.label) {
                case 0:
                  _c2.trys.push([0, 4, , 5]);
                  conditionResult = (_a2 = options == null ? void 0 : options.condition) == null ? void 0 : _a2.call(options, arg, { getState, extra: extra2 });
                  if (!isThenable(conditionResult))
                    return [3, 2];
                  return [4, conditionResult];
                case 1:
                  conditionResult = _c2.sent();
                  _c2.label = 2;
                case 2:
                  if (conditionResult === false || abortController.signal.aborted) {
                    throw {
                      name: "ConditionError",
                      message: "Aborted due to condition callback returning false."
                    };
                  }
                  abortedPromise = new Promise(function(_24, reject2) {
                    return abortController.signal.addEventListener("abort", function() {
                      return reject2({
                        name: "AbortError",
                        message: abortReason || "Aborted"
                      });
                    });
                  });
                  dispatch(pending(requestId, arg, (_b2 = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b2.call(options, { requestId, arg }, { getState, extra: extra2 })));
                  return [4, Promise.race([
                    abortedPromise,
                    Promise.resolve(payloadCreator(arg, {
                      dispatch,
                      getState,
                      extra: extra2,
                      requestId,
                      signal: abortController.signal,
                      abort,
                      rejectWithValue: function(value, meta) {
                        return new RejectWithValue(value, meta);
                      },
                      fulfillWithValue: function(value, meta) {
                        return new FulfillWithMeta(value, meta);
                      }
                    })).then(function(result) {
                      if (result instanceof RejectWithValue) {
                        throw result;
                      }
                      if (result instanceof FulfillWithMeta) {
                        return fulfilled(result.payload, requestId, arg, result.meta);
                      }
                      return fulfilled(result, requestId, arg);
                    })
                  ])];
                case 3:
                  finalAction = _c2.sent();
                  return [3, 5];
                case 4:
                  err_1 = _c2.sent();
                  finalAction = err_1 instanceof RejectWithValue ? rejected(null, requestId, arg, err_1.payload, err_1.meta) : rejected(err_1, requestId, arg);
                  return [3, 5];
                case 5:
                  skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
                  if (!skipDispatch) {
                    dispatch(finalAction);
                  }
                  return [2, finalAction];
              }
            });
          });
        }();
        return Object.assign(promise2, {
          abort,
          requestId,
          arg,
          unwrap: function() {
            return promise2.then(unwrapResult);
          }
        });
      };
    }
    return Object.assign(actionCreator, {
      pending,
      rejected,
      fulfilled,
      typePrefix
    });
  }
  createAsyncThunk2.withTypes = function() {
    return createAsyncThunk2;
  };
  return createAsyncThunk2;
})();
function unwrapResult(action) {
  if (action.meta && action.meta.rejectedWithValue) {
    throw action.payload;
  }
  if (action.error) {
    throw action.error;
  }
  return action.payload;
}
function isThenable(value) {
  return value !== null && typeof value === "object" && typeof value.then === "function";
}
var alm = "listenerMiddleware";
createAction(alm + "/add");
createAction(alm + "/removeAll");
createAction(alm + "/remove");
var promise;
typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : globalThis) : function(cb2) {
  return (promise || (promise = Promise.resolve())).then(cb2).catch(function(err) {
    return setTimeout(function() {
      throw err;
    }, 0);
  });
};
F();
function listCacheClear$3() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear$1 = listCacheClear$3;
function eq$5(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1$1 = eq$5;
var eq$4 = eq_1$1;
function assocIndexOf$9(array, key) {
  var length2 = array.length;
  while (length2--) {
    if (eq$4(array[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
var _assocIndexOf$1 = assocIndexOf$9;
var assocIndexOf$8 = _assocIndexOf$1;
var arrayProto$1 = Array.prototype;
var splice$1 = arrayProto$1.splice;
function listCacheDelete$3(key) {
  var data2 = this.__data__, index2 = assocIndexOf$8(data2, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data2.length - 1;
  if (index2 == lastIndex) {
    data2.pop();
  } else {
    splice$1.call(data2, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete$1 = listCacheDelete$3;
var assocIndexOf$7 = _assocIndexOf$1;
function listCacheGet$3(key) {
  var data2 = this.__data__, index2 = assocIndexOf$7(data2, key);
  return index2 < 0 ? void 0 : data2[index2][1];
}
var _listCacheGet$1 = listCacheGet$3;
var assocIndexOf$6 = _assocIndexOf$1;
function listCacheHas$3(key) {
  return assocIndexOf$6(this.__data__, key) > -1;
}
var _listCacheHas$1 = listCacheHas$3;
var assocIndexOf$5 = _assocIndexOf$1;
function listCacheSet$3(key, value) {
  var data2 = this.__data__, index2 = assocIndexOf$5(data2, key);
  if (index2 < 0) {
    ++this.size;
    data2.push([key, value]);
  } else {
    data2[index2][1] = value;
  }
  return this;
}
var _listCacheSet$1 = listCacheSet$3;
var listCacheClear$2 = _listCacheClear$1, listCacheDelete$2 = _listCacheDelete$1, listCacheGet$2 = _listCacheGet$1, listCacheHas$2 = _listCacheHas$1, listCacheSet$2 = _listCacheSet$1;
function ListCache$6(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$6.prototype.clear = listCacheClear$2;
ListCache$6.prototype["delete"] = listCacheDelete$2;
ListCache$6.prototype.get = listCacheGet$2;
ListCache$6.prototype.has = listCacheHas$2;
ListCache$6.prototype.set = listCacheSet$2;
var _ListCache$1 = ListCache$6;
var ListCache$5 = _ListCache$1;
function stackClear$1() {
  this.__data__ = new ListCache$5();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data2 = this.__data__, result = data2["delete"](key);
  this.size = data2.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var freeGlobal$3 = typeof commonjsGlobal$1 == "object" && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;
var _freeGlobal$1 = freeGlobal$3;
var freeGlobal$2 = _freeGlobal$1;
var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
var root$e = freeGlobal$2 || freeSelf$1 || Function("return this")();
var _root$1 = root$e;
var root$d = _root$1;
var Symbol$7 = root$d.Symbol;
var _Symbol$1 = Symbol$7;
var Symbol$6 = _Symbol$1;
var objectProto$i = Object.prototype;
var hasOwnProperty$e = objectProto$i.hasOwnProperty;
var nativeObjectToString$3 = objectProto$i.toString;
var symToStringTag$3 = Symbol$6 ? Symbol$6.toStringTag : void 0;
function getRawTag$3(value) {
  var isOwn = hasOwnProperty$e.call(value, symToStringTag$3), tag2 = value[symToStringTag$3];
  try {
    value[symToStringTag$3] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$3.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$3] = tag2;
    } else {
      delete value[symToStringTag$3];
    }
  }
  return result;
}
var _getRawTag$1 = getRawTag$3;
var objectProto$h = Object.prototype;
var nativeObjectToString$2 = objectProto$h.toString;
function objectToString$4(value) {
  return nativeObjectToString$2.call(value);
}
var _objectToString$1 = objectToString$4;
var Symbol$5 = _Symbol$1, getRawTag$2 = _getRawTag$1, objectToString$3 = _objectToString$1;
var nullTag$1 = "[object Null]", undefinedTag$1 = "[object Undefined]";
var symToStringTag$2 = Symbol$5 ? Symbol$5.toStringTag : void 0;
function baseGetTag$7(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag$1 : nullTag$1;
  }
  return symToStringTag$2 && symToStringTag$2 in Object(value) ? getRawTag$2(value) : objectToString$3(value);
}
var _baseGetTag$1 = baseGetTag$7;
function isObject$e(value) {
  var type2 = typeof value;
  return value != null && (type2 == "object" || type2 == "function");
}
var isObject_1$1 = isObject$e;
var baseGetTag$6 = _baseGetTag$1, isObject$d = isObject_1$1;
var asyncTag$1 = "[object AsyncFunction]", funcTag$3 = "[object Function]", genTag$2 = "[object GeneratorFunction]", proxyTag$1 = "[object Proxy]";
function isFunction$6(value) {
  if (!isObject$d(value)) {
    return false;
  }
  var tag2 = baseGetTag$6(value);
  return tag2 == funcTag$3 || tag2 == genTag$2 || tag2 == asyncTag$1 || tag2 == proxyTag$1;
}
var isFunction_1$1 = isFunction$6;
var root$c = _root$1;
var coreJsData$3 = root$c["__core-js_shared__"];
var _coreJsData$1 = coreJsData$3;
var coreJsData$2 = _coreJsData$1;
var maskSrcKey$1 = function() {
  var uid2 = /[^.]+$/.exec(coreJsData$2 && coreJsData$2.keys && coreJsData$2.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked$3(func) {
  return !!maskSrcKey$1 && maskSrcKey$1 in func;
}
var _isMasked$1 = isMasked$3;
var funcProto$3 = Function.prototype;
var funcToString$3 = funcProto$3.toString;
function toSource$4(func) {
  if (func != null) {
    try {
      return funcToString$3.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var _toSource$1 = toSource$4;
var isFunction$5 = isFunction_1$1, isMasked$2 = _isMasked$1, isObject$c = isObject_1$1, toSource$3 = _toSource$1;
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
var funcProto$2 = Function.prototype, objectProto$g = Object.prototype;
var funcToString$2 = funcProto$2.toString;
var hasOwnProperty$d = objectProto$g.hasOwnProperty;
var reIsNative$1 = RegExp(
  "^" + funcToString$2.call(hasOwnProperty$d).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$3(value) {
  if (!isObject$c(value) || isMasked$2(value)) {
    return false;
  }
  var pattern = isFunction$5(value) ? reIsNative$1 : reIsHostCtor$1;
  return pattern.test(toSource$3(value));
}
var _baseIsNative$1 = baseIsNative$3;
function getValue$4(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue$1 = getValue$4;
var baseIsNative$2 = _baseIsNative$1, getValue$3 = _getValue$1;
function getNative$b(object, key) {
  var value = getValue$3(object, key);
  return baseIsNative$2(value) ? value : void 0;
}
var _getNative$1 = getNative$b;
var getNative$a = _getNative$1, root$b = _root$1;
var Map$6 = getNative$a(root$b, "Map");
var _Map$1 = Map$6;
var getNative$9 = _getNative$1;
var nativeCreate$9 = getNative$9(Object, "create");
var _nativeCreate$1 = nativeCreate$9;
var nativeCreate$8 = _nativeCreate$1;
function hashClear$3() {
  this.__data__ = nativeCreate$8 ? nativeCreate$8(null) : {};
  this.size = 0;
}
var _hashClear$1 = hashClear$3;
function hashDelete$3(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete$1 = hashDelete$3;
var nativeCreate$7 = _nativeCreate$1;
var HASH_UNDEFINED$5 = "__lodash_hash_undefined__";
var objectProto$f = Object.prototype;
var hasOwnProperty$c = objectProto$f.hasOwnProperty;
function hashGet$3(key) {
  var data2 = this.__data__;
  if (nativeCreate$7) {
    var result = data2[key];
    return result === HASH_UNDEFINED$5 ? void 0 : result;
  }
  return hasOwnProperty$c.call(data2, key) ? data2[key] : void 0;
}
var _hashGet$1 = hashGet$3;
var nativeCreate$6 = _nativeCreate$1;
var objectProto$e = Object.prototype;
var hasOwnProperty$b = objectProto$e.hasOwnProperty;
function hashHas$3(key) {
  var data2 = this.__data__;
  return nativeCreate$6 ? data2[key] !== void 0 : hasOwnProperty$b.call(data2, key);
}
var _hashHas$1 = hashHas$3;
var nativeCreate$5 = _nativeCreate$1;
var HASH_UNDEFINED$4 = "__lodash_hash_undefined__";
function hashSet$3(key, value) {
  var data2 = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data2[key] = nativeCreate$5 && value === void 0 ? HASH_UNDEFINED$4 : value;
  return this;
}
var _hashSet$1 = hashSet$3;
var hashClear$2 = _hashClear$1, hashDelete$2 = _hashDelete$1, hashGet$2 = _hashGet$1, hashHas$2 = _hashHas$1, hashSet$2 = _hashSet$1;
function Hash$3(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$3.prototype.clear = hashClear$2;
Hash$3.prototype["delete"] = hashDelete$2;
Hash$3.prototype.get = hashGet$2;
Hash$3.prototype.has = hashHas$2;
Hash$3.prototype.set = hashSet$2;
var _Hash$1 = Hash$3;
var Hash$2 = _Hash$1, ListCache$4 = _ListCache$1, Map$5 = _Map$1;
function mapCacheClear$3() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash$2(),
    "map": new (Map$5 || ListCache$4)(),
    "string": new Hash$2()
  };
}
var _mapCacheClear$1 = mapCacheClear$3;
function isKeyable$3(value) {
  var type2 = typeof value;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable$1 = isKeyable$3;
var isKeyable$2 = _isKeyable$1;
function getMapData$9(map2, key) {
  var data2 = map2.__data__;
  return isKeyable$2(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
}
var _getMapData$1 = getMapData$9;
var getMapData$8 = _getMapData$1;
function mapCacheDelete$3(key) {
  var result = getMapData$8(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete$1 = mapCacheDelete$3;
var getMapData$7 = _getMapData$1;
function mapCacheGet$3(key) {
  return getMapData$7(this, key).get(key);
}
var _mapCacheGet$1 = mapCacheGet$3;
var getMapData$6 = _getMapData$1;
function mapCacheHas$3(key) {
  return getMapData$6(this, key).has(key);
}
var _mapCacheHas$1 = mapCacheHas$3;
var getMapData$5 = _getMapData$1;
function mapCacheSet$3(key, value) {
  var data2 = getMapData$5(this, key), size = data2.size;
  data2.set(key, value);
  this.size += data2.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet$1 = mapCacheSet$3;
var mapCacheClear$2 = _mapCacheClear$1, mapCacheDelete$2 = _mapCacheDelete$1, mapCacheGet$2 = _mapCacheGet$1, mapCacheHas$2 = _mapCacheHas$1, mapCacheSet$2 = _mapCacheSet$1;
function MapCache$4(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$4.prototype.clear = mapCacheClear$2;
MapCache$4.prototype["delete"] = mapCacheDelete$2;
MapCache$4.prototype.get = mapCacheGet$2;
MapCache$4.prototype.has = mapCacheHas$2;
MapCache$4.prototype.set = mapCacheSet$2;
var _MapCache$1 = MapCache$4;
var ListCache$3 = _ListCache$1, Map$4 = _Map$1, MapCache$3 = _MapCache$1;
var LARGE_ARRAY_SIZE$2 = 200;
function stackSet$1(key, value) {
  var data2 = this.__data__;
  if (data2 instanceof ListCache$3) {
    var pairs = data2.__data__;
    if (!Map$4 || pairs.length < LARGE_ARRAY_SIZE$2 - 1) {
      pairs.push([key, value]);
      this.size = ++data2.size;
      return this;
    }
    data2 = this.__data__ = new MapCache$3(pairs);
  }
  data2.set(key, value);
  this.size = data2.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache$2 = _ListCache$1, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$3(entries) {
  var data2 = this.__data__ = new ListCache$2(entries);
  this.size = data2.size;
}
Stack$3.prototype.clear = stackClear;
Stack$3.prototype["delete"] = stackDelete;
Stack$3.prototype.get = stackGet;
Stack$3.prototype.has = stackHas;
Stack$3.prototype.set = stackSet;
var _Stack = Stack$3;
function arrayEach$1(array, iteratee) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
var _arrayEach = arrayEach$1;
var getNative$8 = _getNative$1;
var defineProperty$1 = function() {
  try {
    var func = getNative$8(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var _defineProperty$1 = defineProperty$1;
var defineProperty = _defineProperty$1;
function baseAssignValue$2(object, key, value) {
  if (key == "__proto__" && defineProperty) {
    defineProperty(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$2;
var baseAssignValue$1 = _baseAssignValue, eq$3 = eq_1$1;
var objectProto$d = Object.prototype;
var hasOwnProperty$a = objectProto$d.hasOwnProperty;
function assignValue$3(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$a.call(object, key) && eq$3(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue$1(object, key, value);
  }
}
var _assignValue = assignValue$3;
var assignValue$2 = _assignValue, baseAssignValue = _baseAssignValue;
function copyObject$4(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length2 = props.length;
  while (++index2 < length2) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue$2(object, key, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$4;
function baseTimes$1(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$1;
function isObjectLike$7(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$7;
var baseGetTag$5 = _baseGetTag$1, isObjectLike$6 = isObjectLike_1;
var argsTag$3 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$6(value) && baseGetTag$5(value) == argsTag$3;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$5 = isObjectLike_1;
var objectProto$c = Object.prototype;
var hasOwnProperty$9 = objectProto$c.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$c.propertyIsEnumerable;
var isArguments$2 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$5(value) && hasOwnProperty$9.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments_1 = isArguments$2;
var isArray$h = Array.isArray;
var isArray_1 = isArray$h;
var isBuffer$7 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
isBuffer$7.exports;
(function(module, exports) {
  var root2 = _root$1, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer3 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer3;
})(isBuffer$7, isBuffer$7.exports);
var isBufferExports = isBuffer$7.exports;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$3(value, length2) {
  var type2 = typeof value;
  length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
  return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
var _isIndex = isIndex$3;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$3;
var baseGetTag$4 = _baseGetTag$1, isLength$2 = isLength_1, isObjectLike$4 = isObjectLike_1;
var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$2 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$2] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$4(value) && isLength$2(value.length) && !!typedArrayTags[baseGetTag$4(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$3(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$3;
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
(function(module, exports) {
  var freeGlobal2 = _freeGlobal$1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types2 = freeModule && freeModule.require && freeModule.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var _nodeUtilExports = _nodeUtil.exports;
var baseIsTypedArray = _baseIsTypedArray, baseUnary$2 = _baseUnary, nodeUtil$2 = _nodeUtilExports;
var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;
var isTypedArray$4 = nodeIsTypedArray ? baseUnary$2(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$4;
var baseTimes = _baseTimes, isArguments$1 = isArguments_1, isArray$g = isArray_1, isBuffer$6 = isBufferExports, isIndex$2 = _isIndex, isTypedArray$3 = isTypedArray_1;
var objectProto$b = Object.prototype;
var hasOwnProperty$8 = objectProto$b.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$g(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$6(value), isType = !isArr && !isArg && !isBuff && isTypedArray$3(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$8.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex$2(key, length2)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$2;
var objectProto$a = Object.prototype;
function isPrototype$3(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
  return value === proto;
}
var _isPrototype = isPrototype$3;
function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype$2 = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$9 = Object.prototype;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
function baseKeys$1(object) {
  if (!isPrototype$2(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$7.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var isFunction$4 = isFunction_1$1, isLength$1 = isLength_1;
function isArrayLike$3(value) {
  return value != null && isLength$1(value.length) && !isFunction$4(value);
}
var isArrayLike_1 = isArrayLike$3;
var arrayLikeKeys$1 = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$2 = isArrayLike_1;
function keys$4(object) {
  return isArrayLike$2(object) ? arrayLikeKeys$1(object) : baseKeys(object);
}
var keys_1 = keys$4;
var copyObject$3 = _copyObject, keys$3 = keys_1;
function baseAssign$1(object, source) {
  return object && copyObject$3(source, keys$3(source), object);
}
var _baseAssign = baseAssign$1;
function nativeKeysIn$1(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$b = isObject_1$1, isPrototype$1 = _isPrototype, nativeKeysIn = _nativeKeysIn;
var objectProto$8 = Object.prototype;
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function baseKeysIn$1(object) {
  if (!isObject$b(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype$1(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$6.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike$1 = isArrayLike_1;
function keysIn$3(object) {
  return isArrayLike$1(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var keysIn_1 = keysIn$3;
var copyObject$2 = _copyObject, keysIn$2 = keysIn_1;
function baseAssignIn$1(object, source) {
  return object && copyObject$2(source, keysIn$2(source), object);
}
var _baseAssignIn = baseAssignIn$1;
var _cloneBuffer = { exports: {} };
_cloneBuffer.exports;
(function(module, exports) {
  var root2 = _root$1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length2 = buffer.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
    buffer.copy(result);
    return result;
  }
  module.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
var _cloneBufferExports = _cloneBuffer.exports;
function copyArray$1(source, array) {
  var index2 = -1, length2 = source.length;
  array || (array = Array(length2));
  while (++index2 < length2) {
    array[index2] = source[index2];
  }
  return array;
}
var _copyArray = copyArray$1;
function arrayFilter$1(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length2) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2;
var arrayFilter = _arrayFilter, stubArray$1 = stubArray_1;
var objectProto$7 = Object.prototype;
var propertyIsEnumerable = objectProto$7.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var _getSymbols = getSymbols$3;
var copyObject$1 = _copyObject, getSymbols$2 = _getSymbols;
function copySymbols$1(source, object) {
  return copyObject$1(source, getSymbols$2(source), object);
}
var _copySymbols = copySymbols$1;
function arrayPush$2(array, values) {
  var index2 = -1, length2 = values.length, offset = array.length;
  while (++index2 < length2) {
    array[offset + index2] = values[index2];
  }
  return array;
}
var _arrayPush = arrayPush$2;
var overArg = _overArg;
var getPrototype$2 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$2;
var arrayPush$1 = _arrayPush, getPrototype$1 = _getPrototype, getSymbols$1 = _getSymbols, stubArray = stubArray_1;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush$1(result, getSymbols$1(object));
    object = getPrototype$1(object);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object) {
  return copyObject(source, getSymbolsIn$1(source), object);
}
var _copySymbolsIn = copySymbolsIn$1;
var arrayPush = _arrayPush, isArray$f = isArray_1;
function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$f(object) ? result : arrayPush(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$2;
var baseGetAllKeys$1 = _baseGetAllKeys, getSymbols = _getSymbols, keys$2 = keys_1;
function getAllKeys$2(object) {
  return baseGetAllKeys$1(object, keys$2, getSymbols);
}
var _getAllKeys = getAllKeys$2;
var baseGetAllKeys = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$1 = keysIn_1;
function getAllKeysIn$2(object) {
  return baseGetAllKeys(object, keysIn$1, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$2;
var getNative$7 = _getNative$1, root$a = _root$1;
var DataView$2 = getNative$7(root$a, "DataView");
var _DataView = DataView$2;
var getNative$6 = _getNative$1, root$9 = _root$1;
var Promise$3 = getNative$6(root$9, "Promise");
var _Promise = Promise$3;
var getNative$5 = _getNative$1, root$8 = _root$1;
var Set$4 = getNative$5(root$8, "Set");
var _Set$1 = Set$4;
var getNative$4 = _getNative$1, root$7 = _root$1;
var WeakMap$2 = getNative$4(root$7, "WeakMap");
var _WeakMap = WeakMap$2;
var DataView$1 = _DataView, Map$3 = _Map$1, Promise$2 = _Promise, Set$3 = _Set$1, WeakMap$1 = _WeakMap, baseGetTag$3 = _baseGetTag$1, toSource$2 = _toSource$1;
var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$3 = "[object DataView]";
var dataViewCtorString = toSource$2(DataView$1), mapCtorString = toSource$2(Map$3), promiseCtorString = toSource$2(Promise$2), setCtorString = toSource$2(Set$3), weakMapCtorString = toSource$2(WeakMap$1);
var getTag$4 = baseGetTag$3;
if (DataView$1 && getTag$4(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$3 && getTag$4(new Map$3()) != mapTag$4 || Promise$2 && getTag$4(Promise$2.resolve()) != promiseTag || Set$3 && getTag$4(new Set$3()) != setTag$4 || WeakMap$1 && getTag$4(new WeakMap$1()) != weakMapTag$1) {
  getTag$4 = function(value) {
    var result = baseGetTag$3(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource$2(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$3;
        case mapCtorString:
          return mapTag$4;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$4;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var _getTag = getTag$4;
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function initCloneArray$1(array) {
  var length2 = array.length, result = new array.constructor(length2);
  if (length2 && typeof array[0] == "string" && hasOwnProperty$5.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var _initCloneArray = initCloneArray$1;
var root$6 = _root$1;
var Uint8Array$3 = root$6.Uint8Array;
var _Uint8Array = Uint8Array$3;
var Uint8Array$2 = _Uint8Array;
function cloneArrayBuffer$3(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$3;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$4 = _Symbol$1;
var symbolProto$2 = Symbol$4 ? Symbol$4.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneTypedArray$1(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$1;
var cloneArrayBuffer = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray = _cloneTypedArray;
var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$3 = "[object Symbol]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(object, tag2, isDeep) {
  var Ctor = object.constructor;
  switch (tag2) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(object);
    case boolTag$2:
    case dateTag$2:
      return new Ctor(+object);
    case dataViewTag$2:
      return cloneDataView(object, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object, isDeep);
    case mapTag$3:
      return new Ctor();
    case numberTag$2:
    case stringTag$2:
      return new Ctor(object);
    case regexpTag$2:
      return cloneRegExp(object);
    case setTag$3:
      return new Ctor();
    case symbolTag$3:
      return cloneSymbol(object);
  }
}
var _initCloneByTag = initCloneByTag$1;
var isObject$a = isObject_1$1;
var objectCreate = Object.create;
var baseCreate$1 = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$a(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$1;
var baseCreate = _baseCreate, getPrototype = _getPrototype, isPrototype = _isPrototype;
function initCloneObject$1(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}
var _initCloneObject = initCloneObject$1;
var getTag$3 = _getTag, isObjectLike$3 = isObjectLike_1;
var mapTag$2 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$3(value) && getTag$3(value) == mapTag$2;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap, baseUnary$1 = _baseUnary, nodeUtil$1 = _nodeUtilExports;
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap$2 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$2;
var getTag$2 = _getTag, isObjectLike$2 = isObjectLike_1;
var setTag$2 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike$2(value) && getTag$2(value) == setTag$2;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet, baseUnary = _baseUnary, nodeUtil = _nodeUtilExports;
var nodeIsSet = nodeUtil && nodeUtil.isSet;
var isSet$2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$2;
var Stack$2 = _Stack, arrayEach = _arrayEach, assignValue$1 = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer = _cloneBufferExports, copyArray = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys$1 = _getAllKeys, getAllKeysIn$1 = _getAllKeysIn, getTag$1 = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject = _initCloneObject, isArray$e = isArray_1, isBuffer$5 = isBufferExports, isMap$1 = isMap_1, isObject$9 = isObject_1$1, isSet$1 = isSet_1, keys$1 = keys_1, keysIn = keysIn_1;
var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", genTag$1 = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$2 = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$2] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag$1] = cloneableTags[weakMapTag] = false;
function baseClone$1(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$9(value)) {
    return value;
  }
  var isArr = isArray$e(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag2 = getTag$1(value), isFunc = tag2 == funcTag$1 || tag2 == genTag$1;
    if (isBuffer$5(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag2 == objectTag$1 || tag2 == argsTag$1 || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag2]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag2, isDeep);
    }
  }
  stack || (stack = new Stack$2());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet$1(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone$1(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap$1(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone$1(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn$1 : getAllKeys$1 : isFlat ? keysIn : keys$1;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue$1(result, key2, baseClone$1(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var _baseClone = baseClone$1;
var baseClone = _baseClone;
var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
var cloneDeep_1 = cloneDeep;
const cloneDeep$1 = /* @__PURE__ */ getDefaultExportFromCjs(cloneDeep_1);
var commandType$1 = /* @__PURE__ */ ((commandType2) => {
  commandType2[commandType2["say"] = 0] = "say";
  commandType2[commandType2["changeBg"] = 1] = "changeBg";
  commandType2[commandType2["changeFigure"] = 2] = "changeFigure";
  commandType2[commandType2["bgm"] = 3] = "bgm";
  commandType2[commandType2["video"] = 4] = "video";
  commandType2[commandType2["pixi"] = 5] = "pixi";
  commandType2[commandType2["pixiInit"] = 6] = "pixiInit";
  commandType2[commandType2["intro"] = 7] = "intro";
  commandType2[commandType2["miniAvatar"] = 8] = "miniAvatar";
  commandType2[commandType2["changeScene"] = 9] = "changeScene";
  commandType2[commandType2["choose"] = 10] = "choose";
  commandType2[commandType2["end"] = 11] = "end";
  commandType2[commandType2["setComplexAnimation"] = 12] = "setComplexAnimation";
  commandType2[commandType2["setFilter"] = 13] = "setFilter";
  commandType2[commandType2["label"] = 14] = "label";
  commandType2[commandType2["jumpLabel"] = 15] = "jumpLabel";
  commandType2[commandType2["chooseLabel"] = 16] = "chooseLabel";
  commandType2[commandType2["setVar"] = 17] = "setVar";
  commandType2[commandType2["if"] = 18] = "if";
  commandType2[commandType2["callScene"] = 19] = "callScene";
  commandType2[commandType2["showVars"] = 20] = "showVars";
  commandType2[commandType2["unlockCg"] = 21] = "unlockCg";
  commandType2[commandType2["unlockBgm"] = 22] = "unlockBgm";
  commandType2[commandType2["filmMode"] = 23] = "filmMode";
  commandType2[commandType2["setTextbox"] = 24] = "setTextbox";
  commandType2[commandType2["setAnimation"] = 25] = "setAnimation";
  commandType2[commandType2["playEffect"] = 26] = "playEffect";
  commandType2[commandType2["setTempAnimation"] = 27] = "setTempAnimation";
  commandType2[commandType2["comment"] = 28] = "comment";
  commandType2[commandType2["setTransform"] = 29] = "setTransform";
  commandType2[commandType2["setTransition"] = 30] = "setTransition";
  commandType2[commandType2["getUserInput"] = 31] = "getUserInput";
  commandType2[commandType2["applyStyle"] = 32] = "applyStyle";
  return commandType2;
})(commandType$1 || {});
const initState$3 = {
  oldBgName: "",
  bgName: "",
  // 
  figName: "",
  // _ 
  figNameLeft: "",
  // _ 
  figNameRight: "",
  // _ 
  freeFigure: [],
  figureAssociatedAnimation: [],
  showText: "",
  // 
  showTextSize: -1,
  showName: "",
  // 
  command: "",
  // 
  choose: [],
  // 
  vocal: "",
  //  
  playVocal: "",
  // 
  vocalVolume: 100,
  //  0 - 100
  bgm: {
    // 
    src: "",
    //  
    enter: 0,
    //  
    volume: 100
    //  0 - 100
  },
  uiSe: "",
  //  
  miniAvatar: "",
  //  
  GameVar: {},
  // 
  effects: [],
  // 
  bgFilter: "",
  // 
  bgTransform: "",
  // 
  PerformList: [],
  // 
  currentDialogKey: "initial",
  live2dMotion: [],
  live2dExpression: [],
  // currentPerformDelay: 0
  currentConcatDialogPrev: "",
  enableFilm: "",
  isDisableTextbox: false,
  replacedUIlable: {}
};
const stageSlice = createSlice({
  name: "stage",
  initialState: cloneDeep$1(initState$3),
  reducers: {
    /**
     * 
     * @param state 
     * @param action 
     */
    resetStageState: (state, action) => {
      Object.assign(state, action.payload);
    },
    /**
     * 
     * @param state 
     * @param action 
     */
    setStage: (state, action) => {
      state[action.payload.key] = action.payload.value;
    },
    /**
     * 
     * @param state 
     * @param action 
     */
    setStageVar: (state, action) => {
      state.GameVar[action.payload.key] = action.payload.value;
    },
    updateEffect: (state, action) => {
      const { target, transform } = action.payload;
      const effectIndex = state.effects.findIndex((e2) => e2.target === target);
      if (effectIndex >= 0) {
        state.effects[effectIndex].transform = transform;
      } else {
        state.effects.push({
          target,
          transform
        });
      }
    },
    removeEffectByTargetId: (state, action) => {
      const index2 = state.effects.findIndex((e2) => e2.target === action.payload);
      if (index2 >= 0) {
        state.effects.splice(index2, 1);
      }
    },
    addPerform: (state, action) => {
      state.PerformList.push(action.payload);
    },
    removePerformByName: (state, action) => {
      for (let i2 = 0; i2 < state.PerformList.length; i2++) {
        const performItem = state.PerformList[i2];
        if (performItem.id === action.payload) {
          state.PerformList.splice(i2, 1);
          i2--;
        }
      }
    },
    removeAllPixiPerforms: (state, action) => {
      for (let i2 = 0; i2 < state.PerformList.length; i2++) {
        const performItem = state.PerformList[i2];
        if (performItem.script.command === commandType$1.pixi) {
          state.PerformList.splice(i2, 1);
          i2--;
        }
      }
    },
    setFreeFigureByKey: (state, action) => {
      const currentFreeFigures = state.freeFigure;
      const newFigure = action.payload;
      const index2 = currentFreeFigures.findIndex((figure) => figure.key === newFigure.key);
      if (index2 >= 0) {
        currentFreeFigures[index2].basePosition = newFigure.basePosition;
        currentFreeFigures[index2].name = newFigure.name;
      } else {
        if (newFigure.name !== "")
          currentFreeFigures.push(newFigure);
      }
    },
    setLive2dMotion: (state, action) => {
      const { target, motion } = action.payload;
      const index2 = state.live2dMotion.findIndex((e2) => e2.target === target);
      if (index2 < 0) {
        state.live2dMotion.push({ target, motion });
      } else {
        state.live2dMotion[index2].motion = motion;
      }
    },
    setLive2dExpression: (state, action) => {
      const { target, expression } = action.payload;
      const index2 = state.live2dExpression.findIndex((e2) => e2.target === target);
      if (index2 < 0) {
        state.live2dExpression.push({ target, expression });
      } else {
        state.live2dExpression[index2].expression = expression;
      }
    },
    replaceUIlable: (state, action) => {
      state.replacedUIlable[action.payload[0]] = action.payload[1];
    }
  }
});
const { resetStageState, setStage, setStageVar } = stageSlice.actions;
const stageActions = stageSlice.actions;
const stageReducer = stageSlice.reducer;
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var localforage$1 = { exports: {} };
/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
(function(module, exports) {
  (function(f2) {
    {
      module.exports = f2();
    }
  })(function() {
    return function e2(t2, n2, r2) {
      function s2(o3, u2) {
        if (!n2[o3]) {
          if (!t2[o3]) {
            var a2 = typeof commonjsRequire == "function" && commonjsRequire;
            if (!u2 && a2)
              return a2(o3, true);
            if (i2)
              return i2(o3, true);
            var f2 = new Error("Cannot find module '" + o3 + "'");
            throw f2.code = "MODULE_NOT_FOUND", f2;
          }
          var l2 = n2[o3] = { exports: {} };
          t2[o3][0].call(l2.exports, function(e3) {
            var n3 = t2[o3][1][e3];
            return s2(n3 ? n3 : e3);
          }, l2, l2.exports, e2, t2, n2, r2);
        }
        return n2[o3].exports;
      }
      var i2 = typeof commonjsRequire == "function" && commonjsRequire;
      for (var o2 = 0; o2 < r2.length; o2++)
        s2(r2[o2]);
      return s2;
    }({ 1: [function(_dereq_, module2, exports2) {
      (function(global2) {
        var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
        var scheduleDrain;
        {
          if (Mutation) {
            var called = 0;
            var observer = new Mutation(nextTick);
            var element = global2.document.createTextNode("");
            observer.observe(element, {
              characterData: true
            });
            scheduleDrain = function() {
              element.data = called = ++called % 2;
            };
          } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
            var channel = new global2.MessageChannel();
            channel.port1.onmessage = nextTick;
            scheduleDrain = function() {
              channel.port2.postMessage(0);
            };
          } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
            scheduleDrain = function() {
              var scriptEl = global2.document.createElement("script");
              scriptEl.onreadystatechange = function() {
                nextTick();
                scriptEl.onreadystatechange = null;
                scriptEl.parentNode.removeChild(scriptEl);
                scriptEl = null;
              };
              global2.document.documentElement.appendChild(scriptEl);
            };
          } else {
            scheduleDrain = function() {
              setTimeout(nextTick, 0);
            };
          }
        }
        var draining;
        var queue = [];
        function nextTick() {
          draining = true;
          var i2, oldQueue;
          var len = queue.length;
          while (len) {
            oldQueue = queue;
            queue = [];
            i2 = -1;
            while (++i2 < len) {
              oldQueue[i2]();
            }
            len = queue.length;
          }
          draining = false;
        }
        module2.exports = immediate;
        function immediate(task) {
          if (queue.push(task) === 1 && !draining) {
            scheduleDrain();
          }
        }
      }).call(this, typeof commonjsGlobal$1 !== "undefined" ? commonjsGlobal$1 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 2: [function(_dereq_, module2, exports2) {
      var immediate = _dereq_(1);
      function INTERNAL() {
      }
      var handlers = {};
      var REJECTED = ["REJECTED"];
      var FULFILLED = ["FULFILLED"];
      var PENDING = ["PENDING"];
      module2.exports = Promise2;
      function Promise2(resolver2) {
        if (typeof resolver2 !== "function") {
          throw new TypeError("resolver must be a function");
        }
        this.state = PENDING;
        this.queue = [];
        this.outcome = void 0;
        if (resolver2 !== INTERNAL) {
          safelyResolveThenable(this, resolver2);
        }
      }
      Promise2.prototype["catch"] = function(onRejected) {
        return this.then(null, onRejected);
      };
      Promise2.prototype.then = function(onFulfilled, onRejected) {
        if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
          return this;
        }
        var promise2 = new this.constructor(INTERNAL);
        if (this.state !== PENDING) {
          var resolver2 = this.state === FULFILLED ? onFulfilled : onRejected;
          unwrap(promise2, resolver2, this.outcome);
        } else {
          this.queue.push(new QueueItem(promise2, onFulfilled, onRejected));
        }
        return promise2;
      };
      function QueueItem(promise2, onFulfilled, onRejected) {
        this.promise = promise2;
        if (typeof onFulfilled === "function") {
          this.onFulfilled = onFulfilled;
          this.callFulfilled = this.otherCallFulfilled;
        }
        if (typeof onRejected === "function") {
          this.onRejected = onRejected;
          this.callRejected = this.otherCallRejected;
        }
      }
      QueueItem.prototype.callFulfilled = function(value) {
        handlers.resolve(this.promise, value);
      };
      QueueItem.prototype.otherCallFulfilled = function(value) {
        unwrap(this.promise, this.onFulfilled, value);
      };
      QueueItem.prototype.callRejected = function(value) {
        handlers.reject(this.promise, value);
      };
      QueueItem.prototype.otherCallRejected = function(value) {
        unwrap(this.promise, this.onRejected, value);
      };
      function unwrap(promise2, func, value) {
        immediate(function() {
          var returnValue;
          try {
            returnValue = func(value);
          } catch (e2) {
            return handlers.reject(promise2, e2);
          }
          if (returnValue === promise2) {
            handlers.reject(promise2, new TypeError("Cannot resolve promise with itself"));
          } else {
            handlers.resolve(promise2, returnValue);
          }
        });
      }
      handlers.resolve = function(self2, value) {
        var result = tryCatch(getThen, value);
        if (result.status === "error") {
          return handlers.reject(self2, result.value);
        }
        var thenable = result.value;
        if (thenable) {
          safelyResolveThenable(self2, thenable);
        } else {
          self2.state = FULFILLED;
          self2.outcome = value;
          var i2 = -1;
          var len = self2.queue.length;
          while (++i2 < len) {
            self2.queue[i2].callFulfilled(value);
          }
        }
        return self2;
      };
      handlers.reject = function(self2, error2) {
        self2.state = REJECTED;
        self2.outcome = error2;
        var i2 = -1;
        var len = self2.queue.length;
        while (++i2 < len) {
          self2.queue[i2].callRejected(error2);
        }
        return self2;
      };
      function getThen(obj) {
        var then = obj && obj.then;
        if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
          return function appyThen() {
            then.apply(obj, arguments);
          };
        }
      }
      function safelyResolveThenable(self2, thenable) {
        var called = false;
        function onError(value) {
          if (called) {
            return;
          }
          called = true;
          handlers.reject(self2, value);
        }
        function onSuccess(value) {
          if (called) {
            return;
          }
          called = true;
          handlers.resolve(self2, value);
        }
        function tryToUnwrap() {
          thenable(onSuccess, onError);
        }
        var result = tryCatch(tryToUnwrap);
        if (result.status === "error") {
          onError(result.value);
        }
      }
      function tryCatch(func, value) {
        var out = {};
        try {
          out.value = func(value);
          out.status = "success";
        } catch (e2) {
          out.status = "error";
          out.value = e2;
        }
        return out;
      }
      Promise2.resolve = resolve2;
      function resolve2(value) {
        if (value instanceof this) {
          return value;
        }
        return handlers.resolve(new this(INTERNAL), value);
      }
      Promise2.reject = reject2;
      function reject2(reason) {
        var promise2 = new this(INTERNAL);
        return handlers.reject(promise2, reason);
      }
      Promise2.all = all3;
      function all3(iterable) {
        var self2 = this;
        if (Object.prototype.toString.call(iterable) !== "[object Array]") {
          return this.reject(new TypeError("must be an array"));
        }
        var len = iterable.length;
        var called = false;
        if (!len) {
          return this.resolve([]);
        }
        var values = new Array(len);
        var resolved = 0;
        var i2 = -1;
        var promise2 = new this(INTERNAL);
        while (++i2 < len) {
          allResolver(iterable[i2], i2);
        }
        return promise2;
        function allResolver(value, i3) {
          self2.resolve(value).then(resolveFromAll, function(error2) {
            if (!called) {
              called = true;
              handlers.reject(promise2, error2);
            }
          });
          function resolveFromAll(outValue) {
            values[i3] = outValue;
            if (++resolved === len && !called) {
              called = true;
              handlers.resolve(promise2, values);
            }
          }
        }
      }
      Promise2.race = race;
      function race(iterable) {
        var self2 = this;
        if (Object.prototype.toString.call(iterable) !== "[object Array]") {
          return this.reject(new TypeError("must be an array"));
        }
        var len = iterable.length;
        var called = false;
        if (!len) {
          return this.resolve([]);
        }
        var i2 = -1;
        var promise2 = new this(INTERNAL);
        while (++i2 < len) {
          resolver2(iterable[i2]);
        }
        return promise2;
        function resolver2(value) {
          self2.resolve(value).then(function(response) {
            if (!called) {
              called = true;
              handlers.resolve(promise2, response);
            }
          }, function(error2) {
            if (!called) {
              called = true;
              handlers.reject(promise2, error2);
            }
          });
        }
      }
    }, { "1": 1 }], 3: [function(_dereq_, module2, exports2) {
      (function(global2) {
        if (typeof global2.Promise !== "function") {
          global2.Promise = _dereq_(2);
        }
      }).call(this, typeof commonjsGlobal$1 !== "undefined" ? commonjsGlobal$1 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "2": 2 }], 4: [function(_dereq_, module2, exports2) {
      var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      function _classCallCheck2(instance2, Constructor) {
        if (!(instance2 instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function getIDB() {
        try {
          if (typeof indexedDB !== "undefined") {
            return indexedDB;
          }
          if (typeof webkitIndexedDB !== "undefined") {
            return webkitIndexedDB;
          }
          if (typeof mozIndexedDB !== "undefined") {
            return mozIndexedDB;
          }
          if (typeof OIndexedDB !== "undefined") {
            return OIndexedDB;
          }
          if (typeof msIndexedDB !== "undefined") {
            return msIndexedDB;
          }
        } catch (e2) {
          return;
        }
      }
      var idb = getIDB();
      function isIndexedDBValid() {
        try {
          if (!idb || !idb.open) {
            return false;
          }
          var isSafari2 = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
          var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
          return (!isSafari2 || hasFetch) && typeof indexedDB !== "undefined" && // some outdated implementations of IDB that appear on Samsung
          // and HTC Android devices <4.4 are missing IDBKeyRange
          // See: https://github.com/mozilla/localForage/issues/128
          // See: https://github.com/mozilla/localForage/issues/272
          typeof IDBKeyRange !== "undefined";
        } catch (e2) {
          return false;
        }
      }
      function createBlob(parts, properties) {
        parts = parts || [];
        properties = properties || {};
        try {
          return new Blob(parts, properties);
        } catch (e2) {
          if (e2.name !== "TypeError") {
            throw e2;
          }
          var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
          var builder = new Builder();
          for (var i2 = 0; i2 < parts.length; i2 += 1) {
            builder.append(parts[i2]);
          }
          return builder.getBlob(properties.type);
        }
      }
      if (typeof Promise === "undefined") {
        _dereq_(3);
      }
      var Promise$12 = Promise;
      function executeCallback(promise2, callback) {
        if (callback) {
          promise2.then(function(result) {
            callback(null, result);
          }, function(error2) {
            callback(error2);
          });
        }
      }
      function executeTwoCallbacks(promise2, callback, errorCallback) {
        if (typeof callback === "function") {
          promise2.then(callback);
        }
        if (typeof errorCallback === "function") {
          promise2["catch"](errorCallback);
        }
      }
      function normalizeKey(key2) {
        if (typeof key2 !== "string") {
          console.warn(key2 + " used as a key, but it is not a string.");
          key2 = String(key2);
        }
        return key2;
      }
      function getCallback() {
        if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
          return arguments[arguments.length - 1];
        }
      }
      var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
      var supportsBlobs = void 0;
      var dbContexts = {};
      var toString3 = Object.prototype.toString;
      var READ_ONLY = "readonly";
      var READ_WRITE = "readwrite";
      function _binStringToArrayBuffer(bin) {
        var length3 = bin.length;
        var buf = new ArrayBuffer(length3);
        var arr = new Uint8Array(buf);
        for (var i2 = 0; i2 < length3; i2++) {
          arr[i2] = bin.charCodeAt(i2);
        }
        return buf;
      }
      function _checkBlobSupportWithoutCaching(idb2) {
        return new Promise$12(function(resolve2) {
          var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
          var blob = createBlob([""]);
          txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key");
          txn.onabort = function(e2) {
            e2.preventDefault();
            e2.stopPropagation();
            resolve2(false);
          };
          txn.oncomplete = function() {
            var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
            var matchedEdge = navigator.userAgent.match(/Edge\//);
            resolve2(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
          };
        })["catch"](function() {
          return false;
        });
      }
      function _checkBlobSupport(idb2) {
        if (typeof supportsBlobs === "boolean") {
          return Promise$12.resolve(supportsBlobs);
        }
        return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
          supportsBlobs = value;
          return supportsBlobs;
        });
      }
      function _deferReadiness(dbInfo) {
        var dbContext = dbContexts[dbInfo.name];
        var deferredOperation = {};
        deferredOperation.promise = new Promise$12(function(resolve2, reject2) {
          deferredOperation.resolve = resolve2;
          deferredOperation.reject = reject2;
        });
        dbContext.deferredOperations.push(deferredOperation);
        if (!dbContext.dbReady) {
          dbContext.dbReady = deferredOperation.promise;
        } else {
          dbContext.dbReady = dbContext.dbReady.then(function() {
            return deferredOperation.promise;
          });
        }
      }
      function _advanceReadiness(dbInfo) {
        var dbContext = dbContexts[dbInfo.name];
        var deferredOperation = dbContext.deferredOperations.pop();
        if (deferredOperation) {
          deferredOperation.resolve();
          return deferredOperation.promise;
        }
      }
      function _rejectReadiness(dbInfo, err) {
        var dbContext = dbContexts[dbInfo.name];
        var deferredOperation = dbContext.deferredOperations.pop();
        if (deferredOperation) {
          deferredOperation.reject(err);
          return deferredOperation.promise;
        }
      }
      function _getConnection(dbInfo, upgradeNeeded) {
        return new Promise$12(function(resolve2, reject2) {
          dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
          if (dbInfo.db) {
            if (upgradeNeeded) {
              _deferReadiness(dbInfo);
              dbInfo.db.close();
            } else {
              return resolve2(dbInfo.db);
            }
          }
          var dbArgs = [dbInfo.name];
          if (upgradeNeeded) {
            dbArgs.push(dbInfo.version);
          }
          var openreq = idb.open.apply(idb, dbArgs);
          if (upgradeNeeded) {
            openreq.onupgradeneeded = function(e2) {
              var db2 = openreq.result;
              try {
                db2.createObjectStore(dbInfo.storeName);
                if (e2.oldVersion <= 1) {
                  db2.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                }
              } catch (ex) {
                if (ex.name === "ConstraintError") {
                  console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e2.oldVersion + " to version " + e2.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                } else {
                  throw ex;
                }
              }
            };
          }
          openreq.onerror = function(e2) {
            e2.preventDefault();
            reject2(openreq.error);
          };
          openreq.onsuccess = function() {
            var db2 = openreq.result;
            db2.onversionchange = function(e2) {
              e2.target.close();
            };
            resolve2(db2);
            _advanceReadiness(dbInfo);
          };
        });
      }
      function _getOriginalConnection(dbInfo) {
        return _getConnection(dbInfo, false);
      }
      function _getUpgradedConnection(dbInfo) {
        return _getConnection(dbInfo, true);
      }
      function _isUpgradeNeeded(dbInfo, defaultVersion) {
        if (!dbInfo.db) {
          return true;
        }
        var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
        var isDowngrade = dbInfo.version < dbInfo.db.version;
        var isUpgrade = dbInfo.version > dbInfo.db.version;
        if (isDowngrade) {
          if (dbInfo.version !== defaultVersion) {
            console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
          }
          dbInfo.version = dbInfo.db.version;
        }
        if (isUpgrade || isNewStore) {
          if (isNewStore) {
            var incVersion = dbInfo.db.version + 1;
            if (incVersion > dbInfo.version) {
              dbInfo.version = incVersion;
            }
          }
          return true;
        }
        return false;
      }
      function _encodeBlob(blob) {
        return new Promise$12(function(resolve2, reject2) {
          var reader = new FileReader();
          reader.onerror = reject2;
          reader.onloadend = function(e2) {
            var base64 = btoa(e2.target.result || "");
            resolve2({
              __local_forage_encoded_blob: true,
              data: base64,
              type: blob.type
            });
          };
          reader.readAsBinaryString(blob);
        });
      }
      function _decodeBlob(encodedBlob) {
        var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
        return createBlob([arrayBuff], { type: encodedBlob.type });
      }
      function _isEncodedBlob(value) {
        return value && value.__local_forage_encoded_blob;
      }
      function _fullyReady(callback) {
        var self2 = this;
        var promise2 = self2._initReady().then(function() {
          var dbContext = dbContexts[self2._dbInfo.name];
          if (dbContext && dbContext.dbReady) {
            return dbContext.dbReady;
          }
        });
        executeTwoCallbacks(promise2, callback, callback);
        return promise2;
      }
      function _tryReconnect(dbInfo) {
        _deferReadiness(dbInfo);
        var dbContext = dbContexts[dbInfo.name];
        var forages = dbContext.forages;
        for (var i2 = 0; i2 < forages.length; i2++) {
          var forage = forages[i2];
          if (forage._dbInfo.db) {
            forage._dbInfo.db.close();
            forage._dbInfo.db = null;
          }
        }
        dbInfo.db = null;
        return _getOriginalConnection(dbInfo).then(function(db2) {
          dbInfo.db = db2;
          if (_isUpgradeNeeded(dbInfo)) {
            return _getUpgradedConnection(dbInfo);
          }
          return db2;
        }).then(function(db2) {
          dbInfo.db = dbContext.db = db2;
          for (var i3 = 0; i3 < forages.length; i3++) {
            forages[i3]._dbInfo.db = db2;
          }
        })["catch"](function(err) {
          _rejectReadiness(dbInfo, err);
          throw err;
        });
      }
      function createTransaction(dbInfo, mode, callback, retries) {
        if (retries === void 0) {
          retries = 1;
        }
        try {
          var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
          callback(null, tx);
        } catch (err) {
          if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
            return Promise$12.resolve().then(function() {
              if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                if (dbInfo.db) {
                  dbInfo.version = dbInfo.db.version + 1;
                }
                return _getUpgradedConnection(dbInfo);
              }
            }).then(function() {
              return _tryReconnect(dbInfo).then(function() {
                createTransaction(dbInfo, mode, callback, retries - 1);
              });
            })["catch"](callback);
          }
          callback(err);
        }
      }
      function createDbContext() {
        return {
          // Running localForages sharing a database.
          forages: [],
          // Shared database.
          db: null,
          // Database readiness (promise).
          dbReady: null,
          // Deferred operations on the database.
          deferredOperations: []
        };
      }
      function _initStorage(options) {
        var self2 = this;
        var dbInfo = {
          db: null
        };
        if (options) {
          for (var i2 in options) {
            dbInfo[i2] = options[i2];
          }
        }
        var dbContext = dbContexts[dbInfo.name];
        if (!dbContext) {
          dbContext = createDbContext();
          dbContexts[dbInfo.name] = dbContext;
        }
        dbContext.forages.push(self2);
        if (!self2._initReady) {
          self2._initReady = self2.ready;
          self2.ready = _fullyReady;
        }
        var initPromises = [];
        function ignoreErrors() {
          return Promise$12.resolve();
        }
        for (var j2 = 0; j2 < dbContext.forages.length; j2++) {
          var forage = dbContext.forages[j2];
          if (forage !== self2) {
            initPromises.push(forage._initReady()["catch"](ignoreErrors));
          }
        }
        var forages = dbContext.forages.slice(0);
        return Promise$12.all(initPromises).then(function() {
          dbInfo.db = dbContext.db;
          return _getOriginalConnection(dbInfo);
        }).then(function(db2) {
          dbInfo.db = db2;
          if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
            return _getUpgradedConnection(dbInfo);
          }
          return db2;
        }).then(function(db2) {
          dbInfo.db = dbContext.db = db2;
          self2._dbInfo = dbInfo;
          for (var k2 = 0; k2 < forages.length; k2++) {
            var forage2 = forages[k2];
            if (forage2 !== self2) {
              forage2._dbInfo.db = dbInfo.db;
              forage2._dbInfo.version = dbInfo.version;
            }
          }
        });
      }
      function getItem(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise2 = new Promise$12(function(resolve2, reject2) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject2(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req2 = store.get(key2);
                req2.onsuccess = function() {
                  var value = req2.result;
                  if (value === void 0) {
                    value = null;
                  }
                  if (_isEncodedBlob(value)) {
                    value = _decodeBlob(value);
                  }
                  resolve2(value);
                };
                req2.onerror = function() {
                  reject2(req2.error);
                };
              } catch (e2) {
                reject2(e2);
              }
            });
          })["catch"](reject2);
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function iterate(iterator, callback) {
        var self2 = this;
        var promise2 = new Promise$12(function(resolve2, reject2) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject2(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req2 = store.openCursor();
                var iterationNumber = 1;
                req2.onsuccess = function() {
                  var cursor2 = req2.result;
                  if (cursor2) {
                    var value = cursor2.value;
                    if (_isEncodedBlob(value)) {
                      value = _decodeBlob(value);
                    }
                    var result = iterator(value, cursor2.key, iterationNumber++);
                    if (result !== void 0) {
                      resolve2(result);
                    } else {
                      cursor2["continue"]();
                    }
                  } else {
                    resolve2();
                  }
                };
                req2.onerror = function() {
                  reject2(req2.error);
                };
              } catch (e2) {
                reject2(e2);
              }
            });
          })["catch"](reject2);
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function setItem(key2, value, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise2 = new Promise$12(function(resolve2, reject2) {
          var dbInfo;
          self2.ready().then(function() {
            dbInfo = self2._dbInfo;
            if (toString3.call(value) === "[object Blob]") {
              return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                if (blobSupport) {
                  return value;
                }
                return _encodeBlob(value);
              });
            }
            return value;
          }).then(function(value2) {
            createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
              if (err) {
                return reject2(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                if (value2 === null) {
                  value2 = void 0;
                }
                var req2 = store.put(value2, key2);
                transaction.oncomplete = function() {
                  if (value2 === void 0) {
                    value2 = null;
                  }
                  resolve2(value2);
                };
                transaction.onabort = transaction.onerror = function() {
                  var err2 = req2.error ? req2.error : req2.transaction.error;
                  reject2(err2);
                };
              } catch (e2) {
                reject2(e2);
              }
            });
          })["catch"](reject2);
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function removeItem(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise2 = new Promise$12(function(resolve2, reject2) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
              if (err) {
                return reject2(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req2 = store["delete"](key2);
                transaction.oncomplete = function() {
                  resolve2();
                };
                transaction.onerror = function() {
                  reject2(req2.error);
                };
                transaction.onabort = function() {
                  var err2 = req2.error ? req2.error : req2.transaction.error;
                  reject2(err2);
                };
              } catch (e2) {
                reject2(e2);
              }
            });
          })["catch"](reject2);
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function clear2(callback) {
        var self2 = this;
        var promise2 = new Promise$12(function(resolve2, reject2) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
              if (err) {
                return reject2(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req2 = store.clear();
                transaction.oncomplete = function() {
                  resolve2();
                };
                transaction.onabort = transaction.onerror = function() {
                  var err2 = req2.error ? req2.error : req2.transaction.error;
                  reject2(err2);
                };
              } catch (e2) {
                reject2(e2);
              }
            });
          })["catch"](reject2);
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function length2(callback) {
        var self2 = this;
        var promise2 = new Promise$12(function(resolve2, reject2) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject2(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req2 = store.count();
                req2.onsuccess = function() {
                  resolve2(req2.result);
                };
                req2.onerror = function() {
                  reject2(req2.error);
                };
              } catch (e2) {
                reject2(e2);
              }
            });
          })["catch"](reject2);
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function key(n2, callback) {
        var self2 = this;
        var promise2 = new Promise$12(function(resolve2, reject2) {
          if (n2 < 0) {
            resolve2(null);
            return;
          }
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject2(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var advanced = false;
                var req2 = store.openKeyCursor();
                req2.onsuccess = function() {
                  var cursor2 = req2.result;
                  if (!cursor2) {
                    resolve2(null);
                    return;
                  }
                  if (n2 === 0) {
                    resolve2(cursor2.key);
                  } else {
                    if (!advanced) {
                      advanced = true;
                      cursor2.advance(n2);
                    } else {
                      resolve2(cursor2.key);
                    }
                  }
                };
                req2.onerror = function() {
                  reject2(req2.error);
                };
              } catch (e2) {
                reject2(e2);
              }
            });
          })["catch"](reject2);
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function keys2(callback) {
        var self2 = this;
        var promise2 = new Promise$12(function(resolve2, reject2) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject2(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req2 = store.openKeyCursor();
                var keys3 = [];
                req2.onsuccess = function() {
                  var cursor2 = req2.result;
                  if (!cursor2) {
                    resolve2(keys3);
                    return;
                  }
                  keys3.push(cursor2.key);
                  cursor2["continue"]();
                };
                req2.onerror = function() {
                  reject2(req2.error);
                };
              } catch (e2) {
                reject2(e2);
              }
            });
          })["catch"](reject2);
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function dropInstance(options, callback) {
        callback = getCallback.apply(this, arguments);
        var currentConfig = this.config();
        options = typeof options !== "function" && options || {};
        if (!options.name) {
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }
        var self2 = this;
        var promise2;
        if (!options.name) {
          promise2 = Promise$12.reject("Invalid arguments");
        } else {
          var isCurrentDb = options.name === currentConfig.name && self2._dbInfo.db;
          var dbPromise = isCurrentDb ? Promise$12.resolve(self2._dbInfo.db) : _getOriginalConnection(options).then(function(db2) {
            var dbContext = dbContexts[options.name];
            var forages = dbContext.forages;
            dbContext.db = db2;
            for (var i2 = 0; i2 < forages.length; i2++) {
              forages[i2]._dbInfo.db = db2;
            }
            return db2;
          });
          if (!options.storeName) {
            promise2 = dbPromise.then(function(db2) {
              _deferReadiness(options);
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              db2.close();
              for (var i2 = 0; i2 < forages.length; i2++) {
                var forage = forages[i2];
                forage._dbInfo.db = null;
              }
              var dropDBPromise = new Promise$12(function(resolve2, reject2) {
                var req2 = idb.deleteDatabase(options.name);
                req2.onerror = function() {
                  var db3 = req2.result;
                  if (db3) {
                    db3.close();
                  }
                  reject2(req2.error);
                };
                req2.onblocked = function() {
                  console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                };
                req2.onsuccess = function() {
                  var db3 = req2.result;
                  if (db3) {
                    db3.close();
                  }
                  resolve2(db3);
                };
              });
              return dropDBPromise.then(function(db3) {
                dbContext.db = db3;
                for (var i3 = 0; i3 < forages.length; i3++) {
                  var _forage = forages[i3];
                  _advanceReadiness(_forage._dbInfo);
                }
              })["catch"](function(err) {
                (_rejectReadiness(options, err) || Promise$12.resolve())["catch"](function() {
                });
                throw err;
              });
            });
          } else {
            promise2 = dbPromise.then(function(db2) {
              if (!db2.objectStoreNames.contains(options.storeName)) {
                return;
              }
              var newVersion = db2.version + 1;
              _deferReadiness(options);
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              db2.close();
              for (var i2 = 0; i2 < forages.length; i2++) {
                var forage = forages[i2];
                forage._dbInfo.db = null;
                forage._dbInfo.version = newVersion;
              }
              var dropObjectPromise = new Promise$12(function(resolve2, reject2) {
                var req2 = idb.open(options.name, newVersion);
                req2.onerror = function(err) {
                  var db3 = req2.result;
                  db3.close();
                  reject2(err);
                };
                req2.onupgradeneeded = function() {
                  var db3 = req2.result;
                  db3.deleteObjectStore(options.storeName);
                };
                req2.onsuccess = function() {
                  var db3 = req2.result;
                  db3.close();
                  resolve2(db3);
                };
              });
              return dropObjectPromise.then(function(db3) {
                dbContext.db = db3;
                for (var j2 = 0; j2 < forages.length; j2++) {
                  var _forage2 = forages[j2];
                  _forage2._dbInfo.db = db3;
                  _advanceReadiness(_forage2._dbInfo);
                }
              })["catch"](function(err) {
                (_rejectReadiness(options, err) || Promise$12.resolve())["catch"](function() {
                });
                throw err;
              });
            });
          }
        }
        executeCallback(promise2, callback);
        return promise2;
      }
      var asyncStorage = {
        _driver: "asyncStorage",
        _initStorage,
        _support: isIndexedDBValid(),
        iterate,
        getItem,
        setItem,
        removeItem,
        clear: clear2,
        length: length2,
        key,
        keys: keys2,
        dropInstance
      };
      function isWebSQLValid() {
        return typeof openDatabase === "function";
      }
      var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var BLOB_TYPE_PREFIX = "~~local_forage_type~";
      var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
      var SERIALIZED_MARKER = "__lfsc__:";
      var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
      var TYPE_ARRAYBUFFER = "arbf";
      var TYPE_BLOB = "blob";
      var TYPE_INT8ARRAY = "si08";
      var TYPE_UINT8ARRAY = "ui08";
      var TYPE_UINT8CLAMPEDARRAY = "uic8";
      var TYPE_INT16ARRAY = "si16";
      var TYPE_INT32ARRAY = "si32";
      var TYPE_UINT16ARRAY = "ur16";
      var TYPE_UINT32ARRAY = "ui32";
      var TYPE_FLOAT32ARRAY = "fl32";
      var TYPE_FLOAT64ARRAY = "fl64";
      var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
      var toString$12 = Object.prototype.toString;
      function stringToBuffer(serializedString) {
        var bufferLength = serializedString.length * 0.75;
        var len = serializedString.length;
        var i2;
        var p = 0;
        var encoded1, encoded2, encoded3, encoded4;
        if (serializedString[serializedString.length - 1] === "=") {
          bufferLength--;
          if (serializedString[serializedString.length - 2] === "=") {
            bufferLength--;
          }
        }
        var buffer = new ArrayBuffer(bufferLength);
        var bytes = new Uint8Array(buffer);
        for (i2 = 0; i2 < len; i2 += 4) {
          encoded1 = BASE_CHARS.indexOf(serializedString[i2]);
          encoded2 = BASE_CHARS.indexOf(serializedString[i2 + 1]);
          encoded3 = BASE_CHARS.indexOf(serializedString[i2 + 2]);
          encoded4 = BASE_CHARS.indexOf(serializedString[i2 + 3]);
          bytes[p++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
          bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
        }
        return buffer;
      }
      function bufferToString(buffer) {
        var bytes = new Uint8Array(buffer);
        var base64String = "";
        var i2;
        for (i2 = 0; i2 < bytes.length; i2 += 3) {
          base64String += BASE_CHARS[bytes[i2] >> 2];
          base64String += BASE_CHARS[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
          base64String += BASE_CHARS[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
          base64String += BASE_CHARS[bytes[i2 + 2] & 63];
        }
        if (bytes.length % 3 === 2) {
          base64String = base64String.substring(0, base64String.length - 1) + "=";
        } else if (bytes.length % 3 === 1) {
          base64String = base64String.substring(0, base64String.length - 2) + "==";
        }
        return base64String;
      }
      function serialize2(value, callback) {
        var valueType = "";
        if (value) {
          valueType = toString$12.call(value);
        }
        if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$12.call(value.buffer) === "[object ArrayBuffer]")) {
          var buffer;
          var marker = SERIALIZED_MARKER;
          if (value instanceof ArrayBuffer) {
            buffer = value;
            marker += TYPE_ARRAYBUFFER;
          } else {
            buffer = value.buffer;
            if (valueType === "[object Int8Array]") {
              marker += TYPE_INT8ARRAY;
            } else if (valueType === "[object Uint8Array]") {
              marker += TYPE_UINT8ARRAY;
            } else if (valueType === "[object Uint8ClampedArray]") {
              marker += TYPE_UINT8CLAMPEDARRAY;
            } else if (valueType === "[object Int16Array]") {
              marker += TYPE_INT16ARRAY;
            } else if (valueType === "[object Uint16Array]") {
              marker += TYPE_UINT16ARRAY;
            } else if (valueType === "[object Int32Array]") {
              marker += TYPE_INT32ARRAY;
            } else if (valueType === "[object Uint32Array]") {
              marker += TYPE_UINT32ARRAY;
            } else if (valueType === "[object Float32Array]") {
              marker += TYPE_FLOAT32ARRAY;
            } else if (valueType === "[object Float64Array]") {
              marker += TYPE_FLOAT64ARRAY;
            } else {
              callback(new Error("Failed to get type for BinaryArray"));
            }
          }
          callback(marker + bufferToString(buffer));
        } else if (valueType === "[object Blob]") {
          var fileReader = new FileReader();
          fileReader.onload = function() {
            var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
            callback(SERIALIZED_MARKER + TYPE_BLOB + str);
          };
          fileReader.readAsArrayBuffer(value);
        } else {
          try {
            callback(JSON.stringify(value));
          } catch (e2) {
            console.error("Couldn't convert value into a JSON string: ", value);
            callback(null, e2);
          }
        }
      }
      function deserialize(value) {
        if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
          return JSON.parse(value);
        }
        var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
        var type2 = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
        var blobType;
        if (type2 === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
          var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
          blobType = matcher[1];
          serializedString = serializedString.substring(matcher[0].length);
        }
        var buffer = stringToBuffer(serializedString);
        switch (type2) {
          case TYPE_ARRAYBUFFER:
            return buffer;
          case TYPE_BLOB:
            return createBlob([buffer], { type: blobType });
          case TYPE_INT8ARRAY:
            return new Int8Array(buffer);
          case TYPE_UINT8ARRAY:
            return new Uint8Array(buffer);
          case TYPE_UINT8CLAMPEDARRAY:
            return new Uint8ClampedArray(buffer);
          case TYPE_INT16ARRAY:
            return new Int16Array(buffer);
          case TYPE_UINT16ARRAY:
            return new Uint16Array(buffer);
          case TYPE_INT32ARRAY:
            return new Int32Array(buffer);
          case TYPE_UINT32ARRAY:
            return new Uint32Array(buffer);
          case TYPE_FLOAT32ARRAY:
            return new Float32Array(buffer);
          case TYPE_FLOAT64ARRAY:
            return new Float64Array(buffer);
          default:
            throw new Error("Unkown type: " + type2);
        }
      }
      var localforageSerializer = {
        serialize: serialize2,
        deserialize,
        stringToBuffer,
        bufferToString
      };
      function createDbTable(t2, dbInfo, callback, errorCallback) {
        t2.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
      }
      function _initStorage$1(options) {
        var self2 = this;
        var dbInfo = {
          db: null
        };
        if (options) {
          for (var i2 in options) {
            dbInfo[i2] = typeof options[i2] !== "string" ? options[i2].toString() : options[i2];
          }
        }
        var dbInfoPromise = new Promise$12(function(resolve2, reject2) {
          try {
            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
          } catch (e2) {
            return reject2(e2);
          }
          dbInfo.db.transaction(function(t2) {
            createDbTable(t2, dbInfo, function() {
              self2._dbInfo = dbInfo;
              resolve2();
            }, function(t3, error2) {
              reject2(error2);
            });
          }, reject2);
        });
        dbInfo.serializer = localforageSerializer;
        return dbInfoPromise;
      }
      function tryExecuteSql(t2, dbInfo, sqlStatement, args, callback, errorCallback) {
        t2.executeSql(sqlStatement, args, callback, function(t3, error2) {
          if (error2.code === error2.SYNTAX_ERR) {
            t3.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [dbInfo.storeName], function(t4, results) {
              if (!results.rows.length) {
                createDbTable(t4, dbInfo, function() {
                  t4.executeSql(sqlStatement, args, callback, errorCallback);
                }, errorCallback);
              } else {
                errorCallback(t4, error2);
              }
            }, errorCallback);
          } else {
            errorCallback(t3, error2);
          }
        }, errorCallback);
      }
      function getItem$1(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise2 = new Promise$12(function(resolve2, reject2) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t2) {
              tryExecuteSql(t2, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [key2], function(t3, results) {
                var result = results.rows.length ? results.rows.item(0).value : null;
                if (result) {
                  result = dbInfo.serializer.deserialize(result);
                }
                resolve2(result);
              }, function(t3, error2) {
                reject2(error2);
              });
            });
          })["catch"](reject2);
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function iterate$1(iterator, callback) {
        var self2 = this;
        var promise2 = new Promise$12(function(resolve2, reject2) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t2) {
              tryExecuteSql(t2, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t3, results) {
                var rows = results.rows;
                var length3 = rows.length;
                for (var i2 = 0; i2 < length3; i2++) {
                  var item = rows.item(i2);
                  var result = item.value;
                  if (result) {
                    result = dbInfo.serializer.deserialize(result);
                  }
                  result = iterator(result, item.key, i2 + 1);
                  if (result !== void 0) {
                    resolve2(result);
                    return;
                  }
                }
                resolve2();
              }, function(t3, error2) {
                reject2(error2);
              });
            });
          })["catch"](reject2);
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function _setItem(key2, value, callback, retriesLeft) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise2 = new Promise$12(function(resolve2, reject2) {
          self2.ready().then(function() {
            if (value === void 0) {
              value = null;
            }
            var originalValue = value;
            var dbInfo = self2._dbInfo;
            dbInfo.serializer.serialize(value, function(value2, error2) {
              if (error2) {
                reject2(error2);
              } else {
                dbInfo.db.transaction(function(t2) {
                  tryExecuteSql(t2, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [key2, value2], function() {
                    resolve2(originalValue);
                  }, function(t3, error3) {
                    reject2(error3);
                  });
                }, function(sqlError) {
                  if (sqlError.code === sqlError.QUOTA_ERR) {
                    if (retriesLeft > 0) {
                      resolve2(_setItem.apply(self2, [key2, originalValue, callback, retriesLeft - 1]));
                      return;
                    }
                    reject2(sqlError);
                  }
                });
              }
            });
          })["catch"](reject2);
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function setItem$1(key2, value, callback) {
        return _setItem.apply(this, [key2, value, callback, 1]);
      }
      function removeItem$1(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise2 = new Promise$12(function(resolve2, reject2) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t2) {
              tryExecuteSql(t2, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [key2], function() {
                resolve2();
              }, function(t3, error2) {
                reject2(error2);
              });
            });
          })["catch"](reject2);
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function clear$1(callback) {
        var self2 = this;
        var promise2 = new Promise$12(function(resolve2, reject2) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t2) {
              tryExecuteSql(t2, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                resolve2();
              }, function(t3, error2) {
                reject2(error2);
              });
            });
          })["catch"](reject2);
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function length$1(callback) {
        var self2 = this;
        var promise2 = new Promise$12(function(resolve2, reject2) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t2) {
              tryExecuteSql(t2, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t3, results) {
                var result = results.rows.item(0).c;
                resolve2(result);
              }, function(t3, error2) {
                reject2(error2);
              });
            });
          })["catch"](reject2);
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function key$1(n2, callback) {
        var self2 = this;
        var promise2 = new Promise$12(function(resolve2, reject2) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t2) {
              tryExecuteSql(t2, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [n2 + 1], function(t3, results) {
                var result = results.rows.length ? results.rows.item(0).key : null;
                resolve2(result);
              }, function(t3, error2) {
                reject2(error2);
              });
            });
          })["catch"](reject2);
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function keys$12(callback) {
        var self2 = this;
        var promise2 = new Promise$12(function(resolve2, reject2) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t2) {
              tryExecuteSql(t2, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t3, results) {
                var keys3 = [];
                for (var i2 = 0; i2 < results.rows.length; i2++) {
                  keys3.push(results.rows.item(i2).key);
                }
                resolve2(keys3);
              }, function(t3, error2) {
                reject2(error2);
              });
            });
          })["catch"](reject2);
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function getAllStoreNames(db2) {
        return new Promise$12(function(resolve2, reject2) {
          db2.transaction(function(t2) {
            t2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t3, results) {
              var storeNames = [];
              for (var i2 = 0; i2 < results.rows.length; i2++) {
                storeNames.push(results.rows.item(i2).name);
              }
              resolve2({
                db: db2,
                storeNames
              });
            }, function(t3, error2) {
              reject2(error2);
            });
          }, function(sqlError) {
            reject2(sqlError);
          });
        });
      }
      function dropInstance$1(options, callback) {
        callback = getCallback.apply(this, arguments);
        var currentConfig = this.config();
        options = typeof options !== "function" && options || {};
        if (!options.name) {
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }
        var self2 = this;
        var promise2;
        if (!options.name) {
          promise2 = Promise$12.reject("Invalid arguments");
        } else {
          promise2 = new Promise$12(function(resolve2) {
            var db2;
            if (options.name === currentConfig.name) {
              db2 = self2._dbInfo.db;
            } else {
              db2 = openDatabase(options.name, "", "", 0);
            }
            if (!options.storeName) {
              resolve2(getAllStoreNames(db2));
            } else {
              resolve2({
                db: db2,
                storeNames: [options.storeName]
              });
            }
          }).then(function(operationInfo) {
            return new Promise$12(function(resolve2, reject2) {
              operationInfo.db.transaction(function(t2) {
                function dropTable(storeName) {
                  return new Promise$12(function(resolve3, reject3) {
                    t2.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                      resolve3();
                    }, function(t3, error2) {
                      reject3(error2);
                    });
                  });
                }
                var operations = [];
                for (var i2 = 0, len = operationInfo.storeNames.length; i2 < len; i2++) {
                  operations.push(dropTable(operationInfo.storeNames[i2]));
                }
                Promise$12.all(operations).then(function() {
                  resolve2();
                })["catch"](function(e2) {
                  reject2(e2);
                });
              }, function(sqlError) {
                reject2(sqlError);
              });
            });
          });
        }
        executeCallback(promise2, callback);
        return promise2;
      }
      var webSQLStorage = {
        _driver: "webSQLStorage",
        _initStorage: _initStorage$1,
        _support: isWebSQLValid(),
        iterate: iterate$1,
        getItem: getItem$1,
        setItem: setItem$1,
        removeItem: removeItem$1,
        clear: clear$1,
        length: length$1,
        key: key$1,
        keys: keys$12,
        dropInstance: dropInstance$1
      };
      function isLocalStorageValid() {
        try {
          return typeof localStorage !== "undefined" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
          !!localStorage.setItem;
        } catch (e2) {
          return false;
        }
      }
      function _getKeyPrefix(options, defaultConfig) {
        var keyPrefix = options.name + "/";
        if (options.storeName !== defaultConfig.storeName) {
          keyPrefix += options.storeName + "/";
        }
        return keyPrefix;
      }
      function checkIfLocalStorageThrows() {
        var localStorageTestKey = "_localforage_support_test";
        try {
          localStorage.setItem(localStorageTestKey, true);
          localStorage.removeItem(localStorageTestKey);
          return false;
        } catch (e2) {
          return true;
        }
      }
      function _isLocalStorageUsable() {
        return !checkIfLocalStorageThrows() || localStorage.length > 0;
      }
      function _initStorage$2(options) {
        var self2 = this;
        var dbInfo = {};
        if (options) {
          for (var i2 in options) {
            dbInfo[i2] = options[i2];
          }
        }
        dbInfo.keyPrefix = _getKeyPrefix(options, self2._defaultConfig);
        if (!_isLocalStorageUsable()) {
          return Promise$12.reject();
        }
        self2._dbInfo = dbInfo;
        dbInfo.serializer = localforageSerializer;
        return Promise$12.resolve();
      }
      function clear$2(callback) {
        var self2 = this;
        var promise2 = self2.ready().then(function() {
          var keyPrefix = self2._dbInfo.keyPrefix;
          for (var i2 = localStorage.length - 1; i2 >= 0; i2--) {
            var key2 = localStorage.key(i2);
            if (key2.indexOf(keyPrefix) === 0) {
              localStorage.removeItem(key2);
            }
          }
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function getItem$2(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise2 = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var result = localStorage.getItem(dbInfo.keyPrefix + key2);
          if (result) {
            result = dbInfo.serializer.deserialize(result);
          }
          return result;
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function iterate$2(iterator, callback) {
        var self2 = this;
        var promise2 = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var keyPrefix = dbInfo.keyPrefix;
          var keyPrefixLength = keyPrefix.length;
          var length3 = localStorage.length;
          var iterationNumber = 1;
          for (var i2 = 0; i2 < length3; i2++) {
            var key2 = localStorage.key(i2);
            if (key2.indexOf(keyPrefix) !== 0) {
              continue;
            }
            var value = localStorage.getItem(key2);
            if (value) {
              value = dbInfo.serializer.deserialize(value);
            }
            value = iterator(value, key2.substring(keyPrefixLength), iterationNumber++);
            if (value !== void 0) {
              return value;
            }
          }
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function key$2(n2, callback) {
        var self2 = this;
        var promise2 = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var result;
          try {
            result = localStorage.key(n2);
          } catch (error2) {
            result = null;
          }
          if (result) {
            result = result.substring(dbInfo.keyPrefix.length);
          }
          return result;
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function keys$22(callback) {
        var self2 = this;
        var promise2 = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var length3 = localStorage.length;
          var keys3 = [];
          for (var i2 = 0; i2 < length3; i2++) {
            var itemKey = localStorage.key(i2);
            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
              keys3.push(itemKey.substring(dbInfo.keyPrefix.length));
            }
          }
          return keys3;
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function length$2(callback) {
        var self2 = this;
        var promise2 = self2.keys().then(function(keys3) {
          return keys3.length;
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function removeItem$2(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise2 = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          localStorage.removeItem(dbInfo.keyPrefix + key2);
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function setItem$2(key2, value, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise2 = self2.ready().then(function() {
          if (value === void 0) {
            value = null;
          }
          var originalValue = value;
          return new Promise$12(function(resolve2, reject2) {
            var dbInfo = self2._dbInfo;
            dbInfo.serializer.serialize(value, function(value2, error2) {
              if (error2) {
                reject2(error2);
              } else {
                try {
                  localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                  resolve2(originalValue);
                } catch (e2) {
                  if (e2.name === "QuotaExceededError" || e2.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                    reject2(e2);
                  }
                  reject2(e2);
                }
              }
            });
          });
        });
        executeCallback(promise2, callback);
        return promise2;
      }
      function dropInstance$2(options, callback) {
        callback = getCallback.apply(this, arguments);
        options = typeof options !== "function" && options || {};
        if (!options.name) {
          var currentConfig = this.config();
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }
        var self2 = this;
        var promise2;
        if (!options.name) {
          promise2 = Promise$12.reject("Invalid arguments");
        } else {
          promise2 = new Promise$12(function(resolve2) {
            if (!options.storeName) {
              resolve2(options.name + "/");
            } else {
              resolve2(_getKeyPrefix(options, self2._defaultConfig));
            }
          }).then(function(keyPrefix) {
            for (var i2 = localStorage.length - 1; i2 >= 0; i2--) {
              var key2 = localStorage.key(i2);
              if (key2.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key2);
              }
            }
          });
        }
        executeCallback(promise2, callback);
        return promise2;
      }
      var localStorageWrapper = {
        _driver: "localStorageWrapper",
        _initStorage: _initStorage$2,
        _support: isLocalStorageValid(),
        iterate: iterate$2,
        getItem: getItem$2,
        setItem: setItem$2,
        removeItem: removeItem$2,
        clear: clear$2,
        length: length$2,
        key: key$2,
        keys: keys$22,
        dropInstance: dropInstance$2
      };
      var sameValue = function sameValue2(x, y2) {
        return x === y2 || typeof x === "number" && typeof y2 === "number" && isNaN(x) && isNaN(y2);
      };
      var includes = function includes2(array, searchElement) {
        var len = array.length;
        var i2 = 0;
        while (i2 < len) {
          if (sameValue(array[i2], searchElement)) {
            return true;
          }
          i2++;
        }
        return false;
      };
      var isArray2 = Array.isArray || function(arg) {
        return Object.prototype.toString.call(arg) === "[object Array]";
      };
      var DefinedDrivers = {};
      var DriverSupport = {};
      var DefaultDrivers = {
        INDEXEDDB: asyncStorage,
        WEBSQL: webSQLStorage,
        LOCALSTORAGE: localStorageWrapper
      };
      var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
      var OptionalDriverMethods = ["dropInstance"];
      var LibraryMethods = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(OptionalDriverMethods);
      var DefaultConfig = {
        description: "",
        driver: DefaultDriverOrder.slice(),
        name: "localforage",
        // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
        // we can use without a prompt.
        size: 4980736,
        storeName: "keyvaluepairs",
        version: 1
      };
      function callWhenReady(localForageInstance, libraryMethod) {
        localForageInstance[libraryMethod] = function() {
          var _args = arguments;
          return localForageInstance.ready().then(function() {
            return localForageInstance[libraryMethod].apply(localForageInstance, _args);
          });
        };
      }
      function extend2() {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var arg = arguments[i2];
          if (arg) {
            for (var _key in arg) {
              if (arg.hasOwnProperty(_key)) {
                if (isArray2(arg[_key])) {
                  arguments[0][_key] = arg[_key].slice();
                } else {
                  arguments[0][_key] = arg[_key];
                }
              }
            }
          }
        }
        return arguments[0];
      }
      var LocalForage = function() {
        function LocalForage2(options) {
          _classCallCheck2(this, LocalForage2);
          for (var driverTypeKey in DefaultDrivers) {
            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
              var driver = DefaultDrivers[driverTypeKey];
              var driverName = driver._driver;
              this[driverTypeKey] = driverName;
              if (!DefinedDrivers[driverName]) {
                this.defineDriver(driver);
              }
            }
          }
          this._defaultConfig = extend2({}, DefaultConfig);
          this._config = extend2({}, this._defaultConfig, options);
          this._driverSet = null;
          this._initDriver = null;
          this._ready = false;
          this._dbInfo = null;
          this._wrapLibraryMethodsWithReady();
          this.setDriver(this._config.driver)["catch"](function() {
          });
        }
        LocalForage2.prototype.config = function config(options) {
          if ((typeof options === "undefined" ? "undefined" : _typeof2(options)) === "object") {
            if (this._ready) {
              return new Error("Can't call config() after localforage has been used.");
            }
            for (var i2 in options) {
              if (i2 === "storeName") {
                options[i2] = options[i2].replace(/\W/g, "_");
              }
              if (i2 === "version" && typeof options[i2] !== "number") {
                return new Error("Database version must be a number.");
              }
              this._config[i2] = options[i2];
            }
            if ("driver" in options && options.driver) {
              return this.setDriver(this._config.driver);
            }
            return true;
          } else if (typeof options === "string") {
            return this._config[options];
          } else {
            return this._config;
          }
        };
        LocalForage2.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
          var promise2 = new Promise$12(function(resolve2, reject2) {
            try {
              var driverName = driverObject._driver;
              var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
              if (!driverObject._driver) {
                reject2(complianceError);
                return;
              }
              var driverMethods = LibraryMethods.concat("_initStorage");
              for (var i2 = 0, len = driverMethods.length; i2 < len; i2++) {
                var driverMethodName = driverMethods[i2];
                var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                  reject2(complianceError);
                  return;
                }
              }
              var configureMissingMethods = function configureMissingMethods2() {
                var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                  return function() {
                    var error2 = new Error("Method " + methodName + " is not implemented by the current driver");
                    var promise3 = Promise$12.reject(error2);
                    executeCallback(promise3, arguments[arguments.length - 1]);
                    return promise3;
                  };
                };
                for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                  var optionalDriverMethod = OptionalDriverMethods[_i];
                  if (!driverObject[optionalDriverMethod]) {
                    driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                  }
                }
              };
              configureMissingMethods();
              var setDriverSupport = function setDriverSupport2(support) {
                if (DefinedDrivers[driverName]) {
                  console.info("Redefining LocalForage driver: " + driverName);
                }
                DefinedDrivers[driverName] = driverObject;
                DriverSupport[driverName] = support;
                resolve2();
              };
              if ("_support" in driverObject) {
                if (driverObject._support && typeof driverObject._support === "function") {
                  driverObject._support().then(setDriverSupport, reject2);
                } else {
                  setDriverSupport(!!driverObject._support);
                }
              } else {
                setDriverSupport(true);
              }
            } catch (e2) {
              reject2(e2);
            }
          });
          executeTwoCallbacks(promise2, callback, errorCallback);
          return promise2;
        };
        LocalForage2.prototype.driver = function driver() {
          return this._driver || null;
        };
        LocalForage2.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
          var getDriverPromise = DefinedDrivers[driverName] ? Promise$12.resolve(DefinedDrivers[driverName]) : Promise$12.reject(new Error("Driver not found."));
          executeTwoCallbacks(getDriverPromise, callback, errorCallback);
          return getDriverPromise;
        };
        LocalForage2.prototype.getSerializer = function getSerializer(callback) {
          var serializerPromise = Promise$12.resolve(localforageSerializer);
          executeTwoCallbacks(serializerPromise, callback);
          return serializerPromise;
        };
        LocalForage2.prototype.ready = function ready(callback) {
          var self2 = this;
          var promise2 = self2._driverSet.then(function() {
            if (self2._ready === null) {
              self2._ready = self2._initDriver();
            }
            return self2._ready;
          });
          executeTwoCallbacks(promise2, callback, callback);
          return promise2;
        };
        LocalForage2.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
          var self2 = this;
          if (!isArray2(drivers)) {
            drivers = [drivers];
          }
          var supportedDrivers = this._getSupportedDrivers(drivers);
          function setDriverToConfig() {
            self2._config.driver = self2.driver();
          }
          function extendSelfWithDriver(driver) {
            self2._extend(driver);
            setDriverToConfig();
            self2._ready = self2._initStorage(self2._config);
            return self2._ready;
          }
          function initDriver(supportedDrivers2) {
            return function() {
              var currentDriverIndex = 0;
              function driverPromiseLoop() {
                while (currentDriverIndex < supportedDrivers2.length) {
                  var driverName = supportedDrivers2[currentDriverIndex];
                  currentDriverIndex++;
                  self2._dbInfo = null;
                  self2._ready = null;
                  return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                }
                setDriverToConfig();
                var error2 = new Error("No available storage method found.");
                self2._driverSet = Promise$12.reject(error2);
                return self2._driverSet;
              }
              return driverPromiseLoop();
            };
          }
          var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
            return Promise$12.resolve();
          }) : Promise$12.resolve();
          this._driverSet = oldDriverSetDone.then(function() {
            var driverName = supportedDrivers[0];
            self2._dbInfo = null;
            self2._ready = null;
            return self2.getDriver(driverName).then(function(driver) {
              self2._driver = driver._driver;
              setDriverToConfig();
              self2._wrapLibraryMethodsWithReady();
              self2._initDriver = initDriver(supportedDrivers);
            });
          })["catch"](function() {
            setDriverToConfig();
            var error2 = new Error("No available storage method found.");
            self2._driverSet = Promise$12.reject(error2);
            return self2._driverSet;
          });
          executeTwoCallbacks(this._driverSet, callback, errorCallback);
          return this._driverSet;
        };
        LocalForage2.prototype.supports = function supports(driverName) {
          return !!DriverSupport[driverName];
        };
        LocalForage2.prototype._extend = function _extend(libraryMethodsAndProperties) {
          extend2(this, libraryMethodsAndProperties);
        };
        LocalForage2.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
          var supportedDrivers = [];
          for (var i2 = 0, len = drivers.length; i2 < len; i2++) {
            var driverName = drivers[i2];
            if (this.supports(driverName)) {
              supportedDrivers.push(driverName);
            }
          }
          return supportedDrivers;
        };
        LocalForage2.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
          for (var i2 = 0, len = LibraryMethods.length; i2 < len; i2++) {
            callWhenReady(this, LibraryMethods[i2]);
          }
        };
        LocalForage2.prototype.createInstance = function createInstance2(options) {
          return new LocalForage2(options);
        };
        return LocalForage2;
      }();
      var localforage_js = new LocalForage();
      module2.exports = localforage_js;
    }, { "3": 3 }] }, {}, [4])(4);
  });
})(localforage$1);
var localforageExports = localforage$1.exports;
const localforage = /* @__PURE__ */ getDefaultExportFromCjs(localforageExports);
var axios$7 = { exports: {} };
var bind$8 = function bind(fn2, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i2 = 0; i2 < args.length; i2++) {
      args[i2] = arguments[i2];
    }
    return fn2.apply(thisArg, args);
  };
};
var bind$7 = bind$8;
var toString$4 = Object.prototype.toString;
function isArray$d(val) {
  return toString$4.call(val) === "[object Array]";
}
function isUndefined$4(val) {
  return typeof val === "undefined";
}
function isBuffer$4(val) {
  return val !== null && !isUndefined$4(val) && val.constructor !== null && !isUndefined$4(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
function isArrayBuffer$2(val) {
  return toString$4.call(val) === "[object ArrayBuffer]";
}
function isFormData$1(val) {
  return typeof FormData !== "undefined" && val instanceof FormData;
}
function isArrayBufferView$1(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}
function isString$4(val) {
  return typeof val === "string";
}
function isNumber$3(val) {
  return typeof val === "number";
}
function isObject$8(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject$1(val) {
  if (toString$4.call(val) !== "[object Object]") {
    return false;
  }
  var prototype2 = Object.getPrototypeOf(val);
  return prototype2 === null || prototype2 === Object.prototype;
}
function isDate$2(val) {
  return toString$4.call(val) === "[object Date]";
}
function isFile$1(val) {
  return toString$4.call(val) === "[object File]";
}
function isBlob$1(val) {
  return toString$4.call(val) === "[object Blob]";
}
function isFunction$3(val) {
  return toString$4.call(val) === "[object Function]";
}
function isStream$1(val) {
  return isObject$8(val) && isFunction$3(val.pipe);
}
function isURLSearchParams$1(val) {
  return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
}
function trim$2(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv$1() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach$2(obj, fn2) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$d(obj)) {
    for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn2.call(null, obj[i2], i2, obj);
    }
  } else {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn2.call(null, obj[key], key, obj);
      }
    }
  }
}
function merge$3() {
  var result = {};
  function assignValue2(val, key) {
    if (isPlainObject$1(result[key]) && isPlainObject$1(val)) {
      result[key] = merge$3(result[key], val);
    } else if (isPlainObject$1(val)) {
      result[key] = merge$3({}, val);
    } else if (isArray$d(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }
  for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    forEach$2(arguments[i2], assignValue2);
  }
  return result;
}
function extend$1(a2, b2, thisArg) {
  forEach$2(b2, function assignValue2(val, key) {
    if (thisArg && typeof val === "function") {
      a2[key] = bind$7(val, thisArg);
    } else {
      a2[key] = val;
    }
  });
  return a2;
}
function stripBOM$1(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}
var utils$q = {
  isArray: isArray$d,
  isArrayBuffer: isArrayBuffer$2,
  isBuffer: isBuffer$4,
  isFormData: isFormData$1,
  isArrayBufferView: isArrayBufferView$1,
  isString: isString$4,
  isNumber: isNumber$3,
  isObject: isObject$8,
  isPlainObject: isPlainObject$1,
  isUndefined: isUndefined$4,
  isDate: isDate$2,
  isFile: isFile$1,
  isBlob: isBlob$1,
  isFunction: isFunction$3,
  isStream: isStream$1,
  isURLSearchParams: isURLSearchParams$1,
  isStandardBrowserEnv: isStandardBrowserEnv$1,
  forEach: forEach$2,
  merge: merge$3,
  extend: extend$1,
  trim: trim$2,
  stripBOM: stripBOM$1
};
var utils$p = utils$q;
function encode$3(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$3 = function buildURL(url2, params, paramsSerializer) {
  if (!params) {
    return url2;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$p.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils$p.forEach(params, function serialize2(val, key) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$p.isArray(val)) {
        key = key + "[]";
      } else {
        val = [val];
      }
      utils$p.forEach(val, function parseValue(v2) {
        if (utils$p.isDate(v2)) {
          v2 = v2.toISOString();
        } else if (utils$p.isObject(v2)) {
          v2 = JSON.stringify(v2);
        }
        parts.push(encode$3(key) + "=" + encode$3(v2));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
};
var utils$o = utils$q;
function InterceptorManager$3() {
  this.handlers = [];
}
InterceptorManager$3.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled,
    rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
InterceptorManager$3.prototype.eject = function eject(id2) {
  if (this.handlers[id2]) {
    this.handlers[id2] = null;
  }
};
InterceptorManager$3.prototype.forEach = function forEach(fn2) {
  utils$o.forEach(this.handlers, function forEachHandler(h2) {
    if (h2 !== null) {
      fn2(h2);
    }
  });
};
var InterceptorManager_1$1 = InterceptorManager$3;
var utils$n = utils$q;
var normalizeHeaderName$3 = function normalizeHeaderName(headers, normalizedName) {
  utils$n.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};
var enhanceError = function enhanceError2(error2, config, code, request3, response) {
  error2.config = config;
  if (code) {
    error2.code = code;
  }
  error2.request = request3;
  error2.response = response;
  error2.isAxiosError = true;
  error2.toJSON = function toJSON2() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  };
  return error2;
};
var createError;
var hasRequiredCreateError;
function requireCreateError() {
  if (hasRequiredCreateError)
    return createError;
  hasRequiredCreateError = 1;
  var enhanceError$1 = enhanceError;
  createError = function createError2(message, config, code, request3, response) {
    var error2 = new Error(message);
    return enhanceError$1(error2, config, code, request3, response);
  };
  return createError;
}
var settle$1;
var hasRequiredSettle$1;
function requireSettle$1() {
  if (hasRequiredSettle$1)
    return settle$1;
  hasRequiredSettle$1 = 1;
  var createError2 = requireCreateError();
  settle$1 = function settle2(resolve2, reject2, response) {
    var validateStatus2 = response.config.validateStatus;
    if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
      resolve2(response);
    } else {
      reject2(createError2(
        "Request failed with status code " + response.status,
        response.config,
        null,
        response.request,
        response
      ));
    }
  };
  return settle$1;
}
var cookies$1;
var hasRequiredCookies$1;
function requireCookies$1() {
  if (hasRequiredCookies$1)
    return cookies$1;
  hasRequiredCookies$1 = 1;
  var utils2 = utils$q;
  cookies$1 = utils2.isStandardBrowserEnv() ? (
    // Standard browser envs support document.cookie
    function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils2.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils2.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils2.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          var match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match2 ? decodeURIComponent(match2[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove() {
        }
      };
    }()
  );
  return cookies$1;
}
var isAbsoluteURL$2;
var hasRequiredIsAbsoluteURL;
function requireIsAbsoluteURL() {
  if (hasRequiredIsAbsoluteURL)
    return isAbsoluteURL$2;
  hasRequiredIsAbsoluteURL = 1;
  isAbsoluteURL$2 = function isAbsoluteURL3(url2) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url2);
  };
  return isAbsoluteURL$2;
}
var combineURLs$2;
var hasRequiredCombineURLs;
function requireCombineURLs() {
  if (hasRequiredCombineURLs)
    return combineURLs$2;
  hasRequiredCombineURLs = 1;
  combineURLs$2 = function combineURLs3(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  };
  return combineURLs$2;
}
var buildFullPath$2;
var hasRequiredBuildFullPath;
function requireBuildFullPath() {
  if (hasRequiredBuildFullPath)
    return buildFullPath$2;
  hasRequiredBuildFullPath = 1;
  var isAbsoluteURL3 = requireIsAbsoluteURL();
  var combineURLs3 = requireCombineURLs();
  buildFullPath$2 = function buildFullPath3(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL3(requestedURL)) {
      return combineURLs3(baseURL, requestedURL);
    }
    return requestedURL;
  };
  return buildFullPath$2;
}
var parseHeaders$1;
var hasRequiredParseHeaders$1;
function requireParseHeaders$1() {
  if (hasRequiredParseHeaders$1)
    return parseHeaders$1;
  hasRequiredParseHeaders$1 = 1;
  var utils2 = utils$q;
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  parseHeaders$1 = function parseHeaders2(headers) {
    var parsed = {};
    var key;
    var val;
    var i2;
    if (!headers) {
      return parsed;
    }
    utils2.forEach(headers.split("\n"), function parser(line2) {
      i2 = line2.indexOf(":");
      key = utils2.trim(line2.substr(0, i2)).toLowerCase();
      val = utils2.trim(line2.substr(i2 + 1));
      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === "set-cookie") {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  return parseHeaders$1;
}
var isURLSameOrigin$1;
var hasRequiredIsURLSameOrigin$1;
function requireIsURLSameOrigin$1() {
  if (hasRequiredIsURLSameOrigin$1)
    return isURLSameOrigin$1;
  hasRequiredIsURLSameOrigin$1 = 1;
  var utils2 = utils$q;
  isURLSameOrigin$1 = utils2.isStandardBrowserEnv() ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url2) {
        var href = url2;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin2(requestURL) {
        var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return function isURLSameOrigin2() {
        return true;
      };
    }()
  );
  return isURLSameOrigin$1;
}
var Cancel_1;
var hasRequiredCancel;
function requireCancel() {
  if (hasRequiredCancel)
    return Cancel_1;
  hasRequiredCancel = 1;
  function Cancel2(message) {
    this.message = message;
  }
  Cancel2.prototype.toString = function toString3() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  };
  Cancel2.prototype.__CANCEL__ = true;
  Cancel_1 = Cancel2;
  return Cancel_1;
}
var xhr$1;
var hasRequiredXhr$1;
function requireXhr$1() {
  if (hasRequiredXhr$1)
    return xhr$1;
  hasRequiredXhr$1 = 1;
  var utils2 = utils$q;
  var settle2 = requireSettle$1();
  var cookies2 = requireCookies$1();
  var buildURL4 = buildURL$3;
  var buildFullPath3 = requireBuildFullPath();
  var parseHeaders2 = requireParseHeaders$1();
  var isURLSameOrigin2 = requireIsURLSameOrigin$1();
  var createError2 = requireCreateError();
  var defaults2 = requireDefaults();
  var Cancel2 = requireCancel();
  xhr$1 = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve2, reject2) {
      var requestData = config.data;
      var requestHeaders = config.headers;
      var responseType = config.responseType;
      var onCanceled;
      function done() {
        if (config.cancelToken) {
          config.cancelToken.unsubscribe(onCanceled);
        }
        if (config.signal) {
          config.signal.removeEventListener("abort", onCanceled);
        }
      }
      if (utils2.isFormData(requestData)) {
        delete requestHeaders["Content-Type"];
      }
      var request3 = new XMLHttpRequest();
      if (config.auth) {
        var username = config.auth.username || "";
        var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath3(config.baseURL, config.url);
      request3.open(config.method.toUpperCase(), buildURL4(fullPath, config.params, config.paramsSerializer), true);
      request3.timeout = config.timeout;
      function onloadend() {
        if (!request3) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request3 ? parseHeaders2(request3.getAllResponseHeaders()) : null;
        var responseData = !responseType || responseType === "text" || responseType === "json" ? request3.responseText : request3.response;
        var response = {
          data: responseData,
          status: request3.status,
          statusText: request3.statusText,
          headers: responseHeaders,
          config,
          request: request3
        };
        settle2(function _resolve(value) {
          resolve2(value);
          done();
        }, function _reject(err) {
          reject2(err);
          done();
        }, response);
        request3 = null;
      }
      if ("onloadend" in request3) {
        request3.onloadend = onloadend;
      } else {
        request3.onreadystatechange = function handleLoad() {
          if (!request3 || request3.readyState !== 4) {
            return;
          }
          if (request3.status === 0 && !(request3.responseURL && request3.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request3.onabort = function handleAbort() {
        if (!request3) {
          return;
        }
        reject2(createError2("Request aborted", config, "ECONNABORTED", request3));
        request3 = null;
      };
      request3.onerror = function handleError() {
        reject2(createError2("Network Error", config, null, request3));
        request3 = null;
      };
      request3.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        var transitional4 = config.transitional || defaults2.transitional;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject2(createError2(
          timeoutErrorMessage,
          config,
          transitional4.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
          request3
        ));
        request3 = null;
      };
      if (utils2.isStandardBrowserEnv()) {
        var xsrfValue = (config.withCredentials || isURLSameOrigin2(fullPath)) && config.xsrfCookieName ? cookies2.read(config.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request3) {
        utils2.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
            delete requestHeaders[key];
          } else {
            request3.setRequestHeader(key, val);
          }
        });
      }
      if (!utils2.isUndefined(config.withCredentials)) {
        request3.withCredentials = !!config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request3.responseType = config.responseType;
      }
      if (typeof config.onDownloadProgress === "function") {
        request3.addEventListener("progress", config.onDownloadProgress);
      }
      if (typeof config.onUploadProgress === "function" && request3.upload) {
        request3.upload.addEventListener("progress", config.onUploadProgress);
      }
      if (config.cancelToken || config.signal) {
        onCanceled = function(cancel) {
          if (!request3) {
            return;
          }
          reject2(!cancel || cancel && cancel.type ? new Cancel2("canceled") : cancel);
          request3.abort();
          request3 = null;
        };
        config.cancelToken && config.cancelToken.subscribe(onCanceled);
        if (config.signal) {
          config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
        }
      }
      if (!requestData) {
        requestData = null;
      }
      request3.send(requestData);
    });
  };
  return xhr$1;
}
var defaults_1$1;
var hasRequiredDefaults;
function requireDefaults() {
  if (hasRequiredDefaults)
    return defaults_1$1;
  hasRequiredDefaults = 1;
  var utils2 = utils$q;
  var normalizeHeaderName4 = normalizeHeaderName$3;
  var enhanceError$1 = enhanceError;
  var DEFAULT_CONTENT_TYPE2 = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  function setContentTypeIfUnset2(headers, value) {
    if (!utils2.isUndefined(headers) && utils2.isUndefined(headers["Content-Type"])) {
      headers["Content-Type"] = value;
    }
  }
  function getDefaultAdapter2() {
    var adapter;
    if (typeof XMLHttpRequest !== "undefined") {
      adapter = requireXhr$1();
    } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
      adapter = requireXhr$1();
    }
    return adapter;
  }
  function stringifySafely2(rawValue, parser, encoder) {
    if (utils2.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils2.trim(rawValue);
      } catch (e2) {
        if (e2.name !== "SyntaxError") {
          throw e2;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  var defaults2 = {
    transitional: {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    },
    adapter: getDefaultAdapter2(),
    transformRequest: [function transformRequest2(data2, headers) {
      normalizeHeaderName4(headers, "Accept");
      normalizeHeaderName4(headers, "Content-Type");
      if (utils2.isFormData(data2) || utils2.isArrayBuffer(data2) || utils2.isBuffer(data2) || utils2.isStream(data2) || utils2.isFile(data2) || utils2.isBlob(data2)) {
        return data2;
      }
      if (utils2.isArrayBufferView(data2)) {
        return data2.buffer;
      }
      if (utils2.isURLSearchParams(data2)) {
        setContentTypeIfUnset2(headers, "application/x-www-form-urlencoded;charset=utf-8");
        return data2.toString();
      }
      if (utils2.isObject(data2) || headers && headers["Content-Type"] === "application/json") {
        setContentTypeIfUnset2(headers, "application/json");
        return stringifySafely2(data2);
      }
      return data2;
    }],
    transformResponse: [function transformResponse2(data2) {
      var transitional4 = this.transitional || defaults2.transitional;
      var silentJSONParsing = transitional4 && transitional4.silentJSONParsing;
      var forcedJSONParsing = transitional4 && transitional4.forcedJSONParsing;
      var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
      if (strictJSONParsing || forcedJSONParsing && utils2.isString(data2) && data2.length) {
        try {
          return JSON.parse(data2);
        } catch (e2) {
          if (strictJSONParsing) {
            if (e2.name === "SyntaxError") {
              throw enhanceError$1(e2, this, "E_JSON_PARSE");
            }
            throw e2;
          }
        }
      }
      return data2;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    validateStatus: function validateStatus2(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    }
  };
  utils2.forEach(["delete", "get", "head"], function forEachMethodNoData4(method) {
    defaults2.headers[method] = {};
  });
  utils2.forEach(["post", "put", "patch"], function forEachMethodWithData4(method) {
    defaults2.headers[method] = utils2.merge(DEFAULT_CONTENT_TYPE2);
  });
  defaults_1$1 = defaults2;
  return defaults_1$1;
}
var utils$m = utils$q;
var defaults$8 = requireDefaults();
var transformData$3 = function transformData(data2, headers, fns) {
  var context2 = this || defaults$8;
  utils$m.forEach(fns, function transform(fn2) {
    data2 = fn2.call(context2, data2, headers);
  });
  return data2;
};
var isCancel$3;
var hasRequiredIsCancel$1;
function requireIsCancel$1() {
  if (hasRequiredIsCancel$1)
    return isCancel$3;
  hasRequiredIsCancel$1 = 1;
  isCancel$3 = function isCancel2(value) {
    return !!(value && value.__CANCEL__);
  };
  return isCancel$3;
}
var utils$l = utils$q;
var transformData$2 = transformData$3;
var isCancel$2 = requireIsCancel$1();
var defaults$7 = requireDefaults();
var Cancel = requireCancel();
function throwIfCancellationRequested$1(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new Cancel("canceled");
  }
}
var dispatchRequest$3 = function dispatchRequest(config) {
  throwIfCancellationRequested$1(config);
  config.headers = config.headers || {};
  config.data = transformData$2.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );
  config.headers = utils$l.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );
  utils$l.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );
  var adapter = config.adapter || defaults$7.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested$1(config);
    response.data = transformData$2.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel$2(reason)) {
      throwIfCancellationRequested$1(config);
      if (reason && reason.response) {
        reason.response.data = transformData$2.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }
    return Promise.reject(reason);
  });
};
var utils$k = utils$q;
var mergeConfig$5 = function mergeConfig(config1, config2) {
  config2 = config2 || {};
  var config = {};
  function getMergedValue(target, source) {
    if (utils$k.isPlainObject(target) && utils$k.isPlainObject(source)) {
      return utils$k.merge(target, source);
    } else if (utils$k.isPlainObject(source)) {
      return utils$k.merge({}, source);
    } else if (utils$k.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(prop) {
    if (!utils$k.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$k.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function valueFromConfig2(prop) {
    if (!utils$k.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    }
  }
  function defaultToConfig2(prop) {
    if (!utils$k.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    } else if (!utils$k.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  var mergeMap = {
    "url": valueFromConfig2,
    "method": valueFromConfig2,
    "data": valueFromConfig2,
    "baseURL": defaultToConfig2,
    "transformRequest": defaultToConfig2,
    "transformResponse": defaultToConfig2,
    "paramsSerializer": defaultToConfig2,
    "timeout": defaultToConfig2,
    "timeoutMessage": defaultToConfig2,
    "withCredentials": defaultToConfig2,
    "adapter": defaultToConfig2,
    "responseType": defaultToConfig2,
    "xsrfCookieName": defaultToConfig2,
    "xsrfHeaderName": defaultToConfig2,
    "onUploadProgress": defaultToConfig2,
    "onDownloadProgress": defaultToConfig2,
    "decompress": defaultToConfig2,
    "maxContentLength": defaultToConfig2,
    "maxBodyLength": defaultToConfig2,
    "transport": defaultToConfig2,
    "httpAgent": defaultToConfig2,
    "httpsAgent": defaultToConfig2,
    "cancelToken": defaultToConfig2,
    "socketPath": defaultToConfig2,
    "responseEncoding": defaultToConfig2,
    "validateStatus": mergeDirectKeys
  };
  utils$k.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge3 = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge3(prop);
    utils$k.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
};
var data$1;
var hasRequiredData$1;
function requireData$1() {
  if (hasRequiredData$1)
    return data$1;
  hasRequiredData$1 = 1;
  data$1 = {
    "version": "0.24.0"
  };
  return data$1;
}
var VERSION$3 = requireData$1().version;
var validators$3 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type2, i2) {
  validators$3[type2] = function validator2(thing) {
    return typeof thing === type2 || "a" + (i2 < 1 ? "n " : " ") + type2;
  };
});
var deprecatedWarnings$1 = {};
validators$3.transitional = function transitional(validator2, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION$3 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return function(value, opt, opts) {
    if (validator2 === false) {
      throw new Error(formatMessage(opt, " has been removed" + (version ? " in " + version : "")));
    }
    if (version && !deprecatedWarnings$1[opt]) {
      deprecatedWarnings$1[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions$1(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new TypeError("options must be an object");
  }
  var keys2 = Object.keys(options);
  var i2 = keys2.length;
  while (i2-- > 0) {
    var opt = keys2[i2];
    var validator2 = schema[opt];
    if (validator2) {
      var value = options[opt];
      var result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new TypeError("option " + opt + " must be " + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error("Unknown option " + opt);
    }
  }
}
var validator$3 = {
  assertOptions: assertOptions$1,
  validators: validators$3
};
var utils$j = utils$q;
var buildURL$2 = buildURL$3;
var InterceptorManager$2 = InterceptorManager_1$1;
var dispatchRequest$2 = dispatchRequest$3;
var mergeConfig$4 = mergeConfig$5;
var validator$2 = validator$3;
var validators$2 = validator$2.validators;
function Axios$3(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager$2(),
    response: new InterceptorManager$2()
  };
}
Axios$3.prototype.request = function request(config) {
  if (typeof config === "string") {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }
  config = mergeConfig$4(this.defaults, config);
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = "get";
  }
  var transitional4 = config.transitional;
  if (transitional4 !== void 0) {
    validator$2.assertOptions(transitional4, {
      silentJSONParsing: validators$2.transitional(validators$2.boolean),
      forcedJSONParsing: validators$2.transitional(validators$2.boolean),
      clarifyTimeoutError: validators$2.transitional(validators$2.boolean)
    }, false);
  }
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise2;
  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest$2, void 0];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise2 = Promise.resolve(config);
    while (chain.length) {
      promise2 = promise2.then(chain.shift(), chain.shift());
    }
    return promise2;
  }
  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error2) {
      onRejected(error2);
      break;
    }
  }
  try {
    promise2 = dispatchRequest$2(newConfig);
  } catch (error2) {
    return Promise.reject(error2);
  }
  while (responseInterceptorChain.length) {
    promise2 = promise2.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise2;
};
Axios$3.prototype.getUri = function getUri(config) {
  config = mergeConfig$4(this.defaults, config);
  return buildURL$2(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
};
utils$j.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios$3.prototype[method] = function(url2, config) {
    return this.request(mergeConfig$4(config || {}, {
      method,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils$j.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  Axios$3.prototype[method] = function(url2, data2, config) {
    return this.request(mergeConfig$4(config || {}, {
      method,
      url: url2,
      data: data2
    }));
  };
});
var Axios_1$1 = Axios$3;
var CancelToken_1$1;
var hasRequiredCancelToken$1;
function requireCancelToken$1() {
  if (hasRequiredCancelToken$1)
    return CancelToken_1$1;
  hasRequiredCancelToken$1 = 1;
  var Cancel2 = requireCancel();
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    var token2 = this;
    this.promise.then(function(cancel) {
      if (!token2._listeners)
        return;
      var i2;
      var l2 = token2._listeners.length;
      for (i2 = 0; i2 < l2; i2++) {
        token2._listeners[i2](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = function(onfulfilled) {
      var _resolve;
      var promise2 = new Promise(function(resolve2) {
        token2.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise2.cancel = function reject2() {
        token2.unsubscribe(_resolve);
      };
      return promise2;
    };
    executor(function cancel(message) {
      if (token2.reason) {
        return;
      }
      token2.reason = new Cancel2(message);
      resolvePromise(token2.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.prototype.subscribe = function subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  };
  CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    var index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token2 = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token: token2,
      cancel
    };
  };
  CancelToken_1$1 = CancelToken;
  return CancelToken_1$1;
}
var spread$1;
var hasRequiredSpread$1;
function requireSpread$1() {
  if (hasRequiredSpread$1)
    return spread$1;
  hasRequiredSpread$1 = 1;
  spread$1 = function spread2(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };
  return spread$1;
}
var isAxiosError$1;
var hasRequiredIsAxiosError$1;
function requireIsAxiosError$1() {
  if (hasRequiredIsAxiosError$1)
    return isAxiosError$1;
  hasRequiredIsAxiosError$1 = 1;
  isAxiosError$1 = function isAxiosError2(payload) {
    return typeof payload === "object" && payload.isAxiosError === true;
  };
  return isAxiosError$1;
}
var utils$i = utils$q;
var bind$6 = bind$8;
var Axios$2 = Axios_1$1;
var mergeConfig$3 = mergeConfig$5;
var defaults$6 = requireDefaults();
function createInstance$1(defaultConfig) {
  var context2 = new Axios$2(defaultConfig);
  var instance2 = bind$6(Axios$2.prototype.request, context2);
  utils$i.extend(instance2, Axios$2.prototype, context2);
  utils$i.extend(instance2, context2);
  instance2.create = function create(instanceConfig) {
    return createInstance$1(mergeConfig$3(defaultConfig, instanceConfig));
  };
  return instance2;
}
var axios$6 = createInstance$1(defaults$6);
axios$6.Axios = Axios$2;
axios$6.Cancel = requireCancel();
axios$6.CancelToken = requireCancelToken$1();
axios$6.isCancel = requireIsCancel$1();
axios$6.VERSION = requireData$1().version;
axios$6.all = function all(promises) {
  return Promise.all(promises);
};
axios$6.spread = requireSpread$1();
axios$6.isAxiosError = requireIsAxiosError$1();
axios$7.exports = axios$6;
axios$7.exports.default = axios$6;
var axiosExports$1 = axios$7.exports;
var axios$5 = axiosExports$1;
const axios$4 = axios$5;
class Cloudlog {
  constructor() {
    this.url = "";
    this.level = "all";
    this.mongoUrl = "mongodb://localhost:27017/";
    this.collection = "main";
    this.isUpload = true;
  }
  init(url2, mongoUrl) {
    this.url = url2;
    if (mongoUrl) {
      this.mongoUrl = mongoUrl;
    }
  }
  setUpload(s2) {
    this.isUpload = s2;
  }
  setCollection(c2) {
    this.collection = c2;
  }
  setLevel(l2) {
    this.level = l2.toUpperCase();
  }
  upload(info, data2, level, now2) {
    if (typeof info !== "string") {
      this.error("log", void 0, false);
    }
    let postData = {
      log: {
        info,
        data: data2,
        level,
        now: now2
      },
      mongoUrl: this.mongoUrl,
      collection: this.collection
    };
    const that = this;
    if (this.url !== "" && this.isUpload) {
      axios$4.post(this.url + "/log", postData).then((r2) => {
        that.trace("Logged to cloud.", void 0, false);
      }).catch((e2) => {
        that.error("Logging to cloud failed!", void 0, false);
      });
    }
  }
  clog(info, data2, level, color2, now2, upload) {
    const levelToNum = {
      all: 7,
      ALL: 7,
      TRACE: 6,
      DEBUG: 5,
      INFO: 4,
      WARN: 3,
      ERROR: 2,
      FATAL: 1,
      NONE: 0,
      none: 0
    };
    if (levelToNum[level] <= levelToNum[this.level]) {
      console.log(
        "%c%s%c%s%c%s%c %s",
        "color:white;background-color:" + color2,
        "[" + level + "]",
        "",
        " ",
        "color:" + color2,
        "[" + now2.toLocaleString() + "]",
        "",
        info
      );
      if (data2) {
        console.log(data2);
        console.log("------------------------");
      }
    }
    if (upload === void 0) {
      this.upload(info, data2, level, now2);
    }
    if (upload !== void 0) {
      if (upload) {
        this.upload(info, data2, level, now2);
      }
    }
  }
  trace(info, data2, upload) {
    const now2 = /* @__PURE__ */ new Date();
    const level = "TRACE";
    const color2 = "#005CAF";
    this.clog(info, data2, level, color2, now2, upload);
  }
  debug(info, data2, upload) {
    const now2 = /* @__PURE__ */ new Date();
    const level = "DEBUG";
    const color2 = "#0089A7";
    this.clog(info, data2, level, color2, now2, upload);
  }
  info(info, data2, upload) {
    const now2 = /* @__PURE__ */ new Date();
    const level = "INFO";
    const color2 = "#00896C";
    this.clog(info, data2, level, color2, now2, upload);
  }
  warn(info, data2, upload) {
    const now2 = /* @__PURE__ */ new Date();
    const level = "WARN";
    const color2 = "#DDA52D";
    this.clog(info, data2, level, color2, now2, upload);
  }
  error(info, data2, upload) {
    const now2 = /* @__PURE__ */ new Date();
    const level = "ERROR";
    const color2 = "#AB3B3A";
    this.clog(info, data2, level, color2, now2, upload);
  }
  fatal(info, data2, upload) {
    const now2 = /* @__PURE__ */ new Date();
    const level = "FATAL";
    const color2 = "#E16B8C";
    this.clog(info, data2, level, color2, now2, upload);
  }
}
var cloudlogjs = Cloudlog;
const Cloudlog$1 = /* @__PURE__ */ getDefaultExportFromCjs(cloudlogjs);
const logger = new Cloudlog$1();
const en = {
  // 
  common: {
    yes: "OK",
    no: "Cancel"
  },
  menu: {
    options: {
      title: "OPTIONS",
      pages: {
        system: {
          title: "System",
          options: {
            autoSpeed: {
              title: "Autoplay Speed",
              options: {
                slow: "Slow",
                medium: "Medium",
                fast: "Fast"
              }
            },
            language: {
              title: "Language"
            },
            resetData: {
              title: "Clear or Reset Data",
              options: {
                clearGameSave: "Clear game saving",
                resetSettings: "Reset settings",
                clearAll: "Clear all data"
              },
              dialogs: {
                clearGameSave: "Are you sure you want to clear game saving",
                resetSettings: "Are you sure you want to reset all settings",
                clearAll: "Are you sure you want to clear all data"
              }
            },
            gameSave: {
              title: "Import or Export Game Saving and Options",
              options: {
                export: "Export game saving and options",
                import: "Import game saving and options"
              },
              dialogs: {
                import: {
                  title: "Are you sure you want to import game saving and options",
                  tip: "Import game saving",
                  error: "Parse game saving failed"
                }
              }
            },
            about: {
              title: "About WebGAL",
              subTitle: "WebGAL: An Open-Source Web-Based Visual Novel Engine",
              version: "Version",
              source: "Source Code Repository",
              contributors: "Contributors",
              website: "Website"
            }
          }
        },
        display: {
          title: "Display",
          options: {
            fullScreen: {
              title: "Full Screen",
              options: {
                on: "ON",
                off: "OFF"
              }
            },
            textSpeed: {
              title: "Text Speed",
              options: {
                slow: "Slow",
                medium: "Medium",
                fast: "Fast"
              }
            },
            textSize: {
              title: "Text Size",
              options: {
                small: "Small",
                medium: "Medium",
                large: "Large"
              }
            },
            textFont: {
              title: "Text Font",
              options: {
                siYuanSimSun: "Source Han Serif",
                SimHei: "Sans",
                lxgw: "LXGW WenKai"
              }
            },
            textboxOpacity: {
              title: "Textbox Opacity"
            },
            textPreview: {
              title: "Preview Text Showing",
              text: "You are previewing the text's font, size and playback speed, now. You can adjust the above options according to your perception."
            }
          }
        },
        sound: {
          title: "Sound",
          options: {
            volumeMain: { title: "Main Volume" },
            vocalVolume: { title: "Vocal Volume" },
            bgmVolume: { title: "BGM Volume" },
            seVolume: { title: "Sound Effects Volume" },
            uiSeVolume: { title: "UI Sound Effects Volume" }
          }
        }
        // language: {
        //   title: '',
        //   options: {
        //   },
        // },
      }
    },
    saving: {
      title: "SAVE",
      isOverwrite: "Are you sure you want to overwrite this save?"
    },
    loadSaving: {
      title: "LOAD"
    },
    title: {
      title: "TITLE"
    },
    exit: {
      title: "BACK"
    }
  },
  title: {
    start: {
      title: "START",
      subtitle: ""
    },
    continue: {
      title: "CONTINUE",
      subtitle: ""
    },
    options: {
      title: "OPTIONS",
      subtitle: ""
    },
    load: {
      title: "LOAD",
      subtitle: ""
    },
    extra: {
      title: "EXTRA",
      subtitle: ""
    }
  },
  gaming: {
    noSaving: "No saving",
    buttons: {
      hide: "Hide",
      show: "Show",
      backlog: "Backlog",
      replay: "Replay",
      auto: "Auto",
      forward: "Forward",
      quicklySave: "Quickly Save",
      quicklyLoad: "Quickly Load",
      save: "Save",
      load: "Load",
      options: "Options",
      title: "Title",
      titleTips: "Confirm return to the title screen"
    }
  },
  extra: {
    title: "EXTRA"
  }
};
const jp = {
  // 
  common: {
    yes: "",
    no: ""
  },
  menu: {
    options: {
      title: "CONFIG",
      pages: {
        system: {
          title: "",
          options: {
            autoSpeed: {
              title: "",
              options: {
                slow: "",
                medium: "",
                fast: ""
              }
            },
            language: {
              title: ""
            },
            resetData: {
              title: "",
              options: {
                clearGameSave: "",
                resetSettings: "",
                clearAll: ""
              },
              dialogs: {
                clearGameSave: "",
                resetSettings: "",
                clearAll: ""
              }
            },
            gameSave: {
              title: "",
              options: {
                export: "",
                import: ""
              },
              dialogs: {
                import: {
                  title: "",
                  tip: "",
                  error: ""
                }
              }
            },
            about: {
              title: "WebGAL",
              subTitle: "WebGAL",
              version: "",
              source: "",
              contributors: "",
              website: ""
            }
          }
        },
        display: {
          title: "",
          options: {
            textSpeed: {
              title: "",
              options: {
                slow: "",
                medium: "",
                fast: ""
              }
            },
            textSize: {
              title: "",
              options: {
                small: "",
                medium: "",
                large: ""
              }
            },
            textFont: {
              title: "",
              options: {
                siYuanSimSun: "",
                SimHei: "",
                lxgw: ""
              }
            },
            textboxOpacity: {
              title: "Textbox Opacity"
            },
            textPreview: {
              title: "",
              // todo
              text: ""
            }
          }
        },
        sound: {
          title: "",
          options: {
            volumeMain: { title: "MAIN " },
            vocalVolume: { title: "VOICE " },
            bgmVolume: { title: "BGM " },
            seVolume: { title: "SE " },
            uiSeVolume: { title: "UI " }
          }
        }
        // language: {
        //   title: '',
        //   options: {
        //   },
        // },
      }
    },
    saving: {
      title: "SAVE",
      isOverwrite: ""
    },
    loadSaving: {
      title: "LOAD"
    },
    title: {
      title: "HOME"
    },
    exit: {
      title: "BACK"
    }
  },
  // todo
  title: {
    start: {
      title: "",
      subtitle: "START"
    },
    continue: {
      title: "",
      subtitle: "CONTINUE"
    },
    options: {
      title: "",
      subtitle: "CONFIG"
    },
    load: {
      title: "",
      subtitle: "LOAD"
    },
    extra: {
      title: "",
      subtitle: "EXTRA"
    }
  },
  gaming: {
    noSaving: "",
    buttons: {
      hide: "CLOSE",
      show: "SHOW",
      backlog: "LOG",
      replay: "REPLAY",
      auto: "AUTO",
      forward: "SKIP",
      quicklySave: "QUICK SAVE",
      quicklyLoad: "QUICK LOAD",
      save: "SAVE",
      load: "LOAD",
      options: "CONFIG",
      title: "HOME",
      titleTips: ""
    }
  },
  extra: {
    title: ""
  }
};
const zhCn = {
  // 
  common: {
    yes: "",
    no: "",
    confirm: "",
    cancel: ""
  },
  menu: {
    options: {
      title: "",
      pages: {
        system: {
          title: "",
          options: {
            autoSpeed: {
              title: "",
              options: {
                slow: "",
                medium: "",
                fast: ""
              }
            },
            language: {
              title: ""
            },
            resetData: {
              title: "",
              options: {
                clearGameSave: "",
                resetSettings: "",
                clearAll: ""
              },
              dialogs: {
                clearGameSave: "",
                resetSettings: "",
                clearAll: ""
              }
            },
            gameSave: {
              title: "",
              options: {
                export: "",
                import: ""
              },
              dialogs: {
                import: {
                  title: "",
                  tip: "",
                  error: ""
                }
              }
            },
            about: {
              title: " WebGAL",
              subTitle: "WebGAL",
              version: "",
              source: "",
              contributors: "",
              website: ""
            }
          }
        },
        display: {
          title: "",
          options: {
            fullScreen: {
              title: "",
              options: {
                on: "",
                off: ""
              }
            },
            textSpeed: {
              title: "",
              options: {
                slow: "",
                medium: "",
                fast: ""
              }
            },
            textSize: {
              title: "",
              options: {
                small: "",
                medium: "",
                large: ""
              }
            },
            textFont: {
              title: "",
              options: {
                siYuanSimSun: "",
                SimHei: "",
                lxgw: ""
              }
            },
            textboxOpacity: {
              title: ""
            },
            textPreview: {
              title: "",
              text: ""
            }
          }
        },
        sound: {
          title: "",
          options: {
            volumeMain: { title: "" },
            vocalVolume: { title: "" },
            bgmVolume: { title: "" },
            seVolume: { title: "" },
            uiSeVolume: { title: "" },
            voiceOption: { title: "" },
            voiceStop: { title: "" },
            voiceContinue: { title: "" }
          }
        }
        // language: {
        //   title: '',
        //   options: {
        //   },
        // },
      }
    },
    saving: {
      title: "",
      isOverwrite: ""
    },
    loadSaving: {
      title: ""
    },
    title: {
      title: "",
      options: {
        load: "",
        extra: ""
      }
    },
    exit: {
      title: ""
    }
  },
  title: {
    start: {
      title: "",
      subtitle: "START"
    },
    continue: {
      title: "",
      subtitle: "CONTINUE"
    },
    options: {
      title: "",
      subtitle: "OPTIONS"
    },
    load: {
      title: "",
      subtitle: "LOAD"
    },
    extra: {
      title: "",
      subtitle: "EXTRA"
    },
    quit: {
      title: "",
      subtitle: "QUIT"
    }
  },
  gaming: {
    noSaving: "",
    buttons: {
      hide: "",
      show: "",
      backlog: "",
      replay: "",
      auto: "",
      forward: "",
      quicklySave: "",
      quicklyLoad: "",
      save: "",
      load: "",
      options: "",
      title: "",
      titleTips: "",
      quitTips: "",
      backToGame: "",
      preserve: "",
      read: "",
      setting: "",
      backToTitle: ""
    }
  },
  extra: {
    title: ""
  }
};
const fr = {
  // 
  common: {
    yes: "OK",
    no: "Annuler"
  },
  menu: {
    options: {
      title: "OPTIONS",
      pages: {
        system: {
          title: "Systme",
          options: {
            autoSpeed: {
              title: "Vitesse de lecture automatique",
              options: {
                slow: "Lente",
                medium: "Moyenne",
                fast: "Rapide"
              }
            },
            language: {
              title: "Langue"
            },
            resetData: {
              title: "Effacer ou rinitialiser les donnes",
              options: {
                clearGameSave: "Effacer la sauvegarde du jeu",
                resetSettings: "Rinitialiser les paramtres",
                clearAll: "Tout effacer"
              },
              dialogs: {
                clearGameSave: "tes-vous sr de vouloir effacer la sauvegarde du jeu",
                resetSettings: "tes-vous sr de vouloir rinitialiser tous les paramtres",
                clearAll: "tes-vous sr de vouloir tout effacer"
              }
            },
            gameSave: {
              title: "Importer ou exporter la sauvegarde du jeu et les options",
              options: {
                export: "Exporter la sauvegarde du jeu et les options",
                import: "Importer la sauvegarde du jeu et les options"
              },
              dialogs: {
                import: {
                  title: "tes-vous sr de vouloir importer la sauvegarde du jeu et les options",
                  tip: "Importer la sauvegarde du jeu",
                  error: "Impossible d'analyser la sauvegarde du jeu"
                }
              }
            },
            about: {
              title: " propos de WebGAL",
              subTitle: "WebGAL: Un moteur de visual novel bas sur le web en open-source",
              version: "Version",
              source: "Dpt de code source",
              contributors: "Contributeurs",
              website: "Site web"
            }
          }
        },
        display: {
          title: "Affichage",
          options: {
            textSpeed: {
              title: "Vitesse d'affichage du texte",
              options: {
                slow: "Lente",
                medium: "Moyenne",
                fast: "Rapide"
              }
            },
            textSize: {
              title: "Taille du texte",
              options: {
                small: "Petite",
                medium: "Moyenne",
                large: "Grande"
              }
            },
            textFont: {
              title: "Police du texte",
              options: {
                siYuanSimSun: "Source Han Serif",
                SimHei: "Sans",
                lxgw: "LXGW WenKai"
              }
            },
            textboxOpacity: {
              title: "Textbox Opacity"
            },
            textPreview: {
              title: "Aperu de l'affichage du texte",
              text: "Vous prvisualisez la police, la taille et la vitesse de lecture du texte, maintenant. Vous pouvez ajuster les options ci-dessus selon votre perception."
            }
          }
        },
        sound: {
          title: "Son",
          options: {
            volumeMain: { title: "Volume principal" },
            vocalVolume: { title: "Volume des voix" },
            bgmVolume: { title: "Volume de la musique de fond" },
            seVolume: { title: "Volume des effets sonores" },
            uiSeVolume: { title: "Volume de linterface utilisateur" }
          }
        }
        // language: {
        //   title: 'Langue',
        //   options: {
        //   },
        // },
      }
    },
    saving: {
      title: "SAUVEGARDER",
      isOverwrite: "tes-vous sr de vouloir craser cette sauvegarde ?"
    },
    loadSaving: {
      title: "CHARGER"
    },
    title: {
      title: "TITRE"
    },
    exit: {
      title: "RETOUR"
    }
  },
  title: {
    start: {
      title: "COMMENCER",
      subtitle: ""
    },
    continue: {
      title: "CONTINUER",
      subtitle: ""
    },
    options: {
      title: "OPTIONS",
      subtitle: ""
    },
    load: {
      title: "CHARGER",
      subtitle: ""
    },
    extra: {
      title: "EXTRA",
      subtitle: ""
    }
  },
  gaming: {
    noSaving: "Aucune sauvegarde",
    buttons: {
      hide: "Masquer",
      show: "Afficher",
      backlog: "Journal",
      replay: "Rejouer",
      auto: "Automatique",
      forward: "Avancer",
      quicklySave: "Sauvegarde rapide",
      quicklyLoad: "Chargement rapide",
      save: "Sauvegarder",
      load: "Charger",
      options: "Options",
      title: "Titre",
      titleTips: "Confirmer le retour  l'cran titre"
    }
  },
  extra: {
    title: "EXTRA"
  }
};
const de = {
  // 
  common: {
    yes: "Ja",
    no: "Nein"
  },
  menu: {
    options: {
      title: "OPTIONEN",
      pages: {
        system: {
          title: "System",
          options: {
            autoSpeed: {
              title: "Auto-Geschwindigkeit",
              options: {
                slow: "Langsam",
                medium: "Normal",
                fast: "Schnell"
              }
            },
            language: {
              title: "Sprache"
            },
            resetData: {
              title: "Daten lschen oder zurcksetzen",
              options: {
                clearGameSave: "Alle Spielstnde lschen",
                resetSettings: "Alle Einstellungen zurcksetzen",
                clearAll: "Alle Daten lschen"
              },
              dialogs: {
                clearGameSave: "Sind Sie sicher, dass Sie den Spielstand lschen mchten?",
                resetSettings: "Sind Sie sicher, dass Sie alle Einstellungen zurcksetzen mchten?",
                clearAll: "Sind Sie sicher, dass Sie alle Daten lschen mchten?"
              }
            },
            gameSave: {
              title: "Spielstand und Optionen importieren oder exportieren",
              options: {
                export: "Spielstand und Optionen exportieren",
                import: "Spielstand und Optionen importieren"
              },
              dialogs: {
                import: {
                  title: "Sind Sie sicher, dass Sie den Spielstand und die Optionen importieren mchten?",
                  tip: "Spielstand importieren",
                  error: "Ein Fehler ist beim Analysieren des Spielstands aufgetreten"
                }
              }
            },
            about: {
              title: "ber WebGAL",
              subTitle: "WebGAL: Eine Open-Source Web-Based Visual Novel Engine",
              version: "Version",
              source: "Source Code Repository",
              contributors: "Contributors",
              website: "Website"
            }
          }
        },
        display: {
          title: "Darstellung",
          options: {
            textSpeed: {
              title: "Geschwindigkeit der Textanzeige",
              options: {
                slow: "Langsam",
                medium: "Normal",
                fast: "Schnell"
              }
            },
            textSize: {
              title: "Textgre",
              options: {
                small: "Klein",
                medium: "Normal",
                large: "Gro"
              }
            },
            textFont: {
              title: "Schriftart",
              options: {
                siYuanSimSun: "Source Han Serif",
                SimHei: "Sans",
                lxgw: "LXGW WenKai"
              }
            },
            textboxOpacity: {
              title: "Textbox Opacity"
            },
            textPreview: {
              title: "Vorschautext wird angezeigt",
              text: "Sie knnen jederzeit die Schriftart, Gre und Wiedergabegeschwindigkeit des Textes nach Ihrer Vorliebe anpassen."
            }
          }
        },
        sound: {
          title: "Ton",
          options: {
            volumeMain: { title: "Hauptlautstrke" },
            vocalVolume: { title: "Stimmlautstrke" },
            bgmVolume: { title: "Musiklautstrke" },
            seVolume: { title: "Soundeffektlautstrke" },
            uiSeVolume: { title: "UI Soundeffektlautstrke" }
          }
        }
        // language: {
        //   title: 'Sprache',
        //   options: {
        //   },
        // },
      }
    },
    saving: {
      title: "SPEICHERN",
      isOverwrite: "Sind Sie sicher, dass Sie diesen Spielstand berschreiben mchten?"
    },
    loadSaving: {
      title: "LADEN"
    },
    title: {
      title: "TITEL"
    },
    exit: {
      title: "ZURCK"
    }
  },
  title: {
    start: {
      title: "STARTEN",
      subtitle: ""
    },
    continue: {
      title: "WEITERLESEN",
      subtitle: ""
    },
    options: {
      title: "OPTIONEN",
      subtitle: ""
    },
    load: {
      title: "LADEN",
      subtitle: ""
    },
    extra: {
      title: "EXTRA",
      subtitle: ""
    }
  },
  gaming: {
    noSaving: "Keine Speicherung",
    buttons: {
      hide: "Verstecken",
      show: "Anzeigen",
      backlog: "Verlauf",
      replay: "Wiedergabe",
      auto: "Auto",
      forward: "berspringen",
      quicklySave: "Quickly Save",
      quicklyLoad: "Quickly Load",
      save: "Speichern",
      load: "Laden",
      options: "Optionen",
      title: "Titel"
    }
  },
  extra: {
    title: "EXTRA"
  }
};
const zhTw = {
  // 
  common: {
    yes: "",
    no: ""
  },
  menu: {
    options: {
      title: "",
      pages: {
        system: {
          title: "",
          options: {
            autoSpeed: {
              title: "",
              options: {
                slow: "",
                medium: "",
                fast: ""
              }
            },
            language: {
              title: ""
            },
            resetData: {
              title: "",
              options: {
                clearGameSave: "",
                resetSettings: "",
                clearAll: ""
              },
              dialogs: {
                clearGameSave: "",
                resetSettings: "",
                clearAll: ""
              }
            },
            gameSave: {
              title: "",
              options: {
                export: "",
                import: ""
              },
              dialogs: {
                import: {
                  title: "",
                  tip: "",
                  error: ""
                }
              }
            },
            about: {
              title: " WebGAL",
              subTitle: "WebGAL",
              version: "",
              source: "",
              contributors: "",
              website: ""
            }
          }
        },
        display: {
          title: "",
          options: {
            textSpeed: {
              title: "",
              options: {
                slow: "",
                medium: "",
                fast: ""
              }
            },
            textSize: {
              title: "",
              options: {
                small: "",
                medium: "",
                large: ""
              }
            },
            textFont: {
              title: "",
              options: {
                siYuanSimSun: "",
                SimHei: ""
              }
            },
            textboxOpacity: {
              title: ""
            },
            textPreview: {
              title: "",
              text: ""
            }
          }
        },
        sound: {
          title: "",
          options: {
            volumeMain: { title: "" },
            vocalVolume: { title: "" },
            bgmVolume: { title: "" },
            seVolume: { title: "" },
            uiSeVolume: { title: "" }
          }
        }
        // language: {
        //   title: '',
        //   options: {
        //   },
        // },
      }
    },
    saving: {
      title: "",
      isOverwrite: "?"
    },
    loadSaving: {
      title: ""
    },
    title: {
      title: "",
      options: {
        load: "",
        extra: "CG"
      }
    },
    exit: {
      title: ""
    }
  },
  title: {
    start: {
      title: "",
      subtitle: "START"
    },
    continue: {
      title: "",
      subtitle: "CONTINUE"
    },
    options: {
      title: "",
      subtitle: "OPTIONS"
    },
    load: {
      title: "",
      subtitle: "LOAD"
    },
    extra: {
      title: "CG",
      subtitle: "EXTRA"
    }
  },
  gaming: {
    noSaving: "",
    buttons: {
      hide: "",
      show: "",
      backlog: "",
      replay: "",
      auto: "",
      forward: "",
      quicklySave: "",
      quicklyLoad: "",
      save: "",
      load: "",
      options: "",
      title: "",
      titleTips: ""
    }
  },
  extra: {
    title: "CG"
  }
};
var language = /* @__PURE__ */ ((language2) => {
  language2[language2["zhCn"] = 0] = "zhCn";
  language2[language2["en"] = 1] = "en";
  language2[language2["jp"] = 2] = "jp";
  language2[language2["fr"] = 3] = "fr";
  language2[language2["de"] = 4] = "de";
  language2[language2["zhTw"] = 5] = "zhTw";
  return language2;
})(language || {});
const languages = {
  zhCn: "",
  en: "English",
  jp: "",
  fr: "Franais",
  de: "Deutsch",
  zhTw: ""
};
const i18nTranslationResources = {
  en: { translation: en },
  zhCn: { translation: zhCn },
  jp: { translation: jp },
  fr: { translation: fr },
  de: { translation: de },
  zhTw: { translation: zhTw }
};
const defaultLanguage = 0;
var playSpeed = /* @__PURE__ */ ((playSpeed2) => {
  playSpeed2[playSpeed2["slow"] = 0] = "slow";
  playSpeed2[playSpeed2["normal"] = 1] = "normal";
  playSpeed2[playSpeed2["fast"] = 2] = "fast";
  return playSpeed2;
})(playSpeed || {});
var textSize = /* @__PURE__ */ ((textSize2) => {
  textSize2[textSize2["small"] = 0] = "small";
  textSize2[textSize2["medium"] = 1] = "medium";
  textSize2[textSize2["large"] = 2] = "large";
  return textSize2;
})(textSize || {});
var textFont = /* @__PURE__ */ ((textFont2) => {
  textFont2[textFont2["song"] = 0] = "song";
  textFont2[textFont2["hei"] = 1] = "hei";
  textFont2[textFont2["lxgw"] = 2] = "lxgw";
  return textFont2;
})(textFont || {});
var voiceOption = /* @__PURE__ */ ((voiceOption2) => {
  voiceOption2[voiceOption2["yes"] = 0] = "yes";
  voiceOption2[voiceOption2["no"] = 1] = "no";
  return voiceOption2;
})(voiceOption || {});
var fullScreenOption = /* @__PURE__ */ ((fullScreenOption2) => {
  fullScreenOption2[fullScreenOption2["on"] = 0] = "on";
  fullScreenOption2[fullScreenOption2["off"] = 1] = "off";
  return fullScreenOption2;
})(fullScreenOption || {});
const initialOptionSet = {
  slPage: 1,
  volumeMain: 100,
  // 
  textSpeed: 50,
  //   [0, 100] =>[3, 80]
  autoSpeed: playSpeed.normal,
  // 
  textSize: textSize.medium,
  vocalVolume: 100,
  // 
  bgmVolume: 25,
  // 
  seVolume: 100,
  // 
  uiSeVolume: 50,
  // UI
  textboxFont: textFont.song,
  textboxOpacity: 75,
  language: language.zhCn,
  voiceInterruption: voiceOption.yes,
  fullScreen: fullScreenOption.off
};
const initState$2 = {
  optionData: initialOptionSet,
  globalGameVar: {},
  appreciationData: {
    bgm: [],
    cg: []
  }
};
const userDataSlice = createSlice({
  name: "userData",
  initialState: cloneDeep$1(initState$2),
  reducers: {
    /**
     * 
     * @param state
     * @param action
     */
    setUserData: (state, action) => {
      const { key, value } = action.payload;
      state[key] = value;
    },
    unlockCgInUserData: (state, action) => {
      const { name, url: url2, series } = action.payload;
      let isExist = false;
      state.appreciationData.cg.forEach((e2) => {
        if (url2 === e2.url) {
          isExist = true;
          e2.url = url2;
          e2.series = series;
        }
      });
      if (!isExist) {
        state.appreciationData.cg.push(action.payload);
      }
    },
    unlockBgmInUserData: (state, action) => {
      const { name, url: url2, series } = action.payload;
      let isExist = false;
      state.appreciationData.bgm.forEach((e2) => {
        if (url2 === e2.url) {
          isExist = true;
          e2.url = url2;
          e2.series = series;
        }
      });
      if (!isExist) {
        state.appreciationData.bgm.push(action.payload);
      }
    },
    /**
     * 
     * @param state
     * @param action
     */
    resetUserData: (state, action) => {
      Object.assign(state, action.payload);
    },
    /**
     * 
     * @param state
     * @param action
     */
    setOptionData: (state, action) => {
      const { key, value } = action.payload;
      state.optionData[key] = value;
    },
    /**
     * 
     * @param state 
     * @param action 
     */
    setGlobalVar: (state, action) => {
      state.globalGameVar[action.payload.key] = action.payload.value;
    },
    /**
     * /
     * @param state
     * @param action
     */
    setSlPage: (state, action) => {
      state.optionData.slPage = action.payload;
    },
    resetOptionSet(state) {
      Object.assign(state.optionData, initialOptionSet);
    },
    resetAllData(state) {
      Object.assign(state, cloneDeep$1(initState$2));
    }
  }
});
const {
  setUserData,
  resetUserData,
  setOptionData,
  setGlobalVar,
  setSlPage,
  unlockCgInUserData,
  unlockBgmInUserData,
  resetOptionSet,
  resetAllData
} = userDataSlice.actions;
const userDataReducer = userDataSlice.reducer;
const SYSTEM_CONFIG = {
  backlog_size: 200,
  fast_timeout: 50
};
const PERFORM_CONFIG = {
  // 50
  textInitialDelay: 80
};
class BacklogManager {
  constructor(sceneManager) {
    __publicField(this, "isSaveBacklogNext", false);
    __publicField(this, "backlog", []);
    __publicField(this, "sceneManager");
    this.sceneManager = sceneManager;
  }
  getBacklog() {
    return this.backlog;
  }
  editLastBacklogItemEffect(effects) {
    this.backlog[this.backlog.length - 1].currentStageState.effects = effects;
  }
  makeBacklogEmpty() {
    this.backlog.splice(0, this.backlog.length);
  }
  insertBacklogItem(item) {
    this.backlog.push(item);
  }
  saveCurrentStateToBacklog() {
    const currentStageState = webgalStore.getState().stage;
    const stageStateToBacklog = cloneDeep$1(currentStageState);
    stageStateToBacklog.PerformList.forEach((ele) => {
      ele.script.args.forEach((argelement) => {
        if (argelement.key === "concat") {
          argelement.value = false;
          ele.script.content = stageStateToBacklog.showText;
        }
      });
    });
    const backlogElement = {
      currentStageState: stageStateToBacklog,
      saveScene: {
        currentSentenceId: this.sceneManager.sceneData.currentSentenceId,
        // ID
        sceneStack: cloneDeep$1(this.sceneManager.sceneData.sceneStack),
        // 
        sceneName: this.sceneManager.sceneData.currentScene.sceneName,
        // 
        sceneUrl: this.sceneManager.sceneData.currentScene.sceneUrl
        // url
      }
    };
    this.getBacklog().push(backlogElement);
    while (this.getBacklog().length > SYSTEM_CONFIG.backlog_size) {
      this.getBacklog().shift();
    }
  }
}
var fileType$1 = /* @__PURE__ */ ((fileType2) => {
  fileType2[fileType2["background"] = 0] = "background";
  fileType2[fileType2["bgm"] = 1] = "bgm";
  fileType2[fileType2["figure"] = 2] = "figure";
  fileType2[fileType2["scene"] = 3] = "scene";
  fileType2[fileType2["tex"] = 4] = "tex";
  fileType2[fileType2["vocal"] = 5] = "vocal";
  fileType2[fileType2["video"] = 6] = "video";
  fileType2[fileType2["ui"] = 7] = "ui";
  return fileType2;
})(fileType$1 || {});
const assetSetter = (fileName, assetType) => {
  if (fileName.match("http://") || fileName.match("https://")) {
    return fileName;
  } else {
    let returnFilePath;
    switch (assetType) {
      case 0:
        returnFilePath = `./game/background/${fileName}`;
        break;
      case 3:
        returnFilePath = `./game/scene/${fileName}`;
        break;
      case 5:
        returnFilePath = `./game/vocal/${fileName}`;
        break;
      case 2:
        returnFilePath = `./game/figure/${fileName}`;
        break;
      case 1:
        returnFilePath = `./game/bgm/${fileName}`;
        break;
      case 6:
        returnFilePath = `./game/video/${fileName}`;
        break;
      case 7:
        returnFilePath = `./game/ui/${fileName}`;
        break;
      default:
        returnFilePath = ``;
        break;
    }
    return returnFilePath;
  }
};
const assetsPrefetcher = (assetList, sceneName) => {
  WebGAL.sceneManager.sceneAssetsList[sceneName] = assetList.reduce((p, c2) => {
    p[c2.url] = false;
    return p;
  }, {});
  for (const asset of assetList) {
    const hasHandled = !!WebGAL.sceneManager.settledAssets.find((settledAssetUrl) => {
      if (settledAssetUrl === asset.url) {
        return true;
      }
      return false;
    });
    const assetsLoadedObject = WebGAL.sceneManager.sceneAssetsList[sceneName];
    if (hasHandled) {
      assetsLoadedObject[asset.url] = true;
      checkIfAllSceneAssetsAreSettled(sceneName);
      logger.warn("");
    } else {
      console.log("", asset.url);
      if (asset.url.endsWith(".mp4") || asset.url.endsWith(".flv")) {
        assetsLoadedObject[asset.url] = true;
        checkIfAllSceneAssetsAreSettled(sceneName);
        WebGAL.videoManager.preloadVideo(asset.url);
      } else {
        const newLink = document.createElement("link");
        newLink.setAttribute("rel", "prefetch");
        newLink.setAttribute("href", asset.url);
        const head = document.getElementsByTagName("head");
        if (head.length) {
          head[0].appendChild(newLink);
        }
        newLink.onload = () => {
          assetsLoadedObject[asset.url] = true;
          checkIfAllSceneAssetsAreSettled(sceneName);
        };
        WebGAL.sceneManager.settledAssets.push(asset.url);
      }
    }
  }
};
const checkIfAllSceneAssetsAreSettled = (sceneName) => {
  const assetsLoadedObject = WebGAL.sceneManager.sceneAssetsList[sceneName];
  const allSettled2 = Object.values(assetsLoadedObject).every((x) => x);
  if (allSettled2) {
    WebGAL.sceneManager.sceneAssetsLoadedList[sceneName] = true;
    window.pubsub.publish("sceneAssetsLoaded", { sceneName });
  }
};
var commandType;
(function(commandType2) {
  commandType2[commandType2["say"] = 0] = "say";
  commandType2[commandType2["changeBg"] = 1] = "changeBg";
  commandType2[commandType2["changeFigure"] = 2] = "changeFigure";
  commandType2[commandType2["bgm"] = 3] = "bgm";
  commandType2[commandType2["video"] = 4] = "video";
  commandType2[commandType2["pixi"] = 5] = "pixi";
  commandType2[commandType2["pixiInit"] = 6] = "pixiInit";
  commandType2[commandType2["intro"] = 7] = "intro";
  commandType2[commandType2["miniAvatar"] = 8] = "miniAvatar";
  commandType2[commandType2["changeScene"] = 9] = "changeScene";
  commandType2[commandType2["choose"] = 10] = "choose";
  commandType2[commandType2["end"] = 11] = "end";
  commandType2[commandType2["setComplexAnimation"] = 12] = "setComplexAnimation";
  commandType2[commandType2["setFilter"] = 13] = "setFilter";
  commandType2[commandType2["label"] = 14] = "label";
  commandType2[commandType2["jumpLabel"] = 15] = "jumpLabel";
  commandType2[commandType2["chooseLabel"] = 16] = "chooseLabel";
  commandType2[commandType2["setVar"] = 17] = "setVar";
  commandType2[commandType2["if"] = 18] = "if";
  commandType2[commandType2["callScene"] = 19] = "callScene";
  commandType2[commandType2["showVars"] = 20] = "showVars";
  commandType2[commandType2["unlockCg"] = 21] = "unlockCg";
  commandType2[commandType2["unlockBgm"] = 22] = "unlockBgm";
  commandType2[commandType2["filmMode"] = 23] = "filmMode";
  commandType2[commandType2["setTextbox"] = 24] = "setTextbox";
  commandType2[commandType2["setAnimation"] = 25] = "setAnimation";
  commandType2[commandType2["playEffect"] = 26] = "playEffect";
  commandType2[commandType2["setTempAnimation"] = 27] = "setTempAnimation";
  commandType2[commandType2["comment"] = 28] = "comment";
  commandType2[commandType2["setTransform"] = 29] = "setTransform";
  commandType2[commandType2["setTransition"] = 30] = "setTransition";
  commandType2[commandType2["getUserInput"] = 31] = "getUserInput";
  commandType2[commandType2["applyStyle"] = 32] = "applyStyle";
})(commandType || (commandType = {}));
[
  { scriptString: "intro", scriptType: commandType.intro },
  { scriptString: "changeBg", scriptType: commandType.changeBg },
  { scriptString: "changeFigure", scriptType: commandType.changeFigure },
  { scriptString: "miniAvatar", scriptType: commandType.miniAvatar },
  { scriptString: "changeScene", scriptType: commandType.changeScene },
  { scriptString: "choose", scriptType: commandType.choose },
  { scriptString: "end", scriptType: commandType.end },
  { scriptString: "bgm", scriptType: commandType.bgm },
  { scriptString: "playVideo", scriptType: commandType.video },
  {
    scriptString: "setComplexAnimation",
    scriptType: commandType.setComplexAnimation
  },
  { scriptString: "setFilter", scriptType: commandType.setFilter },
  { scriptString: "pixiInit", scriptType: commandType.pixiInit },
  { scriptString: "pixiPerform", scriptType: commandType.pixi },
  { scriptString: "label", scriptType: commandType.label },
  { scriptString: "jumpLabel", scriptType: commandType.jumpLabel },
  { scriptString: "setVar", scriptType: commandType.setVar },
  { scriptString: "callScene", scriptType: commandType.callScene },
  { scriptString: "showVars", scriptType: commandType.showVars },
  { scriptString: "unlockCg", scriptType: commandType.unlockCg },
  { scriptString: "unlockBgm", scriptType: commandType.unlockBgm },
  { scriptString: "say", scriptType: commandType.say },
  { scriptString: "filmMode", scriptType: commandType.filmMode },
  { scriptString: "callScene", scriptType: commandType.callScene },
  { scriptString: "setTextbox", scriptType: commandType.setTextbox },
  { scriptString: "setAnimation", scriptType: commandType.setAnimation },
  { scriptString: "playEffect", scriptType: commandType.playEffect },
  { scriptString: "applyStyle", scriptType: commandType.applyStyle }
];
[
  commandType.bgm,
  commandType.pixi,
  commandType.pixiInit,
  commandType.label,
  commandType.if,
  commandType.miniAvatar,
  commandType.setVar,
  commandType.unlockBgm,
  commandType.unlockCg,
  commandType.filmMode,
  commandType.playEffect
];
var fileType;
(function(fileType2) {
  fileType2[fileType2["background"] = 0] = "background";
  fileType2[fileType2["bgm"] = 1] = "bgm";
  fileType2[fileType2["figure"] = 2] = "figure";
  fileType2[fileType2["scene"] = 3] = "scene";
  fileType2[fileType2["tex"] = 4] = "tex";
  fileType2[fileType2["vocal"] = 5] = "vocal";
  fileType2[fileType2["video"] = 6] = "video";
})(fileType || (fileType = {}));
function argsParser(argsRaw, assetSetter2) {
  const returnArrayList = [];
  let newArgsRaw = argsRaw.replace(/ /g, " ");
  let rawArgsList = newArgsRaw.split(" -");
  rawArgsList = rawArgsList.filter((e2) => {
    return e2 !== "";
  });
  rawArgsList.forEach((e2) => {
    const equalSignIndex = e2.indexOf("=");
    let argName = e2.slice(0, equalSignIndex);
    let argValue = e2.slice(equalSignIndex + 1);
    if (equalSignIndex < 0) {
      argName = e2;
      argValue = void 0;
    }
    if (argName.toLowerCase().match(/.ogg|.mp3|.wav/)) {
      returnArrayList.push({
        key: "vocal",
        value: assetSetter2(e2, fileType.vocal)
      });
    } else {
      if (argValue === void 0) {
        returnArrayList.push({
          key: argName,
          value: true
        });
      } else {
        if (argValue === "true" || argValue === "false") {
          returnArrayList.push({
            key: argName,
            value: argValue === "true"
          });
        } else {
          if (!isNaN(Number(argValue))) {
            returnArrayList.push({
              key: argName,
              value: Number(argValue)
            });
          } else {
            returnArrayList.push({
              key: argName,
              value: argValue
            });
          }
        }
      }
    }
  });
  return returnArrayList;
}
function configLineParser(inputLine) {
  const options = [];
  let command;
  let newSentenceRaw = inputLine.split(";")[0];
  if (newSentenceRaw === "") {
    return {
      command: "",
      args: [],
      options: []
    };
  }
  const getCommandResult = /:/.exec(newSentenceRaw);
  if (getCommandResult === null) {
    command = "";
  } else {
    command = newSentenceRaw.substring(0, getCommandResult.index);
    newSentenceRaw = newSentenceRaw.substring(getCommandResult.index + 1, newSentenceRaw.length);
  }
  const getOptionsResult = / -/.exec(newSentenceRaw);
  if (getOptionsResult) {
    const optionsRaw = newSentenceRaw.substring(getOptionsResult.index, newSentenceRaw.length);
    newSentenceRaw = newSentenceRaw.substring(0, getOptionsResult.index);
    for (const e2 of argsParser(optionsRaw, (name, _24) => {
      return name;
    })) {
      options.push(e2);
    }
  }
  return {
    command,
    args: newSentenceRaw.split("|").map((e2) => e2.trim()).filter((e2) => e2 !== ""),
    options
  };
}
function configParser(configText) {
  const configLines = configText.replaceAll(`\r`, "").split("\n");
  return configLines.map((e2) => configLineParser(e2)).filter((e2) => e2.command !== "");
}
const commandParser = (commandRaw, ADD_NEXT_ARG_LIST2, SCRIPT_CONFIG_MAP) => {
  let returnCommand = {
    type: commandType.say,
    additionalArgs: []
  };
  const type2 = getCommandType(commandRaw, ADD_NEXT_ARG_LIST2, SCRIPT_CONFIG_MAP);
  returnCommand.type = type2;
  if (type2 === commandType.say && commandRaw !== "say") {
    returnCommand.additionalArgs.push({
      key: "speaker",
      value: commandRaw
    });
  }
  returnCommand = addNextArg(returnCommand, type2, ADD_NEXT_ARG_LIST2);
  return returnCommand;
};
function getCommandType(command, ADD_NEXT_ARG_LIST2, SCRIPT_CONFIG_MAP) {
  var _a2;
  return ((_a2 = SCRIPT_CONFIG_MAP.get(command)) == null ? void 0 : _a2.scriptType) ?? commandType.say;
}
function addNextArg(commandToParse, thisCommandType, ADD_NEXT_ARG_LIST2) {
  if (ADD_NEXT_ARG_LIST2.includes(thisCommandType)) {
    commandToParse.additionalArgs.push({
      key: "next",
      value: true
    });
  }
  return commandToParse;
}
const contentParser = (contentRaw, type2, assetSetter2) => {
  if (contentRaw === "none" || contentRaw === "") {
    return "";
  }
  switch (type2) {
    case commandType.playEffect:
      return assetSetter2(contentRaw, fileType.vocal);
    case commandType.changeBg:
      return assetSetter2(contentRaw, fileType.background);
    case commandType.changeFigure:
      return assetSetter2(contentRaw, fileType.figure);
    case commandType.bgm:
      return assetSetter2(contentRaw, fileType.bgm);
    case commandType.callScene:
      return assetSetter2(contentRaw, fileType.scene);
    case commandType.changeScene:
      return assetSetter2(contentRaw, fileType.scene);
    case commandType.miniAvatar:
      return assetSetter2(contentRaw, fileType.figure);
    case commandType.video:
      return assetSetter2(contentRaw, fileType.video);
    case commandType.choose:
      return getChooseContent(contentRaw, assetSetter2);
    case commandType.unlockBgm:
      return assetSetter2(contentRaw, fileType.bgm);
    case commandType.unlockCg:
      return assetSetter2(contentRaw, fileType.background);
    default:
      return contentRaw;
  }
};
function getChooseContent(contentRaw, assetSetter2) {
  const chooseList = contentRaw.split("|");
  const chooseKeyList = [];
  const chooseValueList = [];
  for (const e2 of chooseList) {
    chooseKeyList.push(e2.split(":")[0] ?? "");
    chooseValueList.push(e2.split(":")[1] ?? "");
  }
  const parsedChooseList = chooseValueList.map((e2) => {
    if (e2.match(/\./)) {
      return assetSetter2(e2, fileType.scene);
    } else {
      return e2;
    }
  });
  let ret = "";
  for (let i2 = 0; i2 < chooseKeyList.length; i2++) {
    if (i2 !== 0) {
      ret = ret + "|";
    }
    ret = ret + `${chooseKeyList[i2]}:${parsedChooseList[i2]}`;
  }
  return ret;
}
const assetsScanner = (command, content, args) => {
  const returnAssetsList = [];
  if (command === commandType.say) {
    args.forEach((e2) => {
      if (e2.key === "vocal") {
        returnAssetsList.push({
          name: e2.value,
          url: e2.value,
          lineNumber: 0,
          type: fileType.vocal
        });
      }
    });
  }
  if (content === "none" || content === "") {
    return returnAssetsList;
  }
  if (command === commandType.changeBg) {
    returnAssetsList.push({
      name: content,
      url: content,
      lineNumber: 0,
      type: fileType.background
    });
  }
  if (command === commandType.changeFigure) {
    returnAssetsList.push({
      name: content,
      url: content,
      lineNumber: 0,
      type: fileType.figure
    });
  }
  if (command === commandType.miniAvatar) {
    returnAssetsList.push({
      name: content,
      url: content,
      lineNumber: 0,
      type: fileType.figure
    });
  }
  if (command === commandType.video) {
    returnAssetsList.push({
      name: content,
      url: content,
      lineNumber: 0,
      type: fileType.video
    });
  }
  if (command === commandType.bgm) {
    returnAssetsList.push({
      name: content,
      url: content,
      lineNumber: 0,
      type: fileType.bgm
    });
  }
  return returnAssetsList;
};
const subSceneScanner = (command, content) => {
  const subSceneList = [];
  if (command === commandType.changeScene || command === commandType.callScene) {
    subSceneList.push(content);
  }
  if (command === commandType.choose || command === commandType.video) {
    const chooseList = content.split("|");
    const chooseValue = chooseList.map((e2) => e2.split(":")[1] ?? "");
    chooseValue.forEach((e2) => {
      if (e2.match(/\./)) {
        subSceneList.push(e2);
      }
    });
  }
  return subSceneList;
};
const scriptParser = (sentenceRaw, assetSetter2, ADD_NEXT_ARG_LIST2, SCRIPT_CONFIG_MAP) => {
  let command;
  let content;
  let subScene;
  const args = [];
  let sentenceAssets;
  let parsedCommand;
  let commandRaw;
  let newSentenceRaw = sentenceRaw.split(";")[0];
  if (newSentenceRaw === "") {
    return {
      command: commandType.comment,
      commandRaw: "comment",
      content: sentenceRaw.split(";")[1] ?? "",
      args: [{ key: "next", value: true }],
      sentenceAssets: [],
      subScene: []
      // 
    };
  }
  const getCommandResult = /:/.exec(newSentenceRaw);
  if (getCommandResult === null) {
    commandRaw = newSentenceRaw;
    parsedCommand = commandParser(commandRaw, ADD_NEXT_ARG_LIST2, SCRIPT_CONFIG_MAP);
    command = parsedCommand.type;
    for (const e2 of parsedCommand.additionalArgs) {
      if (command === commandType.say && e2.key === "speaker") {
        continue;
      }
      args.push(e2);
    }
  } else {
    commandRaw = newSentenceRaw.substring(0, getCommandResult.index);
    newSentenceRaw = newSentenceRaw.substring(getCommandResult.index + 1, newSentenceRaw.length);
    parsedCommand = commandParser(commandRaw, ADD_NEXT_ARG_LIST2, SCRIPT_CONFIG_MAP);
    command = parsedCommand.type;
    for (const e2 of parsedCommand.additionalArgs) {
      args.push(e2);
    }
  }
  const getArgsResult = / -/.exec(newSentenceRaw);
  if (getArgsResult) {
    const argsRaw = newSentenceRaw.substring(getArgsResult.index, sentenceRaw.length);
    newSentenceRaw = newSentenceRaw.substring(0, getArgsResult.index);
    for (const e2 of argsParser(argsRaw, assetSetter2)) {
      args.push(e2);
    }
  }
  content = contentParser(newSentenceRaw, command, assetSetter2);
  sentenceAssets = assetsScanner(command, content, args);
  subScene = subSceneScanner(command, content);
  return {
    command,
    commandRaw,
    content,
    args,
    sentenceAssets,
    subScene
    // 
  };
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$4 = freeGlobal || freeSelf || Function("return this")();
var _root = root$4;
var root$3 = _root;
var Symbol$2$1 = root$3.Symbol;
var _Symbol = Symbol$2$1;
var Symbol$1$1 = _Symbol;
var objectProto$4 = Object.prototype;
var hasOwnProperty$3$1 = objectProto$4.hasOwnProperty;
var nativeObjectToString$1 = objectProto$4.toString;
var symToStringTag$1 = Symbol$1$1 ? Symbol$1$1.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$3$1.call(value, symToStringTag$1), tag2 = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag2;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$3 = Object.prototype;
var nativeObjectToString = objectProto$3.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$3 = _Symbol, getRawTag = _getRawTag, objectToString$2 = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$3 ? Symbol$3.toStringTag : void 0;
function baseGetTag$1(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString$2(value);
}
var _baseGetTag = baseGetTag$1;
function isObject$2$1(value) {
  var type2 = typeof value;
  return value != null && (type2 == "object" || type2 == "function");
}
var isObject_1 = isObject$2$1;
var baseGetTag$2 = _baseGetTag, isObject$1$1 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$1$1(value) {
  if (!isObject$1$1(value)) {
    return false;
  }
  var tag2 = baseGetTag$2(value);
  return tag2 == funcTag || tag2 == genTag || tag2 == asyncTag || tag2 == proxyTag;
}
var isFunction_1 = isFunction$1$1;
var root$2 = _root;
var coreJsData$1 = root$2["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource$1(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var _toSource = toSource$1;
var isFunction$2 = isFunction_1, isMasked = _isMasked, isObject$7 = isObject_1, toSource = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$2 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$2$1 = objectProto$2.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$2$1).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject$7(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative, getValue$2 = _getValue;
function getNative$3(object, key) {
  var value = getValue$2(object, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$3;
var getNative$2 = _getNative;
var nativeCreate$4 = getNative$2(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$1$1 = Object.prototype;
var hasOwnProperty$1$1 = objectProto$1$1.hasOwnProperty;
function hashGet$1(key) {
  var data2 = this.__data__;
  if (nativeCreate$2) {
    var result = data2[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$1$1.call(data2, key) ? data2[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function hashHas$1(key) {
  var data2 = this.__data__;
  return nativeCreate$1 ? data2[key] !== void 0 : hasOwnProperty$4.call(data2, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data2 = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$1(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$1;
var eq$2 = eq_1;
function assocIndexOf$4(array, key) {
  var length2 = array.length;
  while (length2--) {
    if (eq$2(array[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data2 = this.__data__, index2 = assocIndexOf$3(data2, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data2.length - 1;
  if (index2 == lastIndex) {
    data2.pop();
  } else {
    splice.call(data2, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data2 = this.__data__, index2 = assocIndexOf$2(data2, key);
  return index2 < 0 ? void 0 : data2[index2][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key);
  if (index2 < 0) {
    ++this.size;
    data2.push([key, value]);
  } else {
    data2[index2][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$1(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$1.prototype.clear = listCacheClear;
ListCache$1.prototype["delete"] = listCacheDelete;
ListCache$1.prototype.get = listCacheGet;
ListCache$1.prototype.has = listCacheHas;
ListCache$1.prototype.set = listCacheSet;
var _ListCache = ListCache$1;
var getNative$1 = _getNative, root$1 = _root;
var Map$2 = getNative$1(root$1, "Map");
var _Map = Map$2;
var Hash = _Hash, ListCache = _ListCache, Map$1 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$1 || ListCache)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type2 = typeof value;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map2, key) {
  var data2 = map2.__data__;
  return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data2 = getMapData(this, key), size = data2.size;
  data2.set(key, value);
  this.size += data2.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$1$1(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$1$1.prototype.clear = mapCacheClear;
MapCache$1$1.prototype["delete"] = mapCacheDelete;
MapCache$1$1.prototype.get = mapCacheGet;
MapCache$1$1.prototype.has = mapCacheHas;
MapCache$1$1.prototype.set = mapCacheSet;
var _MapCache = MapCache$1$1;
var HASH_UNDEFINED$3 = "__lodash_hash_undefined__";
function setCacheAdd$1$1(value) {
  this.__data__.set(value, HASH_UNDEFINED$3);
  return this;
}
var _setCacheAdd$1 = setCacheAdd$1$1;
function setCacheHas$1$1(value) {
  return this.__data__.has(value);
}
var _setCacheHas$1 = setCacheHas$1$1;
var MapCache$2 = _MapCache, setCacheAdd$2 = _setCacheAdd$1, setCacheHas$2 = _setCacheHas$1;
function SetCache$1$1(values) {
  var index2 = -1, length2 = values == null ? 0 : values.length;
  this.__data__ = new MapCache$2();
  while (++index2 < length2) {
    this.add(values[index2]);
  }
}
SetCache$1$1.prototype.add = SetCache$1$1.prototype.push = setCacheAdd$2;
SetCache$1$1.prototype.has = setCacheHas$2;
var _SetCache$1 = SetCache$1$1;
function baseFindIndex$1$1(array, predicate, fromIndex, fromRight) {
  var length2 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length2) {
    if (predicate(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
}
var _baseFindIndex$1 = baseFindIndex$1$1;
function baseIsNaN$1$1(value) {
  return value !== value;
}
var _baseIsNaN$1 = baseIsNaN$1$1;
function strictIndexOf$1$1(array, value, fromIndex) {
  var index2 = fromIndex - 1, length2 = array.length;
  while (++index2 < length2) {
    if (array[index2] === value) {
      return index2;
    }
  }
  return -1;
}
var _strictIndexOf$1 = strictIndexOf$1$1;
var baseFindIndex$2 = _baseFindIndex$1, baseIsNaN$2 = _baseIsNaN$1, strictIndexOf$2 = _strictIndexOf$1;
function baseIndexOf$1$1(array, value, fromIndex) {
  return value === value ? strictIndexOf$2(array, value, fromIndex) : baseFindIndex$2(array, baseIsNaN$2, fromIndex);
}
var _baseIndexOf$1 = baseIndexOf$1$1;
var baseIndexOf$2 = _baseIndexOf$1;
function arrayIncludes$1$1(array, value) {
  var length2 = array == null ? 0 : array.length;
  return !!length2 && baseIndexOf$2(array, value, 0) > -1;
}
var _arrayIncludes$1 = arrayIncludes$1$1;
function arrayIncludesWith$1$1(array, value, comparator) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (comparator(value, array[index2])) {
      return true;
    }
  }
  return false;
}
var _arrayIncludesWith$1 = arrayIncludesWith$1$1;
function cacheHas$1$1(cache, key) {
  return cache.has(key);
}
var _cacheHas$1 = cacheHas$1$1;
var getNative = _getNative, root$5 = _root;
var Set$1$1 = getNative(root$5, "Set");
var _Set = Set$1$1;
function noop$1$1() {
}
var noop_1$1 = noop$1$1;
function setToArray$2$1(set) {
  var index2 = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var _setToArray$1 = setToArray$2$1;
var Set$2 = _Set, noop$5 = noop_1$1, setToArray$1$1 = _setToArray$1;
var INFINITY$3 = 1 / 0;
var createSet$1$1 = !(Set$2 && 1 / setToArray$1$1(new Set$2([, -0]))[1] == INFINITY$3) ? noop$5 : function(values) {
  return new Set$2(values);
};
var _createSet$1 = createSet$1$1;
var SetCache$3 = _SetCache$1, arrayIncludes$2 = _arrayIncludes$1, arrayIncludesWith$2 = _arrayIncludesWith$1, cacheHas$3 = _cacheHas$1, createSet$2 = _createSet$1, setToArray$4 = _setToArray$1;
var LARGE_ARRAY_SIZE$1 = 200;
function baseUniq$1$1(array, iteratee, comparator) {
  var index2 = -1, includes = arrayIncludes$2, length2 = array.length, isCommon = true, result = [], seen2 = result;
  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith$2;
  } else if (length2 >= LARGE_ARRAY_SIZE$1) {
    var set = iteratee ? null : createSet$2(array);
    if (set) {
      return setToArray$4(set);
    }
    isCommon = false;
    includes = cacheHas$3;
    seen2 = new SetCache$3();
  } else {
    seen2 = iteratee ? [] : result;
  }
  outer:
    while (++index2 < length2) {
      var value = array[index2], computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen2.length;
        while (seenIndex--) {
          if (seen2[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen2.push(computed);
        }
        result.push(value);
      } else if (!includes(seen2, computed, comparator)) {
        if (seen2 !== result) {
          seen2.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
var _baseUniq$1 = baseUniq$1$1;
var baseUniq$2 = _baseUniq$1;
function uniqWith$2(array, comparator) {
  comparator = typeof comparator == "function" ? comparator : void 0;
  return array && array.length ? baseUniq$2(array, void 0, comparator) : [];
}
var uniqWith_1$1 = uniqWith$2;
const sceneParser$1 = (rawScene, sceneName, sceneUrl, assetsPrefetcher2, assetSetter2, ADD_NEXT_ARG_LIST2, SCRIPT_CONFIG_MAP) => {
  const rawSentenceList = rawScene.split("\n");
  const rawSentenceListWithoutEmpty = rawSentenceList;
  let assetsList = [];
  let subSceneList = [];
  const sentenceList = rawSentenceListWithoutEmpty.map((sentence) => {
    const returnSentence = scriptParser(sentence, assetSetter2, ADD_NEXT_ARG_LIST2, SCRIPT_CONFIG_MAP);
    assetsList = [...assetsList, ...returnSentence.sentenceAssets];
    subSceneList = [...subSceneList, ...returnSentence.subScene];
    return returnSentence;
  });
  assetsList = uniqWith_1$1(assetsList);
  assetsPrefetcher2(assetsList, sceneName);
  return {
    sceneName,
    sceneUrl,
    sentenceList,
    assetsList,
    subSceneList
    // 
  };
};
function scss2cssinjsParser$1(scssString) {
  const [classNameStyles, others] = parseCSS(scssString);
  return {
    classNameStyles,
    others
  };
}
function parseCSS(css2) {
  const result = {};
  let specialRules = "";
  let matches;
  const classRegex = /\.([^{\s]+)\s*{((?:[^{}]*|{[^}]*})*)}/g;
  const specialRegex = /(@[^{]+{\s*(?:[^{}]*{[^}]*}[^{}]*)+\s*})/g;
  while ((matches = classRegex.exec(css2)) !== null) {
    const key = matches[1];
    const value = matches[2].trim().replace(/\s*;\s*/g, ";\n");
    result[key] = value;
  }
  while ((matches = specialRegex.exec(css2)) !== null) {
    specialRules += matches[1].trim() + "\n";
  }
  return [result, specialRules.trim()];
}
class SceneParser {
  constructor(assetsPrefetcher2, assetSetter2, ADD_NEXT_ARG_LIST2, SCRIPT_CONFIG_INPUT) {
    __publicField(this, "assetsPrefetcher");
    __publicField(this, "assetSetter");
    __publicField(this, "ADD_NEXT_ARG_LIST");
    __publicField(this, "SCRIPT_CONFIG_MAP");
    this.assetsPrefetcher = assetsPrefetcher2;
    this.assetSetter = assetSetter2;
    this.ADD_NEXT_ARG_LIST = ADD_NEXT_ARG_LIST2;
    if (Array.isArray(SCRIPT_CONFIG_INPUT)) {
      this.SCRIPT_CONFIG_MAP = /* @__PURE__ */ new Map();
      SCRIPT_CONFIG_INPUT.forEach((config) => {
        this.SCRIPT_CONFIG_MAP.set(config.scriptString, config);
      });
    } else {
      this.SCRIPT_CONFIG_MAP = SCRIPT_CONFIG_INPUT;
    }
  }
  /**
   * 
   * @param rawScene 
   * @param sceneName 
   * @param sceneUrl url
   * @return 
   */
  parse(rawScene, sceneName, sceneUrl) {
    return sceneParser$1(rawScene, sceneName, sceneUrl, this.assetsPrefetcher, this.assetSetter, this.ADD_NEXT_ARG_LIST, this.SCRIPT_CONFIG_MAP);
  }
  parseConfig(configText) {
    return configParser(configText);
  }
  stringifyConfig(config) {
    return config.reduce((previousValue, curr) => previousValue + `${curr.command}:${curr.args.join("|")}${curr.options.length <= 0 ? "" : curr.options.reduce((p, c2) => p + " -" + c2.key + "=" + c2.value, "")};
`, "");
  }
  parseScssToWebgalStyleObj(scssString) {
    return scss2cssinjsParser$1(scssString);
  }
}
function getSentenceArgByKey(sentnece, argk) {
  const args = sentnece.args;
  const result = args.find((arg) => arg.key === argk);
  if (result) {
    return result.value;
  } else
    return null;
}
const bgm = (sentence) => {
  let url2 = sentence.content;
  let name = "";
  let series = "default";
  sentence.args.forEach((e2) => {
    if (e2.key === "unlockname") {
      name = e2.value.toString();
    }
    if (e2.key === "series") {
      series = e2.value.toString();
    }
  });
  const enter = getSentenceArgByKey(sentence, "enter");
  const volume = getSentenceArgByKey(sentence, "volume");
  if (name !== "")
    webgalStore.dispatch(unlockBgmInUserData({ name, url: url2, series }));
  playBgm(
    url2,
    typeof enter === "number" && enter >= 0 ? enter : 0,
    // 
    typeof volume === "number" && volume >= 0 && volume <= 100 ? volume : 100
    // 
  );
  return {
    performName: "none",
    duration: 0,
    isHoldOn: true,
    stopFunction: () => {
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
var axios$3 = { exports: {} };
var bind$5 = function bind2(fn2, thisArg) {
  return function wrap() {
    return fn2.apply(thisArg, arguments);
  };
};
var bind$4 = bind$5;
var toString$3 = Object.prototype.toString;
var kindOf = function(cache) {
  return function(thing) {
    var str = toString$3.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  };
}(/* @__PURE__ */ Object.create(null));
function kindOfTest(type2) {
  type2 = type2.toLowerCase();
  return function isKindOf(thing) {
    return kindOf(thing) === type2;
  };
}
function isArray$c(val) {
  return Array.isArray(val);
}
function isUndefined$3(val) {
  return typeof val === "undefined";
}
function isBuffer$3(val) {
  return val !== null && !isUndefined$3(val) && val.constructor !== null && !isUndefined$3(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
var isArrayBuffer$1 = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer$1(val.buffer);
  }
  return result;
}
function isString$3(val) {
  return typeof val === "string";
}
function isNumber$2(val) {
  return typeof val === "number";
}
function isObject$6(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject(val) {
  if (kindOf(val) !== "object") {
    return false;
  }
  var prototype2 = Object.getPrototypeOf(val);
  return prototype2 === null || prototype2 === Object.prototype;
}
function isEmptyObject(val) {
  return val && Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
}
var isDate$1 = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
function isFunction$1(val) {
  return toString$3.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject$6(val) && isFunction$1(val.pipe);
}
function isFormData(thing) {
  var pattern = "[object FormData]";
  return thing && (typeof FormData === "function" && thing instanceof FormData || toString$3.call(thing) === pattern || isFunction$1(thing.toString) && thing.toString() === pattern);
}
var isURLSearchParams = kindOfTest("URLSearchParams");
function trim$1(str) {
  return str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
function isStandardBrowserEnv() {
  var product;
  if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach$1(obj, fn2) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$c(obj)) {
    for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn2.call(null, obj[i2], i2, obj);
    }
  } else {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn2.call(null, obj[key], key, obj);
      }
    }
  }
}
function merge$2() {
  var result = {};
  function assignValue2(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge$2(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge$2({}, val);
    } else if (isArray$c(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }
  for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    forEach$1(arguments[i2], assignValue2);
  }
  return result;
}
function extend(a2, b2, thisArg) {
  forEach$1(b2, function assignValue2(val, key) {
    if (thisArg && typeof val === "function") {
      a2[key] = bind$4(val, thisArg);
    } else {
      a2[key] = val;
    }
  });
  return a2;
}
function stripBOM(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}
function inherits(constructor, superConstructor, props, descriptors2) {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  props && Object.assign(constructor.prototype, props);
}
function toFlatObject(sourceObj, destObj, filter2, propFilter) {
  var props;
  var i2;
  var prop;
  var merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && Object.getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
}
function endsWith(str, searchString, position2) {
  str = String(str);
  if (position2 === void 0 || position2 > str.length) {
    position2 = str.length;
  }
  position2 -= searchString.length;
  var lastIndex = str.indexOf(searchString, position2);
  return lastIndex !== -1 && lastIndex === position2;
}
function toArray(thing) {
  if (!thing)
    return null;
  if (isArray$c(thing))
    return thing;
  var i2 = thing.length;
  if (!isNumber$2(i2))
    return null;
  var arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
}
var isTypedArray$2 = function(TypedArray2) {
  return function(thing) {
    return TypedArray2 && thing instanceof TypedArray2;
  };
}(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
function forEachEntry(obj, fn2) {
  var generator = obj && obj[Symbol.iterator];
  var iterator = generator.call(obj);
  var result;
  while ((result = iterator.next()) && !result.done) {
    var pair = result.value;
    fn2.call(obj, pair[0], pair[1]);
  }
}
function matchAll(regExp, str) {
  var matches;
  var arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
}
var isHTMLForm = kindOfTest("HTMLFormElement");
var hasOwnProperty$3 = function resolver(_hasOwnProperty) {
  return function(obj, prop) {
    return _hasOwnProperty.call(obj, prop);
  };
}(Object.prototype.hasOwnProperty);
var utils$h = {
  isArray: isArray$c,
  isArrayBuffer: isArrayBuffer$1,
  isBuffer: isBuffer$3,
  isFormData,
  isArrayBufferView,
  isString: isString$3,
  isNumber: isNumber$2,
  isObject: isObject$6,
  isPlainObject,
  isEmptyObject,
  isUndefined: isUndefined$3,
  isDate: isDate$1,
  isFile,
  isBlob,
  isFunction: isFunction$1,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach: forEach$1,
  merge: merge$2,
  extend,
  trim: trim$1,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  isTypedArray: isTypedArray$2,
  isFileList,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty$3
};
var utils$g = utils$h;
function AxiosError$3(message, code, config, request3, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request3 && (this.request = request3);
  response && (this.response = response);
}
utils$g.inherits(AxiosError$3, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype$1 = AxiosError$3.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach(function(code) {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError$3, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError$3.from = function(error2, code, config, request3, response, customProps) {
  var axiosError = Object.create(prototype$1);
  utils$g.toFlatObject(error2, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  });
  AxiosError$3.call(axiosError, error2.message, code, config, request3, response);
  axiosError.cause = error2;
  axiosError.name = error2.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_1 = AxiosError$3;
var browser$1 = typeof self == "object" ? self.FormData : window.FormData;
var FormData$1 = browser$1;
var utils$f = utils$h;
var AxiosError$2 = AxiosError_1;
var envFormData = FormData$1;
function isVisitable(thing) {
  return utils$f.isPlainObject(thing) || utils$f.isArray(thing);
}
function removeBrackets(key) {
  return utils$f.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token2, i2) {
    token2 = removeBrackets(token2);
    return !dots && i2 ? "[" + token2 + "]" : token2;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$f.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils$f.toFlatObject(utils$f, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function isSpecCompliant(thing) {
  return thing && utils$f.isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator];
}
function toFormData$3(obj, formData, options) {
  if (!utils$f.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (envFormData || FormData)();
  options = utils$f.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$f.isUndefined(source[option]);
  });
  var metaTokens = options.metaTokens;
  var visitor = options.visitor || defaultVisitor;
  var dots = options.dots;
  var indexes = options.indexes;
  var _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  var useBlob = _Blob && isSpecCompliant(formData);
  if (!utils$f.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils$f.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$f.isBlob(value)) {
      throw new AxiosError$2("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$f.isArrayBuffer(value) || utils$f.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    var arr = value;
    if (value && !path && typeof value === "object") {
      if (utils$f.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$f.isArray(value) && isFlatArray(value) || (utils$f.isFileList(value) || utils$f.endsWith(key, "[]") && (arr = utils$f.toArray(value)))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index2) {
          !utils$f.isUndefined(el) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  var stack = [];
  var exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils$f.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils$f.forEach(value, function each(el, key) {
      var result = !utils$f.isUndefined(el) && visitor.call(
        formData,
        el,
        utils$f.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$f.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_1 = toFormData$3;
var toFormData$2 = toFormData_1;
function encode$2(str) {
  var charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'\(\)~]|%20|%00/g, function replacer(match2) {
    return charMap[match2];
  });
}
function AxiosURLSearchParams$2(params, options) {
  this._pairs = [];
  params && toFormData$2(params, this, options);
}
var prototype = AxiosURLSearchParams$2.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString(encoder) {
  var _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$2);
  } : encode$2;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_1 = AxiosURLSearchParams$2;
var utils$e = utils$h;
var AxiosURLSearchParams$1 = AxiosURLSearchParams_1;
function encode$1(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$1 = function buildURL2(url2, params, options) {
  if (!params) {
    return url2;
  }
  var hashmarkIndex = url2.indexOf("#");
  if (hashmarkIndex !== -1) {
    url2 = url2.slice(0, hashmarkIndex);
  }
  var _encode = options && options.encode || encode$1;
  var serializerParams = utils$e.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams$1(params, options).toString(_encode);
  if (serializerParams) {
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializerParams;
  }
  return url2;
};
var utils$d = utils$h;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function use2(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled,
    rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function eject2(id2) {
  if (this.handlers[id2]) {
    this.handlers[id2] = null;
  }
};
InterceptorManager$1.prototype.clear = function clear() {
  if (this.handlers) {
    this.handlers = [];
  }
};
InterceptorManager$1.prototype.forEach = function forEach2(fn2) {
  utils$d.forEach(this.handlers, function forEachHandler(h2) {
    if (h2 !== null) {
      fn2(h2);
    }
  });
};
var InterceptorManager_1 = InterceptorManager$1;
var utils$c = utils$h;
var normalizeHeaderName$2 = function normalizeHeaderName2(headers, normalizedName) {
  utils$c.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};
var transitional2 = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
var AxiosURLSearchParams = AxiosURLSearchParams_1;
var URLSearchParams_1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
var FormData_1 = FormData;
var browser = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_1,
    FormData: FormData_1,
    Blob
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
var platform$2 = browser;
var utils$b = utils$h;
var toFormData$1 = toFormData_1;
var platform$1 = platform$2;
var toURLEncodedForm$1 = function toURLEncodedForm(data2, options) {
  return toFormData$1(data2, new platform$1.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform$1.isNode && utils$b.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
};
var utils$a = utils$h;
function parsePropPath(name) {
  return utils$a.matchAll(/\w+|\[(\w*)]/g, name).map(function(match2) {
    return match2[0] === "[]" ? "" : match2[1] || match2[0];
  });
}
function arrayToObject$1(arr) {
  var obj = {};
  var keys2 = Object.keys(arr);
  var i2;
  var len = keys2.length;
  var key;
  for (i2 = 0; i2 < len; i2++) {
    key = keys2[i2];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON$2(formData) {
  function buildPath(path, value, target, index2) {
    var name = path[index2++];
    var isNumericKey = Number.isFinite(+name);
    var isLast = index2 >= path.length;
    name = !name && utils$a.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$a.hasOwnProperty(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$a.isObject(target[name])) {
      target[name] = [];
    }
    var result = buildPath(path, value, target[name], index2);
    if (result && utils$a.isArray(target[name])) {
      target[name] = arrayToObject$1(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$a.isFormData(formData) && utils$a.isFunction(formData.entries)) {
    var obj = {};
    utils$a.forEachEntry(formData, function(name, value) {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_1 = formDataToJSON$2;
var settle;
var hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle)
    return settle;
  hasRequiredSettle = 1;
  var AxiosError2 = AxiosError_1;
  settle = function settle2(resolve2, reject2, response) {
    var validateStatus2 = response.config.validateStatus;
    if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
      resolve2(response);
    } else {
      reject2(new AxiosError2(
        "Request failed with status code " + response.status,
        [AxiosError2.ERR_BAD_REQUEST, AxiosError2.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  };
  return settle;
}
var cookies;
var hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies)
    return cookies;
  hasRequiredCookies = 1;
  var utils2 = utils$h;
  cookies = utils2.isStandardBrowserEnv() ? (
    // Standard browser envs support document.cookie
    function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils2.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils2.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils2.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          var match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match2 ? decodeURIComponent(match2[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove() {
        }
      };
    }()
  );
  return cookies;
}
var isAbsoluteURL$1 = function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
};
var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};
var isAbsoluteURL2 = isAbsoluteURL$1;
var combineURLs2 = combineURLs$1;
var buildFullPath$1 = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL2(requestedURL)) {
    return combineURLs2(baseURL, requestedURL);
  }
  return requestedURL;
};
var parseHeaders;
var hasRequiredParseHeaders;
function requireParseHeaders() {
  if (hasRequiredParseHeaders)
    return parseHeaders;
  hasRequiredParseHeaders = 1;
  var utils2 = utils$h;
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  parseHeaders = function parseHeaders2(headers) {
    var parsed = {};
    var key;
    var val;
    var i2;
    if (!headers) {
      return parsed;
    }
    utils2.forEach(headers.split("\n"), function parser(line2) {
      i2 = line2.indexOf(":");
      key = utils2.trim(line2.slice(0, i2)).toLowerCase();
      val = utils2.trim(line2.slice(i2 + 1));
      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === "set-cookie") {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  return parseHeaders;
}
var isURLSameOrigin;
var hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin)
    return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var utils2 = utils$h;
  isURLSameOrigin = utils2.isStandardBrowserEnv() ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url2) {
        var href = url2;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin2(requestURL) {
        var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return function isURLSameOrigin2() {
        return true;
      };
    }()
  );
  return isURLSameOrigin;
}
var CanceledError_1;
var hasRequiredCanceledError;
function requireCanceledError() {
  if (hasRequiredCanceledError)
    return CanceledError_1;
  hasRequiredCanceledError = 1;
  var AxiosError2 = AxiosError_1;
  var utils2 = utils$h;
  function CanceledError2(message, config, request3) {
    AxiosError2.call(this, message == null ? "canceled" : message, AxiosError2.ERR_CANCELED, config, request3);
    this.name = "CanceledError";
  }
  utils2.inherits(CanceledError2, AxiosError2, {
    __CANCEL__: true
  });
  CanceledError_1 = CanceledError2;
  return CanceledError_1;
}
var parseProtocol;
var hasRequiredParseProtocol;
function requireParseProtocol() {
  if (hasRequiredParseProtocol)
    return parseProtocol;
  hasRequiredParseProtocol = 1;
  parseProtocol = function parseProtocol2(url2) {
    var match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
    return match2 && match2[1] || "";
  };
  return parseProtocol;
}
var xhr;
var hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  var utils2 = utils$h;
  var settle2 = requireSettle();
  var cookies2 = requireCookies();
  var buildURL4 = buildURL$1;
  var buildFullPath3 = buildFullPath$1;
  var parseHeaders2 = requireParseHeaders();
  var isURLSameOrigin2 = requireIsURLSameOrigin();
  var transitionalDefaults2 = transitional2;
  var AxiosError2 = AxiosError_1;
  var CanceledError2 = requireCanceledError();
  var parseProtocol2 = requireParseProtocol();
  var platform2 = platform$2;
  xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve2, reject2) {
      var requestData = config.data;
      var requestHeaders = config.headers;
      var responseType = config.responseType;
      var withXSRFToken = config.withXSRFToken;
      var onCanceled;
      function done() {
        if (config.cancelToken) {
          config.cancelToken.unsubscribe(onCanceled);
        }
        if (config.signal) {
          config.signal.removeEventListener("abort", onCanceled);
        }
      }
      if (utils2.isFormData(requestData) && utils2.isStandardBrowserEnv()) {
        delete requestHeaders["Content-Type"];
      }
      var request3 = new XMLHttpRequest();
      if (config.auth) {
        var username = config.auth.username || "";
        var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath3(config.baseURL, config.url);
      request3.open(config.method.toUpperCase(), buildURL4(fullPath, config.params, config.paramsSerializer), true);
      request3.timeout = config.timeout;
      function onloadend() {
        if (!request3) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request3 ? parseHeaders2(request3.getAllResponseHeaders()) : null;
        var responseData = !responseType || responseType === "text" || responseType === "json" ? request3.responseText : request3.response;
        var response = {
          data: responseData,
          status: request3.status,
          statusText: request3.statusText,
          headers: responseHeaders,
          config,
          request: request3
        };
        settle2(function _resolve(value) {
          resolve2(value);
          done();
        }, function _reject(err) {
          reject2(err);
          done();
        }, response);
        request3 = null;
      }
      if ("onloadend" in request3) {
        request3.onloadend = onloadend;
      } else {
        request3.onreadystatechange = function handleLoad() {
          if (!request3 || request3.readyState !== 4) {
            return;
          }
          if (request3.status === 0 && !(request3.responseURL && request3.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request3.onabort = function handleAbort() {
        if (!request3) {
          return;
        }
        reject2(new AxiosError2("Request aborted", AxiosError2.ECONNABORTED, config, request3));
        request3 = null;
      };
      request3.onerror = function handleError() {
        reject2(new AxiosError2("Network Error", AxiosError2.ERR_NETWORK, config, request3));
        request3 = null;
      };
      request3.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        var transitional4 = config.transitional || transitionalDefaults2;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject2(new AxiosError2(
          timeoutErrorMessage,
          transitional4.clarifyTimeoutError ? AxiosError2.ETIMEDOUT : AxiosError2.ECONNABORTED,
          config,
          request3
        ));
        request3 = null;
      };
      if (utils2.isStandardBrowserEnv()) {
        withXSRFToken && utils2.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
        if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin2(fullPath)) {
          var xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies2.read(config.xsrfCookieName);
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
      }
      if ("setRequestHeader" in request3) {
        utils2.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
            delete requestHeaders[key];
          } else {
            request3.setRequestHeader(key, val);
          }
        });
      }
      if (!utils2.isUndefined(config.withCredentials)) {
        request3.withCredentials = !!config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request3.responseType = config.responseType;
      }
      if (typeof config.onDownloadProgress === "function") {
        request3.addEventListener("progress", config.onDownloadProgress);
      }
      if (typeof config.onUploadProgress === "function" && request3.upload) {
        request3.upload.addEventListener("progress", config.onUploadProgress);
      }
      if (config.cancelToken || config.signal) {
        onCanceled = function(cancel) {
          if (!request3) {
            return;
          }
          reject2(!cancel || cancel.type ? new CanceledError2(null, config, req) : cancel);
          request3.abort();
          request3 = null;
        };
        config.cancelToken && config.cancelToken.subscribe(onCanceled);
        if (config.signal) {
          config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
        }
      }
      if (!requestData && requestData !== false && requestData !== 0 && requestData !== "") {
        requestData = null;
      }
      var protocol = parseProtocol2(fullPath);
      if (protocol && platform2.protocols.indexOf(protocol) === -1) {
        reject2(new AxiosError2("Unsupported protocol " + protocol + ":", AxiosError2.ERR_BAD_REQUEST, config));
        return;
      }
      request3.send(requestData);
    });
  };
  return xhr;
}
var utils$9 = utils$h;
var normalizeHeaderName$1 = normalizeHeaderName$2;
var AxiosError$1 = AxiosError_1;
var transitionalDefaults = transitional2;
var toFormData = toFormData_1;
var toURLEncodedForm2 = toURLEncodedForm$1;
var platform = platform$2;
var formDataToJSON$1 = formDataToJSON_1;
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value) {
  if (!utils$9.isUndefined(headers) && utils$9.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = requireXhr();
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = requireXhr();
  }
  return adapter;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$9.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$9.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults$5 = {
  transitional: transitionalDefaults,
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data2, headers) {
    normalizeHeaderName$1(headers, "Accept");
    normalizeHeaderName$1(headers, "Content-Type");
    var contentType = headers && headers["Content-Type"] || "";
    var hasJSONContentType = contentType.indexOf("application/json") > -1;
    var isObjectPayload = utils$9.isObject(data2);
    if (isObjectPayload && utils$9.isHTMLForm(data2)) {
      data2 = new FormData(data2);
    }
    var isFormData2 = utils$9.isFormData(data2);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON$1(data2)) : data2;
    }
    if (utils$9.isArrayBuffer(data2) || utils$9.isBuffer(data2) || utils$9.isStream(data2) || utils$9.isFile(data2) || utils$9.isBlob(data2)) {
      return data2;
    }
    if (utils$9.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils$9.isURLSearchParams(data2)) {
      setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
      return data2.toString();
    }
    var isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
        return toURLEncodedForm2(data2, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$9.isFileList(data2)) || contentType.indexOf("multipart/form-data") > -1) {
        var _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data2 } : data2,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      setContentTypeIfUnset(headers, "application/json");
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    var transitional4 = this.transitional || defaults$5.transitional;
    var forcedJSONParsing = transitional4 && transitional4.forcedJSONParsing;
    var JSONRequested = this.responseType === "json";
    if (data2 && utils$9.isString(data2) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      var silentJSONParsing = transitional4 && transitional4.silentJSONParsing;
      var strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data2);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError$1.from(e2, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data2;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils$9.forEach(["delete", "get", "head"], function forEachMethodNoData2(method) {
  defaults$5.headers[method] = {};
});
utils$9.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  defaults$5.headers[method] = utils$9.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$5;
var utils$8 = utils$h;
var defaults$4 = defaults_1;
var transformData$1 = function transformData2(data2, headers, status, fns) {
  var context2 = this || defaults$4;
  utils$8.forEach(fns, function transform(fn2) {
    data2 = fn2.call(context2, data2, headers, status);
  });
  return data2;
};
var isCancel$1;
var hasRequiredIsCancel;
function requireIsCancel() {
  if (hasRequiredIsCancel)
    return isCancel$1;
  hasRequiredIsCancel = 1;
  isCancel$1 = function isCancel2(value) {
    return !!(value && value.__CANCEL__);
  };
  return isCancel$1;
}
var utils$7 = utils$h;
var transformData3 = transformData$1;
var isCancel = requireIsCancel();
var defaults$3 = defaults_1;
var CanceledError = requireCanceledError();
var normalizeHeaderName3 = normalizeHeaderName$2;
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError();
  }
}
var dispatchRequest$1 = function dispatchRequest2(config) {
  throwIfCancellationRequested(config);
  config.headers = config.headers || {};
  config.data = transformData3.call(
    config,
    config.data,
    config.headers,
    null,
    config.transformRequest
  );
  normalizeHeaderName3(config.headers, "Accept");
  normalizeHeaderName3(config.headers, "Content-Type");
  config.headers = utils$7.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );
  utils$7.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );
  var adapter = config.adapter || defaults$3.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData3.call(
      config,
      response.data,
      response.headers,
      response.status,
      config.transformResponse
    );
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData3.call(
          config,
          reason.response.data,
          reason.response.headers,
          reason.response.status,
          config.transformResponse
        );
      }
    }
    return Promise.reject(reason);
  });
};
var utils$6 = utils$h;
var mergeConfig$2 = function mergeConfig2(config1, config2) {
  config2 = config2 || {};
  var config = {};
  function getMergedValue(target, source) {
    if (utils$6.isPlainObject(target) && utils$6.isPlainObject(source)) {
      return utils$6.merge(target, source);
    } else if (utils$6.isEmptyObject(source)) {
      return utils$6.merge({}, target);
    } else if (utils$6.isPlainObject(source)) {
      return utils$6.merge({}, source);
    } else if (utils$6.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(prop) {
    if (!utils$6.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$6.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function valueFromConfig2(prop) {
    if (!utils$6.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    }
  }
  function defaultToConfig2(prop) {
    if (!utils$6.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    } else if (!utils$6.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  var mergeMap = {
    "url": valueFromConfig2,
    "method": valueFromConfig2,
    "data": valueFromConfig2,
    "baseURL": defaultToConfig2,
    "transformRequest": defaultToConfig2,
    "transformResponse": defaultToConfig2,
    "paramsSerializer": defaultToConfig2,
    "timeout": defaultToConfig2,
    "timeoutMessage": defaultToConfig2,
    "withCredentials": defaultToConfig2,
    "withXSRFToken": defaultToConfig2,
    "adapter": defaultToConfig2,
    "responseType": defaultToConfig2,
    "xsrfCookieName": defaultToConfig2,
    "xsrfHeaderName": defaultToConfig2,
    "onUploadProgress": defaultToConfig2,
    "onDownloadProgress": defaultToConfig2,
    "decompress": defaultToConfig2,
    "maxContentLength": defaultToConfig2,
    "maxBodyLength": defaultToConfig2,
    "beforeRedirect": defaultToConfig2,
    "transport": defaultToConfig2,
    "httpAgent": defaultToConfig2,
    "httpsAgent": defaultToConfig2,
    "cancelToken": defaultToConfig2,
    "socketPath": defaultToConfig2,
    "responseEncoding": defaultToConfig2,
    "validateStatus": mergeDirectKeys
  };
  utils$6.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge3 = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge3(prop);
    utils$6.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
};
var data;
var hasRequiredData;
function requireData() {
  if (hasRequiredData)
    return data;
  hasRequiredData = 1;
  data = {
    "version": "0.28.0"
  };
  return data;
}
var VERSION$2 = requireData().version;
var AxiosError = AxiosError_1;
var validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type2, i2) {
  validators$1[type2] = function validator2(thing) {
    return typeof thing === type2 || "a" + (i2 < 1 ? "n " : " ") + type2;
  };
});
var deprecatedWarnings = {};
validators$1.transitional = function transitional3(validator2, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION$2 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return function(value, opt, opts) {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  var keys2 = Object.keys(options);
  var i2 = keys2.length;
  while (i2-- > 0) {
    var opt = keys2[i2];
    var validator2 = schema[opt];
    if (validator2) {
      var value = options[opt];
      var result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
var validator$1 = {
  assertOptions,
  validators: validators$1
};
var utils$5 = utils$h;
var buildURL3 = buildURL$1;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest3 = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
var buildFullPath2 = buildFullPath$1;
var validator = validator$1;
var validators = validator.validators;
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function request2(configOrUrl, config) {
  if (typeof configOrUrl === "string") {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }
  config = mergeConfig$1(this.defaults, config);
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = "get";
  }
  var transitional4 = config.transitional;
  if (transitional4 !== void 0) {
    validator.assertOptions(transitional4, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }
  var paramsSerializer = config.paramsSerializer;
  utils$5.isFunction(paramsSerializer) && (config.paramsSerializer = { serialize: paramsSerializer });
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise2;
  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest3, void 0];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise2 = Promise.resolve(config);
    while (chain.length) {
      promise2 = promise2.then(chain.shift(), chain.shift());
    }
    return promise2;
  }
  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error2) {
      onRejected(error2);
      break;
    }
  }
  try {
    promise2 = dispatchRequest3(newConfig);
  } catch (error2) {
    return Promise.reject(error2);
  }
  while (responseInterceptorChain.length) {
    promise2 = promise2.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise2;
};
Axios$1.prototype.getUri = function getUri2(config) {
  config = mergeConfig$1(this.defaults, config);
  var fullPath = buildFullPath2(config.baseURL, config.url);
  return buildURL3(fullPath, config.params, config.paramsSerializer);
};
utils$5.forEach(["delete", "get", "head", "options"], function forEachMethodNoData3(method) {
  Axios$1.prototype[method] = function(url2, config) {
    return this.request(mergeConfig$1(config || {}, {
      method,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils$5.forEach(["post", "put", "patch"], function forEachMethodWithData3(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data2, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data: data2
      }));
    };
  }
  Axios$1.prototype[method] = generateHTTPMethod();
  Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_1 = Axios$1;
var CancelToken_1;
var hasRequiredCancelToken;
function requireCancelToken() {
  if (hasRequiredCancelToken)
    return CancelToken_1;
  hasRequiredCancelToken = 1;
  var CanceledError2 = requireCanceledError();
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    var token2 = this;
    this.promise.then(function(cancel) {
      if (!token2._listeners)
        return;
      var i2 = token2._listeners.length;
      while (i2-- > 0) {
        token2._listeners[i2](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = function(onfulfilled) {
      var _resolve;
      var promise2 = new Promise(function(resolve2) {
        token2.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise2.cancel = function reject2() {
        token2.unsubscribe(_resolve);
      };
      return promise2;
    };
    executor(function cancel(message, config, request3) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError2(message, config, request3);
      resolvePromise(token2.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.prototype.subscribe = function subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  };
  CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    var index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token2 = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token: token2,
      cancel
    };
  };
  CancelToken_1 = CancelToken;
  return CancelToken_1;
}
var spread;
var hasRequiredSpread;
function requireSpread() {
  if (hasRequiredSpread)
    return spread;
  hasRequiredSpread = 1;
  spread = function spread2(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };
  return spread;
}
var isAxiosError;
var hasRequiredIsAxiosError;
function requireIsAxiosError() {
  if (hasRequiredIsAxiosError)
    return isAxiosError;
  hasRequiredIsAxiosError = 1;
  var utils2 = utils$h;
  isAxiosError = function isAxiosError2(payload) {
    return utils2.isObject(payload) && payload.isAxiosError === true;
  };
  return isAxiosError;
}
var utils$4 = utils$h;
var bind$3 = bind$5;
var Axios = Axios_1;
var mergeConfig3 = mergeConfig$2;
var defaults$2 = defaults_1;
var formDataToJSON = formDataToJSON_1;
function createInstance(defaultConfig) {
  var context2 = new Axios(defaultConfig);
  var instance2 = bind$3(Axios.prototype.request, context2);
  utils$4.extend(instance2, Axios.prototype, context2);
  utils$4.extend(instance2, context2);
  instance2.create = function create(instanceConfig) {
    return createInstance(mergeConfig3(defaultConfig, instanceConfig));
  };
  return instance2;
}
var axios$2 = createInstance(defaults$2);
axios$2.Axios = Axios;
axios$2.CanceledError = requireCanceledError();
axios$2.CancelToken = requireCancelToken();
axios$2.isCancel = requireIsCancel();
axios$2.VERSION = requireData().version;
axios$2.toFormData = toFormData_1;
axios$2.AxiosError = AxiosError_1;
axios$2.Cancel = axios$2.CanceledError;
axios$2.all = function all2(promises) {
  return Promise.all(promises);
};
axios$2.spread = requireSpread();
axios$2.isAxiosError = requireIsAxiosError();
axios$2.formToJSON = function(thing) {
  return formDataToJSON(utils$4.isHTMLForm(thing) ? new FormData(thing) : thing);
};
axios$3.exports = axios$2;
axios$3.exports.default = axios$2;
var axiosExports = axios$3.exports;
var axios = axiosExports;
const axios$1 = /* @__PURE__ */ getDefaultExportFromCjs(axios);
const sceneFetcher = (sceneUrl) => {
  return new Promise((resolve2) => {
    axios$1.get(sceneUrl).then((response) => {
      const rawScene = response.data.toString();
      resolve2(rawScene);
    });
  });
};
const initPerform = {
  performName: "",
  duration: 100,
  // isOver: false,
  isHoldOn: false,
  stopFunction: () => {
  },
  blockingNext: () => false,
  blockingAuto: () => true,
  stopTimeout: void 0
};
const runScript = (script) => {
  var _a2;
  let perform = initPerform;
  const funcToRun = ((_a2 = scriptRegistry[script.command]) == null ? void 0 : _a2.scriptFunction) ?? SCRIPT_TAG_MAP.say.scriptFunction;
  perform = funcToRun(script);
  if (perform.arrangePerformPromise) {
    perform.arrangePerformPromise.then(
      (resolovedPerform) => WebGAL.gameplay.performController.arrangeNewPerform(resolovedPerform, script)
    );
  } else {
    WebGAL.gameplay.performController.arrangeNewPerform(perform, script);
  }
};
const restoreScene = (entry) => {
  sceneFetcher(entry.sceneUrl).then(async (rawScene) => {
    const scene = await WebGAL.sceneManager.setCurrentScene(rawScene, entry.sceneName, entry.sceneUrl, true);
    if (scene) {
      WebGAL.sceneManager.sceneData.currentSentenceId = entry.continueLine + 1;
      logger.debug("", WebGAL.sceneManager.sceneData.currentScene);
      nextSentence();
    }
  });
};
var parse$6 = {};
var window$1 = { document: {} };
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
var lowercase = function(string) {
  return isString$2(string) ? string.toLowerCase() : string;
};
var isArray$b = Array.isArray;
var manualLowercase = function(s2) {
  return isString$2(s2) ? s2.replace(/[A-Z]/g, function(ch2) {
    return String.fromCharCode(ch2.charCodeAt(0) | 32);
  }) : s2;
};
if ("i" !== "I".toLowerCase()) {
  lowercase = manualLowercase;
}
var jqLite, toString$2 = Object.prototype.toString, getPrototypeOf = Object.getPrototypeOf, ngMinErr = minErr("ng");
window$1.angular || (window$1.angular = {});
window$1.document.documentMode;
function isArrayLike(obj) {
  if (obj == null || isWindow(obj))
    return false;
  if (isArray$b(obj) || isString$2(obj) || jqLite)
    return true;
  var length2 = "length" in Object(obj) && obj.length;
  return isNumber$1(length2) && (length2 >= 0 && (length2 - 1 in obj || obj instanceof Array) || typeof obj.item === "function");
}
function forEach3(obj, iterator, context2) {
  var key, length2;
  if (obj) {
    if (isFunction(obj)) {
      for (key in obj) {
        if (key !== "prototype" && key !== "length" && key !== "name" && obj.hasOwnProperty(key)) {
          iterator.call(context2, obj[key], key, obj);
        }
      }
    } else if (isArray$b(obj) || isArrayLike(obj)) {
      var isPrimitive = typeof obj !== "object";
      for (key = 0, length2 = obj.length; key < length2; key++) {
        if (isPrimitive || key in obj) {
          iterator.call(context2, obj[key], key, obj);
        }
      }
    } else if (obj.forEach && obj.forEach !== forEach3) {
      obj.forEach(iterator, context2, obj);
    } else if (isBlankObject(obj)) {
      for (key in obj) {
        iterator.call(context2, obj[key], key, obj);
      }
    } else if (typeof obj.hasOwnProperty === "function") {
      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          iterator.call(context2, obj[key], key, obj);
        }
      }
    } else {
      for (key in obj) {
        if (hasOwnProperty$2.call(obj, key)) {
          iterator.call(context2, obj[key], key, obj);
        }
      }
    }
  }
  return obj;
}
function setHashKey(obj, h2) {
  if (h2) {
    obj.$$hashKey = h2;
  } else {
    delete obj.$$hashKey;
  }
}
function noop$4() {
}
noop$4.$inject = [];
function isUndefined$2(value) {
  return typeof value === "undefined";
}
function isDefined(value) {
  return typeof value !== "undefined";
}
function isObject$5(value) {
  return value !== null && typeof value === "object";
}
function isBlankObject(value) {
  return value !== null && typeof value === "object" && !getPrototypeOf(value);
}
function isString$2(value) {
  return typeof value === "string";
}
function isNumber$1(value) {
  return typeof value === "number";
}
function isFunction(value) {
  return typeof value === "function";
}
function isWindow(obj) {
  return obj && obj.window === obj;
}
function isScope(obj) {
  return obj && obj.$evalAsync && obj.$watch;
}
var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/;
function isTypedArray$1(value) {
  return value && isNumber$1(value.length) && TYPED_ARRAY_REGEXP.test(toString$2.call(value));
}
function isArrayBuffer(obj) {
  return toString$2.call(obj) === "[object ArrayBuffer]";
}
function copy$2(source, destination) {
  var stackSource = [];
  var stackDest = [];
  if (destination) {
    if (isTypedArray$1(destination) || isArrayBuffer(destination)) {
      throw ngMinErr(
        "cpta",
        "Can't copy! TypedArray destination cannot be mutated."
      );
    }
    if (source === destination) {
      throw ngMinErr(
        "cpi",
        "Can't copy! Source and destination are identical."
      );
    }
    if (isArray$b(destination)) {
      destination.length = 0;
    } else {
      forEach3(destination, function(value, key) {
        if (key !== "$$hashKey") {
          delete destination[key];
        }
      });
    }
    stackSource.push(source);
    stackDest.push(destination);
    return copyRecurse(source, destination);
  }
  return copyElement(source);
  function copyRecurse(source2, destination2) {
    var h2 = destination2.$$hashKey;
    var key;
    if (isArray$b(source2)) {
      for (var i2 = 0, ii2 = source2.length; i2 < ii2; i2++) {
        destination2.push(copyElement(source2[i2]));
      }
    } else if (isBlankObject(source2)) {
      for (key in source2) {
        destination2[key] = copyElement(source2[key]);
      }
    } else if (source2 && typeof source2.hasOwnProperty === "function") {
      for (key in source2) {
        if (source2.hasOwnProperty(key)) {
          destination2[key] = copyElement(source2[key]);
        }
      }
    } else {
      for (key in source2) {
        if (hasOwnProperty$2.call(source2, key)) {
          destination2[key] = copyElement(source2[key]);
        }
      }
    }
    setHashKey(destination2, h2);
    return destination2;
  }
  function copyElement(source2) {
    if (!isObject$5(source2)) {
      return source2;
    }
    var index2 = stackSource.indexOf(source2);
    if (index2 !== -1) {
      return stackDest[index2];
    }
    if (isWindow(source2) || isScope(source2)) {
      throw ngMinErr(
        "cpws",
        "Can't copy! Making copies of Window or Scope instances is not supported."
      );
    }
    var needsRecurse = false;
    var destination2 = copyType(source2);
    if (destination2 === void 0) {
      destination2 = isArray$b(source2) ? [] : Object.create(getPrototypeOf(source2));
      needsRecurse = true;
    }
    stackSource.push(source2);
    stackDest.push(destination2);
    return needsRecurse ? copyRecurse(source2, destination2) : destination2;
  }
  function copyType(source2) {
    switch (toString$2.call(source2)) {
      case "[object Int8Array]":
      case "[object Int16Array]":
      case "[object Int32Array]":
      case "[object Float32Array]":
      case "[object Float64Array]":
      case "[object Uint8Array]":
      case "[object Uint8ClampedArray]":
      case "[object Uint16Array]":
      case "[object Uint32Array]":
        return new source2.constructor(
          copyElement(source2.buffer),
          source2.byteOffset,
          source2.length
        );
      case "[object ArrayBuffer]":
        if (!source2.slice) {
          var copied = new ArrayBuffer(source2.byteLength);
          new Uint8Array(copied).set(new Uint8Array(source2));
          return copied;
        }
        return source2.slice(0);
      case "[object Boolean]":
      case "[object Number]":
      case "[object String]":
      case "[object Date]":
        return new source2.constructor(source2.valueOf());
      case "[object RegExp]":
        var re2 = new RegExp(
          source2.source,
          source2.toString().match(/[^\/]*$/)[0]
        );
        re2.lastIndex = source2.lastIndex;
        return re2;
      case "[object Blob]":
        return new source2.constructor([source2], { type: source2.type });
    }
    if (isFunction(source2.cloneNode)) {
      return source2.cloneNode(true);
    }
  }
}
function toJsonReplacer(key, value) {
  var val = value;
  if (typeof key === "string" && key.charAt(0) === "$" && key.charAt(1) === "$") {
    val = void 0;
  } else if (isWindow(value)) {
    val = "$WINDOW";
  } else if (value && window$1.document === value) {
    val = "$DOCUMENT";
  } else if (isScope(value)) {
    val = "$SCOPE";
  }
  return val;
}
function allowAutoBootstrap(document2) {
  if (!document2.currentScript) {
    return true;
  }
  var src = document2.currentScript.getAttribute("src");
  var link = document2.createElement("a");
  link.href = src;
  var scriptProtocol = link.protocol;
  var docLoadProtocol = document2.location.protocol;
  if ((scriptProtocol === "resource:" || scriptProtocol === "chrome-extension:") && docLoadProtocol !== scriptProtocol) {
    return false;
  }
  return true;
}
allowAutoBootstrap(window$1.document);
function createMap() {
  return /* @__PURE__ */ Object.create(null);
}
function serializeObject(obj) {
  var seen2 = [];
  return JSON.stringify(obj, function(key, val) {
    val = toJsonReplacer(key, val);
    if (isObject$5(val)) {
      if (seen2.indexOf(val) >= 0)
        return "...";
      seen2.push(val);
    }
    return val;
  });
}
function toDebugString(obj) {
  if (typeof obj === "function") {
    return obj.toString().replace(/ \{[\s\S]*$/, "");
  } else if (isUndefined$2(obj)) {
    return "undefined";
  } else if (typeof obj !== "string") {
    return serializeObject(obj);
  }
  return obj;
}
function minErr(module, ErrorConstructor) {
  ErrorConstructor = ErrorConstructor || Error;
  return function() {
    var SKIP_INDEXES = 2;
    var templateArgs = arguments, code = templateArgs[0], message = "[" + (module ? module + ":" : "") + code + "] ", template = templateArgs[1], paramPrefix, i2;
    message += template.replace(/\{\d+\}/g, function(match2) {
      var index2 = +match2.slice(1, -1), shiftedIndex = index2 + SKIP_INDEXES;
      if (shiftedIndex < templateArgs.length) {
        return toDebugString(templateArgs[shiftedIndex]);
      }
      return match2;
    });
    message += '\nhttp://errors.angularjs.org/"NG_VERSION_FULL"/' + (module ? module + "/" : "") + code;
    for (i2 = SKIP_INDEXES, paramPrefix = "?"; i2 < templateArgs.length; i2++, paramPrefix = "&") {
      message += paramPrefix + "p" + (i2 - SKIP_INDEXES) + "=" + encodeURIComponent(toDebugString(templateArgs[i2]));
    }
    return new ErrorConstructor(message);
  };
}
var $parseMinErr = minErr("$parse");
({}).constructor.prototype.valueOf;
function getStringValue(name) {
  return name + "";
}
var OPERATORS = createMap();
forEach3(
  "+ - * / % === !== == != < > <= >= && || ! = |".split(" "),
  function(operator) {
    OPERATORS[operator] = true;
  }
);
var ESCAPE = {
  n: "\n",
  f: "\f",
  r: "\r",
  t: "	",
  v: "\v",
  "'": "'",
  '"': '"'
};
var Lexer$1 = function Lexer(options) {
  this.options = options;
};
Lexer$1.prototype = {
  constructor: Lexer$1,
  lex: function(text2) {
    this.text = text2;
    this.index = 0;
    this.tokens = [];
    while (this.index < this.text.length) {
      var ch2 = this.text.charAt(this.index);
      if (ch2 === '"' || ch2 === "'") {
        this.readString(ch2);
      } else if (this.isNumber(ch2) || ch2 === "." && this.isNumber(this.peek())) {
        this.readNumber();
      } else if (this.isIdentifierStart(this.peekMultichar())) {
        this.readIdent();
      } else if (this.is(ch2, "(){}[].,;:?")) {
        this.tokens.push({ index: this.index, text: ch2 });
        this.index++;
      } else if (this.isWhitespace(ch2)) {
        this.index++;
      } else {
        var ch22 = ch2 + this.peek();
        var ch3 = ch22 + this.peek(2);
        var op1 = OPERATORS[ch2];
        var op2 = OPERATORS[ch22];
        var op3 = OPERATORS[ch3];
        if (op1 || op2 || op3) {
          var token2 = op3 ? ch3 : op2 ? ch22 : ch2;
          this.tokens.push({ index: this.index, text: token2, operator: true });
          this.index += token2.length;
        } else {
          this.throwError(
            "Unexpected next character ",
            this.index,
            this.index + 1
          );
        }
      }
    }
    return this.tokens;
  },
  is: function(ch2, chars2) {
    return chars2.indexOf(ch2) !== -1;
  },
  peek: function(i2) {
    var num = i2 || 1;
    return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false;
  },
  isNumber: function(ch2) {
    return "0" <= ch2 && ch2 <= "9" && typeof ch2 === "string";
  },
  isWhitespace: function(ch2) {
    return ch2 === " " || ch2 === "\r" || ch2 === "	" || ch2 === "\n" || ch2 === "\v" || ch2 === "";
  },
  isIdentifierStart: function(ch2) {
    return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch2, this.codePointAt(ch2)) : this.isValidIdentifierStart(ch2);
  },
  isValidIdentifierStart: function(ch2) {
    return "a" <= ch2 && ch2 <= "z" || "A" <= ch2 && ch2 <= "Z" || "_" === ch2 || ch2 === "$";
  },
  isIdentifierContinue: function(ch2) {
    return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch2, this.codePointAt(ch2)) : this.isValidIdentifierContinue(ch2);
  },
  isValidIdentifierContinue: function(ch2, cp) {
    return this.isValidIdentifierStart(ch2, cp) || this.isNumber(ch2);
  },
  codePointAt: function(ch2) {
    if (ch2.length === 1)
      return ch2.charCodeAt(0);
    return (ch2.charCodeAt(0) << 10) + ch2.charCodeAt(1) - 56613888;
  },
  peekMultichar: function() {
    var ch2 = this.text.charAt(this.index);
    var peek2 = this.peek();
    if (!peek2) {
      return ch2;
    }
    var cp1 = ch2.charCodeAt(0);
    var cp2 = peek2.charCodeAt(0);
    if (cp1 >= 55296 && cp1 <= 56319 && cp2 >= 56320 && cp2 <= 57343) {
      return ch2 + peek2;
    }
    return ch2;
  },
  isExpOperator: function(ch2) {
    return ch2 === "-" || ch2 === "+" || this.isNumber(ch2);
  },
  throwError: function(error2, start, end2) {
    end2 = end2 || this.index;
    var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end2) + "]" : " " + end2;
    throw $parseMinErr(
      "lexerr",
      "Lexer Error: {0} at column{1} in expression [{2}].",
      error2,
      colStr,
      this.text
    );
  },
  readNumber: function() {
    var number2 = "";
    var start = this.index;
    while (this.index < this.text.length) {
      var ch2 = lowercase(this.text.charAt(this.index));
      if (ch2 === "." || this.isNumber(ch2)) {
        number2 += ch2;
      } else {
        var peekCh = this.peek();
        if (ch2 === "e" && this.isExpOperator(peekCh)) {
          number2 += ch2;
        } else if (this.isExpOperator(ch2) && peekCh && this.isNumber(peekCh) && number2.charAt(number2.length - 1) === "e") {
          number2 += ch2;
        } else if (this.isExpOperator(ch2) && (!peekCh || !this.isNumber(peekCh)) && number2.charAt(number2.length - 1) === "e") {
          this.throwError("Invalid exponent");
        } else {
          break;
        }
      }
      this.index++;
    }
    this.tokens.push({
      index: start,
      text: number2,
      constant: true,
      value: Number(number2)
    });
  },
  readIdent: function() {
    var start = this.index;
    this.index += this.peekMultichar().length;
    while (this.index < this.text.length) {
      var ch2 = this.peekMultichar();
      if (!this.isIdentifierContinue(ch2)) {
        break;
      }
      this.index += ch2.length;
    }
    this.tokens.push({
      index: start,
      text: this.text.slice(start, this.index),
      identifier: true
    });
  },
  readString: function(quote2) {
    var start = this.index;
    this.index++;
    var string = "";
    var rawString = quote2;
    var escape2 = false;
    while (this.index < this.text.length) {
      var ch2 = this.text.charAt(this.index);
      rawString += ch2;
      if (escape2) {
        if (ch2 === "u") {
          var hex2 = this.text.substring(this.index + 1, this.index + 5);
          if (!hex2.match(/[\da-f]{4}/i)) {
            this.throwError("Invalid unicode escape [\\u" + hex2 + "]");
          }
          this.index += 4;
          string += String.fromCharCode(parseInt(hex2, 16));
        } else {
          var rep = ESCAPE[ch2];
          string = string + (rep || ch2);
        }
        escape2 = false;
      } else if (ch2 === "\\") {
        escape2 = true;
      } else if (ch2 === quote2) {
        this.index++;
        this.tokens.push({
          index: start,
          text: rawString,
          constant: true,
          value: string
        });
        return;
      } else {
        string += ch2;
      }
      this.index++;
    }
    this.throwError("Unterminated quote", start);
  }
};
var AST = function AST2(lexer, options) {
  this.lexer = lexer;
  this.options = options;
};
AST.Program = "Program";
AST.ExpressionStatement = "ExpressionStatement";
AST.AssignmentExpression = "AssignmentExpression";
AST.ConditionalExpression = "ConditionalExpression";
AST.LogicalExpression = "LogicalExpression";
AST.BinaryExpression = "BinaryExpression";
AST.UnaryExpression = "UnaryExpression";
AST.CallExpression = "CallExpression";
AST.MemberExpression = "MemberExpression";
AST.Identifier = "Identifier";
AST.Literal = "Literal";
AST.ArrayExpression = "ArrayExpression";
AST.Property = "Property";
AST.ObjectExpression = "ObjectExpression";
AST.ThisExpression = "ThisExpression";
AST.LocalsExpression = "LocalsExpression";
AST.NGValueParameter = "NGValueParameter";
AST.prototype = {
  ast: function(text2) {
    this.text = text2;
    this.tokens = this.lexer.lex(text2);
    var value = this.program();
    if (this.tokens.length !== 0) {
      this.throwError("is an unexpected token", this.tokens[0]);
    }
    return value;
  },
  program: function() {
    var body = [];
    while (true) {
      if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]"))
        body.push(this.expressionStatement());
      if (!this.expect(";")) {
        return { type: AST.Program, body };
      }
    }
  },
  expressionStatement: function() {
    return { type: AST.ExpressionStatement, expression: this.filterChain() };
  },
  filterChain: function() {
    var left = this.expression();
    while (this.expect("|")) {
      left = this.filter(left);
    }
    return left;
  },
  expression: function() {
    return this.assignment();
  },
  assignment: function() {
    var result = this.ternary();
    if (this.expect("=")) {
      if (!isAssignable(result)) {
        throw $parseMinErr("lval", "Trying to assign a value to a non l-value");
      }
      result = {
        type: AST.AssignmentExpression,
        left: result,
        right: this.assignment(),
        operator: "="
      };
    }
    return result;
  },
  ternary: function() {
    var test2 = this.logicalOR();
    var alternate;
    var consequent;
    if (this.expect("?")) {
      alternate = this.expression();
      if (this.consume(":")) {
        consequent = this.expression();
        return {
          type: AST.ConditionalExpression,
          test: test2,
          alternate,
          consequent
        };
      }
    }
    return test2;
  },
  logicalOR: function() {
    var left = this.logicalAND();
    while (this.expect("||")) {
      left = {
        type: AST.LogicalExpression,
        operator: "||",
        left,
        right: this.logicalAND()
      };
    }
    return left;
  },
  logicalAND: function() {
    var left = this.equality();
    while (this.expect("&&")) {
      left = {
        type: AST.LogicalExpression,
        operator: "&&",
        left,
        right: this.equality()
      };
    }
    return left;
  },
  equality: function() {
    var left = this.relational();
    var token2;
    while (token2 = this.expect("==", "!=", "===", "!==")) {
      left = {
        type: AST.BinaryExpression,
        operator: token2.text,
        left,
        right: this.relational()
      };
    }
    return left;
  },
  relational: function() {
    var left = this.additive();
    var token2;
    while (token2 = this.expect("<", ">", "<=", ">=")) {
      left = {
        type: AST.BinaryExpression,
        operator: token2.text,
        left,
        right: this.additive()
      };
    }
    return left;
  },
  additive: function() {
    var left = this.multiplicative();
    var token2;
    while (token2 = this.expect("+", "-")) {
      left = {
        type: AST.BinaryExpression,
        operator: token2.text,
        left,
        right: this.multiplicative()
      };
    }
    return left;
  },
  multiplicative: function() {
    var left = this.unary();
    var token2;
    while (token2 = this.expect("*", "/", "%")) {
      left = {
        type: AST.BinaryExpression,
        operator: token2.text,
        left,
        right: this.unary()
      };
    }
    return left;
  },
  unary: function() {
    var token2;
    if (token2 = this.expect("+", "-", "!")) {
      return {
        type: AST.UnaryExpression,
        operator: token2.text,
        prefix: true,
        argument: this.unary()
      };
    } else {
      return this.primary();
    }
  },
  primary: function() {
    var primary;
    if (this.expect("(")) {
      primary = this.filterChain();
      this.consume(")");
    } else if (this.expect("[")) {
      primary = this.arrayDeclaration();
    } else if (this.expect("{")) {
      primary = this.object();
    } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {
      primary = copy$2(this.selfReferential[this.consume().text]);
    } else if (this.options.literals.hasOwnProperty(this.peek().text)) {
      primary = {
        type: AST.Literal,
        value: this.options.literals[this.consume().text]
      };
    } else if (this.peek().identifier) {
      primary = this.identifier();
    } else if (this.peek().constant) {
      primary = this.constant();
    } else {
      this.throwError("not a primary expression", this.peek());
    }
    var next2;
    while (next2 = this.expect("(", "[", ".")) {
      if (next2.text === "(") {
        primary = {
          type: AST.CallExpression,
          callee: primary,
          arguments: this.parseArguments()
        };
        this.consume(")");
      } else if (next2.text === "[") {
        primary = {
          type: AST.MemberExpression,
          object: primary,
          property: this.expression(),
          computed: true
        };
        this.consume("]");
      } else if (next2.text === ".") {
        primary = {
          type: AST.MemberExpression,
          object: primary,
          property: this.identifier(),
          computed: false
        };
      } else {
        this.throwError("IMPOSSIBLE");
      }
    }
    return primary;
  },
  filter: function(baseExpression) {
    var args = [baseExpression];
    var result = {
      type: AST.CallExpression,
      callee: this.identifier(),
      arguments: args,
      filter: true
    };
    while (this.expect(":")) {
      args.push(this.expression());
    }
    return result;
  },
  parseArguments: function() {
    var args = [];
    if (this.peekToken().text !== ")") {
      do {
        args.push(this.filterChain());
      } while (this.expect(","));
    }
    return args;
  },
  identifier: function() {
    var token2 = this.consume();
    if (!token2.identifier) {
      this.throwError("is not a valid identifier", token2);
    }
    return { type: AST.Identifier, name: token2.text };
  },
  constant: function() {
    return { type: AST.Literal, value: this.consume().value };
  },
  arrayDeclaration: function() {
    var elements = [];
    if (this.peekToken().text !== "]") {
      do {
        if (this.peek("]")) {
          break;
        }
        elements.push(this.expression());
      } while (this.expect(","));
    }
    this.consume("]");
    return { type: AST.ArrayExpression, elements };
  },
  object: function() {
    var properties = [], property2;
    if (this.peekToken().text !== "}") {
      do {
        if (this.peek("}")) {
          break;
        }
        property2 = { type: AST.Property, kind: "init" };
        if (this.peek().constant) {
          property2.key = this.constant();
          property2.computed = false;
          this.consume(":");
          property2.value = this.expression();
        } else if (this.peek().identifier) {
          property2.key = this.identifier();
          property2.computed = false;
          if (this.peek(":")) {
            this.consume(":");
            property2.value = this.expression();
          } else {
            property2.value = property2.key;
          }
        } else if (this.peek("[")) {
          this.consume("[");
          property2.key = this.expression();
          this.consume("]");
          property2.computed = true;
          this.consume(":");
          property2.value = this.expression();
        } else {
          this.throwError("invalid key", this.peek());
        }
        properties.push(property2);
      } while (this.expect(","));
    }
    this.consume("}");
    return { type: AST.ObjectExpression, properties };
  },
  throwError: function(msg, token2) {
    throw $parseMinErr(
      "syntax",
      "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].",
      token2.text,
      msg,
      token2.index + 1,
      this.text,
      this.text.substring(token2.index)
    );
  },
  consume: function(e1) {
    if (this.tokens.length === 0) {
      throw $parseMinErr(
        "ueoe",
        "Unexpected end of expression: {0}",
        this.text
      );
    }
    var token2 = this.expect(e1);
    if (!token2) {
      this.throwError("is unexpected, expecting [" + e1 + "]", this.peek());
    }
    return token2;
  },
  peekToken: function() {
    if (this.tokens.length === 0) {
      throw $parseMinErr(
        "ueoe",
        "Unexpected end of expression: {0}",
        this.text
      );
    }
    return this.tokens[0];
  },
  peek: function(e1, e2, e3, e4) {
    return this.peekAhead(0, e1, e2, e3, e4);
  },
  peekAhead: function(i2, e1, e2, e3, e4) {
    if (this.tokens.length > i2) {
      var token2 = this.tokens[i2];
      var t2 = token2.text;
      if (t2 === e1 || t2 === e2 || t2 === e3 || t2 === e4 || !e1 && !e2 && !e3 && !e4) {
        return token2;
      }
    }
    return false;
  },
  expect: function(e1, e2, e3, e4) {
    var token2 = this.peek(e1, e2, e3, e4);
    if (token2) {
      this.tokens.shift();
      return token2;
    }
    return false;
  },
  selfReferential: {
    this: { type: AST.ThisExpression },
    $locals: { type: AST.LocalsExpression }
  }
};
function ifDefined(v2, d2) {
  return typeof v2 !== "undefined" ? v2 : d2;
}
function plusFn(l2, r2) {
  if (typeof l2 === "undefined")
    return r2;
  if (typeof r2 === "undefined")
    return l2;
  return l2 + r2;
}
function isStateless($filter, filterName) {
  var fn2 = $filter(filterName);
  if (!fn2) {
    throw new Error("Filter '" + filterName + "' is not defined");
  }
  return !fn2.$stateful;
}
function findConstantAndWatchExpressions(ast, $filter) {
  var allConstants;
  var argsToWatch;
  var isStatelessFilter;
  switch (ast.type) {
    case AST.Program:
      allConstants = true;
      forEach3(ast.body, function(expr) {
        findConstantAndWatchExpressions(expr.expression, $filter);
        allConstants = allConstants && expr.expression.constant;
      });
      ast.constant = allConstants;
      break;
    case AST.Literal:
      ast.constant = true;
      ast.toWatch = [];
      break;
    case AST.UnaryExpression:
      findConstantAndWatchExpressions(ast.argument, $filter);
      ast.constant = ast.argument.constant;
      ast.toWatch = ast.argument.toWatch;
      break;
    case AST.BinaryExpression:
      findConstantAndWatchExpressions(ast.left, $filter);
      findConstantAndWatchExpressions(ast.right, $filter);
      ast.constant = ast.left.constant && ast.right.constant;
      ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
      break;
    case AST.LogicalExpression:
      findConstantAndWatchExpressions(ast.left, $filter);
      findConstantAndWatchExpressions(ast.right, $filter);
      ast.constant = ast.left.constant && ast.right.constant;
      ast.toWatch = ast.constant ? [] : [ast];
      break;
    case AST.ConditionalExpression:
      findConstantAndWatchExpressions(ast.test, $filter);
      findConstantAndWatchExpressions(ast.alternate, $filter);
      findConstantAndWatchExpressions(ast.consequent, $filter);
      ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
      ast.toWatch = ast.constant ? [] : [ast];
      break;
    case AST.Identifier:
      ast.constant = false;
      ast.toWatch = [ast];
      break;
    case AST.MemberExpression:
      findConstantAndWatchExpressions(ast.object, $filter);
      if (ast.computed) {
        findConstantAndWatchExpressions(ast.property, $filter);
      }
      ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
      ast.toWatch = [ast];
      break;
    case AST.CallExpression:
      isStatelessFilter = ast.filter ? isStateless($filter, ast.callee.name) : false;
      allConstants = isStatelessFilter;
      argsToWatch = [];
      forEach3(ast.arguments, function(expr) {
        findConstantAndWatchExpressions(expr, $filter);
        allConstants = allConstants && expr.constant;
        if (!expr.constant) {
          argsToWatch.push.apply(argsToWatch, expr.toWatch);
        }
      });
      ast.constant = allConstants;
      ast.toWatch = isStatelessFilter ? argsToWatch : [ast];
      break;
    case AST.AssignmentExpression:
      findConstantAndWatchExpressions(ast.left, $filter);
      findConstantAndWatchExpressions(ast.right, $filter);
      ast.constant = ast.left.constant && ast.right.constant;
      ast.toWatch = [ast];
      break;
    case AST.ArrayExpression:
      allConstants = true;
      argsToWatch = [];
      forEach3(ast.elements, function(expr) {
        findConstantAndWatchExpressions(expr, $filter);
        allConstants = allConstants && expr.constant;
        if (!expr.constant) {
          argsToWatch.push.apply(argsToWatch, expr.toWatch);
        }
      });
      ast.constant = allConstants;
      ast.toWatch = argsToWatch;
      break;
    case AST.ObjectExpression:
      allConstants = true;
      argsToWatch = [];
      forEach3(ast.properties, function(property2) {
        findConstantAndWatchExpressions(property2.value, $filter);
        allConstants = allConstants && property2.value.constant && !property2.computed;
        if (!property2.value.constant) {
          argsToWatch.push.apply(argsToWatch, property2.value.toWatch);
        }
      });
      ast.constant = allConstants;
      ast.toWatch = argsToWatch;
      break;
    case AST.ThisExpression:
      ast.constant = false;
      ast.toWatch = [];
      break;
    case AST.LocalsExpression:
      ast.constant = false;
      ast.toWatch = [];
      break;
  }
}
function getInputs(body) {
  if (body.length !== 1)
    return;
  var lastExpression = body[0].expression;
  var candidate = lastExpression.toWatch;
  if (candidate.length !== 1)
    return candidate;
  return candidate[0] !== lastExpression ? candidate : void 0;
}
function isAssignable(ast) {
  return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
}
function assignableAST(ast) {
  if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
    return {
      type: AST.AssignmentExpression,
      left: ast.body[0].expression,
      right: { type: AST.NGValueParameter },
      operator: "="
    };
  }
}
function isLiteral(ast) {
  return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
}
function isConstant(ast) {
  return ast.constant;
}
function ASTCompiler(astBuilder, $filter) {
  this.astBuilder = astBuilder;
  this.$filter = $filter;
}
ASTCompiler.prototype = {
  compile: function(expression) {
    var self2 = this;
    var ast = this.astBuilder.ast(expression);
    this.state = {
      nextId: 0,
      filters: {},
      fn: { vars: [], body: [], own: {} },
      assign: { vars: [], body: [], own: {} },
      inputs: []
    };
    findConstantAndWatchExpressions(ast, self2.$filter);
    var extra2 = "";
    var assignable;
    this.stage = "assign";
    if (assignable = assignableAST(ast)) {
      this.state.computing = "assign";
      var result = this.nextId();
      this.recurse(assignable, result);
      this.return_(result);
      extra2 = "fn.assign=" + this.generateFunction("assign", "s,v,l");
    }
    var toWatch = getInputs(ast.body);
    self2.stage = "inputs";
    forEach3(toWatch, function(watch, key) {
      var fnKey = "fn" + key;
      self2.state[fnKey] = { vars: [], body: [], own: {} };
      self2.state.computing = fnKey;
      var intoId = self2.nextId();
      self2.recurse(watch, intoId);
      self2.return_(intoId);
      self2.state.inputs.push(fnKey);
      watch.watchId = key;
    });
    this.state.computing = "fn";
    this.stage = "main";
    this.recurse(ast);
    var fnString = (
      // The build and minification steps remove the string "use strict" from the code, but this is done using a regex.
      // This is a workaround for this until we do a better job at only removing the prefix only when we should.
      '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + extra2 + this.watchFns() + "return fn;"
    );
    var fn2 = new Function(
      "$filter",
      "getStringValue",
      "ifDefined",
      "plus",
      fnString
    )(this.$filter, getStringValue, ifDefined, plusFn);
    this.state = this.stage = void 0;
    fn2.ast = ast;
    fn2.literal = isLiteral(ast);
    fn2.constant = isConstant(ast);
    return fn2;
  },
  USE: "use",
  STRICT: "strict",
  watchFns: function() {
    var result = [];
    var fns = this.state.inputs;
    var self2 = this;
    forEach3(fns, function(name) {
      result.push("var " + name + "=" + self2.generateFunction(name, "s"));
    });
    if (fns.length) {
      result.push("fn.inputs=[" + fns.join(",") + "];");
    }
    return result.join("");
  },
  generateFunction: function(name, params) {
    return "function(" + params + "){" + this.varsPrefix(name) + this.body(name) + "};";
  },
  filterPrefix: function() {
    var parts = [];
    var self2 = this;
    forEach3(this.state.filters, function(id2, filter2) {
      parts.push(id2 + "=$filter(" + self2.escape(filter2) + ")");
    });
    if (parts.length)
      return "var " + parts.join(",") + ";";
    return "";
  },
  varsPrefix: function(section) {
    return this.state[section].vars.length ? "var " + this.state[section].vars.join(",") + ";" : "";
  },
  body: function(section) {
    return this.state[section].body.join("");
  },
  recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
    var left, right, self2 = this, args, expression, computed;
    recursionFn = recursionFn || noop$4;
    if (!skipWatchIdCheck && isDefined(ast.watchId)) {
      intoId = intoId || this.nextId();
      this.if_(
        "i",
        this.lazyAssign(intoId, this.unsafeComputedMember("i", ast.watchId)),
        this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true)
      );
      return;
    }
    switch (ast.type) {
      case AST.Program:
        forEach3(ast.body, function(expression2, pos) {
          self2.recurse(
            expression2.expression,
            void 0,
            void 0,
            function(expr) {
              right = expr;
            }
          );
          if (pos !== ast.body.length - 1) {
            self2.current().body.push(right, ";");
          } else {
            self2.return_(right);
          }
        });
        break;
      case AST.Literal:
        expression = this.escape(ast.value);
        this.assign(intoId, expression);
        recursionFn(intoId || expression);
        break;
      case AST.UnaryExpression:
        this.recurse(ast.argument, void 0, void 0, function(expr) {
          right = expr;
        });
        expression = ast.operator + "(" + this.ifDefined(right, 0) + ")";
        this.assign(intoId, expression);
        recursionFn(expression);
        break;
      case AST.BinaryExpression:
        this.recurse(ast.left, void 0, void 0, function(expr) {
          left = expr;
        });
        this.recurse(ast.right, void 0, void 0, function(expr) {
          right = expr;
        });
        if (ast.operator === "+") {
          expression = this.plus(left, right);
        } else if (ast.operator === "-") {
          expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
        } else {
          expression = "(" + left + ")" + ast.operator + "(" + right + ")";
        }
        this.assign(intoId, expression);
        recursionFn(expression);
        break;
      case AST.LogicalExpression:
        intoId = intoId || this.nextId();
        self2.recurse(ast.left, intoId);
        self2.if_(
          ast.operator === "&&" ? intoId : self2.not(intoId),
          self2.lazyRecurse(ast.right, intoId)
        );
        recursionFn(intoId);
        break;
      case AST.ConditionalExpression:
        intoId = intoId || this.nextId();
        self2.recurse(ast.test, intoId);
        self2.if_(
          intoId,
          self2.lazyRecurse(ast.alternate, intoId),
          self2.lazyRecurse(ast.consequent, intoId)
        );
        recursionFn(intoId);
        break;
      case AST.Identifier:
        intoId = intoId || this.nextId();
        var inAssignment = self2.current().inAssignment;
        if (nameId) {
          if (inAssignment) {
            nameId.context = this.assign(this.nextId(), "s");
          } else {
            nameId.context = self2.stage === "inputs" ? "s" : this.assign(
              this.nextId(),
              this.getHasOwnProperty("l", ast.name) + "?l:s"
            );
          }
          nameId.computed = false;
          nameId.name = ast.name;
        }
        self2.if_(
          self2.stage === "inputs" || self2.not(self2.getHasOwnProperty("l", ast.name)),
          function() {
            self2.if_(
              self2.stage === "inputs" || self2.and_(
                "s",
                self2.or_(
                  self2.isNull(self2.nonComputedMember("s", ast.name)),
                  self2.hasOwnProperty_("s", ast.name)
                )
              ),
              function() {
                if (create && create !== 1) {
                  self2.if_(
                    self2.isNull(self2.nonComputedMember("s", ast.name)),
                    self2.lazyAssign(self2.nonComputedMember("s", ast.name), "{}")
                  );
                }
                self2.assign(intoId, self2.nonComputedMember("s", ast.name));
              }
            );
          },
          intoId && self2.lazyAssign(intoId, self2.nonComputedMember("l", ast.name))
        );
        recursionFn(intoId);
        break;
      case AST.MemberExpression:
        left = nameId && (nameId.context = this.nextId()) || this.nextId();
        intoId = intoId || this.nextId();
        self2.recurse(
          ast.object,
          left,
          void 0,
          function() {
            var member = null;
            var inAssignment2 = self2.current().inAssignment;
            if (ast.computed) {
              right = self2.nextId();
              if (inAssignment2 || self2.state.computing === "assign") {
                member = self2.unsafeComputedMember(left, right);
              } else {
                member = self2.computedMember(left, right);
              }
            } else {
              if (inAssignment2 || self2.state.computing === "assign") {
                member = self2.unsafeNonComputedMember(left, ast.property.name);
              } else {
                member = self2.nonComputedMember(left, ast.property.name);
              }
              right = ast.property.name;
            }
            if (ast.computed) {
              if (ast.property.type === AST.Literal) {
                self2.recurse(ast.property, right);
              }
            }
            self2.if_(
              self2.and_(
                self2.notNull(left),
                self2.or_(
                  self2.isNull(member),
                  self2.hasOwnProperty_(left, right, ast.computed)
                )
              ),
              function() {
                if (ast.computed) {
                  if (ast.property.type !== AST.Literal) {
                    self2.recurse(ast.property, right);
                  }
                  if (create && create !== 1) {
                    self2.if_(self2.not(member), self2.lazyAssign(member, "{}"));
                  }
                  self2.assign(intoId, member);
                  if (nameId) {
                    nameId.computed = true;
                    nameId.name = right;
                  }
                } else {
                  if (create && create !== 1) {
                    self2.if_(
                      self2.isNull(member),
                      self2.lazyAssign(member, "{}")
                    );
                  }
                  self2.assign(intoId, member);
                  if (nameId) {
                    nameId.computed = false;
                    nameId.name = ast.property.name;
                  }
                }
              },
              function() {
                self2.assign(intoId, "undefined");
              }
            );
            recursionFn(intoId);
          },
          !!create
        );
        break;
      case AST.CallExpression:
        intoId = intoId || this.nextId();
        if (ast.filter) {
          right = self2.filter(ast.callee.name);
          args = [];
          forEach3(ast.arguments, function(expr) {
            var argument = self2.nextId();
            self2.recurse(expr, argument);
            args.push(argument);
          });
          expression = right + ".call(" + right + "," + args.join(",") + ")";
          self2.assign(intoId, expression);
          recursionFn(intoId);
        } else {
          right = self2.nextId();
          left = {};
          args = [];
          self2.recurse(ast.callee, right, left, function() {
            self2.if_(
              self2.notNull(right),
              function() {
                forEach3(ast.arguments, function(expr) {
                  self2.recurse(
                    expr,
                    ast.constant ? void 0 : self2.nextId(),
                    void 0,
                    function(argument) {
                      args.push(argument);
                    }
                  );
                });
                if (left.name) {
                  var x = self2.member(left.context, left.name, left.computed);
                  expression = "(" + x + " === null ? null : " + self2.unsafeMember(left.context, left.name, left.computed) + ".call(" + [left.context].concat(args).join(",") + "))";
                } else {
                  expression = right + "(" + args.join(",") + ")";
                }
                self2.assign(intoId, expression);
              },
              function() {
                self2.assign(intoId, "undefined");
              }
            );
            recursionFn(intoId);
          });
        }
        break;
      case AST.AssignmentExpression:
        right = this.nextId();
        left = {};
        self2.current().inAssignment = true;
        this.recurse(
          ast.left,
          void 0,
          left,
          function() {
            self2.if_(
              self2.and_(
                self2.notNull(left.context),
                self2.or_(
                  self2.hasOwnProperty_(left.context, left.name),
                  self2.isNull(
                    self2.member(left.context, left.name, left.computed)
                  )
                )
              ),
              function() {
                self2.recurse(ast.right, right);
                expression = self2.member(left.context, left.name, left.computed) + ast.operator + right;
                self2.assign(intoId, expression);
                recursionFn(intoId || expression);
              }
            );
            self2.current().inAssignment = false;
            self2.recurse(ast.right, right);
            self2.current().inAssignment = true;
          },
          1
        );
        self2.current().inAssignment = false;
        break;
      case AST.ArrayExpression:
        args = [];
        forEach3(ast.elements, function(expr) {
          self2.recurse(
            expr,
            ast.constant ? void 0 : self2.nextId(),
            void 0,
            function(argument) {
              args.push(argument);
            }
          );
        });
        expression = "[" + args.join(",") + "]";
        this.assign(intoId, expression);
        recursionFn(intoId || expression);
        break;
      case AST.ObjectExpression:
        args = [];
        computed = false;
        forEach3(ast.properties, function(property2) {
          if (property2.computed) {
            computed = true;
          }
        });
        if (computed) {
          intoId = intoId || this.nextId();
          this.assign(intoId, "{}");
          forEach3(ast.properties, function(property2) {
            if (property2.computed) {
              left = self2.nextId();
              self2.recurse(property2.key, left);
            } else {
              left = property2.key.type === AST.Identifier ? property2.key.name : "" + property2.key.value;
            }
            right = self2.nextId();
            self2.recurse(property2.value, right);
            self2.assign(
              self2.unsafeMember(intoId, left, property2.computed),
              right
            );
          });
        } else {
          forEach3(ast.properties, function(property2) {
            self2.recurse(
              property2.value,
              ast.constant ? void 0 : self2.nextId(),
              void 0,
              function(expr) {
                args.push(
                  self2.escape(
                    property2.key.type === AST.Identifier ? property2.key.name : "" + property2.key.value
                  ) + ":" + expr
                );
              }
            );
          });
          expression = "{" + args.join(",") + "}";
          this.assign(intoId, expression);
        }
        recursionFn(intoId || expression);
        break;
      case AST.ThisExpression:
        this.assign(intoId, "s");
        recursionFn(intoId || "s");
        break;
      case AST.LocalsExpression:
        this.assign(intoId, "l");
        recursionFn(intoId || "l");
        break;
      case AST.NGValueParameter:
        this.assign(intoId, "v");
        recursionFn(intoId || "v");
        break;
    }
  },
  getHasOwnProperty: function(element, property2) {
    var key = element + "." + property2;
    var own = this.current().own;
    if (!own.hasOwnProperty(key)) {
      own[key] = this.nextId(
        false,
        element + "&&(" + this.escape(property2) + " in " + element + ")"
      );
    }
    return own[key];
  },
  assign: function(id2, value) {
    if (!id2)
      return;
    this.current().body.push(id2, "=", value, ";");
    return id2;
  },
  filter: function(filterName) {
    if (!this.state.filters.hasOwnProperty(filterName)) {
      this.state.filters[filterName] = this.nextId(true);
    }
    return this.state.filters[filterName];
  },
  ifDefined: function(id2, defaultValue2) {
    return "ifDefined(" + id2 + "," + this.escape(defaultValue2) + ")";
  },
  plus: function(left, right) {
    return "plus(" + left + "," + right + ")";
  },
  return_: function(id2) {
    this.current().body.push("return ", id2, ";");
  },
  if_: function(test2, alternate, consequent) {
    if (test2 === true) {
      alternate();
    } else {
      var body = this.current().body;
      body.push("if(", test2, "){");
      alternate();
      body.push("}");
      if (consequent) {
        body.push("else{");
        consequent();
        body.push("}");
      }
    }
  },
  or_: function(expr1, expr2) {
    return "(" + expr1 + ") || (" + expr2 + ")";
  },
  hasOwnProperty_: function(obj, prop, computed) {
    if (computed) {
      return "(Object.prototype.hasOwnProperty.call(" + obj + "," + prop + "))";
    } else {
      return "(Object.prototype.hasOwnProperty.call(" + obj + ",'" + prop + "'))";
    }
  },
  and_: function(expr1, expr2) {
    return "(" + expr1 + ") && (" + expr2 + ")";
  },
  not: function(expression) {
    return "!(" + expression + ")";
  },
  isNull: function(expression) {
    return expression + "==null";
  },
  notNull: function(expression) {
    return expression + "!=null";
  },
  nonComputedMember: function(left, right) {
    var SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;
    var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
    var expr = "";
    if (SAFE_IDENTIFIER.test(right)) {
      expr = left + "." + right;
    } else {
      right = right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn);
      expr = left + '["' + right + '"]';
    }
    return expr;
  },
  unsafeComputedMember: function(left, right) {
    return left + "[" + right + "]";
  },
  unsafeNonComputedMember: function(left, right) {
    return this.nonComputedMember(left, right);
  },
  computedMember: function(left, right) {
    if (this.state.computing === "assign") {
      return this.unsafeComputedMember(left, right);
    }
    return "(" + left + ".hasOwnProperty(" + right + ") ? " + left + "[" + right + "] : null)";
  },
  unsafeMember: function(left, right, computed) {
    if (computed)
      return this.unsafeComputedMember(left, right);
    return this.unsafeNonComputedMember(left, right);
  },
  member: function(left, right, computed) {
    if (computed)
      return this.computedMember(left, right);
    return this.nonComputedMember(left, right);
  },
  getStringValue: function(item) {
    this.assign(item, "getStringValue(" + item + ")");
  },
  lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
    var self2 = this;
    return function() {
      self2.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
    };
  },
  lazyAssign: function(id2, value) {
    var self2 = this;
    return function() {
      self2.assign(id2, value);
    };
  },
  stringEscapeRegex: /[^ a-zA-Z0-9]/g,
  stringEscapeFn: function(c2) {
    return "\\u" + ("0000" + c2.charCodeAt(0).toString(16)).slice(-4);
  },
  escape: function(value) {
    if (isString$2(value))
      return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
    if (isNumber$1(value))
      return value.toString();
    if (value === true)
      return "true";
    if (value === false)
      return "false";
    if (value === null)
      return "null";
    if (typeof value === "undefined")
      return "undefined";
    throw $parseMinErr("esc", "IMPOSSIBLE");
  },
  nextId: function(skip, init3) {
    var id2 = "v" + this.state.nextId++;
    if (!skip) {
      this.current().vars.push(id2 + (init3 ? "=" + init3 : ""));
    }
    return id2;
  },
  current: function() {
    return this.state[this.state.computing];
  }
};
function ASTInterpreter(astBuilder, $filter) {
  this.astBuilder = astBuilder;
  this.$filter = $filter;
}
ASTInterpreter.prototype = {
  compile: function(expression) {
    var self2 = this;
    var ast = this.astBuilder.ast(expression);
    findConstantAndWatchExpressions(ast, self2.$filter);
    var assignable;
    var assign2;
    if (assignable = assignableAST(ast)) {
      assign2 = this.recurse(assignable);
    }
    var toWatch = getInputs(ast.body);
    var inputs;
    if (toWatch) {
      inputs = [];
      forEach3(toWatch, function(watch, key) {
        var input = self2.recurse(watch);
        watch.input = input;
        inputs.push(input);
        watch.watchId = key;
      });
    }
    var expressions = [];
    forEach3(ast.body, function(expression2) {
      expressions.push(self2.recurse(expression2.expression));
    });
    var fn2 = ast.body.length === 0 ? noop$4 : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
      var lastValue;
      forEach3(expressions, function(exp) {
        lastValue = exp(scope, locals);
      });
      return lastValue;
    };
    if (assign2) {
      fn2.assign = function(scope, value, locals) {
        return assign2(scope, locals, value);
      };
    }
    if (inputs) {
      fn2.inputs = inputs;
    }
    fn2.ast = ast;
    fn2.literal = isLiteral(ast);
    fn2.constant = isConstant(ast);
    return fn2;
  },
  recurse: function(ast, context2, create) {
    var left, right, self2 = this, args;
    if (ast.input) {
      return this.inputs(ast.input, ast.watchId);
    }
    switch (ast.type) {
      case AST.Literal:
        return this.value(ast.value, context2);
      case AST.UnaryExpression:
        right = this.recurse(ast.argument);
        return this["unary" + ast.operator](right, context2);
      case AST.BinaryExpression:
        left = this.recurse(ast.left);
        right = this.recurse(ast.right);
        return this["binary" + ast.operator](left, right, context2);
      case AST.LogicalExpression:
        left = this.recurse(ast.left);
        right = this.recurse(ast.right);
        return this["binary" + ast.operator](left, right, context2);
      case AST.ConditionalExpression:
        return this["ternary?:"](
          this.recurse(ast.test),
          this.recurse(ast.alternate),
          this.recurse(ast.consequent),
          context2
        );
      case AST.Identifier:
        return self2.identifier(ast.name, context2, create);
      case AST.MemberExpression:
        left = this.recurse(ast.object, false, !!create);
        if (!ast.computed) {
          right = ast.property.name;
        }
        if (ast.computed)
          right = this.recurse(ast.property);
        return ast.computed ? this.computedMember(left, right, context2, create) : this.nonComputedMember(left, right, context2, create);
      case AST.CallExpression:
        args = [];
        forEach3(ast.arguments, function(expr) {
          args.push(self2.recurse(expr));
        });
        if (ast.filter)
          right = this.$filter(ast.callee.name);
        if (!ast.filter)
          right = this.recurse(ast.callee, true);
        return ast.filter ? function(scope, locals, assign2, inputs) {
          var values = [];
          for (var i2 = 0; i2 < args.length; ++i2) {
            values.push(args[i2](scope, locals, assign2, inputs));
          }
          var value = right.apply(void 0, values, inputs);
          return context2 ? { context: void 0, name: void 0, value } : value;
        } : function(scope, locals, assign2, inputs) {
          var rhs = right(scope, locals, assign2, inputs);
          var value;
          if (rhs.value != null) {
            var values = [];
            for (var i2 = 0; i2 < args.length; ++i2) {
              values.push(args[i2](scope, locals, assign2, inputs));
            }
            value = rhs.value.apply(rhs.context, values);
          }
          return context2 ? { value } : value;
        };
      case AST.AssignmentExpression:
        left = this.recurse(ast.left, true, 1);
        right = this.recurse(ast.right);
        return function(scope, locals, assign2, inputs) {
          var lhs = left(scope, false, assign2, inputs);
          var rhs = right(scope, locals, assign2, inputs);
          lhs.context[lhs.name] = rhs;
          return context2 ? { value: rhs } : rhs;
        };
      case AST.ArrayExpression:
        args = [];
        forEach3(ast.elements, function(expr) {
          args.push(self2.recurse(expr));
        });
        return function(scope, locals, assign2, inputs) {
          var value = [];
          for (var i2 = 0; i2 < args.length; ++i2) {
            value.push(args[i2](scope, locals, assign2, inputs));
          }
          return context2 ? { value } : value;
        };
      case AST.ObjectExpression:
        args = [];
        forEach3(ast.properties, function(property2) {
          if (property2.computed) {
            args.push({
              key: self2.recurse(property2.key),
              computed: true,
              value: self2.recurse(property2.value)
            });
          } else {
            args.push({
              key: property2.key.type === AST.Identifier ? property2.key.name : "" + property2.key.value,
              computed: false,
              value: self2.recurse(property2.value)
            });
          }
        });
        return function(scope, locals, assign2, inputs) {
          var value = {};
          for (var i2 = 0; i2 < args.length; ++i2) {
            if (args[i2].computed) {
              value[args[i2].key(scope, locals, assign2, inputs)] = args[i2].value(
                scope,
                locals,
                assign2,
                inputs
              );
            } else {
              value[args[i2].key] = args[i2].value(scope, locals, assign2, inputs);
            }
          }
          return context2 ? { value } : value;
        };
      case AST.ThisExpression:
        return function(scope) {
          return context2 ? { value: scope } : scope;
        };
      case AST.LocalsExpression:
        return function(scope, locals) {
          return context2 ? { value: locals } : locals;
        };
      case AST.NGValueParameter:
        return function(scope, locals, assign2) {
          return context2 ? { value: assign2 } : assign2;
        };
    }
  },
  "unary+": function(argument, context2) {
    return function(scope, locals, assign2, inputs) {
      var arg = argument(scope, locals, assign2, inputs);
      if (isDefined(arg)) {
        arg = +arg;
      } else {
        arg = 0;
      }
      return context2 ? { value: arg } : arg;
    };
  },
  "unary-": function(argument, context2) {
    return function(scope, locals, assign2, inputs) {
      var arg = argument(scope, locals, assign2, inputs);
      if (isDefined(arg)) {
        arg = -arg;
      } else {
        arg = -0;
      }
      return context2 ? { value: arg } : arg;
    };
  },
  "unary!": function(argument, context2) {
    return function(scope, locals, assign2, inputs) {
      var arg = !argument(scope, locals, assign2, inputs);
      return context2 ? { value: arg } : arg;
    };
  },
  "binary+": function(left, right, context2) {
    return function(scope, locals, assign2, inputs) {
      var lhs = left(scope, locals, assign2, inputs);
      var rhs = right(scope, locals, assign2, inputs);
      var arg = plusFn(lhs, rhs);
      return context2 ? { value: arg } : arg;
    };
  },
  "binary-": function(left, right, context2) {
    return function(scope, locals, assign2, inputs) {
      var lhs = left(scope, locals, assign2, inputs);
      var rhs = right(scope, locals, assign2, inputs);
      var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
      return context2 ? { value: arg } : arg;
    };
  },
  "binary*": function(left, right, context2) {
    return function(scope, locals, assign2, inputs) {
      var arg = left(scope, locals, assign2, inputs) * right(scope, locals, assign2, inputs);
      return context2 ? { value: arg } : arg;
    };
  },
  "binary/": function(left, right, context2) {
    return function(scope, locals, assign2, inputs) {
      var arg = left(scope, locals, assign2, inputs) / right(scope, locals, assign2, inputs);
      return context2 ? { value: arg } : arg;
    };
  },
  "binary%": function(left, right, context2) {
    return function(scope, locals, assign2, inputs) {
      var arg = left(scope, locals, assign2, inputs) % right(scope, locals, assign2, inputs);
      return context2 ? { value: arg } : arg;
    };
  },
  "binary===": function(left, right, context2) {
    return function(scope, locals, assign2, inputs) {
      var arg = left(scope, locals, assign2, inputs) === right(scope, locals, assign2, inputs);
      return context2 ? { value: arg } : arg;
    };
  },
  "binary!==": function(left, right, context2) {
    return function(scope, locals, assign2, inputs) {
      var arg = left(scope, locals, assign2, inputs) !== right(scope, locals, assign2, inputs);
      return context2 ? { value: arg } : arg;
    };
  },
  "binary==": function(left, right, context2) {
    return function(scope, locals, assign2, inputs) {
      var arg = left(scope, locals, assign2, inputs) == right(scope, locals, assign2, inputs);
      return context2 ? { value: arg } : arg;
    };
  },
  "binary!=": function(left, right, context2) {
    return function(scope, locals, assign2, inputs) {
      var arg = left(scope, locals, assign2, inputs) != right(scope, locals, assign2, inputs);
      return context2 ? { value: arg } : arg;
    };
  },
  "binary<": function(left, right, context2) {
    return function(scope, locals, assign2, inputs) {
      var arg = left(scope, locals, assign2, inputs) < right(scope, locals, assign2, inputs);
      return context2 ? { value: arg } : arg;
    };
  },
  "binary>": function(left, right, context2) {
    return function(scope, locals, assign2, inputs) {
      var arg = left(scope, locals, assign2, inputs) > right(scope, locals, assign2, inputs);
      return context2 ? { value: arg } : arg;
    };
  },
  "binary<=": function(left, right, context2) {
    return function(scope, locals, assign2, inputs) {
      var arg = left(scope, locals, assign2, inputs) <= right(scope, locals, assign2, inputs);
      return context2 ? { value: arg } : arg;
    };
  },
  "binary>=": function(left, right, context2) {
    return function(scope, locals, assign2, inputs) {
      var arg = left(scope, locals, assign2, inputs) >= right(scope, locals, assign2, inputs);
      return context2 ? { value: arg } : arg;
    };
  },
  "binary&&": function(left, right, context2) {
    return function(scope, locals, assign2, inputs) {
      var arg = left(scope, locals, assign2, inputs) && right(scope, locals, assign2, inputs);
      return context2 ? { value: arg } : arg;
    };
  },
  "binary||": function(left, right, context2) {
    return function(scope, locals, assign2, inputs) {
      var arg = left(scope, locals, assign2, inputs) || right(scope, locals, assign2, inputs);
      return context2 ? { value: arg } : arg;
    };
  },
  "ternary?:": function(test2, alternate, consequent, context2) {
    return function(scope, locals, assign2, inputs) {
      var arg = test2(scope, locals, assign2, inputs) ? alternate(scope, locals, assign2, inputs) : consequent(scope, locals, assign2, inputs);
      return context2 ? { value: arg } : arg;
    };
  },
  value: function(value, context2) {
    return function() {
      return context2 ? { context: void 0, name: void 0, value } : value;
    };
  },
  identifier: function(name, context2, create) {
    return function(scope, locals, assign2, inputs) {
      var base = locals && name in locals ? locals : scope;
      if (create && create !== 1 && base && base[name] == null) {
        base[name] = {};
      }
      var value = base ? base[name] : void 0;
      if (context2) {
        return { context: base, name, value };
      } else {
        return value;
      }
    };
  },
  computedMember: function(left, right, context2, create) {
    return function(scope, locals, assign2, inputs) {
      var lhs = left(scope, locals, assign2, inputs);
      var rhs;
      var value;
      if (lhs != null) {
        rhs = right(scope, locals, assign2, inputs);
        rhs = getStringValue(rhs);
        if (create && create !== 1) {
          if (lhs && !lhs[rhs]) {
            lhs[rhs] = {};
          }
        }
        if (Object.prototype.hasOwnProperty.call(lhs, rhs)) {
          value = lhs[rhs];
        }
      }
      if (context2) {
        return { context: lhs, name: rhs, value };
      } else {
        return value;
      }
    };
  },
  nonComputedMember: function(left, right, context2, create) {
    return function(scope, locals, assign2, inputs) {
      var lhs = left(scope, locals, assign2, inputs);
      if (create && create !== 1) {
        if (lhs && lhs[right] == null) {
          lhs[right] = {};
        }
      }
      var value = void 0;
      if (lhs != null && Object.prototype.hasOwnProperty.call(lhs, right)) {
        value = lhs[right];
      }
      if (context2) {
        return { context: lhs, name: right, value };
      } else {
        return value;
      }
    };
  },
  inputs: function(input, watchId) {
    return function(scope, value, locals, inputs) {
      if (inputs)
        return inputs[watchId];
      return input(scope, value, locals);
    };
  }
};
var Parser$1 = function Parser(lexer, $filter, options) {
  this.lexer = lexer;
  this.$filter = $filter;
  this.options = options;
  this.ast = new AST(lexer, options);
  this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
};
Parser$1.prototype = {
  constructor: Parser$1,
  parse: function(text2) {
    return this.astCompiler.compile(text2);
  }
};
parse$6.Lexer = Lexer$1;
parse$6.Parser = Parser$1;
var parse$5 = parse$6;
var filters$1 = {};
var Lexer2 = parse$5.Lexer;
var Parser2 = parse$5.Parser;
function compile$1(src, options) {
  options = options || {};
  var localFilters = options.filters || filters$1;
  var cache = options.filters ? options.cache || {} : compile$1.cache;
  var lexerOptions = options;
  var cached;
  if (typeof src !== "string") {
    throw new TypeError(
      "src must be a string, instead saw '" + typeof src + "'"
    );
  }
  var parserOptions = {
    csp: options.csp != null ? options.csp : false,
    // noUnsafeEval,
    literals: options.literals != null ? options.literals : {
      // defined at: function $ParseProvider() {
      true: true,
      false: false,
      null: null,
      /*eslint no-undefined: 0*/
      undefined: void 0
      /* eslint: no-undefined: 1  */
    }
  };
  var lexer = new Lexer2(lexerOptions);
  var parser = new Parser2(
    lexer,
    function getFilter(name) {
      return localFilters[name];
    },
    parserOptions
  );
  if (!cache) {
    return parser.parse(src);
  }
  cached = cache[src];
  if (!cached) {
    cached = cache[src] = parser.parse(src);
  }
  return cached;
}
compile$1.cache = /* @__PURE__ */ Object.create(null);
var compile_1 = compile$1;
const setVar = (sentence) => {
  let setGlobal = false;
  let minValue = null;
  let maxValue = null;
  sentence.args.forEach((e2) => {
    if (e2.key === "global") {
      setGlobal = true;
    } else if (e2.key === "minValue") {
      minValue = e2.value;
    } else if (e2.key === "maxValue") {
      maxValue = e2.value;
    }
  });
  let targetReducerFunction;
  if (setGlobal) {
    targetReducerFunction = setGlobalVar;
  } else {
    targetReducerFunction = setStageVar;
  }
  if (sentence.content.match(/=/)) {
    const key = sentence.content.split(/=/)[0];
    const valExp = sentence.content.split(/=/)[1];
    if (valExp === "random()") {
      webgalStore.dispatch(targetReducerFunction({ key, value: Math.random() }));
    } else if (valExp.match(/[+\-*\/()]/)) {
      const valExpArr = valExp.split(/([+\-*\/()])/g);
      const valExp2 = valExpArr.map((e2) => {
        if (e2.match(/[a-zA-Z]/)) {
          return getValueFromState(e2).toString();
        } else
          return e2;
      }).reduce((pre, curr) => pre + curr, "");
      const exp = compile_1(valExp2);
      let result = exp();
      if (typeof result === "number") {
        if (typeof minValue === "number") {
          if (result < minValue) {
            result = minValue;
          }
        }
        if (typeof maxValue === "number") {
          if (result > maxValue) {
            result = maxValue;
          }
        }
      }
      webgalStore.dispatch(targetReducerFunction({ key, value: result }));
    } else if (valExp.match(/true|false/)) {
      if (valExp.match(/true/)) {
        webgalStore.dispatch(targetReducerFunction({ key, value: true }));
      }
      if (valExp.match(/false/)) {
        webgalStore.dispatch(targetReducerFunction({ key, value: false }));
      }
    } else {
      if (!isNaN(Number(valExp))) {
        webgalStore.dispatch(targetReducerFunction({ key, value: Number(valExp) }));
      } else
        webgalStore.dispatch(targetReducerFunction({ key, value: valExp }));
    }
    if (setGlobal) {
      logger.debug("", { key, value: webgalStore.getState().userData.globalGameVar[key] });
      dumpToStorageFast();
    } else {
      logger.debug("", { key, value: webgalStore.getState().stage.GameVar[key] });
    }
  }
  return {
    performName: "none",
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
function getValueFromState(key) {
  let ret = 0;
  if (webgalStore.getState().stage.GameVar.hasOwnProperty(key)) {
    ret = webgalStore.getState().stage.GameVar[key];
  } else if (webgalStore.getState().userData.globalGameVar.hasOwnProperty(key)) {
    ret = webgalStore.getState().userData.globalGameVar[key];
  }
  return ret;
}
function strIf(s2) {
  const res = compile_1(s2);
  return res();
}
const whenChecker = (whenValue) => {
  if (whenValue === void 0) {
    return true;
  }
  const valExpArr = whenValue.split(/([+\-*\/()><!]|>=|<=|==|&&|\|\||!=)/g);
  const valExp = valExpArr.map((e2) => {
    if (e2.match(/[a-zA-Z]/)) {
      if (e2.match(/true/) || e2.match(/false/)) {
        return e2;
      }
      return getValueFromState(e2).toString();
    } else
      return e2;
  }).reduce((pre, curr) => pre + curr, "");
  return !!strIf(valExp);
};
const scriptExecutor = () => {
  if (WebGAL.sceneManager.sceneData.currentSentenceId > WebGAL.sceneManager.sceneData.currentScene.sentenceList.length - 1) {
    if (WebGAL.sceneManager.sceneData.sceneStack.length !== 0) {
      const sceneToRestore = WebGAL.sceneManager.sceneData.sceneStack.pop();
      if (sceneToRestore !== void 0) {
        restoreScene(sceneToRestore);
      }
    }
    return;
  }
  const currentScript = WebGAL.sceneManager.sceneData.currentScene.sentenceList[WebGAL.sceneManager.sceneData.currentSentenceId];
  const interpolationOneItem = (content) => {
    let retContent = content;
    const contentExp = retContent.match(new RegExp("(?<!\\\\)\\{(.*?)\\}", "g"));
    if (contentExp !== null) {
      contentExp.forEach((e2) => {
        const contentVarValue = getValueFromState(e2.replace(new RegExp("(?<!\\\\)\\{(.*)\\}"), "$1"));
        retContent = retContent.replace(e2, contentVarValue ? contentVarValue.toString() : e2);
      });
    }
    retContent = retContent.replace(/\\{/g, "{").replace(/\\}/g, "}");
    return retContent;
  };
  const variableInterpolation = () => {
    currentScript.content = interpolationOneItem(currentScript.content);
    currentScript.args.forEach((arg) => {
      if (arg.value && typeof arg.value === "string") {
        arg.value = interpolationOneItem(arg.value);
      }
    });
  };
  variableInterpolation();
  let runThis = true;
  let isHasWhenArg = false;
  let whenValue = "";
  currentScript.args.forEach((e2) => {
    if (e2.key === "when") {
      isHasWhenArg = true;
      whenValue = e2.value.toString();
    }
  });
  if (isHasWhenArg) {
    runThis = whenChecker(whenValue);
  }
  if (!runThis) {
    logger.warn("");
    WebGAL.sceneManager.sceneData.currentSentenceId++;
    nextSentence();
    return;
  }
  runScript(currentScript);
  let isNext = false;
  currentScript.args.forEach((e2) => {
    if (e2.key === "next" && e2.value) {
      isNext = true;
    }
  });
  let isSaveBacklog = currentScript.command === commandType$1.say;
  currentScript.args.forEach((e2) => {
    if (e2.key === "notend" && e2.value === true) {
      isSaveBacklog = false;
    }
  });
  let currentStageState;
  if (isNext) {
    WebGAL.sceneManager.sceneData.currentSentenceId++;
    scriptExecutor();
    return;
  }
  setTimeout(() => {
    currentStageState = webgalStore.getState().stage;
    const allState = {
      currentStageState,
      globalGameVar: webgalStore.getState().userData.globalGameVar
    };
    logger.debug("", allState);
    if (isSaveBacklog) {
      WebGAL.backlogManager.saveCurrentStateToBacklog();
    }
  }, 0);
  WebGAL.sceneManager.sceneData.currentSentenceId++;
};
const nextSentence = () => {
  WebGAL.events.userInteractNext.emit();
  const GUIState = webgalStore.getState().GUI;
  if (GUIState.showTitle) {
    return;
  }
  let isBlockingNext = false;
  WebGAL.gameplay.performController.performList.forEach((e2) => {
    if (e2.blockingNext()) {
      isBlockingNext = true;
    }
  });
  if (isBlockingNext) {
    logger.warn("next ");
    return;
  }
  let allSettled2 = true;
  WebGAL.gameplay.performController.performList.forEach((e2) => {
    if (!e2.isHoldOn && !e2.skipNextCollect)
      allSettled2 = false;
  });
  if (allSettled2) {
    const stageState = webgalStore.getState().stage;
    const newStageState = cloneDeep$1(stageState);
    for (let i2 = 0; i2 < newStageState.PerformList.length; i2++) {
      const e2 = newStageState.PerformList[i2];
      if (!e2.isHoldOn) {
        newStageState.PerformList.splice(i2, 1);
        i2--;
      }
    }
    webgalStore.dispatch(resetStageState(newStageState));
    scriptExecutor();
    return;
  }
  logger.warn("");
  let isGoNext = false;
  for (let i2 = 0; i2 < WebGAL.gameplay.performController.performList.length; i2++) {
    const e2 = WebGAL.gameplay.performController.performList[i2];
    if (!e2.isHoldOn) {
      if (e2.goNextWhenOver) {
        isGoNext = true;
      }
      if (!e2.skipNextCollect) {
        e2.stopFunction();
        clearTimeout(e2.stopTimeout);
        WebGAL.gameplay.performController.performList.splice(i2, 1);
        i2--;
      }
    }
  }
  if (isGoNext) {
    nextSentence();
  }
};
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$1;
var MapCache$1 = _MapCache$1, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
function SetCache$2(values) {
  var index2 = -1, length2 = values == null ? 0 : values.length;
  this.__data__ = new MapCache$1();
  while (++index2 < length2) {
    this.add(values[index2]);
  }
}
SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd;
SetCache$2.prototype.has = setCacheHas;
var _SetCache = SetCache$2;
function baseFindIndex$1(array, predicate, fromIndex, fromRight) {
  var length2 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length2) {
    if (predicate(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
}
var _baseFindIndex = baseFindIndex$1;
function baseIsNaN$1(value) {
  return value !== value;
}
var _baseIsNaN = baseIsNaN$1;
function strictIndexOf$1(array, value, fromIndex) {
  var index2 = fromIndex - 1, length2 = array.length;
  while (++index2 < length2) {
    if (array[index2] === value) {
      return index2;
    }
  }
  return -1;
}
var _strictIndexOf = strictIndexOf$1;
var baseFindIndex = _baseFindIndex, baseIsNaN = _baseIsNaN, strictIndexOf = _strictIndexOf;
function baseIndexOf$1(array, value, fromIndex) {
  return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
}
var _baseIndexOf = baseIndexOf$1;
var baseIndexOf = _baseIndexOf;
function arrayIncludes$1(array, value) {
  var length2 = array == null ? 0 : array.length;
  return !!length2 && baseIndexOf(array, value, 0) > -1;
}
var _arrayIncludes = arrayIncludes$1;
function arrayIncludesWith$1(array, value, comparator) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (comparator(value, array[index2])) {
      return true;
    }
  }
  return false;
}
var _arrayIncludesWith = arrayIncludesWith$1;
function cacheHas$2(cache, key) {
  return cache.has(key);
}
var _cacheHas = cacheHas$2;
function noop$3() {
}
var noop_1 = noop$3;
function setToArray$3(set) {
  var index2 = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var _setToArray = setToArray$3;
var Set$1 = _Set$1, noop$2 = noop_1, setToArray$2 = _setToArray;
var INFINITY$2 = 1 / 0;
var createSet$1 = !(Set$1 && 1 / setToArray$2(new Set$1([, -0]))[1] == INFINITY$2) ? noop$2 : function(values) {
  return new Set$1(values);
};
var _createSet = createSet$1;
var SetCache$1 = _SetCache, arrayIncludes = _arrayIncludes, arrayIncludesWith = _arrayIncludesWith, cacheHas$1 = _cacheHas, createSet = _createSet, setToArray$1 = _setToArray;
var LARGE_ARRAY_SIZE = 200;
function baseUniq$1(array, iteratee, comparator) {
  var index2 = -1, includes = arrayIncludes, length2 = array.length, isCommon = true, result = [], seen2 = result;
  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length2 >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray$1(set);
    }
    isCommon = false;
    includes = cacheHas$1;
    seen2 = new SetCache$1();
  } else {
    seen2 = iteratee ? [] : result;
  }
  outer:
    while (++index2 < length2) {
      var value = array[index2], computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen2.length;
        while (seenIndex--) {
          if (seen2[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen2.push(computed);
        }
        result.push(value);
      } else if (!includes(seen2, computed, comparator)) {
        if (seen2 !== result) {
          seen2.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
var _baseUniq = baseUniq$1;
var baseUniq = _baseUniq;
function uniqWith(array, comparator) {
  comparator = typeof comparator == "function" ? comparator : void 0;
  return array && array.length ? baseUniq(array, void 0, comparator) : [];
}
var uniqWith_1 = uniqWith;
const uniqWith$1 = /* @__PURE__ */ getDefaultExportFromCjs(uniqWith_1);
const scenePrefetcher = (sceneList) => {
  for (const e2 of sceneList) {
    if (!WebGAL.sceneManager.settledScenes.includes(e2)) {
      logger.info(`${e2}`);
      sceneFetcher(e2).then((r2) => {
        sceneParser(r2, e2, e2);
      });
    } else {
      logger.warn(`${e2}`);
    }
  }
};
const callScene = (sceneUrl, sceneName) => {
  WebGAL.sceneManager.sceneData.sceneStack.push({
    sceneName: WebGAL.sceneManager.sceneData.currentScene.sceneName,
    sceneUrl: WebGAL.sceneManager.sceneData.currentScene.sceneUrl,
    continueLine: WebGAL.sceneManager.sceneData.currentSentenceId
  });
  sceneFetcher(sceneUrl).then(async (rawScene) => {
    const scene = await WebGAL.sceneManager.setCurrentScene(rawScene, sceneName, sceneUrl, true);
    if (scene) {
      WebGAL.sceneManager.sceneData.currentSentenceId = 0;
      const subSceneList = WebGAL.sceneManager.sceneData.currentScene.subSceneList;
      WebGAL.sceneManager.settledScenes.push(sceneUrl);
      const subSceneListUniq = uniqWith$1(subSceneList);
      scenePrefetcher(subSceneListUniq);
      logger.debug("", WebGAL.sceneManager.sceneData);
      nextSentence();
    }
  });
};
const callSceneScript = (sentence) => {
  const sceneNameArray = sentence.content.split("/");
  const sceneName = sceneNameArray[sceneNameArray.length - 1];
  callScene(sentence.content, sceneName);
  return {
    performName: "none",
    duration: 0,
    isHoldOn: true,
    stopFunction: () => {
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
function generateTransformAnimationObj(target, applyFrame, duration) {
  let animationObj;
  const transformState = webgalStore.getState().stage.effects;
  const targetEffect = transformState.find((effect) => effect.target === target);
  applyFrame.duration = 500;
  if (duration && typeof duration === "number") {
    applyFrame.duration = duration;
  }
  animationObj = [applyFrame];
  if (targetEffect) {
    const effectWithDuration = { ...targetEffect.transform, duration: 0 };
    animationObj.unshift(effectWithDuration);
  } else {
    const effectWithDuration = { ...applyFrame, alpha: 0, duration: 0 };
    animationObj.unshift(effectWithDuration);
  }
  return animationObj;
}
function generateUniversalSoftInAnimationObj(targetKey, duration) {
  const target = WebGAL.gameplay.pixiStage.getStageObjByKey(targetKey);
  function setStartState() {
    if (target) {
      target.pixiContainer.alpha = 0;
    }
  }
  function setEndState() {
    if (target) {
      target.pixiContainer.alpha = 1;
    }
  }
  function tickerFunc(delta) {
    if (target) {
      const sprite = target.pixiContainer;
      const baseDuration = WebGAL.gameplay.pixiStage.frameDuration;
      const currentAddOplityDelta = duration / baseDuration * delta;
      const increasement = 1 / currentAddOplityDelta;
      if (sprite.alpha < 1) {
        sprite.alpha += increasement;
      }
    }
  }
  return {
    setStartState,
    setEndState,
    tickerFunc
  };
}
function generateUniversalSoftOffAnimationObj(targetKey, duration) {
  const target = WebGAL.gameplay.pixiStage.getStageObjByKey(targetKey);
  function setStartState() {
  }
  function setEndState() {
    if (target)
      target.pixiContainer.alpha = 0;
  }
  function tickerFunc(delta) {
    if (target) {
      const sprite = target.pixiContainer;
      const baseDuration = WebGAL.gameplay.pixiStage.frameDuration;
      const currentAddOplityDelta = duration / baseDuration * delta;
      const decreasement = 1 / currentAddOplityDelta;
      if (sprite.alpha > 0) {
        sprite.alpha -= decreasement;
      }
    }
  }
  return {
    setStartState,
    setEndState,
    tickerFunc
  };
}
const baseTransform = {
  alpha: 1,
  scale: {
    x: 1,
    y: 1
  },
  // pivot: {
  //   x: 0.5,
  //   y: 0.5,
  // },
  position: {
    x: 0,
    y: 0
  },
  rotation: 0,
  blur: 0
};
function __rest$2(s2, e2) {
  var t2 = {};
  for (var p in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
      t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
      if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
        t2[p[i2]] = s2[p[i2]];
    }
  return t2;
}
var warning = function() {
};
var invariant = function() {
};
const clamp$1 = (min, max2, v2) => Math.min(Math.max(v2, min), max2);
const safeMin = 1e-3;
const minDuration = 0.01;
const maxDuration = 10;
const minDamping = 0.05;
const maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope;
  let derivative;
  warning(duration <= maxDuration * 1e3);
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp$1(minDamping, maxDamping, dampingRatio);
  duration = clamp$1(minDuration, maxDuration, duration / 1e3);
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a2 = exponentialDecay - velocity;
      const b2 = calcAngularFreq(undampedFreq2, dampingRatio);
      const c2 = Math.exp(-delta);
      return safeMin - a2 / b2 * c2;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d2 = delta * velocity + velocity;
      const e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f2 = Math.exp(-delta);
      const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d2 - e2) * f2) / g2;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a2 * b2;
    };
    derivative = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (velocity - undampedFreq2) * (duration * duration);
      return a2 * b2;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = duration * 1e3;
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i2 = 1; i2 < rootIterations; i2++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"];
const physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys2) {
  return keys2.some((key) => options[key] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = Object.assign({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false }, options);
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    const derived = findSpring(options);
    springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0, mass: 1 });
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
function spring(_a2) {
  var { from: from2 = 0, to = 1, restSpeed = 2, restDelta } = _a2, options = __rest$2(_a2, ["from", "to", "restSpeed", "restDelta"]);
  const state = { done: false, value: from2 };
  let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options);
  let resolveSpring = zero;
  let resolveVelocity = zero;
  function createSpring() {
    const initialVelocity = velocity ? -(velocity / 1e3) : 0;
    const initialDelta = to - from2;
    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;
    if (restDelta === void 0) {
      restDelta = Math.min(Math.abs(to - from2) / 100, 0.4);
    }
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
      };
      resolveVelocity = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t2) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t2)) - envelope * (Math.cos(angularFreq * t2) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t2));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = (t2) => to - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        const freqForT = Math.min(dampedAngularFreq * t2, 300);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
  }
  createSpring();
  return {
    next: (t2) => {
      const current = resolveSpring(t2);
      if (!isResolvedFromDuration) {
        const currentVelocity = resolveVelocity(t2) * 1e3;
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t2 >= duration;
      }
      state.value = state.done ? to : current;
      return state;
    },
    flipTarget: () => {
      velocity = -velocity;
      [from2, to] = [to, from2];
      createSpring();
    }
  };
}
spring.needsInterpolation = (a2, b2) => typeof a2 === "string" || typeof b2 === "string";
const zero = (_t) => 0;
const progress = (from2, to, value) => {
  const toFromDifference = to - from2;
  return toFromDifference === 0 ? 1 : (value - from2) / toFromDifference;
};
const mix = (from2, to, progress2) => -progress2 * from2 + progress2 * to + from2;
const clamp = (min, max2) => (v2) => Math.max(Math.min(v2, max2), min);
const sanitize = (v2) => v2 % 1 ? Number(v2.toFixed(5)) : v2;
const floatRegex = /(-)?([\d]*\.?[\d])+/g;
const colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi;
const singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function isString$1(v2) {
  return typeof v2 === "string";
}
const number = {
  test: (v2) => typeof v2 === "number",
  parse: parseFloat,
  transform: (v2) => v2
};
const alpha = Object.assign(Object.assign({}, number), { transform: clamp(0, 1) });
Object.assign(Object.assign({}, number), { default: 1 });
const createUnitType = (unit) => ({
  test: (v2) => isString$1(v2) && v2.endsWith(unit) && v2.split(" ").length === 1,
  parse: parseFloat,
  transform: (v2) => `${v2}${unit}`
});
const percent = createUnitType("%");
Object.assign(Object.assign({}, percent), { parse: (v2) => percent.parse(v2) / 100, transform: (v2) => percent.transform(v2 * 100) });
const isColorString = (type2, testProp) => (v2) => {
  return Boolean(isString$1(v2) && singleColorRegex.test(v2) && v2.startsWith(type2) || testProp && Object.prototype.hasOwnProperty.call(v2, testProp));
};
const splitColor = (aName, bName, cName) => (v2) => {
  if (!isString$1(v2))
    return v2;
  const [a2, b2, c2, alpha2] = v2.match(floatRegex);
  return {
    [aName]: parseFloat(a2),
    [bName]: parseFloat(b2),
    [cName]: parseFloat(c2),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};
const hsla = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};
const clampRgbUnit = clamp(0, 255);
const rgbUnit = Object.assign(Object.assign({}, number), { transform: (v2) => Math.round(clampRgbUnit(v2)) });
const rgba = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red: red2, green: green2, blue: blue2, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red2) + ", " + rgbUnit.transform(green2) + ", " + rgbUnit.transform(blue2) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};
function parseHex(v2) {
  let r2 = "";
  let g2 = "";
  let b2 = "";
  let a2 = "";
  if (v2.length > 5) {
    r2 = v2.substr(1, 2);
    g2 = v2.substr(3, 2);
    b2 = v2.substr(5, 2);
    a2 = v2.substr(7, 2);
  } else {
    r2 = v2.substr(1, 1);
    g2 = v2.substr(2, 1);
    b2 = v2.substr(3, 1);
    a2 = v2.substr(4, 1);
    r2 += r2;
    g2 += g2;
    b2 += b2;
    a2 += a2;
  }
  return {
    red: parseInt(r2, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b2, 16),
    alpha: a2 ? parseInt(a2, 16) / 255 : 1
  };
}
const hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};
const color = {
  test: (v2) => rgba.test(v2) || hex.test(v2) || hsla.test(v2),
  parse: (v2) => {
    if (rgba.test(v2)) {
      return rgba.parse(v2);
    } else if (hsla.test(v2)) {
      return hsla.parse(v2);
    } else {
      return hex.parse(v2);
    }
  },
  transform: (v2) => {
    return isString$1(v2) ? v2 : v2.hasOwnProperty("red") ? rgba.transform(v2) : hsla.transform(v2);
  }
};
const colorToken = "${c}";
const numberToken = "${n}";
function test$1(v2) {
  var _a2, _b2, _c2, _d;
  return isNaN(v2) && isString$1(v2) && ((_b2 = (_a2 = v2.match(floatRegex)) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b2 !== void 0 ? _b2 : 0) + ((_d = (_c2 = v2.match(colorRegex)) === null || _c2 === void 0 ? void 0 : _c2.length) !== null && _d !== void 0 ? _d : 0) > 0;
}
function analyse$1(v2) {
  if (typeof v2 === "number")
    v2 = `${v2}`;
  const values = [];
  let numColors = 0;
  const colors = v2.match(colorRegex);
  if (colors) {
    numColors = colors.length;
    v2 = v2.replace(colorRegex, colorToken);
    values.push(...colors.map(color.parse));
  }
  const numbers = v2.match(floatRegex);
  if (numbers) {
    v2 = v2.replace(floatRegex, numberToken);
    values.push(...numbers.map(number.parse));
  }
  return { values, numColors, tokenised: v2 };
}
function parse$4(v2) {
  return analyse$1(v2).values;
}
function createTransformer(v2) {
  const { values, numColors, tokenised } = analyse$1(v2);
  const numValues = values.length;
  return (v3) => {
    let output2 = tokenised;
    for (let i2 = 0; i2 < numValues; i2++) {
      output2 = output2.replace(i2 < numColors ? colorToken : numberToken, i2 < numColors ? color.transform(v3[i2]) : sanitize(v3[i2]));
    }
    return output2;
  };
}
const convertNumbersToZero = (v2) => typeof v2 === "number" ? 0 : v2;
function getAnimatableNone(v2) {
  const parsed = parse$4(v2);
  const transformer = createTransformer(v2);
  return transformer(parsed.map(convertNumbersToZero));
}
const complex = { test: test$1, parse: parse$4, createTransformer, getAnimatableNone };
function hueToRgb(p, q2, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p + (q2 - p) * 6 * t2;
  if (t2 < 1 / 2)
    return q2;
  if (t2 < 2 / 3)
    return p + (q2 - p) * (2 / 3 - t2) * 6;
  return p;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red2 = 0;
  let green2 = 0;
  let blue2 = 0;
  if (!saturation) {
    red2 = green2 = blue2 = lightness;
  } else {
    const q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p = 2 * lightness - q2;
    red2 = hueToRgb(p, q2, hue + 1 / 3);
    green2 = hueToRgb(p, q2, hue);
    blue2 = hueToRgb(p, q2, hue - 1 / 3);
  }
  return {
    red: Math.round(red2 * 255),
    green: Math.round(green2 * 255),
    blue: Math.round(blue2 * 255),
    alpha: alpha2
  };
}
const mixLinearColor = (from2, to, v2) => {
  const fromExpo = from2 * from2;
  const toExpo = to * to;
  return Math.sqrt(Math.max(0, v2 * (toExpo - fromExpo) + fromExpo));
};
const colorTypes = [hex, rgba, hsla];
const getColorType = (v2) => colorTypes.find((type2) => type2.test(v2));
const mixColor = (from2, to) => {
  let fromColorType = getColorType(from2);
  let toColorType = getColorType(to);
  let fromColor = fromColorType.parse(from2);
  let toColor = toColorType.parse(to);
  if (fromColorType === hsla) {
    fromColor = hslaToRgba(fromColor);
    fromColorType = rgba;
  }
  if (toColorType === hsla) {
    toColor = hslaToRgba(toColor);
    toColorType = rgba;
  }
  const blended = Object.assign({}, fromColor);
  return (v2) => {
    for (const key in blended) {
      if (key !== "alpha") {
        blended[key] = mixLinearColor(fromColor[key], toColor[key], v2);
      }
    }
    blended.alpha = mix(fromColor.alpha, toColor.alpha, v2);
    return fromColorType.transform(blended);
  };
};
const isNum = (v2) => typeof v2 === "number";
const combineFunctions = (a2, b2) => (v2) => b2(a2(v2));
const pipe = (...transformers) => transformers.reduce(combineFunctions);
function getMixer(origin, target) {
  if (isNum(origin)) {
    return (v2) => mix(origin, target, v2);
  } else if (color.test(origin)) {
    return mixColor(origin, target);
  } else {
    return mixComplex(origin, target);
  }
}
const mixArray = (from2, to) => {
  const output2 = [...from2];
  const numValues = output2.length;
  const blendValue = from2.map((fromThis, i2) => getMixer(fromThis, to[i2]));
  return (v2) => {
    for (let i2 = 0; i2 < numValues; i2++) {
      output2[i2] = blendValue[i2](v2);
    }
    return output2;
  };
};
const mixObject = (origin, target) => {
  const output2 = Object.assign(Object.assign({}, origin), target);
  const blendValue = {};
  for (const key in output2) {
    if (origin[key] !== void 0 && target[key] !== void 0) {
      blendValue[key] = getMixer(origin[key], target[key]);
    }
  }
  return (v2) => {
    for (const key in blendValue) {
      output2[key] = blendValue[key](v2);
    }
    return output2;
  };
};
function analyse(value) {
  const parsed = complex.parse(value);
  const numValues = parsed.length;
  let numNumbers = 0;
  let numRGB = 0;
  let numHSL = 0;
  for (let i2 = 0; i2 < numValues; i2++) {
    if (numNumbers || typeof parsed[i2] === "number") {
      numNumbers++;
    } else {
      if (parsed[i2].hue !== void 0) {
        numHSL++;
      } else {
        numRGB++;
      }
    }
  }
  return { parsed, numNumbers, numRGB, numHSL };
}
const mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyse(origin);
  const targetStats = analyse(target);
  const canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;
  if (canInterpolate) {
    return pipe(mixArray(originStats.parsed, targetStats.parsed), template);
  } else {
    return (p) => `${p > 0 ? target : origin}`;
  }
};
const mixNumber = (from2, to) => (p) => mix(from2, to, p);
function detectMixerFactory(v2) {
  if (typeof v2 === "number") {
    return mixNumber;
  } else if (typeof v2 === "string") {
    if (color.test(v2)) {
      return mixColor;
    } else {
      return mixComplex;
    }
  } else if (Array.isArray(v2)) {
    return mixArray;
  } else if (typeof v2 === "object") {
    return mixObject;
  }
}
function createMixers(output2, ease, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || detectMixerFactory(output2[0]);
  const numMixers = output2.length - 1;
  for (let i2 = 0; i2 < numMixers; i2++) {
    let mixer = mixerFactory(output2[i2], output2[i2 + 1]);
    if (ease) {
      const easingFunction = Array.isArray(ease) ? ease[i2] : ease;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function fastInterpolate([from2, to], [mixer]) {
  return (v2) => mixer(progress(from2, to, v2));
}
function slowInterpolate(input, mixers) {
  const inputLength = input.length;
  const lastInputIndex = inputLength - 1;
  return (v2) => {
    let mixerIndex = 0;
    let foundMixerIndex = false;
    if (v2 <= input[0]) {
      foundMixerIndex = true;
    } else if (v2 >= input[lastInputIndex]) {
      mixerIndex = lastInputIndex - 1;
      foundMixerIndex = true;
    }
    if (!foundMixerIndex) {
      let i2 = 1;
      for (; i2 < inputLength; i2++) {
        if (input[i2] > v2 || i2 === lastInputIndex) {
          break;
        }
      }
      mixerIndex = i2 - 1;
    }
    const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v2);
    return mixers[mixerIndex](progressInRange);
  };
}
function interpolate(input, output2, { clamp: isClamp = true, ease, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output2.length);
  invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1);
  if (input[0] > input[inputLength - 1]) {
    input = [].concat(input);
    output2 = [].concat(output2);
    input.reverse();
    output2.reverse();
  }
  const mixers = createMixers(output2, ease, mixer);
  const interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);
  return isClamp ? (v2) => interpolator(clamp$1(input[0], input[inputLength - 1], v2)) : interpolator;
}
const mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
const createExpoIn = (power) => (p) => Math.pow(p, power);
const createBackIn = (power) => (p) => p * p * ((power + 1) * p - power);
const createAnticipate = (power) => {
  const backEasing = createBackIn(power);
  return (p) => (p *= 2) < 1 ? 0.5 * backEasing(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
};
const DEFAULT_OVERSHOOT_STRENGTH = 1.525;
const easeIn = createExpoIn(2);
const easeInOut = mirrorEasing(easeIn);
createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function defaultOffset(values) {
  const numValues = values.length;
  return values.map((_value, i2) => i2 !== 0 ? i2 / (numValues - 1) : 0);
}
function convertOffsetToTimes(offset, duration) {
  return offset.map((o2) => o2 * duration);
}
function keyframes({ from: from2 = 0, to = 1, ease, offset, duration = 300 }) {
  const state = { done: false, value: from2 };
  const values = Array.isArray(to) ? to : [from2, to];
  const times = convertOffsetToTimes(offset && offset.length === values.length ? offset : defaultOffset(values), duration);
  function createInterpolator() {
    return interpolate(times, values, {
      ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)
    });
  }
  let interpolator = createInterpolator();
  return {
    next: (t2) => {
      state.value = interpolator(t2);
      state.done = t2 >= duration;
      return state;
    },
    flipTarget: () => {
      values.reverse();
      interpolator = createInterpolator();
    }
  };
}
function decay({ velocity = 0, from: from2 = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget }) {
  const state = { done: false, value: from2 };
  let amplitude = power * velocity;
  const ideal = from2 + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - from2;
  return {
    next: (t2) => {
      const delta = -amplitude * Math.exp(-t2 / timeConstant);
      state.done = !(delta > restDelta || delta < -restDelta);
      state.value = state.done ? target : target + delta;
      return state;
    },
    flipTarget: () => {
    }
  };
}
const types = { keyframes, spring, decay };
function detectAnimationFromOptions(config) {
  if (Array.isArray(config.to)) {
    return keyframes;
  } else if (types[config.type]) {
    return types[config.type];
  }
  const keys2 = new Set(Object.keys(config));
  if (keys2.has("ease") || keys2.has("duration") && !keys2.has("dampingRatio")) {
    return keyframes;
  } else if (keys2.has("dampingRatio") || keys2.has("stiffness") || keys2.has("mass") || keys2.has("damping") || keys2.has("restSpeed") || keys2.has("restDelta")) {
    return spring;
  }
  return keyframes;
}
const defaultTimestep = 1 / 60 * 1e3;
const getCurrentTime = typeof performance !== "undefined" ? () => performance.now() : () => Date.now();
const onNextFrame = typeof window !== "undefined" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);
function createRenderStep(runNextFrame2) {
  let toRun = [];
  let toRunNextFrame = [];
  let numToRun = 0;
  let isProcessing2 = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step = {
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing2;
      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (buffer.indexOf(callback) === -1) {
        buffer.push(callback);
        if (addToCurrentFrame && isProcessing2)
          numToRun = toRun.length;
      }
      return callback;
    },
    cancel: (callback) => {
      const index2 = toRunNextFrame.indexOf(callback);
      if (index2 !== -1)
        toRunNextFrame.splice(index2, 1);
      toKeepAlive.delete(callback);
    },
    process: (frameData) => {
      if (isProcessing2) {
        flushNextFrame = true;
        return;
      }
      isProcessing2 = true;
      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (let i2 = 0; i2 < numToRun; i2++) {
          const callback = toRun[i2];
          callback(frameData);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame2();
          }
        }
      }
      isProcessing2 = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData);
      }
    }
  };
  return step;
}
const maxElapsed = 40;
let useDefaultElapsed = true;
let runNextFrame = false;
let isProcessing = false;
const frame = {
  delta: 0,
  timestamp: 0
};
const stepsOrder = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
const steps = stepsOrder.reduce((acc, key) => {
  acc[key] = createRenderStep(() => runNextFrame = true);
  return acc;
}, {});
const sync = stepsOrder.reduce((acc, key) => {
  const step = steps[key];
  acc[key] = (process2, keepAlive = false, immediate = false) => {
    if (!runNextFrame)
      startLoop();
    return step.schedule(process2, keepAlive, immediate);
  };
  return acc;
}, {});
const cancelSync = stepsOrder.reduce((acc, key) => {
  acc[key] = steps[key].cancel;
  return acc;
}, {});
stepsOrder.reduce((acc, key) => {
  acc[key] = () => steps[key].process(frame);
  return acc;
}, {});
const processStep = (stepId) => steps[stepId].process(frame);
const processFrame = (timestamp) => {
  runNextFrame = false;
  frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
  frame.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;
  if (runNextFrame) {
    useDefaultElapsed = false;
    onNextFrame(processFrame);
  }
};
const startLoop = () => {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing)
    onNextFrame(processFrame);
};
const sync$1 = sync;
function loopElapsed(elapsed, duration, delay = 0) {
  return elapsed - duration - delay;
}
function reverseElapsed(elapsed, duration, delay = 0, isForwardPlayback = true) {
  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay) : duration - (elapsed - duration) + delay;
}
function hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {
  return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;
}
const framesync = (update) => {
  const passTimestamp = ({ delta }) => update(delta);
  return {
    start: () => sync$1.update(passTimestamp, true),
    stop: () => cancelSync.update(passTimestamp)
  };
};
function animate(_a2) {
  var _b2, _c2;
  var { from: from2, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = "loop", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a2, options = __rest$2(_a2, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]);
  let { to } = options;
  let driverControls;
  let repeatCount = 0;
  let computedDuration = options.duration;
  let latest;
  let isComplete = false;
  let isForwardPlayback = true;
  let interpolateFromNumber;
  const animator = detectAnimationFromOptions(options);
  if ((_c2 = (_b2 = animator).needsInterpolation) === null || _c2 === void 0 ? void 0 : _c2.call(_b2, from2, to)) {
    interpolateFromNumber = interpolate([0, 100], [from2, to], {
      clamp: false
    });
    from2 = 0;
    to = 100;
  }
  const animation2 = animator(Object.assign(Object.assign({}, options), { from: from2, to }));
  function repeat2() {
    repeatCount++;
    if (repeatType === "reverse") {
      isForwardPlayback = repeatCount % 2 === 0;
      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);
    } else {
      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);
      if (repeatType === "mirror")
        animation2.flipTarget();
    }
    isComplete = false;
    onRepeat && onRepeat();
  }
  function complete() {
    driverControls.stop();
    onComplete && onComplete();
  }
  function update(delta) {
    if (!isForwardPlayback)
      delta = -delta;
    elapsed += delta;
    if (!isComplete) {
      const state = animation2.next(Math.max(0, elapsed));
      latest = state.value;
      if (interpolateFromNumber)
        latest = interpolateFromNumber(latest);
      isComplete = isForwardPlayback ? state.done : elapsed <= 0;
    }
    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);
    if (isComplete) {
      if (repeatCount === 0)
        computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;
      if (repeatCount < repeatMax) {
        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat2();
      } else {
        complete();
      }
    }
  }
  function play() {
    onPlay === null || onPlay === void 0 ? void 0 : onPlay();
    driverControls = driver(update);
    driverControls.start();
  }
  autoplay && play();
  return {
    stop: () => {
      onStop === null || onStop === void 0 ? void 0 : onStop();
      driverControls.stop();
    }
  };
}
function arraySome$1(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$1;
var SetCache = _SetCache, arraySome = _arraySome, cacheHas = _cacheHas;
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen2) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen2.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$2;
function mapToArray$1(map2) {
  var index2 = -1, result = Array(map2.size);
  map2.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray$1;
var Symbol$2 = _Symbol$1, Uint8Array$1 = _Uint8Array, eq = eq_1$1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray = _setToArray;
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag$1 = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function equalByTag$1(object, other, tag2, bitmask, customizer, equalFunc, stack) {
  switch (tag2) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
      return object == other + "";
    case mapTag:
      var convert = mapToArray;
    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object, other);
      var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag$1:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
var getAllKeys = _getAllKeys;
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$1;
var Stack$1 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag = _getTag, isArray$a = isArray_1, isBuffer$2 = isBufferExports, isTypedArray = isTypedArray_1;
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$a(object), othIsArr = isArray$a(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$2(object)) {
    if (!isBuffer$2(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$1());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$1());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$1());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike$1 = isObjectLike_1;
function baseIsEqual$2(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike$1(value) && !isObjectLike$1(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$2, stack);
}
var _baseIsEqual = baseIsEqual$2;
var Stack = _Stack, baseIsEqual$1 = _baseIsEqual;
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch$1(object, source, matchData, customizer) {
  var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length2;
  }
  object = Object(object);
  while (index2--) {
    var data2 = matchData[index2];
    if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
      return false;
    }
  }
  while (++index2 < length2) {
    data2 = matchData[index2];
    var key = data2[0], objValue = object[key], srcValue = data2[1];
    if (noCustomizer && data2[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var _baseIsMatch = baseIsMatch$1;
var isObject$4 = isObject_1$1;
function isStrictComparable$2(value) {
  return value === value && !isObject$4(value);
}
var _isStrictComparable = isStrictComparable$2;
var isStrictComparable$1 = _isStrictComparable, keys = keys_1;
function getMatchData$1(object) {
  var result = keys(object), length2 = result.length;
  while (length2--) {
    var key = result[length2], value = object[key];
    result[length2] = [key, value, isStrictComparable$1(value)];
  }
  return result;
}
var _getMatchData = getMatchData$1;
function matchesStrictComparable$2(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var _matchesStrictComparable = matchesStrictComparable$2;
var baseIsMatch = _baseIsMatch, getMatchData = _getMatchData, matchesStrictComparable$1 = _matchesStrictComparable;
function baseMatches$1(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}
var _baseMatches = baseMatches$1;
var baseGetTag = _baseGetTag$1, isObjectLike = isObjectLike_1;
var symbolTag = "[object Symbol]";
function isSymbol$5(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
}
var isSymbol_1 = isSymbol$5;
var isArray$9 = isArray_1, isSymbol$4 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey$3(value, object) {
  if (isArray$9(value)) {
    return false;
  }
  var type2 = typeof value;
  if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol$4(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var _isKey = isKey$3;
var MapCache = _MapCache$1;
var FUNC_ERROR_TEXT$3 = "Expected a function";
function memoize$2(func, resolver2) {
  if (typeof func != "function" || resolver2 != null && typeof resolver2 != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$3);
  }
  var memoized = function() {
    var args = arguments, key = resolver2 ? resolver2.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$2.Cache || MapCache)();
  return memoized;
}
memoize$2.Cache = MapCache;
var memoize_1 = memoize$2;
var memoize$1 = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize$1(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar$1 = /\\(\\)?/g;
var stringToPath$2 = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName$1, function(match2, number2, quote2, subString) {
    result.push(quote2 ? subString.replace(reEscapeChar$1, "$1") : number2 || match2);
  });
  return result;
});
var _stringToPath = stringToPath$2;
function arrayMap$2(array, iteratee) {
  var index2 = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
  while (++index2 < length2) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var _arrayMap = arrayMap$2;
var Symbol$1 = _Symbol$1, arrayMap$1 = _arrayMap, isArray$8 = isArray_1, isSymbol$3 = isSymbol_1;
var INFINITY$1 = 1 / 0;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$8(value)) {
    return arrayMap$1(value, baseToString$1) + "";
  }
  if (isSymbol$3(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var _baseToString = baseToString$1;
var baseToString = _baseToString;
function toString$1(value) {
  return value == null ? "" : baseToString(value);
}
var toString_1 = toString$1;
var isArray$7 = isArray_1, isKey$2 = _isKey, stringToPath$1 = _stringToPath, toString2 = toString_1;
function castPath$4(value, object) {
  if (isArray$7(value)) {
    return value;
  }
  return isKey$2(value, object) ? [value] : stringToPath$1(toString2(value));
}
var _castPath = castPath$4;
var isSymbol$2 = isSymbol_1;
var INFINITY = 1 / 0;
function toKey$5(value) {
  if (typeof value == "string" || isSymbol$2(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var _toKey = toKey$5;
var castPath$3 = _castPath, toKey$4 = _toKey;
function baseGet$3(object, path) {
  path = castPath$3(path, object);
  var index2 = 0, length2 = path.length;
  while (object != null && index2 < length2) {
    object = object[toKey$4(path[index2++])];
  }
  return index2 && index2 == length2 ? object : void 0;
}
var _baseGet = baseGet$3;
var baseGet$2 = _baseGet;
function get$2(object, path, defaultValue2) {
  var result = object == null ? void 0 : baseGet$2(object, path);
  return result === void 0 ? defaultValue2 : result;
}
var get_1 = get$2;
function baseHasIn$1(object, key) {
  return object != null && key in Object(object);
}
var _baseHasIn = baseHasIn$1;
var castPath$2 = _castPath, isArguments = isArguments_1, isArray$6 = isArray_1, isIndex$1 = _isIndex, isLength = isLength_1, toKey$3 = _toKey;
function hasPath$1(object, path, hasFunc) {
  path = castPath$2(path, object);
  var index2 = -1, length2 = path.length, result = false;
  while (++index2 < length2) {
    var key = toKey$3(path[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length2) {
    return result;
  }
  length2 = object == null ? 0 : object.length;
  return !!length2 && isLength(length2) && isIndex$1(key, length2) && (isArray$6(object) || isArguments(object));
}
var _hasPath = hasPath$1;
var baseHasIn = _baseHasIn, hasPath = _hasPath;
function hasIn$1(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var hasIn_1 = hasIn$1;
var baseIsEqual = _baseIsEqual, get$1 = get_1, hasIn = hasIn_1, isKey$1 = _isKey, isStrictComparable = _isStrictComparable, matchesStrictComparable = _matchesStrictComparable, toKey$2 = _toKey;
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty$1(path, srcValue) {
  if (isKey$1(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey$2(path), srcValue);
  }
  return function(object) {
    var objValue = get$1(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
var _baseMatchesProperty = baseMatchesProperty$1;
function identity$1(value) {
  return value;
}
var identity_1 = identity$1;
function baseProperty$1(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var _baseProperty = baseProperty$1;
var baseGet$1 = _baseGet;
function basePropertyDeep$1(path) {
  return function(object) {
    return baseGet$1(object, path);
  };
}
var _basePropertyDeep = basePropertyDeep$1;
var baseProperty = _baseProperty, basePropertyDeep = _basePropertyDeep, isKey = _isKey, toKey$1 = _toKey;
function property$1(path) {
  return isKey(path) ? baseProperty(toKey$1(path)) : basePropertyDeep(path);
}
var property_1 = property$1;
var baseMatches = _baseMatches, baseMatchesProperty = _baseMatchesProperty, identity = identity_1, isArray$5 = isArray_1, property = property_1;
function baseIteratee$2(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == "object") {
    return isArray$5(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
var _baseIteratee = baseIteratee$2;
var FUNC_ERROR_TEXT$2 = "Expected a function";
function negate$1(predicate) {
  if (typeof predicate != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return !predicate.call(this);
      case 1:
        return !predicate.call(this, args[0]);
      case 2:
        return !predicate.call(this, args[0], args[1]);
      case 3:
        return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}
var negate_1 = negate$1;
var assignValue = _assignValue, castPath$1 = _castPath, isIndex = _isIndex, isObject$3 = isObject_1$1, toKey = _toKey;
function baseSet$1(object, path, value, customizer) {
  if (!isObject$3(object)) {
    return object;
  }
  path = castPath$1(path, object);
  var index2 = -1, length2 = path.length, lastIndex = length2 - 1, nested = object;
  while (nested != null && ++index2 < length2) {
    var key = toKey(path[index2]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$3(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var _baseSet = baseSet$1;
var baseGet = _baseGet, baseSet = _baseSet, castPath = _castPath;
function basePickBy$1(object, paths, predicate) {
  var index2 = -1, length2 = paths.length, result = {};
  while (++index2 < length2) {
    var path = paths[index2], value = baseGet(object, path);
    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}
var _basePickBy = basePickBy$1;
var arrayMap = _arrayMap, baseIteratee$1 = _baseIteratee, basePickBy = _basePickBy, getAllKeysIn = _getAllKeysIn;
function pickBy$1(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap(getAllKeysIn(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee$1(predicate);
  return basePickBy(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}
var pickBy_1 = pickBy$1;
var baseIteratee = _baseIteratee, negate = negate_1, pickBy = pickBy_1;
function omitBy(object, predicate) {
  return pickBy(object, negate(baseIteratee(predicate)));
}
var omitBy_1 = omitBy;
const omitBy$1 = /* @__PURE__ */ getDefaultExportFromCjs(omitBy_1);
function isUndefined(value) {
  return value === void 0;
}
var isUndefined_1 = isUndefined;
const isUndefined$1 = /* @__PURE__ */ getDefaultExportFromCjs(isUndefined_1);
function generateTimelineObj(timeline, targetKey, duration) {
  const target = WebGAL.gameplay.pixiStage.getStageObjByKey(targetKey);
  let currentDelay = 0;
  const values = [];
  const times = [];
  for (const segment of timeline) {
    const segmentDuration = segment.duration;
    currentDelay += segmentDuration;
    const { position: position2, scale, ...segmentValues } = segment;
    values.push({ x: position2.x, y: position2.y, scaleX: scale.x, scaleY: scale.y, ...segmentValues });
    if (duration !== 0) {
      times.push(currentDelay / duration);
    } else
      times.push(0);
  }
  const container2 = target == null ? void 0 : target.pixiContainer;
  let animateInstance = null;
  if (duration > 0) {
    animateInstance = animate({
      to: values,
      offset: times,
      duration,
      onUpdate: (updateValue) => {
        if (container2) {
          const { scaleX, scaleY, ...val } = updateValue;
          Object.assign(container2, omitBy$1(val, isUndefined$1));
          if (!isUndefined$1(scaleX))
            container2.scale.x = scaleX;
          if (!isUndefined$1(scaleY))
            container2.scale.y = scaleY;
        }
      }
    });
  }
  const { duration: sliceDuration, ...endState } = getEndStateEffect();
  webgalStore.dispatch(stageActions.updateEffect({ target: targetKey, transform: endState }));
  function setStartState() {
    if (target == null ? void 0 : target.pixiContainer) {
      const { position: position2, scale, ...state } = getStartStateEffect();
      const assignValue2 = omitBy$1({ x: position2.x, y: position2.y, ...state }, isUndefined$1);
      Object.assign(target == null ? void 0 : target.pixiContainer, assignValue2);
      if (target == null ? void 0 : target.pixiContainer) {
        if (!isUndefined$1(scale.x)) {
          target.pixiContainer.scale.x = scale.x;
        }
        if (!isUndefined$1(scale == null ? void 0 : scale.y)) {
          target.pixiContainer.scale.y = scale.y;
        }
      }
    }
  }
  function setEndState() {
    if (animateInstance)
      animateInstance.stop();
    animateInstance = null;
    if (target == null ? void 0 : target.pixiContainer) {
      const { position: position2, scale, ...state } = getEndStateEffect();
      const assignValue2 = omitBy$1({ x: position2.x, y: position2.y, ...state }, isUndefined$1);
      Object.assign(target == null ? void 0 : target.pixiContainer, assignValue2);
      if (target == null ? void 0 : target.pixiContainer) {
        if (!isUndefined$1(scale.x)) {
          target.pixiContainer.scale.x = scale.x;
        }
        if (!isUndefined$1(scale == null ? void 0 : scale.y)) {
          target.pixiContainer.scale.y = scale.y;
        }
      }
    }
  }
  function tickerFunc(delta) {
  }
  function getStartStateEffect() {
    return timeline[0];
  }
  function getEndStateEffect() {
    return timeline[timeline.length - 1];
  }
  function getEndFilterEffect() {
    const endSegment = timeline[timeline.length - 1];
    const { alpha: alpha2, rotation, blur, duration: duration2, scale, position: position2, ...rest } = endSegment;
    return rest;
  }
  return {
    setStartState,
    setEndState,
    tickerFunc,
    getEndFilterEffect
  };
}
function getAnimationObject$2(animationName, target, duration) {
  const effect = WebGAL.animationManager.getAnimations().find((ani) => ani.name === animationName);
  if (effect) {
    const mappedEffects = effect.effects.map((effect2) => {
      const targetSetEffect = webgalStore.getState().stage.effects.find((e2) => e2.target === target);
      const newEffect = cloneDeep$1({ ...(targetSetEffect == null ? void 0 : targetSetEffect.transform) ?? baseTransform, duration: 0 });
      Object.assign(newEffect, effect2);
      newEffect.duration = effect2.duration;
      return newEffect;
    });
    logger.debug("", mappedEffects);
    return generateTimelineObj(mappedEffects, target, duration);
  }
  return null;
}
function getAnimateDuration$1(animationName) {
  const effect = WebGAL.animationManager.getAnimations().find((ani) => ani.name === animationName);
  if (effect) {
    let duration = 0;
    effect.effects.forEach((e2) => {
      duration += e2.duration;
    });
    return duration;
  }
  return 0;
}
function getEnterExitAnimation(target, type2, isBg = false) {
  if (type2 === "enter") {
    let duration = 500;
    if (isBg) {
      duration = 1500;
    }
    let animation2 = generateUniversalSoftInAnimationObj(target, duration);
    const animarionName = WebGAL.animationManager.nextEnterAnimationName.get(target);
    if (animarionName) {
      logger.debug("", target);
      animation2 = getAnimationObject$2(animarionName, target, getAnimateDuration$1(animarionName));
      duration = getAnimateDuration$1(animarionName);
      WebGAL.animationManager.nextEnterAnimationName.delete(target);
    }
    return { duration, animation: animation2 };
  } else {
    let duration = 750;
    if (isBg) {
      duration = 1500;
    }
    let animation2 = generateUniversalSoftOffAnimationObj(target, duration);
    const animarionName = WebGAL.animationManager.nextExitAnimationName.get(target);
    if (animarionName) {
      logger.debug("", target);
      animation2 = getAnimationObject$2(animarionName, target, getAnimateDuration$1(animarionName));
      duration = getAnimateDuration$1(animarionName);
      WebGAL.animationManager.nextExitAnimationName.delete(target);
    }
    return { duration, animation: animation2 };
  }
}
const changeBg = (sentence) => {
  const url2 = sentence.content;
  let name = "";
  let series = "default";
  sentence.args.forEach((e2) => {
    if (e2.key === "unlockname") {
      name = e2.value.toString();
    }
    if (e2.key === "series") {
      series = e2.value.toString();
    }
  });
  const dispatch = webgalStore.dispatch;
  if (name !== "")
    dispatch(unlockCgInUserData({ name, url: url2, series }));
  dispatch(stageActions.removeEffectByTargetId(`bg-main`));
  const transformString = getSentenceArgByKey(sentence, "transform");
  let duration = getSentenceArgByKey(sentence, "duration");
  if (!duration || typeof duration !== "number") {
    duration = 1e3;
  }
  let animationObj;
  if (transformString) {
    try {
      const frame2 = JSON.parse(transformString.toString());
      animationObj = generateTransformAnimationObj("bg-main", frame2, duration);
      animationObj[0].alpha = 0;
      const animationName = (Math.random() * 10).toString(16);
      const newAnimation = { name: animationName, effects: animationObj };
      WebGAL.animationManager.addAnimation(newAnimation);
      duration = getAnimateDuration$1(animationName);
      WebGAL.animationManager.nextEnterAnimationName.set("bg-main", animationName);
    } catch (e2) {
      applyDefaultTransform();
    }
  } else {
    applyDefaultTransform();
  }
  function applyDefaultTransform() {
    const frame2 = {};
    animationObj = generateTransformAnimationObj("bg-main", frame2, duration);
    animationObj[0].alpha = 0;
    const animationName = (Math.random() * 10).toString(16);
    const newAnimation = { name: animationName, effects: animationObj };
    WebGAL.animationManager.addAnimation(newAnimation);
    duration = getAnimateDuration$1(animationName);
    WebGAL.animationManager.nextEnterAnimationName.set("bg-main", animationName);
  }
  if (getSentenceArgByKey(sentence, "enter")) {
    WebGAL.animationManager.nextEnterAnimationName.set("bg-main", getSentenceArgByKey(sentence, "enter").toString());
    duration = getAnimateDuration$1(getSentenceArgByKey(sentence, "enter").toString());
  }
  if (getSentenceArgByKey(sentence, "exit")) {
    WebGAL.animationManager.nextExitAnimationName.set("bg-main-off", getSentenceArgByKey(sentence, "exit").toString());
    duration = getAnimateDuration$1(getSentenceArgByKey(sentence, "exit").toString());
  }
  dispatch(setStage({ key: "bgName", value: sentence.content }));
  return {
    performName: "none",
    duration,
    isHoldOn: false,
    stopFunction: () => {
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
function changeFigure(sentence) {
  let pos = "center";
  let content = sentence.content;
  let isFreeFigure = false;
  let motion = "";
  let expression = "";
  let key = "";
  let duration = 500;
  let mouthOpen = "";
  let mouthClose = "";
  let mouthHalfOpen = "";
  let eyesOpen = "";
  let eyesClose = "";
  let animationFlag = "";
  const dispatch = webgalStore.dispatch;
  for (const e2 of sentence.args) {
    switch (e2.key) {
      case "left":
        if (e2.value === true) {
          pos = "left";
        }
        break;
      case "right":
        if (e2.value === true) {
          pos = "right";
        }
        break;
      case "clear":
        if (e2.value === true) {
          content = "";
        }
        break;
      case "id":
        isFreeFigure = true;
        key = e2.value.toString();
        break;
      case "motion":
        motion = e2.value.toString();
        break;
      case "expression":
        expression = e2.value.toString();
        break;
      case "mouthOpen":
        mouthOpen = e2.value.toString();
        mouthOpen = assetSetter(mouthOpen, fileType$1.figure);
        break;
      case "mouthClose":
        mouthClose = e2.value.toString();
        mouthClose = assetSetter(mouthClose, fileType$1.figure);
        break;
      case "mouthHalfOpen":
        mouthHalfOpen = e2.value.toString();
        mouthHalfOpen = assetSetter(mouthHalfOpen, fileType$1.figure);
        break;
      case "eyesOpen":
        eyesOpen = e2.value.toString();
        eyesOpen = assetSetter(eyesOpen, fileType$1.figure);
        break;
      case "eyesClose":
        eyesClose = e2.value.toString();
        eyesClose = assetSetter(eyesClose, fileType$1.figure);
        break;
      case "animationFlag":
        animationFlag = e2.value.toString();
        break;
      case "none":
        content = "";
        break;
    }
  }
  const id2 = key ? key : `fig-${pos}`;
  const currentFigureAssociatedAnimation = webgalStore.getState().stage.figureAssociatedAnimation;
  const filteredFigureAssociatedAnimation = currentFigureAssociatedAnimation.filter((item) => item.targetId !== id2);
  const newFigureAssociatedAnimationItem = {
    targetId: id2,
    animationFlag,
    mouthAnimation: {
      open: mouthOpen,
      close: mouthClose,
      halfOpen: mouthHalfOpen
    },
    blinkAnimation: {
      open: eyesOpen,
      close: eyesClose
    }
  };
  filteredFigureAssociatedAnimation.push(newFigureAssociatedAnimationItem);
  dispatch(setStage({ key: "figureAssociatedAnimation", value: filteredFigureAssociatedAnimation }));
  let isRemoveEffects = true;
  if (key !== "") {
    const figWithKey = webgalStore.getState().stage.freeFigure.find((e2) => e2.key === key);
    if (figWithKey) {
      if (figWithKey.name === sentence.content) {
        isRemoveEffects = false;
      }
    }
  } else {
    if (pos === "center") {
      if (webgalStore.getState().stage.figName === sentence.content) {
        isRemoveEffects = false;
      }
    }
    if (pos === "left") {
      if (webgalStore.getState().stage.figNameLeft === sentence.content) {
        isRemoveEffects = false;
      }
    }
    if (pos === "right") {
      if (webgalStore.getState().stage.figNameRight === sentence.content) {
        isRemoveEffects = false;
      }
    }
  }
  if (isRemoveEffects) {
    const deleteKey = `fig-${pos}`;
    const deleteKey2 = `${key}`;
    webgalStore.dispatch(stageActions.removeEffectByTargetId(deleteKey));
    webgalStore.dispatch(stageActions.removeEffectByTargetId(deleteKey2));
  }
  const setAnimationNames = (key2, sentence2) => {
    const transformString = getSentenceArgByKey(sentence2, "transform");
    const durationFromArg = getSentenceArgByKey(sentence2, "duration");
    if (durationFromArg && typeof durationFromArg === "number") {
      duration = durationFromArg;
    }
    let animationObj;
    if (transformString) {
      console.log(transformString);
      try {
        const frame2 = JSON.parse(transformString.toString());
        animationObj = generateTransformAnimationObj(key2, frame2, duration);
        animationObj[0].alpha = 0;
        const animationName = (Math.random() * 10).toString(16);
        const newAnimation = { name: animationName, effects: animationObj };
        WebGAL.animationManager.addAnimation(newAnimation);
        duration = getAnimateDuration$1(animationName);
        WebGAL.animationManager.nextEnterAnimationName.set(key2, animationName);
      } catch (e2) {
        applyDefaultTransform();
      }
    } else {
      applyDefaultTransform();
    }
    function applyDefaultTransform() {
      const frame2 = {};
      animationObj = generateTransformAnimationObj(key2, frame2, duration);
      animationObj[0].alpha = 0;
      const animationName = (Math.random() * 10).toString(16);
      const newAnimation = { name: animationName, effects: animationObj };
      WebGAL.animationManager.addAnimation(newAnimation);
      duration = getAnimateDuration$1(animationName);
      WebGAL.animationManager.nextEnterAnimationName.set(key2, animationName);
    }
    const enterAnim = getSentenceArgByKey(sentence2, "enter");
    const exitAnim = getSentenceArgByKey(sentence2, "exit");
    if (enterAnim) {
      WebGAL.animationManager.nextEnterAnimationName.set(key2, enterAnim.toString());
      duration = getAnimateDuration$1(enterAnim.toString());
    }
    if (exitAnim) {
      WebGAL.animationManager.nextExitAnimationName.set(key2 + "-off", exitAnim.toString());
      duration = getAnimateDuration$1(exitAnim.toString());
    }
  };
  if (isFreeFigure) {
    webgalStore.getState().stage.freeFigure;
    const freeFigureItem = { key, name: content, basePosition: pos };
    setAnimationNames(key, sentence);
    if (motion) {
      dispatch(stageActions.setLive2dMotion({ target: key, motion }));
    }
    if (expression) {
      dispatch(stageActions.setLive2dExpression({ target: key, expression }));
    }
    dispatch(stageActions.setFreeFigureByKey(freeFigureItem));
  } else {
    const positionMap = {
      center: "fig-center",
      left: "fig-left",
      right: "fig-right"
    };
    const dispatchMap = {
      center: "figName",
      left: "figNameLeft",
      right: "figNameRight"
    };
    key = positionMap[pos];
    setAnimationNames(key, sentence);
    if (motion) {
      dispatch(stageActions.setLive2dMotion({ target: key, motion }));
    }
    if (expression) {
      dispatch(stageActions.setLive2dExpression({ target: key, expression }));
    }
    dispatch(setStage({ key: dispatchMap[pos], value: content }));
  }
  return {
    performName: "none",
    duration,
    isHoldOn: false,
    stopFunction: () => {
    },
    blockingNext: () => false,
    blockingAuto: () => false,
    stopTimeout: void 0
    // 
  };
}
const changeScene = (sceneUrl, sceneName) => {
  sceneFetcher(sceneUrl).then(async (rawScene) => {
    const scene = await WebGAL.sceneManager.setCurrentScene(rawScene, sceneName, sceneUrl, true);
    if (scene) {
      WebGAL.sceneManager.sceneData.currentSentenceId = 0;
      const currentSceneVideos = [];
      WebGAL.sceneManager.sceneData.currentScene.assetsList.forEach((x) => {
        if (x.url.endsWith(".mp4") || x.url.endsWith(".flv")) {
          currentSceneVideos.push(x.url);
        }
      });
      WebGAL.videoManager.destoryExcept(currentSceneVideos);
      const subSceneList = WebGAL.sceneManager.sceneData.currentScene.subSceneList;
      WebGAL.sceneManager.settledScenes.push(sceneUrl);
      const subSceneListUniq = uniqWith$1(subSceneList);
      scenePrefetcher(subSceneListUniq);
      logger.debug("", WebGAL.sceneManager.sceneData);
      nextSentence();
    }
  });
};
const changeSceneScript = (sentence) => {
  const sceneNameArray = sentence.content.split("/");
  const sceneName = sceneNameArray[sceneNameArray.length - 1];
  changeScene(sentence.content, sceneName);
  return {
    performName: "none",
    duration: 0,
    isHoldOn: true,
    stopFunction: () => {
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
const jmp = (labelName) => {
  const currentLine = WebGAL.sceneManager.sceneData.currentSentenceId;
  let result = currentLine;
  WebGAL.sceneManager.sceneData.currentScene.sentenceList.forEach((sentence, index2) => {
    if (sentence.command === commandType$1.label && sentence.content === labelName && index2 !== currentLine) {
      result = index2;
    }
  });
  WebGAL.sceneManager.sceneData.currentSentenceId = result;
  setTimeout(nextSentence, 1);
};
const Choose_Main$1 = "_Choose_Main_1lgcp_1";
const Choose_item$1 = "_Choose_item_1lgcp_15";
const Choose_item_image = "_Choose_item_image_1lgcp_39";
const Choose_item_countdown = "_Choose_item_countdown_1lgcp_54";
const Choose_item_progress_bar = "_Choose_item_progress_bar_1lgcp_61";
const Choose_item_disabled = "_Choose_item_disabled_1lgcp_70";
const styles$l = {
  Choose_Main: Choose_Main$1,
  Choose_item: Choose_item$1,
  Choose_item_image,
  Choose_item_countdown,
  Choose_item_progress_bar,
  Choose_item_disabled
};
const page_flip_1 = "" + new URL("page-flip-1-7df32409.mp3", import.meta.url).href;
const switch_1 = "" + new URL("switch-1-99b576bc.mp3", import.meta.url).href;
const mouse_enter = "data:audio/mpeg;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU3LjE0LjEwMAAAAAAAAAAAAAAA//OAAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAHAAAGhgA/Pz8/Pz8/Pz8/Pz8/P19fX19fX19fX19fX19ff39/f39/f39/f39/f3+fn5+fn5+fn5+fn5+fn5+/v7+/v7+/v7+/v7+/v9/f39/f39/f39/f39/f//////////////////8AAAAATGF2YzU3LjE1AAAAAAAAAAAAAAAAJAAAAAAAAAAABoYV32R7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/zgGQAAAABpAAAAAAAAANIAAAAACADH/+QtN3NAAAKF6IiVEl7hE0Sv/+XsgGgCgQDQFAgGg3D+yBShQzd+K0qXyBQyRQUp3hEkUMGn/8oCBQ5KOIf+sPl3//+Xf/+GP//6w+EgFgk/nOfWhA4Q4ABxjnQhDhCD3pgIQLAARlkyZ8Ew+Ud1AgUOfy7/4OeGOUORPD//wwUd/KHP//+GPykMA445BCHBIYg4ZC4AyGP+PuWtgyRb6quwuJvp+v8wQwDAKoXYMnpC0w6gAc0HLf/84JkuwnkuN6ioaAAD3CpsVVFMAAFQBkWjRnE4hYMOnIaT5sXEGFHCyMLPhfcDTHTUmRcgnQMuCfCKHjcDRlTchxFTcEHsKGiBNQ6mLhLkNImWi8PkY6s3kUWgaJmjd1igSfFzk+gLLIOcMi4gXyupR9A20G/4zAhOJ/PDgGYKI4y4LMEEBYhnUz1lpozrmZk3//lsky4s+TB4ul8ny6YOV0FmRx0ElHlMbNWYOr///1uZFQ3IGRNBRmfWlRUYkeV8mVhC5j/+UOiwF4DdcGgB//zgmTqHCnhQS/NUAGcStp6X4JQAARBgQCDIwGbMjrzxBIRk8s4+IS7mMEYN4elXLheFicbuxm88zzzHaw/G//9DCJ+eYRf8WGFtZp9ydCUvPMKGf/57ZjPRjzHtq+3//+YZ2U8817jxbb1vcn/1yAPkAgGUJuPiliw1FHilYbAAkIkV4CdGauxnChrTd+JTOW4BTlAB55YoeqaxWm7Wv8xLqLOiiZLUixqapJF5JNAcoviEoN2gAwAUcLiN5Mk6i3TRU+ikk++6KKKTqSKyBsx//OCZFMVigU/GuzMAIuQEq5fwxACNMZGRPKvoqXbR0UbJP11I0t9J/SqSrRZ0lXoqetSTnWoto0kl26LJGJqizoJmtJSSNSWk7WdTpXUkiigbVor9K6lpKSrdFNi8gnstA65dQVWxkXlGyTGRiRt9gUkBwgAggllBkQbKigffEMUfzqlL+6Ruli5Bv+4lPf//////X/////o0Wte9XLYBs4JbHGkwql7GrPNPMusqAJDUPzthoURwGi5eZyu+VuecNrURSYBU/p8//81Vf+Znkn/84JkNA4gwTcvDYYmF1lmTbAzByQpycp3ROJPn025p4SQJoSeFQoViUUAoiJFRL3c8JRUNETudLFn0MtLDwrM4lUeOiJtiztbvBk6xyPrctYdEkBpA09q2Xn9/TmkZxYMuXBUW17I4clP/nKrXbW/C6FI5G0z11z31L9fvGqoAzY1X86WwYUHIdWCvLEwkeEq3kQ7iI8MPM/ssO/8OnlHsFW1nWeCvyzwVOtEvHuyqv/8hOYSETL//NtNaySXOSsAqIiRrkS82UvXUvppbobMbv/zgmQhC0HzBAAEwpKVEO4JYAjTIJ/y/0egY3vXWaZv65cpZm36G/mMUpdalcpStzalb1KXUoUBf8pXKyGM5Sv/TRRPKoUSQMYKTJfSwiUDeW+ZhhmIXNYfiyfSbiqFFLNEQaajFVnrO9YLTodKvET9Z0FcSgq6s6eIz3uLcFQmCxJY06W/g0Cri31AqGrq56EgaXxLPCUNdBZ5USrBUse3BqpNF93yP//yMyMDWEJGQ01////MjMv//I1kcjJrLf/stlzL55SkyyOX5q0cjVrL//OCZC4KtfrOGgAjbodYBawMAEQAYf//+Rk1qGRqygo5GRq1sP/sln//cyNWCg0cj//ZZZZKh+asCHP8lAL////9n/////////GMYm3raaWKige/+sW+LesVTEFNRTMuOTkuNaqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqo=";
const dialog_se = "" + new URL("dialog-d5b91235.mp3", import.meta.url).href;
const click_se = "data:audio/mpeg;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjIzLjEwMQAAAAAAAAAAAAAA//OAAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAHAAAGhgA/Pz8/Pz8/Pz8/Pz8/P19fX19fX19fX19fX19ff39/f39/f39/f39/f3+fn5+fn5+fn5+fn5+fn5+/v7+/v7+/v7+/v7+/v9/f39/f39/f39/f39/f//////////////////8AAAAATGF2YzU4LjQwAAAAAAAAAAAAAAAAJAL7AAAAAAAABobgvJxkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/zgGQADLH/PRigiACM0AZ+XUAQAoAVYA9AY3IAASAgeRjeQMhP0O/nec/1cn+Qnv/8n+RuhGUhPoQDPISc6HP1Oec7+pwAROeQikI3IT////z+p3Q56VOd/nOc5JzyAAhQAAI053QDFnoQjKACGvoQ7yThzoBgZ8ADMJQURtuNAkMH4P4P+XOZD4f5d/D/64f/3co7/8H8u/wQ5R3/+sPiN8TvB95SDgYT/yjgQf+mpbd5dJrdLkpewIOA5GsDQUQZnZzSB6Q1U50Guqy9OaH/84JkIg/hbXkux6gBEfpLBx+SKAZQvxWLwbxAAoJRbMJjWBoPcgIzjpzzz2clFsxj0ITlVELLXdjzyg8Q3UoM0PPct+QCw/6D5KMrNmLdXOUnPRjXJ3nMYVFVfnfdzf//q//MR+Q/8uwB0uyB/lVHlY6YhEIGR4cHYHAcAZwSQAJAcAocdAxoAMh6L1HV969TxECi7iHlYn7jW//an//+JXU5/9v4l//6EM3f83/41j3///+ozd63/9C2p2W2W22i0Mq2OVytAvxB06nWCVQIZP/zgmQXD4W5ey/HqAEQUkbOR4koAmYRklcoUe+Yd1AuC8AHmsVSoIxFCwPh6RI8ajdB8807yw/JxoLbsai/djzjScCv+Q/lARCSFyRC8hIFYZkF06Dv//MLs5zV+edqzv6krdvP9V/yO3p66H//n73UnMetFzzx4P/MNxBOVut0AFwIAARCgysYSXL+VO2TXhMWBADVCKKhQmjLmX/////0/P+rf7f///29++FO9LfYWYp//Z9n/yHlg30VsPil34MMSQVrYqfLAYVacpCtK1Oq//OCZBUPGaFC3+e0AA8ZVoZdyxAA2az68kOa28sO3puYoqNkUTUxnD6CKnSNlGTJJositaK2TdJSb2NWSX/SSScyDlAnQ6myTv/1X0aJePGZqjnT1FL6v9SRkXW/dVaKP6VaKLOv//+r//X/ZzF06dSFLuv/1B0aZUKwhImgCMAB2aHaUe7x55QPP/rp3zyZZf/VkdS3RFZ3m/9H//iSCn/1Qaev/0CVH3+oO1P///1t+j//9KoPL7QDcAaC4x+83dEEEvXL3vljkRVf5ZqiVpT/84JkGw5BSSx+MMpOEjoual7AxBzqOG5mzBJL6c7URxGtROS/Zu8vMwc2/naKcgTgLi5R79f/ZSUVjWOSaa1aHK5xM/apQnJHJUuTbXQ5VN09HRzSUNfirDtAVBYCwdfpJmYrjDVue/9pJZFMiSvSUMuMAg40uvlBXQECFUh3VKcOGoUBJAurXLsY3+xpv///1aZAwAP///yghpkdW/5qt8OMEMKKg7/pDn///h1/Ues6P/xLEaAkoyibeSeC8E+AuhymiEos8tLHJNRoThxKnP/zgmQcDD0TFAk8xToRuh4sCGgPKooy1Y8s/q2X/ZH//6tqJAEEQwRKxjI9y1KWWqPDw8awiKqQPPob/pRUDwAioCEtX9R7/9eGlncrLPLBVgKmRZ+GpD/tqEogdIXwLlNkUnUxiamSS0W/ooqUlrot//zUCIHRc05Zrqaabod86PDZv/+b/UamAIGjTP+W/879s9liLSrmCVxXgq7xL+RKoQZ+UAAwBYQh4Rig2ZaVmytcNUuiO5/zP8jP1/+VMy/1RygyCgEMDDLv4CCZF3/S//OCZC8JaK7qfiQiTgxILdAAYYYEEhVLrP///S1HoCosaCoCCYZrZUSBkQDwESH/WkJSAZjByJI0oE4Z/////4FCQeBkVZ/xX/zIsRd/6hf7X//4qSfqwEEiLv1ciEyISQKqTEFNRTMuMTAwqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqo=";
var shim = { exports: {} };
var useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e$3 = reactExports;
function h$3(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var k$2 = "function" === typeof Object.is ? Object.is : h$3, l$2 = e$3.useState, m$2 = e$3.useEffect, n$4 = e$3.useLayoutEffect, p$4 = e$3.useDebugValue;
function q$3(a2, b2) {
  var d2 = b2(), f2 = l$2({ inst: { value: d2, getSnapshot: b2 } }), c2 = f2[0].inst, g2 = f2[1];
  n$4(function() {
    c2.value = d2;
    c2.getSnapshot = b2;
    r$3(c2) && g2({ inst: c2 });
  }, [a2, d2, b2]);
  m$2(function() {
    r$3(c2) && g2({ inst: c2 });
    return a2(function() {
      r$3(c2) && g2({ inst: c2 });
    });
  }, [a2]);
  p$4(d2);
  return d2;
}
function r$3(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var d2 = b2();
    return !k$2(a2, d2);
  } catch (f2) {
    return true;
  }
}
function t$4(a2, b2) {
  return b2();
}
var u$3 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$4 : q$3;
useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e$3.useSyncExternalStore ? e$3.useSyncExternalStore : u$3;
{
  shim.exports = useSyncExternalStoreShim_production_min;
}
var shimExports = shim.exports;
var withSelector = { exports: {} };
var withSelector_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h$2 = reactExports, n$3 = shimExports;
function p$3(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var q$2 = "function" === typeof Object.is ? Object.is : p$3, r$2 = n$3.useSyncExternalStore, t$3 = h$2.useRef, u$2 = h$2.useEffect, v$2 = h$2.useMemo, w$1 = h$2.useDebugValue;
withSelector_production_min.useSyncExternalStoreWithSelector = function(a2, b2, e2, l2, g2) {
  var c2 = t$3(null);
  if (null === c2.current) {
    var f2 = { hasValue: false, value: null };
    c2.current = f2;
  } else
    f2 = c2.current;
  c2 = v$2(function() {
    function a3(a4) {
      if (!c3) {
        c3 = true;
        d3 = a4;
        a4 = l2(a4);
        if (void 0 !== g2 && f2.hasValue) {
          var b3 = f2.value;
          if (g2(b3, a4))
            return k2 = b3;
        }
        return k2 = a4;
      }
      b3 = k2;
      if (q$2(d3, a4))
        return b3;
      var e3 = l2(a4);
      if (void 0 !== g2 && g2(b3, e3))
        return b3;
      d3 = a4;
      return k2 = e3;
    }
    var c3 = false, d3, k2, m2 = void 0 === e2 ? null : e2;
    return [function() {
      return a3(b2());
    }, null === m2 ? void 0 : function() {
      return a3(m2());
    }];
  }, [b2, e2, l2, g2]);
  var d2 = r$2(a2, c2[0], c2[1]);
  u$2(function() {
    f2.hasValue = true;
    f2.value = d2;
  }, [d2]);
  w$1(d2);
  return d2;
};
{
  withSelector.exports = withSelector_production_min;
}
var withSelectorExports = withSelector.exports;
function defaultNoopBatch(callback) {
  callback();
}
let batch = defaultNoopBatch;
const setBatch = (newBatch) => batch = newBatch;
const getBatch = () => batch;
const ContextKey = Symbol.for(`react-redux-context`);
const gT = typeof globalThis !== "undefined" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function getContext() {
  var _gT$ContextKey;
  if (!reactExports.createContext)
    return {};
  const contextMap = (_gT$ContextKey = gT[ContextKey]) != null ? _gT$ContextKey : gT[ContextKey] = /* @__PURE__ */ new Map();
  let realContext = contextMap.get(reactExports.createContext);
  if (!realContext) {
    realContext = reactExports.createContext(null);
    contextMap.set(reactExports.createContext, realContext);
  }
  return realContext;
}
const ReactReduxContext = /* @__PURE__ */ getContext();
function createReduxContextHook(context2 = ReactReduxContext) {
  return function useReduxContext2() {
    const contextValue = reactExports.useContext(context2);
    return contextValue;
  };
}
const useReduxContext = /* @__PURE__ */ createReduxContextHook();
const notInitialized = () => {
  throw new Error("uSES not initialized!");
};
let useSyncExternalStoreWithSelector = notInitialized;
const initializeUseSelector = (fn2) => {
  useSyncExternalStoreWithSelector = fn2;
};
const refEquality = (a2, b2) => a2 === b2;
function createSelectorHook(context2 = ReactReduxContext) {
  const useReduxContext$1 = context2 === ReactReduxContext ? useReduxContext : createReduxContextHook(context2);
  return function useSelector2(selector, equalityFnOrOptions = {}) {
    const {
      equalityFn = refEquality,
      stabilityCheck = void 0,
      noopCheck = void 0
    } = typeof equalityFnOrOptions === "function" ? {
      equalityFn: equalityFnOrOptions
    } : equalityFnOrOptions;
    const {
      store,
      subscription,
      getServerState,
      stabilityCheck: globalStabilityCheck,
      noopCheck: globalNoopCheck
    } = useReduxContext$1();
    reactExports.useRef(true);
    const wrappedSelector = reactExports.useCallback({
      [selector.name](state) {
        const selected = selector(state);
        return selected;
      }
    }[selector.name], [selector, globalStabilityCheck, stabilityCheck]);
    const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);
    reactExports.useDebugValue(selectedState);
    return selectedState;
  };
}
const useSelector = /* @__PURE__ */ createSelectorHook();
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var reactIs$1 = { exports: {} };
var reactIs_production_min$1 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = "function" === typeof Symbol && Symbol.for, c$2 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$2 = b$1 ? Symbol.for("react.fragment") : 60107, f$1 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$1 ? Symbol.for("react.profiler") : 60114, h$1 = b$1 ? Symbol.for("react.provider") : 60109, k$1 = b$1 ? Symbol.for("react.context") : 60110, l$1 = b$1 ? Symbol.for("react.async_mode") : 60111, m$1 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n$2 = b$1 ? Symbol.for("react.forward_ref") : 60112, p$2 = b$1 ? Symbol.for("react.suspense") : 60113, q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120, r$1 = b$1 ? Symbol.for("react.memo") : 60115, t$2 = b$1 ? Symbol.for("react.lazy") : 60116, v$1 = b$1 ? Symbol.for("react.block") : 60121, w = b$1 ? Symbol.for("react.fundamental") : 60117, x$1 = b$1 ? Symbol.for("react.responder") : 60118, y = b$1 ? Symbol.for("react.scope") : 60119;
function z(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c$2:
        switch (a2 = a2.type, a2) {
          case l$1:
          case m$1:
          case e$2:
          case g$1:
          case f$1:
          case p$2:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$1:
              case n$2:
              case t$2:
              case r$1:
              case h$1:
                return a2;
              default:
                return u2;
            }
        }
      case d$1:
        return u2;
    }
  }
}
function A(a2) {
  return z(a2) === m$1;
}
reactIs_production_min$1.AsyncMode = l$1;
reactIs_production_min$1.ConcurrentMode = m$1;
reactIs_production_min$1.ContextConsumer = k$1;
reactIs_production_min$1.ContextProvider = h$1;
reactIs_production_min$1.Element = c$2;
reactIs_production_min$1.ForwardRef = n$2;
reactIs_production_min$1.Fragment = e$2;
reactIs_production_min$1.Lazy = t$2;
reactIs_production_min$1.Memo = r$1;
reactIs_production_min$1.Portal = d$1;
reactIs_production_min$1.Profiler = g$1;
reactIs_production_min$1.StrictMode = f$1;
reactIs_production_min$1.Suspense = p$2;
reactIs_production_min$1.isAsyncMode = function(a2) {
  return A(a2) || z(a2) === l$1;
};
reactIs_production_min$1.isConcurrentMode = A;
reactIs_production_min$1.isContextConsumer = function(a2) {
  return z(a2) === k$1;
};
reactIs_production_min$1.isContextProvider = function(a2) {
  return z(a2) === h$1;
};
reactIs_production_min$1.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === c$2;
};
reactIs_production_min$1.isForwardRef = function(a2) {
  return z(a2) === n$2;
};
reactIs_production_min$1.isFragment = function(a2) {
  return z(a2) === e$2;
};
reactIs_production_min$1.isLazy = function(a2) {
  return z(a2) === t$2;
};
reactIs_production_min$1.isMemo = function(a2) {
  return z(a2) === r$1;
};
reactIs_production_min$1.isPortal = function(a2) {
  return z(a2) === d$1;
};
reactIs_production_min$1.isProfiler = function(a2) {
  return z(a2) === g$1;
};
reactIs_production_min$1.isStrictMode = function(a2) {
  return z(a2) === f$1;
};
reactIs_production_min$1.isSuspense = function(a2) {
  return z(a2) === p$2;
};
reactIs_production_min$1.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === e$2 || a2 === m$1 || a2 === g$1 || a2 === f$1 || a2 === p$2 || a2 === q$1 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t$2 || a2.$$typeof === r$1 || a2.$$typeof === h$1 || a2.$$typeof === k$1 || a2.$$typeof === n$2 || a2.$$typeof === w || a2.$$typeof === x$1 || a2.$$typeof === y || a2.$$typeof === v$1);
};
reactIs_production_min$1.typeOf = z;
{
  reactIs$1.exports = reactIs_production_min$1;
}
var reactIsExports = reactIs$1.exports;
var reactIs = reactIsExports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var reactIs_production_min = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = Symbol.for("react.element"), c$1 = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e$1 = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n$1 = Symbol.for("react.suspense_list"), p$1 = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t$1 = Symbol.for("react.offscreen"), u$1;
u$1 = Symbol.for("react.module.reference");
function v(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var r2 = a2.$$typeof;
    switch (r2) {
      case b:
        switch (a2 = a2.type, a2) {
          case d:
          case f:
          case e$1:
          case m:
          case n$1:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k:
              case h:
              case l:
              case q:
              case p$1:
              case g:
                return a2;
              default:
                return r2;
            }
        }
      case c$1:
        return r2;
    }
  }
}
reactIs_production_min.ContextConsumer = h;
reactIs_production_min.ContextProvider = g;
reactIs_production_min.Element = b;
reactIs_production_min.ForwardRef = l;
reactIs_production_min.Fragment = d;
reactIs_production_min.Lazy = q;
reactIs_production_min.Memo = p$1;
reactIs_production_min.Portal = c$1;
reactIs_production_min.Profiler = f;
reactIs_production_min.StrictMode = e$1;
reactIs_production_min.Suspense = m;
reactIs_production_min.SuspenseList = n$1;
reactIs_production_min.isAsyncMode = function() {
  return false;
};
reactIs_production_min.isConcurrentMode = function() {
  return false;
};
reactIs_production_min.isContextConsumer = function(a2) {
  return v(a2) === h;
};
reactIs_production_min.isContextProvider = function(a2) {
  return v(a2) === g;
};
reactIs_production_min.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === b;
};
reactIs_production_min.isForwardRef = function(a2) {
  return v(a2) === l;
};
reactIs_production_min.isFragment = function(a2) {
  return v(a2) === d;
};
reactIs_production_min.isLazy = function(a2) {
  return v(a2) === q;
};
reactIs_production_min.isMemo = function(a2) {
  return v(a2) === p$1;
};
reactIs_production_min.isPortal = function(a2) {
  return v(a2) === c$1;
};
reactIs_production_min.isProfiler = function(a2) {
  return v(a2) === f;
};
reactIs_production_min.isStrictMode = function(a2) {
  return v(a2) === e$1;
};
reactIs_production_min.isSuspense = function(a2) {
  return v(a2) === m;
};
reactIs_production_min.isSuspenseList = function(a2) {
  return v(a2) === n$1;
};
reactIs_production_min.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === d || a2 === f || a2 === e$1 || a2 === m || a2 === n$1 || a2 === t$1 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q || a2.$$typeof === p$1 || a2.$$typeof === g || a2.$$typeof === h || a2.$$typeof === l || a2.$$typeof === u$1 || void 0 !== a2.getModuleId) ? true : false;
};
reactIs_production_min.typeOf = v;
function createListenerCollection() {
  const batch2 = getBatch();
  let first = null;
  let last = null;
  return {
    clear() {
      first = null;
      last = null;
    },
    notify() {
      batch2(() => {
        let listener = first;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get() {
      let listeners = [];
      let listener = first;
      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }
      return listeners;
    },
    subscribe(callback) {
      let isSubscribed = true;
      let listener = last = {
        callback,
        next: null,
        prev: last
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }
      return function unsubscribe() {
        if (!isSubscribed || first === null)
          return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}
const nullListeners = {
  notify() {
  },
  get: () => []
};
function createSubscription(store, parentSub) {
  let unsubscribe;
  let listeners = nullListeners;
  let subscriptionsAmount = 0;
  let selfSubscribed = false;
  function addNestedSub(listener) {
    trySubscribe();
    const cleanupListener = listeners.subscribe(listener);
    let removed = false;
    return () => {
      if (!removed) {
        removed = true;
        cleanupListener();
        tryUnsubscribe();
      }
    };
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return selfSubscribed;
  }
  function trySubscribe() {
    subscriptionsAmount++;
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    subscriptionsAmount--;
    if (unsubscribe && subscriptionsAmount === 0) {
      unsubscribe();
      unsubscribe = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  function trySubscribeSelf() {
    if (!selfSubscribed) {
      selfSubscribed = true;
      trySubscribe();
    }
  }
  function tryUnsubscribeSelf() {
    if (selfSubscribed) {
      selfSubscribed = false;
      tryUnsubscribe();
    }
  }
  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe: trySubscribeSelf,
    tryUnsubscribe: tryUnsubscribeSelf,
    getListeners: () => listeners
  };
  return subscription;
}
const canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const useIsomorphicLayoutEffect = canUseDOM ? reactExports.useLayoutEffect : reactExports.useEffect;
function Provider({
  store,
  context: context2,
  children,
  serverState,
  stabilityCheck = "once",
  noopCheck = "once"
}) {
  const contextValue = reactExports.useMemo(() => {
    const subscription = createSubscription(store);
    return {
      store,
      subscription,
      getServerState: serverState ? () => serverState : void 0,
      stabilityCheck,
      noopCheck
    };
  }, [store, serverState, stabilityCheck, noopCheck]);
  const previousState = reactExports.useMemo(() => store.getState(), [store]);
  useIsomorphicLayoutEffect(() => {
    const {
      subscription
    } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = void 0;
    };
  }, [contextValue, previousState]);
  const Context = context2 || ReactReduxContext;
  return /* @__PURE__ */ reactExports.createElement(Context.Provider, {
    value: contextValue
  }, children);
}
function createStoreHook(context2 = ReactReduxContext) {
  const useReduxContext$1 = (
    // @ts-ignore
    context2 === ReactReduxContext ? useReduxContext : (
      // @ts-ignore
      createReduxContextHook(context2)
    )
  );
  return function useStore2() {
    const {
      store
    } = useReduxContext$1();
    return store;
  };
}
const useStore = /* @__PURE__ */ createStoreHook();
function createDispatchHook(context2 = ReactReduxContext) {
  const useStore$1 = (
    // @ts-ignore
    context2 === ReactReduxContext ? useStore : createStoreHook(context2)
  );
  return function useDispatch2() {
    const store = useStore$1();
    return store.dispatch;
  };
}
const useDispatch = /* @__PURE__ */ createDispatchHook();
initializeUseSelector(withSelectorExports.useSyncExternalStoreWithSelector);
setBatch(reactDomExports.unstable_batchedUpdates);
const useSoundEffect = () => {
  const dispatch = useDispatch();
  const playSeEnter = () => {
    dispatch(setStage({ key: "uiSe", value: mouse_enter }));
  };
  const playSeClick = () => {
    dispatch(setStage({ key: "uiSe", value: click_se }));
  };
  const playSeSwitch = () => {
    dispatch(setStage({ key: "uiSe", value: switch_1 }));
  };
  const playSePageChange = () => {
    dispatch(setStage({ key: "uiSe", value: page_flip_1 }));
  };
  const playSeDialogOpen = () => {
    dispatch(setStage({ key: "uiSe", value: dialog_se }));
  };
  return {
    playSeEnter,
    playSeClick,
    playSePageChange,
    playSeDialogOpen,
    playSeSwitch
  };
};
const useSEByWebgalStore = () => {
  const playSeEnter = () => {
    webgalStore.dispatch(setStage({ key: "uiSe", value: mouse_enter }));
  };
  const playSeClick = () => {
    webgalStore.dispatch(setStage({ key: "uiSe", value: click_se }));
  };
  return {
    playSeEnter,
    // 
    playSeClick
    // 
  };
};
const ProgressBarBackground = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABDoAAABqCAMAAABqMsFvAAAAXVBMVEUAAADRnfoAAADRnvvSnfq3itwbFCDQn/rSnPnVoP51Wo1oT30OCxDVqv/FkuvQnvjRnvlcRG5JOFgoHi/Qn/TQn/qdd7uCY502KT40KT7Sm/rRnPzDkunRn/nTnPeeEeHhAAAAH3RSTlNeXgBSL15eIVgMXl5eBl5HPl5eXhg1Xl5eXilYXk0SC9HCDwAABSBJREFUeNrs3dt2ojAUgOG95RBBOYioA46+/2NOzFCWtShJpxez5P8ubJ/gX8lOjLLyl5m+ri/RWQG8lXN0qerYXFf+PNNRtIeKZABv7lzF7Q+mo+jJBrAYtcl+JB0t3QAWpjb/mo4ivutGecx3zT7dCoC3sk27bpcfSx1Fc0sP8QxHkjepAHhraXNKxnjEL+MhPuFINp0AWIR9nozx+FY62kidMqcbwKJ0p3HbEpyOrBrCsWG0ASxOukvUqbOwdJgz4QAWbYhHZALSURzUIRzAcqW5OofCNx1ZpDfHvQBYsHRYeGR+6WjPapU7AbBwm7/tuPqkw+hNwi0OAB8Lj34+HbHenJhyALC2ud7EM+kYyrERAHA2k+2QqXI0AgCDZmjHi3T0apXcHgVwZ1+qZZ6n4+rKwZksgIl2tJPpGO9zUA4ADzq11tl0OoqIOQeA5/OOqJhMx4GzFQCvzlkOU+kwauUCABNOn0el8mnQkXATDMCkbeLGHV/SUavF7XMAT6SlqlaP6TAMOgC8tFOrfUiH264IADx1HE9ZxnTEbFcAzNirFd+nI4s4XQHgc0K7Lu7SEfNCB4BZ23Jcdsi46OBVMADeyw6XDsOMFEDQssOlg0UHAP9lx0c6DMcrAPyXHe2Qjtr+fxIAmJW7K6UuHZlavwQAZnXDoFQYkgIIkKhq79JRcx0MQMigtHLp4FVBAKE7Flm17FcAhO1YWpuOmPMVAGFnLAebjoq3jAH4a9ywQ1Zr7oMB8Je6C6VytX9+CwB4KlU1E2M/jwIAAY+FGYm51QEgdE7aS823ZgGEPm9cS8UXWACEaFw6LqQDQOjrxheJOJsFEHo6G8nafvJzkQC8bVV1LWoJAHhTi3QAIB0AviAdAP4HajEmBfCNMSmHs/jT3r0mpwoEARSmG5CXPKKghlL3v8wLnWQq8U7J4E853yJOzYsGeOVy9sZ4QQBrfNqTsI5JPwDWpqPl8zcAr3z+NvLRPYC1H90njPoB8Mqon4IBgwDWDhi8M9YYwPqxxvxMAcBrP1MYOCcFEO4sIgM/jgTw2o8j65wRgwBCHWWiGqkddlQRAAS+6ugsHSM7FgBr9ivZnA52LACCfcqksHRoyx0LgPD7lU4tHXbHcmXcD4BFO5lklo5JzkEpgNCvZmP9SUfCsgNA8CGpS0fNsgNA6KKj+EoHyw4AYXapiCQ6i5RlB4AwpVt0aKQmEaYbAwi4Xkn0dzrqmGFhAJbPSGN16TC9MN4YwDOVTLKHdNiT0ivTwgA82650+piOIheRlFsWAF771J2RunSYTCbnCAA8SrddMZE6g3BDC+DJQcegvnTUsTDhGIDPQSZx7UuHHXcwuQPA/45WjkI96XA3tFdehgH449jI5K6+dJiMdgB4dLFyjOpPh0mE8w4Afxxklqg/Ha4d3LMA+KXylUMj9baj5G0YgMn+7MrhT4czyizlTToAm9AxyXQ5HXqP2bQAmH00Msl7DUmHFjELDwDR8STuPUdIOrQexJTEA9isfSVmqDUoHSb7XngwwQPYpn3VyCzP1CtSv6KT73iw8gA2Zw6HaQtdkQ638DBnvmoBNuVSNmLiXjU8HU7yE4+05G06sBGXKpUveVLr6nSYwuJh0vOBnQvw5naHMhV/OMLTYYosFqc5lR+Xy46HpsCb2e+Oh4/y1IiEhcPSsSTrBMCW5G2vSyJdVlAPYDPydqx1WaRh+qTNBcBby9uhrzVIpOHuWdK1t5iEAG8mj29dN2aFhvsHJeNTSzL9K1cAAAAASUVORK5CYII=";
const ProgressBar = "" + new URL("progress-bar-01049335.png", import.meta.url).href;
class ChooseOption {
  constructor(text2, jump) {
    __publicField(this, "text");
    __publicField(this, "jump");
    __publicField(this, "jumpToScene");
    __publicField(this, "showCondition");
    __publicField(this, "enableCondition");
    __publicField(this, "style");
    this.text = text2;
    this.jump = jump;
    this.jumpToScene = jump.match(/\./) !== null;
  }
  /**
   * 
   * (showConditionVar>1)[enableConditionVar>2]->${x=1,y=1,scale=1,image=./assets/baidu.png,fontSize:24,fontColor:#fff}text:jump
   */
  static parse(script) {
    const parts = script.split("->");
    const conditonPart = parts.length > 1 ? parts[0] : null;
    const mainPart = parts.length > 1 ? parts[1] : parts[0];
    const mainPartNodes = mainPart.split(":");
    const text2 = mainPartNodes[0].replace(/\${[^{}]*}/, "");
    const option = new ChooseOption(text2, mainPartNodes[1]);
    const styleRegex = /\$\{(.*?)\}/;
    const styleMatch = conditonPart ? conditonPart.match(styleRegex) : mainPart.match(styleRegex);
    if (styleMatch) {
      const styleStr = styleMatch[1];
      const styleProps = styleStr.split(",");
      const style = {};
      styleProps.forEach((prop) => {
        const [key, value] = prop.split("=");
        if (key && value) {
          style[key.trim()] = isNaN(Number(value.trim())) ? value.trim() : Number(value.trim());
        }
      });
      option.style = style;
    }
    if (conditonPart !== null) {
      const showConditionPart = conditonPart.match(/\((.*)\)/);
      if (showConditionPart) {
        option.showCondition = showConditionPart[1];
      }
      const enableConditionPart = conditonPart.match(/\[(.*)\]/);
      if (enableConditionPart) {
        option.enableCondition = enableConditionPart[1];
      }
    }
    return option;
  }
}
const choose = (sentence, chooseCallback) => {
  const chooseOptionScripts = sentence.content.split("|");
  const chooseOptions = chooseOptionScripts.map((e2) => ChooseOption.parse(e2));
  const fontFamily = webgalStore.getState().userData.optionData.textboxFont;
  const font = fontFamily === textFont.song ? '"", serif' : '"WebgalUI", serif';
  const { playSeEnter, playSeClick } = useSEByWebgalStore();
  let timer = {
    current: null
  };
  const runtimeBuildList = (chooseListFull) => {
    return chooseListFull.filter((e2, i2) => whenChecker(e2.showCondition)).map((e2, i2) => {
      var _a2, _b2;
      const enable = whenChecker(e2.enableCondition);
      let className = enable ? styles$l.Choose_item : styles$l.Choose_item_disabled;
      const onClick = enable ? () => {
        playSeClick();
        chooseCallback == null ? void 0 : chooseCallback();
        if (timer.current) {
          clearTimeout(timer.current);
          timer.current = null;
        }
        if (e2.jumpToScene) {
          changeScene(e2.jump, e2.text);
        } else {
          jmp(e2.jump);
        }
        WebGAL.gameplay.performController.unmountPerform("choose");
      } : () => {
      };
      const styleObj = {
        fontFamily: font
      };
      if (e2.style) {
        if (typeof e2.style.x === "number") {
          styleObj.position = "absolute";
          styleObj["left"] = e2.style.x * 1.33333 + "px";
          styleObj["transform"] = "translateX(-50%)";
        }
        if (typeof e2.style.y === "number") {
          styleObj.position = "absolute";
          styleObj["top"] = e2.style.y * 1.33333 + "px";
          if (styleObj["transform"]) {
            styleObj["transform"] += " translateY(-50%)";
          } else {
            styleObj["transform"] = "translateY(-50%)";
          }
        }
        if (typeof e2.style.scale === "number") {
          if (styleObj["transform"]) {
            styleObj["transform"] += " scale(" + e2.style.scale + ")";
          } else {
            styleObj["transform"] = "scale(" + e2.style.scale + ")";
          }
        }
        if (typeof e2.style.fontSize === "number") {
          styleObj["fontSize"] = e2.style.fontSize + "px";
        }
        if (typeof e2.style.fontColor === "string" && e2.style.fontColor[0] === "#") {
          styleObj["color"] = e2.style.fontColor;
        }
      }
      if (typeof ((_a2 = e2.style) == null ? void 0 : _a2.countdown) === "number") {
        className = styles$l.Choose_item_countdown;
        let time = e2.style.countdown;
        let width = 1082;
        let unit = 1082 / (time * 1e3 / 16);
        const countdown = () => {
          if (time <= 0 && timer.current) {
            clearTimeout(timer);
            timer.current = null;
            onClick();
          } else {
            timer.current = setTimeout(() => {
              time -= 0.016;
              width -= unit;
              let rect = document.getElementById("rect");
              rect == null ? void 0 : rect.setAttribute("width", Math.max(0, width).toString());
              countdown();
            }, 16);
          }
        };
        countdown();
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className, style: styleObj, onClick, onMouseEnter: playSeEnter, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: ProgressBarBackground, alt: e2.text, style: { width: "1082px", height: "106px" } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: ProgressBar, className: styles$l.Choose_item_progress_bar })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "0", height: "0", children: /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "myClip", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { id: "rect", width: "1082", height: "106", rx: "53", ry: "53", style: { fill: "#fff" } }) }) }) })
        ] }, e2.jump + i2);
      }
      if ((_b2 = e2.style) == null ? void 0 : _b2.image) {
        className = styles$l.Choose_item_image;
        const imgUrl = assetSetter(e2.style.image, fileType$1.ui);
        const id2 = `img-option-${i2}`;
        const img = new Image();
        img.src = imgUrl;
        img.onload = function() {
          let ele = document.getElementById(id2);
          img.style.width = img.naturalWidth + "px";
          img.style.height = img.naturalHeight + "px";
          img.alt = e2.text;
          if (ele) {
            ele.style.width = img.naturalWidth + "px";
            ele.style.height = img.naturalHeight + "px";
            setTimeout(() => {
              ele == null ? void 0 : ele.prepend(img);
              ele = null;
            }, 32);
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            id: id2,
            className,
            style: styleObj,
            onClick,
            onMouseEnter: playSeEnter,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: e2.text })
          },
          e2.jump + i2
        );
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className, style: styleObj, onClick, onMouseEnter: playSeEnter, children: e2.text }, e2.jump + i2);
    });
  };
  ReactDOM.render(
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$l.Choose_Main, children: runtimeBuildList(chooseOptions) }),
    document.getElementById("chooseContainer")
  );
  return {
    performName: "choose",
    duration: 1e3 * 60 * 60 * 24,
    isHoldOn: false,
    stopFunction: () => {
      ReactDOM.render(/* @__PURE__ */ jsxRuntimeExports.jsx("div", {}), document.getElementById("chooseContainer"));
    },
    blockingNext: () => true,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
const comment$1 = (sentence) => {
  logger.debug(`${sentence.content}`);
  return {
    performName: "none",
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
const filmMode = (sentence) => {
  if (sentence.content !== "" && sentence.content !== "none") {
    webgalStore.dispatch(setStage({ key: "enableFilm", value: sentence.content }));
  } else {
    webgalStore.dispatch(setStage({ key: "enableFilm", value: "" }));
  }
  return {
    performName: "none",
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
const Choose_Main = "_Choose_Main_4xkm5_1";
const Choose_item = "_Choose_item_4xkm5_13";
const glabalDialog_container_inner$1 = "_glabalDialog_container_inner_4xkm5_28";
const glabalDialog_container$1 = "_glabalDialog_container_4xkm5_28";
const title$1 = "_title_4xkm5_47";
const button$3 = "_button_4xkm5_59";
const styles$k = {
  Choose_Main,
  Choose_item,
  glabalDialog_container_inner: glabalDialog_container_inner$1,
  glabalDialog_container: glabalDialog_container$1,
  title: title$1,
  button: button$3
};
const getUserInput = (sentence) => {
  const varKey = sentence.content.toString().trim();
  const titleFromArgs = getSentenceArgByKey(sentence, "title");
  const title2 = (titleFromArgs === 0 ? "Please Input" : titleFromArgs) ?? "Please Input";
  const buttonTextFromArgs = getSentenceArgByKey(sentence, "buttonText");
  const buttonText = (buttonTextFromArgs === 0 ? "OK" : buttonTextFromArgs) ?? "OK";
  const fontFamily = webgalStore.getState().userData.optionData.textboxFont;
  const font = fontFamily === textFont.song ? '"", serif' : '"WebgalUI", serif';
  const { playSeEnter, playSeClick } = useSEByWebgalStore();
  const chooseElements = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontFamily: font }, className: styles$k.glabalDialog_container, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$k.glabalDialog_container_inner, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$k.title, children: title2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("input", { id: "user-input", className: styles$k.Choose_item }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        onMouseEnter: playSeEnter,
        onClick: () => {
          const userInput = document.getElementById("user-input");
          if (userInput) {
            webgalStore.dispatch(
              setStageVar({ key: varKey, value: ((userInput == null ? void 0 : userInput.value) ?? "") === "" ? " " : (userInput == null ? void 0 : userInput.value) ?? "" })
            );
          }
          playSeClick();
          WebGAL.gameplay.performController.unmountPerform("userInput");
          nextSentence();
        },
        className: styles$k.button,
        children: buttonText
      }
    )
  ] }) });
  ReactDOM.render(
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$k.Choose_Main, children: chooseElements }),
    document.getElementById("chooseContainer")
  );
  return {
    performName: "userInput",
    duration: 1e3 * 60 * 60 * 24,
    isHoldOn: false,
    stopFunction: () => {
      ReactDOM.render(/* @__PURE__ */ jsxRuntimeExports.jsx("div", {}), document.getElementById("chooseContainer"));
    },
    blockingNext: () => true,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
const FullScreenPerform_main = "_FullScreenPerform_main_7er8a_2";
const FullScreenPerform_element = "_FullScreenPerform_element_7er8a_9";
const fullScreen_video = "_fullScreen_video_7er8a_17";
const fadeIn = "_fadeIn_7er8a_74";
const intro_showSoftly = "_intro_showSoftly_7er8a_1";
const slideIn = "_slideIn_7er8a_80";
const typingEffect = "_typingEffect_7er8a_86";
const typing = "_typing_7er8a_86";
const blinkCursor = "_blinkCursor_7er8a_1";
const pixelateEffect = "_pixelateEffect_7er8a_95";
const pixelateAnimation = "_pixelateAnimation_7er8a_1";
const revealAnimation = "_revealAnimation_7er8a_101";
const videoContainer = "_videoContainer_7er8a_115";
const styles$j = {
  FullScreenPerform_main,
  FullScreenPerform_element,
  fullScreen_video,
  fadeIn,
  intro_showSoftly,
  slideIn,
  typingEffect,
  typing,
  blinkCursor,
  pixelateEffect,
  pixelateAnimation,
  revealAnimation,
  videoContainer
};
const intro = (sentence) => {
  const performName = `introPerform${Math.random().toString()}`;
  let fontSize;
  let backgroundColor = "rgba(0, 0, 0, 1)";
  let color2 = "rgba(255, 255, 255, 1)";
  const animationClass = (type2, length2 = 0) => {
    switch (type2) {
      case "fadeIn":
        return styles$j.fadeIn;
      case "slideIn":
        return styles$j.slideIn;
      case "typingEffect":
        return `${styles$j.typingEffect} ${length2}`;
      case "pixelateEffect":
        return styles$j.pixelateEffect;
      case "revealAnimation":
        return styles$j.revealAnimation;
      default:
        return styles$j.fadeIn;
    }
  };
  let chosenAnimationClass = styles$j.fadeIn;
  let delayTime = 1500;
  let isHold = false;
  for (const e2 of sentence.args) {
    if (e2.key === "backgroundColor") {
      backgroundColor = e2.value || "rgba(0, 0, 0, 1)";
    }
    if (e2.key === "fontColor") {
      color2 = e2.value || "rgba(255, 255, 255, 1)";
    }
    if (e2.key === "fontSize") {
      switch (e2.value) {
        case "small":
          fontSize = "280%";
          break;
        case "medium":
          fontSize = "350%";
          break;
        case "large":
          fontSize = "420%";
          break;
      }
    }
    if (e2.key === "animation") {
      chosenAnimationClass = animationClass(e2.value);
    }
    if (e2.key === "delayTime") {
      const parsedValue = parseInt(e2.value.toString(), 10);
      delayTime = isNaN(parsedValue) ? delayTime : parsedValue;
    }
    if (e2.key === "hold") {
      if (e2.value === true) {
        isHold = true;
      }
    }
  }
  const introContainerStyle = {
    background: backgroundColor,
    color: color2,
    fontSize: fontSize || "350%",
    width: "100%",
    height: "100%"
  };
  const introArray = sentence.content.split(/\|/);
  let endWait = 1e3;
  let baseDuration = endWait + delayTime * introArray.length;
  const duration = isHold ? 1e3 * 60 * 60 * 24 : 1e3 + delayTime * introArray.length;
  let isBlocking = true;
  let setBlockingStateTimeout = setTimeout(() => {
    isBlocking = false;
  }, baseDuration);
  let timeout = setTimeout(() => {
  });
  const toNextIntroElement = () => {
    const introContainer22 = document.getElementById("introContainer");
    baseDuration -= delayTime;
    clearTimeout(setBlockingStateTimeout);
    setBlockingStateTimeout = setTimeout(() => {
      isBlocking = false;
    }, baseDuration);
    if (introContainer22) {
      const children = introContainer22.childNodes[0].childNodes[0].childNodes;
      const len = children.length;
      children.forEach((node2, index2) => {
        const currentDelay = Number(node2.style.animationDelay.split("ms")[0]);
        if (currentDelay > 0) {
          node2.style.animationDelay = `${currentDelay - delayTime}ms`;
        }
        if (index2 === len - 1) {
          if (currentDelay === 0) {
            clearTimeout(timeout);
            WebGAL.gameplay.performController.unmountPerform(performName);
          } else {
            clearTimeout(timeout);
            if (!isHold) {
              timeout = setTimeout(() => {
                WebGAL.gameplay.performController.unmountPerform(performName);
                setTimeout(nextSentence, 0);
              }, baseDuration);
            }
          }
        }
      });
    }
  };
  WebGAL.events.userInteractNext.on(toNextIntroElement);
  const showIntro = introArray.map((e2, i2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: { animationDelay: `${delayTime * i2}ms` },
      className: chosenAnimationClass,
      children: [
        e2,
        e2 === "" ? "" : ""
      ]
    },
    "introtext" + i2 + Math.random().toString()
  ));
  const intro2 = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: introContainerStyle, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { padding: "3em 4em 3em 4em" }, children: showIntro }) });
  ReactDOM.render(intro2, document.getElementById("introContainer"));
  const introContainer2 = document.getElementById("introContainer");
  if (introContainer2) {
    introContainer2.style.display = "block";
  }
  return {
    performName,
    duration,
    isHoldOn: false,
    stopFunction: () => {
      const introContainer22 = document.getElementById("introContainer");
      if (introContainer22) {
        introContainer22.style.display = "none";
      }
      WebGAL.events.userInteractNext.off(toNextIntroElement);
    },
    blockingNext: () => isBlocking,
    blockingAuto: () => isBlocking,
    stopTimeout: void 0,
    // 
    goNextWhenOver: true
  };
};
const label = (sentence) => {
  return {
    performName: "none",
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
const miniAvatar = (sentence) => {
  let content = sentence.content;
  if (sentence.content === "none" || sentence.content === "") {
    content = "";
  }
  webgalStore.dispatch(setStage({ key: "miniAvatar", value: content }));
  return {
    performName: "none",
    duration: 0,
    isHoldOn: true,
    stopFunction: () => {
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
const scriptRel = "modulepreload";
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep, importerUrl);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i2 = links.length - 1; i2 >= 0; i2--) {
        const link2 = links[i2];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule()).catch((err) => {
    const e2 = new Event("vite:preloadError", { cancelable: true });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  });
};
const performs = /* @__PURE__ */ new Map();
function getName(name) {
  if (!name)
    return null;
  if (typeof name === "string")
    return name;
  return name();
}
function getKey(name) {
  const key = getName(name);
  if (!key) {
    logger.error("Get name of perform failed. There no name of the perform.");
    return "";
  }
  return key;
}
function registerPerform(name, callback) {
  if (!callback || typeof callback !== "function")
    throw new Error(`"${name}" is not a callback.`);
  performs.set(getKey(name), callback);
}
function call$1(name, args = []) {
  const callback = performs.get(getKey(name));
  if (!callback || !(callback instanceof Function)) {
    logger.error(`Can't call the perform named "${name}"`);
    throw new Error(`"${name}" don't have the pixiPerform callback.`);
  }
  return callback(...args);
}
__vitePreload(() => import("./initRegister-309085de.js"), true ? [] : void 0, import.meta.url);
const pixi = (sentence) => {
  const pixiPerformName = "PixiPerform" + sentence.content;
  WebGAL.gameplay.performController.performList.forEach((e2) => {
    if (e2.performName === pixiPerformName) {
      return {
        performName: "none",
        duration: 0,
        isOver: false,
        isHoldOn: true,
        stopFunction: () => {
        },
        blockingNext: () => false,
        blockingAuto: () => false,
        stopTimeout: void 0
        // 
      };
    }
  });
  const res = call$1(sentence.content);
  const { container: container2, tickerKey } = res;
  return {
    performName: pixiPerformName,
    duration: 0,
    isHoldOn: true,
    stopFunction: () => {
      var _a2, _b2;
      logger.warn("pixi");
      container2.destroy({ texture: true, baseTexture: true });
      (_a2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a2.effectsContainer.removeChild(container2);
      (_b2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _b2.removeAnimation(tickerKey);
    },
    blockingNext: () => false,
    blockingAuto: () => false,
    stopTimeout: void 0
    // 
  };
};
const playEffect = (sentence) => {
  var _a2;
  logger.debug("play SE");
  let performInitName = "effect-sound";
  WebGAL.gameplay.performController.unmountPerform(performInitName, true);
  let url2 = sentence.content;
  let isLoop = false;
  if (getSentenceArgByKey(sentence, "id")) {
    const id2 = ((_a2 = getSentenceArgByKey(sentence, "id")) == null ? void 0 : _a2.toString()) ?? "";
    performInitName = `effect-sound-${id2}`;
    WebGAL.gameplay.performController.unmountPerform(performInitName, true);
    isLoop = true;
  }
  let isOver = false;
  return {
    performName: "none",
    blockingAuto() {
      return false;
    },
    blockingNext() {
      return false;
    },
    isHoldOn: false,
    stopFunction() {
    },
    stopTimeout: void 0,
    duration: 1e3 * 60 * 60,
    arrangePerformPromise: new Promise((resolve2) => {
      setTimeout(() => {
        var _a3;
        const volumeArg = getSentenceArgByKey(sentence, "volume");
        let seElement = document.createElement("audio");
        seElement.src = url2;
        if (isLoop) {
          seElement.loop = true;
        }
        const userDataState = webgalStore.getState().userData;
        const mainVol = userDataState.optionData.volumeMain;
        const volume = typeof volumeArg === "number" && volumeArg >= 0 && volumeArg <= 100 ? volumeArg : 100;
        const seVol = mainVol * 0.01 * (((_a3 = userDataState.optionData) == null ? void 0 : _a3.seVolume) ?? 100) * 0.01 * volume * 0.01;
        seElement.volume = seVol;
        seElement.currentTime = 0;
        const perform = {
          performName: performInitName,
          duration: 1e3 * 60 * 60,
          isHoldOn: isLoop,
          skipNextCollect: true,
          stopFunction: () => {
            seElement.pause();
          },
          blockingNext: () => false,
          blockingAuto: () => {
            if (isLoop)
              return false;
            return !isOver;
          },
          stopTimeout: void 0
          // 
        };
        resolve2(perform);
        seElement == null ? void 0 : seElement.play();
        seElement.onended = () => {
          for (const e2 of WebGAL.gameplay.performController.performList) {
            if (e2.performName === performInitName) {
              isOver = true;
              e2.stopFunction();
              WebGAL.gameplay.performController.unmountPerform(e2.performName);
            }
          }
        };
      }, 1);
    })
  };
};
const getRandomPerformName = () => {
  return Math.random().toString().substring(0, 10);
};
class PerformController {
  constructor() {
    __publicField(this, "performList", []);
    __publicField(this, "timeoutList", []);
  }
  arrangeNewPerform(perform, script, syncPerformState = true) {
    if (perform.performName === "none") {
      return;
    }
    if (syncPerformState) {
      const performToAdd = { id: perform.performName, isHoldOn: perform.isHoldOn, script };
      webgalStore.dispatch(stageActions.addPerform(performToAdd));
    }
    perform.stopTimeout = setTimeout(() => {
      if (!perform.isHoldOn) {
        this.unmountPerform(perform.performName);
        if (perform.goNextWhenOver) {
          this.goNextWhenOver();
        }
      }
    }, perform.duration);
    this.performList.push(perform);
  }
  unmountPerform(name, force = false) {
    if (!force) {
      for (let i2 = 0; i2 < this.performList.length; i2++) {
        const e2 = this.performList[i2];
        if (!e2.isHoldOn && e2.performName === name) {
          e2.stopFunction();
          clearTimeout(e2.stopTimeout);
          this.performList.splice(i2, 1);
          i2--;
        }
      }
    } else {
      for (let i2 = 0; i2 < this.performList.length; i2++) {
        const e2 = this.performList[i2];
        if (e2.performName === name) {
          e2.stopFunction();
          clearTimeout(e2.stopTimeout);
          this.performList.splice(i2, 1);
          i2--;
          this.erasePerformFromState(name);
        }
      }
    }
  }
  erasePerformFromState(name) {
    webgalStore.dispatch(stageActions.removePerformByName(name));
  }
  removeAllPerform() {
    for (const e2 of this.performList) {
      e2.stopFunction();
    }
    this.performList = [];
    for (const e2 of this.timeoutList) {
      clearTimeout(e2);
    }
  }
  goNextWhenOver() {
    let isBlockingAuto = false;
    this.performList.forEach((e2) => {
      if (e2.blockingAuto())
        isBlockingAuto = true;
    });
    if (isBlockingAuto) {
      setTimeout(this.goNextWhenOver, 100);
    } else {
      nextSentence();
    }
  }
}
const playVideo = (sentence) => {
  const userDataState = webgalStore.getState().userData;
  const mainVol = userDataState.optionData.volumeMain;
  const vocalVol = mainVol * 0.01 * userDataState.optionData.vocalVolume * 0.01;
  const bgmVol = mainVol * 0.01 * userDataState.optionData.bgmVolume * 0.01;
  const performInitName = getRandomPerformName();
  let chooseContent = "";
  let loopValue = false;
  const optionId = Date.now();
  sentence.args.forEach((e2) => {
    if (e2.key === "choose") {
      chooseContent = "choose:" + e2.value;
    }
    if (e2.key === "loop") {
      loopValue = e2.value === true;
    }
  });
  let blockingNext = getSentenceArgByKey(sentence, "skipOff");
  let blockingNextFlag = false;
  if (blockingNext || loopValue || chooseContent !== "") {
    blockingNextFlag = true;
  }
  WebGAL.videoManager.showVideo(sentence.content);
  let isOver = false;
  const performObject = {
    performName: "none",
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {
    },
    blockingNext: () => blockingNextFlag,
    blockingAuto: () => true,
    stopTimeout: void 0,
    // 
    arrangePerformPromise: new Promise((resolve2) => {
      const endCallback = (e2) => {
        isOver = true;
        e2.stopFunction();
        WebGAL.gameplay.performController.unmountPerform(e2.performName);
      };
      setTimeout(() => {
        const url2 = sentence.content;
        WebGAL.videoManager.seek(url2, 0.03);
        WebGAL.videoManager.setVolume(url2, bgmVol);
        WebGAL.videoManager.setLoop(url2, loopValue);
        const sceneList = chooseContent ? chooseContent.slice(7).split("|").map((x) => "game/scene/" + x.split(":")[1]) : [];
        if (sceneList.length) {
          scenePrefetcher(sceneList);
        }
        const endPerform = () => {
          for (const e2 of WebGAL.gameplay.performController.performList) {
            if (e2.performName === performInitName) {
              if (chooseContent !== "" && !loopValue) {
                const parsedResult = sceneParser(chooseContent, `${optionId}.txt`, "");
                const duration = WebGAL.videoManager.getDuration(url2);
                WebGAL.videoManager.seek(url2, (duration || 0) - 0.03);
                WebGAL.videoManager.pauseVideo(url2);
                const script = parsedResult.sentenceList[0];
                const perform2 = choose(script, () => {
                  endCallback(e2);
                });
                WebGAL.gameplay.performController.arrangeNewPerform(perform2, script);
              } else {
                endCallback(e2);
                nextSentence();
              }
            }
          }
        };
        const skipVideo = () => {
          console.log("skip");
          endPerform();
        };
        WebGAL.events.fullscreenDbClick.on(skipVideo);
        const perform = {
          performName: performInitName,
          duration: 1e3 * 60 * 60,
          isOver: false,
          isHoldOn: false,
          stopFunction: () => {
            WebGAL.events.fullscreenDbClick.off(skipVideo);
            const bgmElement22 = document.getElementById("currentBgm");
            if (bgmElement22) {
              bgmElement22.volume = bgmVol.toString();
            }
            const vocalElement2 = document.getElementById("currentVocal");
            if (bgmElement22) {
              vocalElement2.volume = vocalVol.toString();
            }
            WebGAL.videoManager.destory(url2);
          },
          blockingNext: () => blockingNextFlag,
          blockingAuto: () => {
            return !isOver;
          },
          stopTimeout: void 0,
          // 
          goNextWhenOver: true
        };
        resolve2(perform);
        const vocalVol2 = 0;
        const bgmVol2 = 0;
        const bgmElement2 = document.getElementById("currentBgm");
        if (bgmElement2) {
          bgmElement2.volume = bgmVol2.toString();
        }
        const vocalElement = document.getElementById("currentVocal");
        if (bgmElement2) {
          vocalElement.volume = vocalVol2.toString();
        }
        WebGAL.videoManager.playVideo(url2);
        if (chooseContent && loopValue) {
          const parsedResult = sceneParser(chooseContent, `${optionId}.txt`, "");
          const script = parsedResult.sentenceList[0];
          const perform2 = choose(script, endPerform);
          WebGAL.gameplay.performController.arrangeNewPerform(perform2, script);
        }
        WebGAL.videoManager.onEnded(url2, () => {
          if (loopValue) {
            WebGAL.videoManager.seek(url2, 0.03);
            WebGAL.videoManager.playVideo(url2);
          } else {
            endPerform();
          }
        });
      }, 100);
    })
  };
  return performObject;
};
const setAnimation = (sentence) => {
  var _a2;
  webgalStore.getState().stage.currentDialogKey;
  const animationName = sentence.content;
  const animationDuration = getAnimateDuration$1(animationName);
  const target = (((_a2 = getSentenceArgByKey(sentence, "target")) == null ? void 0 : _a2.toString()) ?? "default_id").toString();
  const key = `${target}-${animationName}-${animationDuration}`;
  let stopFunction;
  setTimeout(() => {
    var _a3, _b2;
    (_a3 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a3.stopPresetAnimationOnTarget(target);
    const animationObj = getAnimationObject$2(animationName, target, animationDuration);
    if (animationObj) {
      logger.debug(`${animationName}${target}`, animationDuration);
      (_b2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _b2.registerAnimation(animationObj, key, target);
    }
  }, 0);
  stopFunction = () => {
    setTimeout(() => {
      var _a3;
      webgalStore.getState().stage.currentDialogKey;
      (_a3 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a3.removeAnimationWithSetEffects(key);
    }, 0);
  };
  return {
    performName: key,
    duration: animationDuration,
    isHoldOn: false,
    stopFunction,
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
function generateTestblurAnimationObj(targetKey, duration) {
  const target = WebGAL.gameplay.pixiStage.getStageObjByKey(targetKey);
  function setStartState() {
    if (target) {
      target.pixiContainer.alpha = 0;
      target.pixiContainer.blur = 0;
    }
  }
  function setEndState() {
    if (target) {
      target.pixiContainer.alpha = 1;
      target.pixiContainer.blur = 5;
    }
  }
  function tickerFunc(delta) {
    if (target) {
      const container2 = target.pixiContainer;
      const baseDuration = WebGAL.gameplay.pixiStage.frameDuration;
      const currentAddOplityDelta = duration / baseDuration * delta;
      const increasement = 1 / currentAddOplityDelta;
      const decreasement = 5 / currentAddOplityDelta;
      if (container2.alpha < 1) {
        container2.alpha += increasement;
      }
      if (container2.blur < 5) {
        container2.blur += decreasement;
      }
    }
  }
  return {
    setStartState,
    setEndState,
    tickerFunc
  };
}
const webgalAnimations = [
  { name: "universalSoftIn", animationGenerateFunc: generateUniversalSoftInAnimationObj },
  { name: "universalSoftOff", animationGenerateFunc: generateUniversalSoftOffAnimationObj },
  { name: "testblur", animationGenerateFunc: generateTestblurAnimationObj }
];
const setComplexAnimation = (sentence) => {
  var _a2, _b2, _c2;
  webgalStore.getState().stage.currentDialogKey;
  const animationName = sentence.content;
  const animationDuration = getSentenceArgByKey(sentence, "duration") ?? 0;
  const target = ((_a2 = getSentenceArgByKey(sentence, "target")) == null ? void 0 : _a2.toString()) ?? "0";
  const key = `${target}-${animationName}-${animationDuration}`;
  const animationFunction = getAnimationObject$1(animationName);
  let stopFunction = () => {
  };
  if (animationFunction) {
    logger.debug(`${animationName}${target}`, animationDuration);
    const animationObj = animationFunction(target, animationDuration);
    (_b2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _b2.stopPresetAnimationOnTarget(target);
    (_c2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _c2.registerAnimation(animationObj, key, target);
    stopFunction = () => {
      var _a3;
      webgalStore.getState().stage.currentDialogKey;
      (_a3 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a3.removeAnimationWithSetEffects(key);
    };
  }
  return {
    performName: key,
    duration: animationDuration,
    isHoldOn: false,
    stopFunction,
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
function getAnimationObject$1(animationName) {
  const result = webgalAnimations.find((e2) => e2.name === animationName);
  logger.debug("", result);
  if (result) {
    return result.animationGenerateFunc;
  }
  return null;
}
const setFilter = (sentence) => {
  return {
    performName: "none",
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
const setTempAnimation = (sentence) => {
  var _a2;
  webgalStore.getState().stage.currentDialogKey;
  const animationName = (Math.random() * 10).toString(16);
  const animationString = sentence.content;
  let animationObj;
  try {
    animationObj = JSON.parse(animationString);
  } catch (e2) {
    animationObj = [];
  }
  const newAnimation = { name: animationName, effects: animationObj };
  WebGAL.animationManager.addAnimation(newAnimation);
  const animationDuration = getAnimateDuration$1(animationName);
  const target = ((_a2 = getSentenceArgByKey(sentence, "target")) == null ? void 0 : _a2.toString()) ?? "0";
  const key = `${target}-${animationName}-${animationDuration}`;
  let stopFunction = () => {
  };
  setTimeout(() => {
    var _a3, _b2;
    (_a3 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a3.stopPresetAnimationOnTarget(target);
    const animationObj2 = getAnimationObject$2(animationName, target, animationDuration);
    if (animationObj2) {
      logger.debug(`${animationName}${target}`, animationDuration);
      (_b2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _b2.registerAnimation(animationObj2, key, target);
    }
  }, 0);
  stopFunction = () => {
    setTimeout(() => {
      var _a3;
      webgalStore.getState().stage.currentDialogKey;
      (_a3 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a3.removeAnimationWithSetEffects(key);
    }, 0);
  };
  return {
    performName: key,
    duration: animationDuration,
    isHoldOn: false,
    stopFunction,
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
function setTextbox(sentence) {
  if (sentence.content === "hide") {
    webgalStore.dispatch(setStage({ key: "isDisableTextbox", value: true }));
  } else {
    webgalStore.dispatch(setStage({ key: "isDisableTextbox", value: false }));
  }
  return {
    performName: "none",
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
}
const setTransform = (sentence) => {
  var _a2;
  webgalStore.getState().stage.currentDialogKey;
  const animationName = (Math.random() * 10).toString(16);
  const animationString = sentence.content;
  let animationObj;
  const duration = getSentenceArgByKey(sentence, "duration");
  const target = ((_a2 = getSentenceArgByKey(sentence, "target")) == null ? void 0 : _a2.toString()) ?? "0";
  try {
    const frame2 = JSON.parse(animationString);
    animationObj = generateTransformAnimationObj(target, frame2, duration);
  } catch (e2) {
    animationObj = [];
  }
  const newAnimation = { name: animationName, effects: animationObj };
  WebGAL.animationManager.addAnimation(newAnimation);
  const animationDuration = getAnimateDuration(animationName);
  const key = `${target}-${animationName}-${animationDuration}`;
  let stopFunction = () => {
  };
  setTimeout(() => {
    var _a3, _b2;
    (_a3 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a3.stopPresetAnimationOnTarget(target);
    const animationObj2 = getAnimationObject(animationName, target, animationDuration);
    if (animationObj2) {
      logger.debug(`${animationName}${target}`, animationDuration);
      (_b2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _b2.registerAnimation(animationObj2, key, target);
    }
  }, 0);
  stopFunction = () => {
    setTimeout(() => {
      var _a3;
      webgalStore.getState().stage.currentDialogKey;
      (_a3 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a3.removeAnimationWithSetEffects(key);
    }, 0);
  };
  return {
    performName: key,
    duration: animationDuration,
    isHoldOn: false,
    stopFunction,
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
function getAnimationObject(animationName, target, duration) {
  const effect = WebGAL.animationManager.getAnimations().find((ani) => ani.name === animationName);
  if (effect) {
    const mappedEffects = effect.effects.map((effect2) => {
      const newEffect = cloneDeep$1({ ...baseTransform, duration: 0 });
      Object.assign(newEffect, effect2);
      newEffect.duration = effect2.duration;
      return newEffect;
    });
    logger.debug("", mappedEffects);
    return generateTimelineObj(mappedEffects, target, duration);
  }
  return null;
}
function getAnimateDuration(animationName) {
  const effect = WebGAL.animationManager.getAnimations().find((ani) => ani.name === animationName);
  if (effect) {
    let duration = 0;
    effect.effects.forEach((e2) => {
      duration += e2.duration;
    });
    return duration;
  }
  return 0;
}
const setTransition = (sentence) => {
  let key = "0";
  for (const e2 of sentence.args) {
    if (e2.key === "target") {
      key = e2.value.toString();
    }
  }
  if (getSentenceArgByKey(sentence, "enter")) {
    WebGAL.animationManager.nextEnterAnimationName.set(key, getSentenceArgByKey(sentence, "enter").toString());
  }
  if (getSentenceArgByKey(sentence, "exit")) {
    WebGAL.animationManager.nextExitAnimationName.set(key + "-off", getSentenceArgByKey(sentence, "exit").toString());
  }
  return {
    performName: "none",
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {
    },
    blockingNext: () => false,
    blockingAuto: () => false,
    stopTimeout: void 0
    // 
  };
};
const unlockBgm$2 = (sentence) => {
  const url2 = sentence.content;
  let name = sentence.content;
  let series = "default";
  console.log(sentence, "bgm-sentence");
  sentence.args.forEach((e2) => {
    if (e2.key === "name") {
      name = e2.value.toString();
    }
    if (e2.key === "series") {
      series = e2.value.toString();
    }
  });
  logger.info(`BGM${name}${url2}${series}`);
  webgalStore.dispatch(unlockBgmInUserData({ name, url: url2, series }));
  const userDataState = webgalStore.getState().userData;
  localforage.setItem(WebGAL.gameKey, userDataState).then(() => {
  });
  return {
    performName: "none",
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
const unlockCg = (sentence) => {
  const url2 = sentence.content;
  let name = sentence.content;
  let series = "default";
  console.log(sentence, "cg-sentence");
  sentence.args.forEach((e2) => {
    if (e2.key === "name") {
      name = e2.value.toString();
    }
    if (e2.key === "series") {
      series = e2.value.toString();
    }
  });
  logger.info(`CG${name}${url2}${series}`);
  webgalStore.dispatch(unlockCgInUserData({ name, url: url2, series }));
  const userDataState = webgalStore.getState().userData;
  localforage.setItem(WebGAL.gameKey, userDataState).then(() => {
  });
  return {
    performName: "none",
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
const resetStage = (resetBacklog, resetSceneAndVar = true, resetVideo = true) => {
  if (resetBacklog) {
    WebGAL.backlogManager.makeBacklogEmpty();
  }
  if (resetVideo) {
    WebGAL.videoManager.destoryAll();
  }
  if (resetSceneAndVar) {
    WebGAL.sceneManager.resetScene();
  }
  WebGAL.gameplay.performController.removeAllPerform();
  WebGAL.gameplay.resetGamePlay();
  const initSceneDataCopy = cloneDeep$1(initState$3);
  const currentVars = webgalStore.getState().stage.GameVar;
  webgalStore.dispatch(resetStageState(initSceneDataCopy));
  if (!resetSceneAndVar) {
    webgalStore.dispatch(setStage({ key: "GameVar", value: currentVars }));
  }
};
const initState$1 = {
  saveData: [],
  quickSaveData: null
};
const saveDataSlice = createSlice({
  name: "saveData",
  initialState: cloneDeep$1(initState$1),
  reducers: {
    setFastSave: (state, action) => {
      state.quickSaveData = action.payload;
    },
    resetFastSave: (state) => {
      state.quickSaveData = null;
    },
    resetSaves: (state) => {
      state.quickSaveData = null;
      state.saveData = [];
    },
    saveGame: (state, action) => {
      state.saveData[action.payload.index] = action.payload.saveData;
    },
    replaceSaveGame: (state, action) => {
      state.saveData = action.payload;
    }
  }
});
const saveActions = saveDataSlice.actions;
const savesReducer = saveDataSlice.reducer;
const end = (sentence) => {
  resetStage(true);
  const dispatch = webgalStore.dispatch;
  const sceneUrl = assetSetter("start.txt", fileType$1.scene);
  setTimeout(() => {
    WebGAL.sceneManager.resetScene();
  }, 5);
  dispatch(saveActions.resetFastSave());
  dumpToStorageFast();
  sceneFetcher(sceneUrl).then((rawScene) => {
    WebGAL.sceneManager.setCurrentScene(rawScene, "start.txt", sceneUrl);
  });
  dispatch(setVisibility({ component: "showTitle", visibility: true }));
  playBgm(webgalStore.getState().GUI.titleBgm);
  return {
    performName: "none",
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
const jumpLabel = (sentence) => {
  jmp(sentence.content);
  return {
    performName: "none",
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
const pixiInit = (sentence) => {
  WebGAL.gameplay.performController.performList.forEach((e2) => {
    if (e2.performName.match(/PixiPerform/)) {
      logger.warn("pixi ", e2.performName);
      for (let i2 = 0; i2 < WebGAL.gameplay.performController.performList.length; i2++) {
        const e22 = WebGAL.gameplay.performController.performList[i2];
        if (e22.performName === e2.performName) {
          e22.stopFunction();
          clearTimeout(e22.stopTimeout);
          WebGAL.gameplay.performController.performList.splice(i2, 1);
          i2--;
        }
      }
      webgalStore.dispatch(stageActions.removeAllPixiPerforms());
    }
  });
  return {
    performName: "none",
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
const audioContextWrapper = {
  audioContext: new AudioContext(),
  source: null,
  analyser: void 0,
  dataArray: void 0,
  audioLevelInterval: setInterval(() => {
  }, 0),
  // dummy interval
  blinkTimerID: setTimeout(() => {
  }, 0),
  // dummy timeout
  maxAudioLevel: 0
};
const updateThresholds = (audioLevel) => {
  audioContextWrapper.maxAudioLevel = Math.max(audioLevel, audioContextWrapper.maxAudioLevel);
  return {
    OPEN_THRESHOLD: audioContextWrapper.maxAudioLevel * 0.75,
    HALF_OPEN_THRESHOLD: audioContextWrapper.maxAudioLevel * 0.5
  };
};
const performBlinkAnimation = (params) => {
  let isBlinking = false;
  function blink() {
    var _a2;
    if (isBlinking || params.animationEndTime && Date.now() > params.animationEndTime)
      return;
    isBlinking = true;
    (_a2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a2.performBlinkAnimation(params.key, params.animationItem, "closed", params.pos);
    audioContextWrapper.blinkTimerID = setTimeout(() => {
      var _a3;
      (_a3 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a3.performBlinkAnimation(params.key, params.animationItem, "open", params.pos);
      isBlinking = false;
      const nextBlinkTime = Math.random() * 300 + 3500;
      audioContextWrapper.blinkTimerID = setTimeout(blink, nextBlinkTime);
    }, 200);
  }
  blink();
};
const getAudioLevel = (analyser, dataArray, bufferLength) => {
  analyser.getByteFrequencyData(dataArray);
  let sum = 0;
  for (let i2 = 0; i2 < bufferLength; i2++) {
    sum += dataArray[i2];
  }
  return sum / bufferLength;
};
const performMouthAnimation = (params) => {
  var _a2, _b2;
  const { audioLevel, OPEN_THRESHOLD, HALF_OPEN_THRESHOLD, currentMouthValue, lerpSpeed, key, animationItem, pos } = params;
  let targetValue;
  if (audioLevel > OPEN_THRESHOLD) {
    targetValue = 1;
  } else if (audioLevel > HALF_OPEN_THRESHOLD) {
    targetValue = 0.5;
  } else {
    targetValue = 0;
  }
  const mouthValue = currentMouthValue + (targetValue - currentMouthValue) * lerpSpeed;
  (_a2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a2.setModelMouthY(key, audioLevel);
  let mouthState;
  if (mouthValue > 0.75) {
    mouthState = "open";
  } else if (mouthValue > 0.25) {
    mouthState = "half_open";
  } else {
    mouthState = "closed";
  }
  if (animationItem !== void 0) {
    (_b2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _b2.performMouthSyncAnimation(key, animationItem, mouthState, pos);
  }
};
class Matcher {
  constructor(subject) {
    __publicField(this, "subject");
    __publicField(this, "result");
    __publicField(this, "isEnd", false);
    this.subject = subject;
  }
  with(pattern, fn2) {
    if (!this.isEnd && this.subject === pattern) {
      this.result = fn2();
      this.isEnd = true;
    }
    return this;
  }
  endsWith(pattern, fn2) {
    if (!this.isEnd && this.subject === pattern) {
      this.result = fn2();
      this.isEnd = true;
    }
    return this.evaluate();
  }
  default(fn2) {
    if (!this.isEnd)
      this.result = fn2();
    return this.evaluate();
  }
  evaluate() {
    return this.result;
  }
}
function match$1(subject) {
  return new Matcher(subject);
}
const playVocal = (sentence) => {
  logger.debug("play vocal");
  const performInitName = "vocal-play";
  const url2 = getSentenceArgByKey(sentence, "vocal");
  const volume = getSentenceArgByKey(sentence, "volume");
  let currentStageState;
  currentStageState = webgalStore.getState().stage;
  let pos = "";
  let key = "";
  const freeFigure = currentStageState.freeFigure;
  const figureAssociatedAnimation = currentStageState.figureAssociatedAnimation;
  let bufferLength = 0;
  let currentMouthValue = 0;
  const lerpSpeed = 1;
  let VocalControl = document.getElementById("currentVocal");
  WebGAL.gameplay.performController.unmountPerform("vocal-play", true);
  if (VocalControl !== null) {
    VocalControl.currentTime = 0;
    VocalControl.pause();
  }
  for (const e2 of sentence.args) {
    if (e2.value === true) {
      match$1(e2.key).with("left", () => {
        pos = "left";
      }).with("right", () => {
        pos = "right";
      }).endsWith("center", () => {
        pos = "center";
      });
    }
    if (e2.key === "figureId") {
      key = `${e2.value.toString()}`;
    }
  }
  webgalStore.dispatch(setStage({ key: "playVocal", value: url2 }));
  webgalStore.dispatch(setStage({ key: "vocal", value: url2 }));
  let isOver = false;
  return {
    arrangePerformPromise: new Promise((resolve2) => {
      setTimeout(() => {
        let VocalControl2 = document.getElementById("currentVocal");
        typeof volume === "number" && volume >= 0 && volume <= 100 ? webgalStore.dispatch(setStage({ key: "vocalVolume", value: volume })) : webgalStore.dispatch(setStage({ key: "vocalVolume", value: 100 }));
        if (VocalControl2 !== null) {
          VocalControl2.currentTime = 0;
          const perform = {
            performName: performInitName,
            duration: 1e3 * 60 * 60,
            isOver: false,
            isHoldOn: false,
            stopFunction: () => {
              clearInterval(audioContextWrapper.audioLevelInterval);
              VocalControl2.pause();
              key = key ? key : `fig-${pos}`;
              const animationItem2 = figureAssociatedAnimation.find((tid) => tid.targetId === key);
              performMouthAnimation({
                audioLevel: 0,
                OPEN_THRESHOLD: 1,
                HALF_OPEN_THRESHOLD: 1,
                currentMouthValue,
                lerpSpeed,
                key,
                animationItem: animationItem2,
                pos
              });
              clearTimeout(audioContextWrapper.blinkTimerID);
            },
            blockingNext: () => false,
            blockingAuto: () => {
              return !isOver;
            },
            skipNextCollect: true,
            stopTimeout: void 0
            // 
          };
          WebGAL.gameplay.performController.arrangeNewPerform(perform, sentence, false);
          key = key ? key : `fig-${pos}`;
          const animationItem = figureAssociatedAnimation.find((tid) => tid.targetId === key);
          if (animationItem) {
            const foundFigure = freeFigure.find((figure) => figure.key === key);
            if (foundFigure) {
              pos = foundFigure.basePosition;
            }
            if (!audioContextWrapper.audioContext) {
              let audioContext;
              audioContext = new AudioContext();
              audioContextWrapper.analyser = audioContext.createAnalyser();
              audioContextWrapper.analyser.fftSize = 256;
              audioContextWrapper.dataArray = new Uint8Array(audioContextWrapper.analyser.frequencyBinCount);
            }
            if (!audioContextWrapper.analyser) {
              audioContextWrapper.analyser = audioContextWrapper.audioContext.createAnalyser();
              audioContextWrapper.analyser.fftSize = 256;
            }
            bufferLength = audioContextWrapper.analyser.frequencyBinCount;
            audioContextWrapper.dataArray = new Uint8Array(bufferLength);
            let vocalControl = document.getElementById("currentVocal");
            if (!audioContextWrapper.source) {
              audioContextWrapper.source = audioContextWrapper.audioContext.createMediaElementSource(vocalControl);
              audioContextWrapper.source.connect(audioContextWrapper.analyser);
            }
            audioContextWrapper.analyser.connect(audioContextWrapper.audioContext.destination);
            audioContextWrapper.audioLevelInterval = setInterval(() => {
              const audioLevel = getAudioLevel(
                audioContextWrapper.analyser,
                audioContextWrapper.dataArray,
                bufferLength
              );
              const { OPEN_THRESHOLD, HALF_OPEN_THRESHOLD } = updateThresholds(audioLevel);
              performMouthAnimation({
                audioLevel,
                OPEN_THRESHOLD,
                HALF_OPEN_THRESHOLD,
                currentMouthValue,
                lerpSpeed,
                key,
                animationItem,
                pos
              });
            }, 50);
            let animationEndTime;
            animationEndTime = Date.now() + 1e4;
            performBlinkAnimation({ key, animationItem, pos, animationEndTime });
            setTimeout(() => {
              clearTimeout(audioContextWrapper.blinkTimerID);
            }, 1e4);
          }
          VocalControl2 == null ? void 0 : VocalControl2.play();
          VocalControl2.onended = () => {
            for (const e2 of WebGAL.gameplay.performController.performList) {
              if (e2.performName === performInitName) {
                isOver = true;
                e2.stopFunction();
                WebGAL.gameplay.performController.unmountPerform(e2.performName);
              }
            }
          };
        }
      }, 1);
    })
  };
};
function useTextDelay(num) {
  if (num === 0) {
    return 3;
  } else if (num === 100) {
    return 80;
  } else {
    return 77 * Number(num) / 100;
  }
}
function useTextAnimationDuration(num) {
  if (num === 0) {
    return 800;
  } else if (num === 100) {
    return 200;
  } else {
    return 800 - 600 * Number(num) / 100;
  }
}
const say = (sentence) => {
  const stageState = webgalStore.getState().stage;
  const userDataState = webgalStore.getState().userData;
  const dispatch = webgalStore.dispatch;
  let dialogKey = Math.random().toString();
  let dialogToShow = sentence.content;
  const isConcat = getSentenceArgByKey(sentence, "concat");
  const isNotend = getSentenceArgByKey(sentence, "notend");
  const speaker = getSentenceArgByKey(sentence, "speaker");
  const clear2 = getSentenceArgByKey(sentence, "clear");
  const vocal = getSentenceArgByKey(sentence, "vocal");
  if (isConcat) {
    dialogKey = stageState.currentDialogKey;
    dialogToShow = stageState.showText + dialogToShow;
    dispatch(setStage({ key: "currentConcatDialogPrev", value: stageState.showText }));
  } else {
    dispatch(setStage({ key: "currentConcatDialogPrev", value: "" }));
  }
  dispatch(setStage({ key: "showText", value: dialogToShow }));
  dispatch(setStage({ key: "vocal", value: "" }));
  if (!(userDataState.optionData.voiceInterruption === voiceOption.no && vocal === null)) {
    dispatch(setStage({ key: "playVocal", value: "" }));
    WebGAL.gameplay.performController.unmountPerform("vocal-play", true);
  }
  dispatch(setStage({ key: "currentDialogKey", value: dialogKey }));
  const textDelay = useTextDelay(userDataState.optionData.textSpeed);
  const sentenceDelay = textDelay * sentence.content.length;
  for (const e2 of sentence.args) {
    if (e2.key === "fontSize") {
      switch (e2.value) {
        case "default":
          dispatch(setStage({ key: "showTextSize", value: -1 }));
          break;
        case "small":
          dispatch(setStage({ key: "showTextSize", value: textSize.small }));
          break;
        case "medium":
          dispatch(setStage({ key: "showTextSize", value: textSize.medium }));
          break;
        case "large":
          dispatch(setStage({ key: "showTextSize", value: textSize.large }));
          break;
      }
    }
  }
  let showName = stageState.showName;
  if (speaker !== null) {
    showName = speaker;
  }
  if (clear2) {
    showName = "";
  }
  dispatch(setStage({ key: "showName", value: showName }));
  if (vocal) {
    playVocal(sentence);
  }
  const performInitName = getRandomPerformName();
  let endDelay = 750 - userDataState.optionData.textSpeed / 100 * 2 * 250;
  if (isNotend) {
    endDelay = 0;
  }
  return {
    performName: performInitName,
    duration: sentenceDelay + endDelay,
    isHoldOn: false,
    stopFunction: () => {
      WebGAL.events.textSettle.emit();
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0,
    // 
    goNextWhenOver: isNotend
  };
};
const showVars = (sentence) => {
  const stageState = webgalStore.getState().stage;
  const userDataState = webgalStore.getState().userData;
  const dispatch = webgalStore.dispatch;
  const allVar = {
    stageGameVar: stageState.GameVar,
    globalGameVar: userDataState.globalGameVar
  };
  dispatch(setStage({ key: "showText", value: JSON.stringify(allVar) }));
  dispatch(setStage({ key: "showName", value: "" }));
  logger.debug("", allVar);
  setTimeout(() => {
    WebGAL.events.textSettle.emit();
  }, 0);
  const performInitName = getRandomPerformName();
  const endDelay = 750 - userDataState.optionData.textSpeed * 250;
  return {
    performName: performInitName,
    duration: endDelay,
    isHoldOn: false,
    stopFunction: () => {
      WebGAL.events.textSettle.emit();
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
function ScriptConfig(scriptType, scriptFunction, config) {
  return { scriptType, scriptFunction, ...config };
}
const scriptRegistry = {};
function defineScripts(record) {
  const result = {};
  for (const [scriptString, config] of Object.entries(record)) {
    result[scriptString] = scriptRegistry[config.scriptType] = { scriptString, ...config };
  }
  return result;
}
const applyStyle = (sentence) => {
  const { content } = sentence;
  const applyStyleSegments = content.split(",");
  for (const applyStyleSegment of applyStyleSegments) {
    const splitSegment = applyStyleSegment.split("->");
    if (splitSegment.length >= 2) {
      const classNameToBeChange = splitSegment[0];
      const classNameChangeTo = splitSegment[1];
      webgalStore.dispatch(stageActions.replaceUIlable([classNameToBeChange, classNameChangeTo]));
    }
  }
  return {
    performName: "none",
    duration: 0,
    isHoldOn: false,
    stopFunction: () => {
    },
    blockingNext: () => false,
    blockingAuto: () => true,
    stopTimeout: void 0
    // 
  };
};
const SCRIPT_TAG_MAP = defineScripts({
  intro: ScriptConfig(commandType$1.intro, intro),
  changeBg: ScriptConfig(commandType$1.changeBg, changeBg),
  changeFigure: ScriptConfig(commandType$1.changeFigure, changeFigure),
  miniAvatar: ScriptConfig(commandType$1.miniAvatar, miniAvatar, { next: true }),
  changeScene: ScriptConfig(commandType$1.changeScene, changeSceneScript),
  choose: ScriptConfig(commandType$1.choose, choose),
  end: ScriptConfig(commandType$1.end, end),
  bgm: ScriptConfig(commandType$1.bgm, bgm, { next: true }),
  playVideo: ScriptConfig(commandType$1.video, playVideo),
  setComplexAnimation: ScriptConfig(commandType$1.setComplexAnimation, setComplexAnimation),
  setFilter: ScriptConfig(commandType$1.setFilter, setFilter),
  pixiInit: ScriptConfig(commandType$1.pixiInit, pixiInit, { next: true }),
  pixiPerform: ScriptConfig(commandType$1.pixi, pixi, { next: true }),
  label: ScriptConfig(commandType$1.label, label, { next: true }),
  jumpLabel: ScriptConfig(commandType$1.jumpLabel, jumpLabel),
  setVar: ScriptConfig(commandType$1.setVar, setVar, { next: true }),
  showVars: ScriptConfig(commandType$1.showVars, showVars),
  unlockCg: ScriptConfig(commandType$1.unlockCg, unlockCg, { next: true }),
  unlockBgm: ScriptConfig(commandType$1.unlockBgm, unlockBgm$2, { next: true }),
  say: ScriptConfig(commandType$1.say, say),
  filmMode: ScriptConfig(commandType$1.filmMode, filmMode, { next: true }),
  callScene: ScriptConfig(commandType$1.callScene, callSceneScript),
  setTextbox: ScriptConfig(commandType$1.setTextbox, setTextbox),
  setAnimation: ScriptConfig(commandType$1.setAnimation, setAnimation),
  playEffect: ScriptConfig(commandType$1.playEffect, playEffect, { next: true }),
  setTempAnimation: ScriptConfig(commandType$1.setTempAnimation, setTempAnimation),
  __commment: ScriptConfig(commandType$1.comment, comment$1, { next: true }),
  setTransform: ScriptConfig(commandType$1.setTransform, setTransform),
  setTransition: ScriptConfig(commandType$1.setTransition, setTransition, { next: true }),
  getUserInput: ScriptConfig(commandType$1.getUserInput, getUserInput),
  applyStyle: ScriptConfig(commandType$1.applyStyle, applyStyle, { next: true })
  // if: ScriptConfig(commandType.if, undefined, { next: true }),
});
const SCRIPT_CONFIG = Object.values(SCRIPT_TAG_MAP);
const ADD_NEXT_ARG_LIST = SCRIPT_CONFIG.filter((config) => config.next).map((config) => config.scriptType);
const WebgalParser = new SceneParser(assetsPrefetcher, assetSetter, ADD_NEXT_ARG_LIST, SCRIPT_CONFIG);
const sceneParser = (rawScene, sceneName, sceneUrl) => {
  const parsedScene = WebgalParser.parse(rawScene, sceneName, sceneUrl);
  logger.info(`${sceneName}`, parsedScene);
  return parsedScene;
};
const initSceneData = {
  currentSentenceId: 0,
  // ID
  sceneStack: [],
  // 
  currentScene: {
    sceneName: "",
    // 
    sceneUrl: "",
    // url
    sentenceList: [],
    // 
    assetsList: [],
    // 
    subSceneList: []
    // 
  }
};
class SceneManager {
  constructor() {
    __publicField(this, "settledScenes", []);
    __publicField(this, "settledAssets", []);
    __publicField(this, "sceneData", cloneDeep$1(initSceneData));
    __publicField(this, "sceneAssetsList", {});
    __publicField(this, "sceneAssetsLoadedList", {});
  }
  resetScene() {
    this.sceneData.currentSentenceId = 0;
    this.sceneData.sceneStack = [];
    this.sceneData.currentScene = cloneDeep$1(initSceneData.currentScene);
  }
  // eslint-disable-next-line max-params
  setCurrentScene(rawScene, scenaName, sceneUrl, loading = false) {
    return new Promise((r2) => {
      let parsedScene = { current: null };
      let timer = null;
      if (loading && !this.sceneAssetsLoadedList[scenaName]) {
        timer = setTimeout(() => {
          window.pubsub.publish("loading", { loading: true });
        }, 1e3);
      }
      const dispose = window.pubsub.subscribe(
        "sceneAssetsLoaded",
        ({ sceneName: _sceneName }) => {
          setTimeout(() => {
            if (scenaName === _sceneName) {
              if (parsedScene.current) {
                this.sceneData.currentScene = parsedScene.current;
              }
              if (loading) {
                window.pubsub.publish("loading", { loading: false });
              }
              timer && clearTimeout(timer);
              r2(parsedScene);
              parsedScene.current = null;
              dispose();
            }
          }, 16);
        }
      );
      parsedScene.current = sceneParser(rawScene, scenaName, sceneUrl);
    });
  }
}
class AnimationManager {
  constructor() {
    __publicField(this, "nextEnterAnimationName", /* @__PURE__ */ new Map());
    __publicField(this, "nextExitAnimationName", /* @__PURE__ */ new Map());
    __publicField(this, "animations", []);
  }
  addAnimation(animation2) {
    this.animations.push(animation2);
  }
  getAnimations() {
    return this.animations;
  }
}
class Gameplay {
  constructor() {
    __publicField(this, "isAuto", false);
    __publicField(this, "isFast", false);
    __publicField(this, "autoInterval", null);
    __publicField(this, "fastInterval", null);
    __publicField(this, "autoTimeout", null);
    __publicField(this, "pixiStage", null);
    __publicField(this, "performController", new PerformController());
  }
  resetGamePlay() {
    this.performController.timeoutList = [];
    this.isAuto = false;
    this.isFast = false;
    const autoInterval = this.autoInterval;
    if (autoInterval !== null)
      clearInterval(autoInterval);
    this.autoInterval = null;
    const fastInterval = this.fastInterval;
    if (fastInterval !== null)
      clearInterval(fastInterval);
    this.fastInterval = null;
    const autoTimeout = this.autoTimeout;
    if (autoTimeout !== null)
      clearInterval(autoTimeout);
    this.autoTimeout = null;
  }
}
function mitt(n2) {
  return { all: n2 = n2 || /* @__PURE__ */ new Map(), on: function(t2, e2) {
    var i2 = n2.get(t2);
    i2 ? i2.push(e2) : n2.set(t2, [e2]);
  }, off: function(t2, e2) {
    var i2 = n2.get(t2);
    i2 && (e2 ? i2.splice(i2.indexOf(e2) >>> 0, 1) : n2.set(t2, []));
  }, emit: function(t2, e2) {
    var i2 = n2.get(t2);
    i2 && i2.slice().map(function(n3) {
      n3(e2);
    }), (i2 = n2.get("*")) && i2.slice().map(function(n3) {
      n3(t2, e2);
    });
  } };
}
class Events {
  constructor() {
    __publicField(this, "textSettle", formEvent("text-settle"));
    __publicField(this, "userInteractNext", formEvent("__NEXT"));
    __publicField(this, "fullscreenDbClick", formEvent("fullscreen-dbclick"));
    __publicField(this, "styleUpdate", formEvent("style-update"));
  }
}
const eventBus = mitt();
function formEvent(eventName) {
  return {
    on: (callback, id2) => {
      eventBus.on(`${eventName}-${id2 ?? ""}`, callback);
    },
    emit: (message, id2) => {
      eventBus.emit(`${eventName}-${id2 ?? ""}`, message);
    },
    off: (callback, id2) => {
      eventBus.off(`${eventName}-${id2 ?? ""}`, callback);
    }
  };
}
var flv = { exports: {} };
(function(module, exports) {
  (function webpackUniversalModuleDefinition(root2, factory) {
    module.exports = factory();
  })(self, function() {
    return (
      /******/
      function() {
        var __webpack_modules__ = {
          /***/
          "./node_modules/es6-promise/dist/es6-promise.js": (
            /*!******************************************************!*\
              !*** ./node_modules/es6-promise/dist/es6-promise.js ***!
              \******************************************************/
            /***/
            function(module2, __unused_webpack_exports, __webpack_require__2) {
              /*!
               * @overview es6-promise - a tiny implementation of Promises/A+.
               * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
               * @license   Licensed under MIT license
               *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
               * @version   v4.2.8+1e68dce6
               */
              (function(global2, factory) {
                module2.exports = factory();
              })(this, function() {
                function objectOrFunction(x) {
                  var type2 = typeof x;
                  return x !== null && (type2 === "object" || type2 === "function");
                }
                function isFunction2(x) {
                  return typeof x === "function";
                }
                var _isArray = void 0;
                if (Array.isArray) {
                  _isArray = Array.isArray;
                } else {
                  _isArray = function(x) {
                    return Object.prototype.toString.call(x) === "[object Array]";
                  };
                }
                var isArray2 = _isArray;
                var len = 0;
                var vertxNext = void 0;
                var customSchedulerFn = void 0;
                var asap = function asap2(callback, arg) {
                  queue[len] = callback;
                  queue[len + 1] = arg;
                  len += 2;
                  if (len === 2) {
                    if (customSchedulerFn) {
                      customSchedulerFn(flush);
                    } else {
                      scheduleFlush();
                    }
                  }
                };
                function setScheduler(scheduleFn) {
                  customSchedulerFn = scheduleFn;
                }
                function setAsap(asapFn) {
                  asap = asapFn;
                }
                var browserWindow = typeof window !== "undefined" ? window : void 0;
                var browserGlobal = browserWindow || {};
                var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
                var isNode = typeof self === "undefined" && typeof process !== "undefined" && {}.toString.call(process) === "[object process]";
                var isWorker = typeof Uint8ClampedArray !== "undefined" && typeof importScripts !== "undefined" && typeof MessageChannel !== "undefined";
                function useNextTick() {
                  return function() {
                    return process.nextTick(flush);
                  };
                }
                function useVertxTimer() {
                  if (typeof vertxNext !== "undefined") {
                    return function() {
                      vertxNext(flush);
                    };
                  }
                  return useSetTimeout();
                }
                function useMutationObserver() {
                  var iterations = 0;
                  var observer = new BrowserMutationObserver(flush);
                  var node2 = document.createTextNode("");
                  observer.observe(node2, { characterData: true });
                  return function() {
                    node2.data = iterations = ++iterations % 2;
                  };
                }
                function useMessageChannel() {
                  var channel = new MessageChannel();
                  channel.port1.onmessage = flush;
                  return function() {
                    return channel.port2.postMessage(0);
                  };
                }
                function useSetTimeout() {
                  var globalSetTimeout = setTimeout;
                  return function() {
                    return globalSetTimeout(flush, 1);
                  };
                }
                var queue = new Array(1e3);
                function flush() {
                  for (var i2 = 0; i2 < len; i2 += 2) {
                    var callback = queue[i2];
                    var arg = queue[i2 + 1];
                    callback(arg);
                    queue[i2] = void 0;
                    queue[i2 + 1] = void 0;
                  }
                  len = 0;
                }
                function attemptVertx() {
                  try {
                    var vertx = Function("return this")().require("vertx");
                    vertxNext = vertx.runOnLoop || vertx.runOnContext;
                    return useVertxTimer();
                  } catch (e2) {
                    return useSetTimeout();
                  }
                }
                var scheduleFlush = void 0;
                if (isNode) {
                  scheduleFlush = useNextTick();
                } else if (BrowserMutationObserver) {
                  scheduleFlush = useMutationObserver();
                } else if (isWorker) {
                  scheduleFlush = useMessageChannel();
                } else if (browserWindow === void 0 && true) {
                  scheduleFlush = attemptVertx();
                } else {
                  scheduleFlush = useSetTimeout();
                }
                function then(onFulfillment, onRejection) {
                  var parent = this;
                  var child = new this.constructor(noop2);
                  if (child[PROMISE_ID] === void 0) {
                    makePromise(child);
                  }
                  var _state = parent._state;
                  if (_state) {
                    var callback = arguments[_state - 1];
                    asap(function() {
                      return invokeCallback(_state, child, callback, parent._result);
                    });
                  } else {
                    subscribe(parent, child, onFulfillment, onRejection);
                  }
                  return child;
                }
                function resolve$12(object) {
                  var Constructor = this;
                  if (object && typeof object === "object" && object.constructor === Constructor) {
                    return object;
                  }
                  var promise2 = new Constructor(noop2);
                  resolve2(promise2, object);
                  return promise2;
                }
                var PROMISE_ID = Math.random().toString(36).substring(2);
                function noop2() {
                }
                var PENDING = void 0;
                var FULFILLED = 1;
                var REJECTED = 2;
                function selfFulfillment() {
                  return new TypeError("You cannot resolve a promise with itself");
                }
                function cannotReturnOwn() {
                  return new TypeError("A promises callback cannot return that same promise.");
                }
                function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
                  try {
                    then$$1.call(value, fulfillmentHandler, rejectionHandler);
                  } catch (e2) {
                    return e2;
                  }
                }
                function handleForeignThenable(promise2, thenable, then$$1) {
                  asap(function(promise3) {
                    var sealed = false;
                    var error2 = tryThen(then$$1, thenable, function(value) {
                      if (sealed) {
                        return;
                      }
                      sealed = true;
                      if (thenable !== value) {
                        resolve2(promise3, value);
                      } else {
                        fulfill(promise3, value);
                      }
                    }, function(reason) {
                      if (sealed) {
                        return;
                      }
                      sealed = true;
                      reject2(promise3, reason);
                    }, "Settle: " + (promise3._label || " unknown promise"));
                    if (!sealed && error2) {
                      sealed = true;
                      reject2(promise3, error2);
                    }
                  }, promise2);
                }
                function handleOwnThenable(promise2, thenable) {
                  if (thenable._state === FULFILLED) {
                    fulfill(promise2, thenable._result);
                  } else if (thenable._state === REJECTED) {
                    reject2(promise2, thenable._result);
                  } else {
                    subscribe(thenable, void 0, function(value) {
                      return resolve2(promise2, value);
                    }, function(reason) {
                      return reject2(promise2, reason);
                    });
                  }
                }
                function handleMaybeThenable(promise2, maybeThenable, then$$1) {
                  if (maybeThenable.constructor === promise2.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$12) {
                    handleOwnThenable(promise2, maybeThenable);
                  } else {
                    if (then$$1 === void 0) {
                      fulfill(promise2, maybeThenable);
                    } else if (isFunction2(then$$1)) {
                      handleForeignThenable(promise2, maybeThenable, then$$1);
                    } else {
                      fulfill(promise2, maybeThenable);
                    }
                  }
                }
                function resolve2(promise2, value) {
                  if (promise2 === value) {
                    reject2(promise2, selfFulfillment());
                  } else if (objectOrFunction(value)) {
                    var then$$1 = void 0;
                    try {
                      then$$1 = value.then;
                    } catch (error2) {
                      reject2(promise2, error2);
                      return;
                    }
                    handleMaybeThenable(promise2, value, then$$1);
                  } else {
                    fulfill(promise2, value);
                  }
                }
                function publishRejection(promise2) {
                  if (promise2._onerror) {
                    promise2._onerror(promise2._result);
                  }
                  publish(promise2);
                }
                function fulfill(promise2, value) {
                  if (promise2._state !== PENDING) {
                    return;
                  }
                  promise2._result = value;
                  promise2._state = FULFILLED;
                  if (promise2._subscribers.length !== 0) {
                    asap(publish, promise2);
                  }
                }
                function reject2(promise2, reason) {
                  if (promise2._state !== PENDING) {
                    return;
                  }
                  promise2._state = REJECTED;
                  promise2._result = reason;
                  asap(publishRejection, promise2);
                }
                function subscribe(parent, child, onFulfillment, onRejection) {
                  var _subscribers = parent._subscribers;
                  var length2 = _subscribers.length;
                  parent._onerror = null;
                  _subscribers[length2] = child;
                  _subscribers[length2 + FULFILLED] = onFulfillment;
                  _subscribers[length2 + REJECTED] = onRejection;
                  if (length2 === 0 && parent._state) {
                    asap(publish, parent);
                  }
                }
                function publish(promise2) {
                  var subscribers = promise2._subscribers;
                  var settled = promise2._state;
                  if (subscribers.length === 0) {
                    return;
                  }
                  var child = void 0, callback = void 0, detail = promise2._result;
                  for (var i2 = 0; i2 < subscribers.length; i2 += 3) {
                    child = subscribers[i2];
                    callback = subscribers[i2 + settled];
                    if (child) {
                      invokeCallback(settled, child, callback, detail);
                    } else {
                      callback(detail);
                    }
                  }
                  promise2._subscribers.length = 0;
                }
                function invokeCallback(settled, promise2, callback, detail) {
                  var hasCallback = isFunction2(callback), value = void 0, error2 = void 0, succeeded = true;
                  if (hasCallback) {
                    try {
                      value = callback(detail);
                    } catch (e2) {
                      succeeded = false;
                      error2 = e2;
                    }
                    if (promise2 === value) {
                      reject2(promise2, cannotReturnOwn());
                      return;
                    }
                  } else {
                    value = detail;
                  }
                  if (promise2._state !== PENDING)
                    ;
                  else if (hasCallback && succeeded) {
                    resolve2(promise2, value);
                  } else if (succeeded === false) {
                    reject2(promise2, error2);
                  } else if (settled === FULFILLED) {
                    fulfill(promise2, value);
                  } else if (settled === REJECTED) {
                    reject2(promise2, value);
                  }
                }
                function initializePromise(promise2, resolver2) {
                  try {
                    resolver2(function resolvePromise(value) {
                      resolve2(promise2, value);
                    }, function rejectPromise(reason) {
                      reject2(promise2, reason);
                    });
                  } catch (e2) {
                    reject2(promise2, e2);
                  }
                }
                var id2 = 0;
                function nextId() {
                  return id2++;
                }
                function makePromise(promise2) {
                  promise2[PROMISE_ID] = id2++;
                  promise2._state = void 0;
                  promise2._result = void 0;
                  promise2._subscribers = [];
                }
                function validationError() {
                  return new Error("Array Methods must be provided an Array");
                }
                var Enumerator = function() {
                  function Enumerator2(Constructor, input) {
                    this._instanceConstructor = Constructor;
                    this.promise = new Constructor(noop2);
                    if (!this.promise[PROMISE_ID]) {
                      makePromise(this.promise);
                    }
                    if (isArray2(input)) {
                      this.length = input.length;
                      this._remaining = input.length;
                      this._result = new Array(this.length);
                      if (this.length === 0) {
                        fulfill(this.promise, this._result);
                      } else {
                        this.length = this.length || 0;
                        this._enumerate(input);
                        if (this._remaining === 0) {
                          fulfill(this.promise, this._result);
                        }
                      }
                    } else {
                      reject2(this.promise, validationError());
                    }
                  }
                  Enumerator2.prototype._enumerate = function _enumerate(input) {
                    for (var i2 = 0; this._state === PENDING && i2 < input.length; i2++) {
                      this._eachEntry(input[i2], i2);
                    }
                  };
                  Enumerator2.prototype._eachEntry = function _eachEntry(entry, i2) {
                    var c2 = this._instanceConstructor;
                    var resolve$$1 = c2.resolve;
                    if (resolve$$1 === resolve$12) {
                      var _then = void 0;
                      var error2 = void 0;
                      var didError = false;
                      try {
                        _then = entry.then;
                      } catch (e2) {
                        didError = true;
                        error2 = e2;
                      }
                      if (_then === then && entry._state !== PENDING) {
                        this._settledAt(entry._state, i2, entry._result);
                      } else if (typeof _then !== "function") {
                        this._remaining--;
                        this._result[i2] = entry;
                      } else if (c2 === Promise$12) {
                        var promise2 = new c2(noop2);
                        if (didError) {
                          reject2(promise2, error2);
                        } else {
                          handleMaybeThenable(promise2, entry, _then);
                        }
                        this._willSettleAt(promise2, i2);
                      } else {
                        this._willSettleAt(new c2(function(resolve$$12) {
                          return resolve$$12(entry);
                        }), i2);
                      }
                    } else {
                      this._willSettleAt(resolve$$1(entry), i2);
                    }
                  };
                  Enumerator2.prototype._settledAt = function _settledAt(state, i2, value) {
                    var promise2 = this.promise;
                    if (promise2._state === PENDING) {
                      this._remaining--;
                      if (state === REJECTED) {
                        reject2(promise2, value);
                      } else {
                        this._result[i2] = value;
                      }
                    }
                    if (this._remaining === 0) {
                      fulfill(promise2, this._result);
                    }
                  };
                  Enumerator2.prototype._willSettleAt = function _willSettleAt(promise2, i2) {
                    var enumerator = this;
                    subscribe(promise2, void 0, function(value) {
                      return enumerator._settledAt(FULFILLED, i2, value);
                    }, function(reason) {
                      return enumerator._settledAt(REJECTED, i2, reason);
                    });
                  };
                  return Enumerator2;
                }();
                function all3(entries) {
                  return new Enumerator(this, entries).promise;
                }
                function race(entries) {
                  var Constructor = this;
                  if (!isArray2(entries)) {
                    return new Constructor(function(_24, reject3) {
                      return reject3(new TypeError("You must pass an array to race."));
                    });
                  } else {
                    return new Constructor(function(resolve3, reject3) {
                      var length2 = entries.length;
                      for (var i2 = 0; i2 < length2; i2++) {
                        Constructor.resolve(entries[i2]).then(resolve3, reject3);
                      }
                    });
                  }
                }
                function reject$1(reason) {
                  var Constructor = this;
                  var promise2 = new Constructor(noop2);
                  reject2(promise2, reason);
                  return promise2;
                }
                function needsResolver() {
                  throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
                }
                function needsNew() {
                  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
                }
                var Promise$12 = function() {
                  function Promise2(resolver2) {
                    this[PROMISE_ID] = nextId();
                    this._result = this._state = void 0;
                    this._subscribers = [];
                    if (noop2 !== resolver2) {
                      typeof resolver2 !== "function" && needsResolver();
                      this instanceof Promise2 ? initializePromise(this, resolver2) : needsNew();
                    }
                  }
                  Promise2.prototype.catch = function _catch(onRejection) {
                    return this.then(null, onRejection);
                  };
                  Promise2.prototype.finally = function _finally(callback) {
                    var promise2 = this;
                    var constructor = promise2.constructor;
                    if (isFunction2(callback)) {
                      return promise2.then(function(value) {
                        return constructor.resolve(callback()).then(function() {
                          return value;
                        });
                      }, function(reason) {
                        return constructor.resolve(callback()).then(function() {
                          throw reason;
                        });
                      });
                    }
                    return promise2.then(callback, callback);
                  };
                  return Promise2;
                }();
                Promise$12.prototype.then = then;
                Promise$12.all = all3;
                Promise$12.race = race;
                Promise$12.resolve = resolve$12;
                Promise$12.reject = reject$1;
                Promise$12._setScheduler = setScheduler;
                Promise$12._setAsap = setAsap;
                Promise$12._asap = asap;
                function polyfill2() {
                  var local = void 0;
                  if (typeof __webpack_require__2.g !== "undefined") {
                    local = __webpack_require__2.g;
                  } else if (typeof self !== "undefined") {
                    local = self;
                  } else {
                    try {
                      local = Function("return this")();
                    } catch (e2) {
                      throw new Error("polyfill failed because global object is unavailable in this environment");
                    }
                  }
                  var P2 = local.Promise;
                  if (P2) {
                    var promiseToString = null;
                    try {
                      promiseToString = Object.prototype.toString.call(P2.resolve());
                    } catch (e2) {
                    }
                    if (promiseToString === "[object Promise]" && !P2.cast) {
                      return;
                    }
                  }
                  local.Promise = Promise$12;
                }
                Promise$12.polyfill = polyfill2;
                Promise$12.Promise = Promise$12;
                return Promise$12;
              });
            }
          ),
          /***/
          "./node_modules/events/events.js": (
            /*!***************************************!*\
              !*** ./node_modules/events/events.js ***!
              \***************************************/
            /***/
            function(module2) {
              var R2 = typeof Reflect === "object" ? Reflect : null;
              var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
                return Function.prototype.apply.call(target, receiver, args);
              };
              var ReflectOwnKeys;
              if (R2 && typeof R2.ownKeys === "function") {
                ReflectOwnKeys = R2.ownKeys;
              } else if (Object.getOwnPropertySymbols) {
                ReflectOwnKeys = function ReflectOwnKeys2(target) {
                  return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
                };
              } else {
                ReflectOwnKeys = function ReflectOwnKeys2(target) {
                  return Object.getOwnPropertyNames(target);
                };
              }
              function ProcessEmitWarning(warning2) {
                if (console && console.warn)
                  console.warn(warning2);
              }
              var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
                return value !== value;
              };
              function EventEmitter2() {
                EventEmitter2.init.call(this);
              }
              module2.exports = EventEmitter2;
              module2.exports.once = once;
              EventEmitter2.EventEmitter = EventEmitter2;
              EventEmitter2.prototype._events = void 0;
              EventEmitter2.prototype._eventsCount = 0;
              EventEmitter2.prototype._maxListeners = void 0;
              var defaultMaxListeners = 10;
              function checkListener(listener) {
                if (typeof listener !== "function") {
                  throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
                }
              }
              Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
                enumerable: true,
                get: function() {
                  return defaultMaxListeners;
                },
                set: function(arg) {
                  if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
                    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
                  }
                  defaultMaxListeners = arg;
                }
              });
              EventEmitter2.init = function() {
                if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
                  this._events = /* @__PURE__ */ Object.create(null);
                  this._eventsCount = 0;
                }
                this._maxListeners = this._maxListeners || void 0;
              };
              EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n2) {
                if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
                  throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
                }
                this._maxListeners = n2;
                return this;
              };
              function _getMaxListeners(that) {
                if (that._maxListeners === void 0)
                  return EventEmitter2.defaultMaxListeners;
                return that._maxListeners;
              }
              EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
                return _getMaxListeners(this);
              };
              EventEmitter2.prototype.emit = function emit(type2) {
                var args = [];
                for (var i2 = 1; i2 < arguments.length; i2++)
                  args.push(arguments[i2]);
                var doError = type2 === "error";
                var events = this._events;
                if (events !== void 0)
                  doError = doError && events.error === void 0;
                else if (!doError)
                  return false;
                if (doError) {
                  var er;
                  if (args.length > 0)
                    er = args[0];
                  if (er instanceof Error) {
                    throw er;
                  }
                  var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
                  err.context = er;
                  throw err;
                }
                var handler = events[type2];
                if (handler === void 0)
                  return false;
                if (typeof handler === "function") {
                  ReflectApply(handler, this, args);
                } else {
                  var len = handler.length;
                  var listeners = arrayClone(handler, len);
                  for (var i2 = 0; i2 < len; ++i2)
                    ReflectApply(listeners[i2], this, args);
                }
                return true;
              };
              function _addListener(target, type2, listener, prepend) {
                var m2;
                var events;
                var existing;
                checkListener(listener);
                events = target._events;
                if (events === void 0) {
                  events = target._events = /* @__PURE__ */ Object.create(null);
                  target._eventsCount = 0;
                } else {
                  if (events.newListener !== void 0) {
                    target.emit("newListener", type2, listener.listener ? listener.listener : listener);
                    events = target._events;
                  }
                  existing = events[type2];
                }
                if (existing === void 0) {
                  existing = events[type2] = listener;
                  ++target._eventsCount;
                } else {
                  if (typeof existing === "function") {
                    existing = events[type2] = prepend ? [listener, existing] : [existing, listener];
                  } else if (prepend) {
                    existing.unshift(listener);
                  } else {
                    existing.push(listener);
                  }
                  m2 = _getMaxListeners(target);
                  if (m2 > 0 && existing.length > m2 && !existing.warned) {
                    existing.warned = true;
                    var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                    w2.name = "MaxListenersExceededWarning";
                    w2.emitter = target;
                    w2.type = type2;
                    w2.count = existing.length;
                    ProcessEmitWarning(w2);
                  }
                }
                return target;
              }
              EventEmitter2.prototype.addListener = function addListener(type2, listener) {
                return _addListener(this, type2, listener, false);
              };
              EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
              EventEmitter2.prototype.prependListener = function prependListener(type2, listener) {
                return _addListener(this, type2, listener, true);
              };
              function onceWrapper() {
                if (!this.fired) {
                  this.target.removeListener(this.type, this.wrapFn);
                  this.fired = true;
                  if (arguments.length === 0)
                    return this.listener.call(this.target);
                  return this.listener.apply(this.target, arguments);
                }
              }
              function _onceWrap(target, type2, listener) {
                var state = { fired: false, wrapFn: void 0, target, type: type2, listener };
                var wrapped = onceWrapper.bind(state);
                wrapped.listener = listener;
                state.wrapFn = wrapped;
                return wrapped;
              }
              EventEmitter2.prototype.once = function once2(type2, listener) {
                checkListener(listener);
                this.on(type2, _onceWrap(this, type2, listener));
                return this;
              };
              EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
                checkListener(listener);
                this.prependListener(type2, _onceWrap(this, type2, listener));
                return this;
              };
              EventEmitter2.prototype.removeListener = function removeListener(type2, listener) {
                var list, events, position2, i2, originalListener;
                checkListener(listener);
                events = this._events;
                if (events === void 0)
                  return this;
                list = events[type2];
                if (list === void 0)
                  return this;
                if (list === listener || list.listener === listener) {
                  if (--this._eventsCount === 0)
                    this._events = /* @__PURE__ */ Object.create(null);
                  else {
                    delete events[type2];
                    if (events.removeListener)
                      this.emit("removeListener", type2, list.listener || listener);
                  }
                } else if (typeof list !== "function") {
                  position2 = -1;
                  for (i2 = list.length - 1; i2 >= 0; i2--) {
                    if (list[i2] === listener || list[i2].listener === listener) {
                      originalListener = list[i2].listener;
                      position2 = i2;
                      break;
                    }
                  }
                  if (position2 < 0)
                    return this;
                  if (position2 === 0)
                    list.shift();
                  else {
                    spliceOne(list, position2);
                  }
                  if (list.length === 1)
                    events[type2] = list[0];
                  if (events.removeListener !== void 0)
                    this.emit("removeListener", type2, originalListener || listener);
                }
                return this;
              };
              EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
              EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type2) {
                var listeners, events, i2;
                events = this._events;
                if (events === void 0)
                  return this;
                if (events.removeListener === void 0) {
                  if (arguments.length === 0) {
                    this._events = /* @__PURE__ */ Object.create(null);
                    this._eventsCount = 0;
                  } else if (events[type2] !== void 0) {
                    if (--this._eventsCount === 0)
                      this._events = /* @__PURE__ */ Object.create(null);
                    else
                      delete events[type2];
                  }
                  return this;
                }
                if (arguments.length === 0) {
                  var keys2 = Object.keys(events);
                  var key;
                  for (i2 = 0; i2 < keys2.length; ++i2) {
                    key = keys2[i2];
                    if (key === "removeListener")
                      continue;
                    this.removeAllListeners(key);
                  }
                  this.removeAllListeners("removeListener");
                  this._events = /* @__PURE__ */ Object.create(null);
                  this._eventsCount = 0;
                  return this;
                }
                listeners = events[type2];
                if (typeof listeners === "function") {
                  this.removeListener(type2, listeners);
                } else if (listeners !== void 0) {
                  for (i2 = listeners.length - 1; i2 >= 0; i2--) {
                    this.removeListener(type2, listeners[i2]);
                  }
                }
                return this;
              };
              function _listeners(target, type2, unwrap) {
                var events = target._events;
                if (events === void 0)
                  return [];
                var evlistener = events[type2];
                if (evlistener === void 0)
                  return [];
                if (typeof evlistener === "function")
                  return unwrap ? [evlistener.listener || evlistener] : [evlistener];
                return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
              }
              EventEmitter2.prototype.listeners = function listeners(type2) {
                return _listeners(this, type2, true);
              };
              EventEmitter2.prototype.rawListeners = function rawListeners(type2) {
                return _listeners(this, type2, false);
              };
              EventEmitter2.listenerCount = function(emitter, type2) {
                if (typeof emitter.listenerCount === "function") {
                  return emitter.listenerCount(type2);
                } else {
                  return listenerCount.call(emitter, type2);
                }
              };
              EventEmitter2.prototype.listenerCount = listenerCount;
              function listenerCount(type2) {
                var events = this._events;
                if (events !== void 0) {
                  var evlistener = events[type2];
                  if (typeof evlistener === "function") {
                    return 1;
                  } else if (evlistener !== void 0) {
                    return evlistener.length;
                  }
                }
                return 0;
              }
              EventEmitter2.prototype.eventNames = function eventNames() {
                return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
              };
              function arrayClone(arr, n2) {
                var copy2 = new Array(n2);
                for (var i2 = 0; i2 < n2; ++i2)
                  copy2[i2] = arr[i2];
                return copy2;
              }
              function spliceOne(list, index2) {
                for (; index2 + 1 < list.length; index2++)
                  list[index2] = list[index2 + 1];
                list.pop();
              }
              function unwrapListeners(arr) {
                var ret = new Array(arr.length);
                for (var i2 = 0; i2 < ret.length; ++i2) {
                  ret[i2] = arr[i2].listener || arr[i2];
                }
                return ret;
              }
              function once(emitter, name) {
                return new Promise(function(resolve2, reject2) {
                  function errorListener(err) {
                    emitter.removeListener(name, resolver2);
                    reject2(err);
                  }
                  function resolver2() {
                    if (typeof emitter.removeListener === "function") {
                      emitter.removeListener("error", errorListener);
                    }
                    resolve2([].slice.call(arguments));
                  }
                  eventTargetAgnosticAddListener(emitter, name, resolver2, { once: true });
                  if (name !== "error") {
                    addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
                  }
                });
              }
              function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
                if (typeof emitter.on === "function") {
                  eventTargetAgnosticAddListener(emitter, "error", handler, flags);
                }
              }
              function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
                if (typeof emitter.on === "function") {
                  if (flags.once) {
                    emitter.once(name, listener);
                  } else {
                    emitter.on(name, listener);
                  }
                } else if (typeof emitter.addEventListener === "function") {
                  emitter.addEventListener(name, function wrapListener(arg) {
                    if (flags.once) {
                      emitter.removeEventListener(name, wrapListener);
                    }
                    listener(arg);
                  });
                } else {
                  throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
                }
              }
            }
          ),
          /***/
          "./node_modules/webworkify-webpack/index.js": (
            /*!**************************************************!*\
              !*** ./node_modules/webworkify-webpack/index.js ***!
              \**************************************************/
            /***/
            function(module2, __unused_webpack_exports, __webpack_require__2) {
              function webpackBootstrapFunc(modules) {
                var installedModules = {};
                function __nested_webpack_require_164__(moduleId) {
                  if (installedModules[moduleId])
                    return installedModules[moduleId].exports;
                  var module3 = installedModules[moduleId] = {
                    /******/
                    i: moduleId,
                    /******/
                    l: false,
                    /******/
                    exports: {}
                    /******/
                  };
                  modules[moduleId].call(module3.exports, module3, module3.exports, __nested_webpack_require_164__);
                  module3.l = true;
                  return module3.exports;
                }
                __nested_webpack_require_164__.m = modules;
                __nested_webpack_require_164__.c = installedModules;
                __nested_webpack_require_164__.i = function(value) {
                  return value;
                };
                __nested_webpack_require_164__.d = function(exports2, name, getter) {
                  if (!__nested_webpack_require_164__.o(exports2, name)) {
                    Object.defineProperty(exports2, name, {
                      /******/
                      configurable: false,
                      /******/
                      enumerable: true,
                      /******/
                      get: getter
                      /******/
                    });
                  }
                };
                __nested_webpack_require_164__.r = function(exports2) {
                  Object.defineProperty(exports2, "__esModule", { value: true });
                };
                __nested_webpack_require_164__.n = function(module3) {
                  var getter = module3 && module3.__esModule ? (
                    /******/
                    function getDefault() {
                      return module3["default"];
                    }
                  ) : (
                    /******/
                    function getModuleExports() {
                      return module3;
                    }
                  );
                  __nested_webpack_require_164__.d(getter, "a", getter);
                  return getter;
                };
                __nested_webpack_require_164__.o = function(object, property2) {
                  return Object.prototype.hasOwnProperty.call(object, property2);
                };
                __nested_webpack_require_164__.p = "/";
                __nested_webpack_require_164__.oe = function(err) {
                  console.error(err);
                  throw err;
                };
                var f2 = __nested_webpack_require_164__(__nested_webpack_require_164__.s = ENTRY_MODULE);
                return f2.default || f2;
              }
              var moduleNameReqExp = "[\\.|\\-|\\+|\\w|/|@]+";
              var dependencyRegExp = "\\(\\s*(/\\*.*?\\*/)?\\s*.*?(" + moduleNameReqExp + ").*?\\)";
              function quoteRegExp(str) {
                return (str + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
              }
              function isNumeric(n2) {
                return !isNaN(1 * n2);
              }
              function getModuleDependencies(sources, module3, queueName) {
                var retval = {};
                retval[queueName] = [];
                var fnString = module3.toString();
                var wrapperSignature = fnString.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/);
                if (!wrapperSignature)
                  return retval;
                var webpackRequireName = wrapperSignature[1];
                var re2 = new RegExp("(\\\\n|\\W)" + quoteRegExp(webpackRequireName) + dependencyRegExp, "g");
                var match2;
                while (match2 = re2.exec(fnString)) {
                  if (match2[3] === "dll-reference")
                    continue;
                  retval[queueName].push(match2[3]);
                }
                re2 = new RegExp("\\(" + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, "g");
                while (match2 = re2.exec(fnString)) {
                  if (!sources[match2[2]]) {
                    retval[queueName].push(match2[1]);
                    sources[match2[2]] = __webpack_require__2(match2[1]).m;
                  }
                  retval[match2[2]] = retval[match2[2]] || [];
                  retval[match2[2]].push(match2[4]);
                }
                var keys2 = Object.keys(retval);
                for (var i2 = 0; i2 < keys2.length; i2++) {
                  for (var j2 = 0; j2 < retval[keys2[i2]].length; j2++) {
                    if (isNumeric(retval[keys2[i2]][j2])) {
                      retval[keys2[i2]][j2] = 1 * retval[keys2[i2]][j2];
                    }
                  }
                }
                return retval;
              }
              function hasValuesInQueues(queues) {
                var keys2 = Object.keys(queues);
                return keys2.reduce(function(hasValues, key) {
                  return hasValues || queues[key].length > 0;
                }, false);
              }
              function getRequiredModules(sources, moduleId) {
                var modulesQueue = {
                  main: [moduleId]
                };
                var requiredModules = {
                  main: []
                };
                var seenModules = {
                  main: {}
                };
                while (hasValuesInQueues(modulesQueue)) {
                  var queues = Object.keys(modulesQueue);
                  for (var i2 = 0; i2 < queues.length; i2++) {
                    var queueName = queues[i2];
                    var queue = modulesQueue[queueName];
                    var moduleToCheck = queue.pop();
                    seenModules[queueName] = seenModules[queueName] || {};
                    if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck])
                      continue;
                    seenModules[queueName][moduleToCheck] = true;
                    requiredModules[queueName] = requiredModules[queueName] || [];
                    requiredModules[queueName].push(moduleToCheck);
                    var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName);
                    var newModulesKeys = Object.keys(newModules);
                    for (var j2 = 0; j2 < newModulesKeys.length; j2++) {
                      modulesQueue[newModulesKeys[j2]] = modulesQueue[newModulesKeys[j2]] || [];
                      modulesQueue[newModulesKeys[j2]] = modulesQueue[newModulesKeys[j2]].concat(newModules[newModulesKeys[j2]]);
                    }
                  }
                }
                return requiredModules;
              }
              module2.exports = function(moduleId, options) {
                options = options || {};
                var sources = {
                  main: __webpack_require__2.m
                };
                var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId);
                var src = "";
                Object.keys(requiredModules).filter(function(m2) {
                  return m2 !== "main";
                }).forEach(function(module3) {
                  var entryModule = 0;
                  while (requiredModules[module3][entryModule]) {
                    entryModule++;
                  }
                  requiredModules[module3].push(entryModule);
                  sources[module3][entryModule] = "(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })";
                  src = src + "var " + module3 + " = (" + webpackBootstrapFunc.toString().replace("ENTRY_MODULE", JSON.stringify(entryModule)) + ")({" + requiredModules[module3].map(function(id2) {
                    return "" + JSON.stringify(id2) + ": " + sources[module3][id2].toString();
                  }).join(",") + "});\n";
                });
                src = src + "new ((" + webpackBootstrapFunc.toString().replace("ENTRY_MODULE", JSON.stringify(moduleId)) + ")({" + requiredModules.main.map(function(id2) {
                  return "" + JSON.stringify(id2) + ": " + sources.main[id2].toString();
                }).join(",") + "}))(self);";
                var blob = new window.Blob([src], { type: "text/javascript" });
                if (options.bare) {
                  return blob;
                }
                var URL2 = window.URL || window.webkitURL || window.mozURL || window.msURL;
                var workerUrl = URL2.createObjectURL(blob);
                var worker = new window.Worker(workerUrl);
                worker.objectURL = workerUrl;
                return worker;
              };
            }
          ),
          /***/
          "./src/config.js": (
            /*!***********************!*\
              !*** ./src/config.js ***!
              \***********************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "defaultConfig": function() {
                  return (
                    /* binding */
                    defaultConfig
                  );
                },
                /* harmony export */
                "createDefaultConfig": function() {
                  return (
                    /* binding */
                    createDefaultConfig
                  );
                }
                /* harmony export */
              });
              var defaultConfig = {
                enableWorker: false,
                enableStashBuffer: true,
                stashInitialSize: void 0,
                isLive: false,
                lazyLoad: true,
                lazyLoadMaxDuration: 3 * 60,
                lazyLoadRecoverDuration: 30,
                deferLoadAfterSourceOpen: true,
                // autoCleanupSourceBuffer: default as false, leave unspecified
                autoCleanupMaxBackwardDuration: 3 * 60,
                autoCleanupMinBackwardDuration: 2 * 60,
                statisticsInfoReportInterval: 600,
                fixAudioTimestampGap: true,
                accurateSeek: false,
                seekType: "range",
                seekParamStart: "bstart",
                seekParamEnd: "bend",
                rangeLoadZeroStart: false,
                customSeekHandler: void 0,
                reuseRedirectedURL: false,
                // referrerPolicy: leave as unspecified
                headers: void 0,
                customLoader: void 0
              };
              function createDefaultConfig() {
                return Object.assign({}, defaultConfig);
              }
            }
          ),
          /***/
          "./src/core/features.js": (
            /*!******************************!*\
              !*** ./src/core/features.js ***!
              \******************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var _io_io_controller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../io/io-controller.js */
                "./src/io/io-controller.js"
              );
              var _config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ../config.js */
                "./src/config.js"
              );
              var Features = (
                /** @class */
                function() {
                  function Features2() {
                  }
                  Features2.supportMSEH264Playback = function() {
                    return window.MediaSource && window.MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
                  };
                  Features2.supportNetworkStreamIO = function() {
                    var ioctl = new _io_io_controller_js__WEBPACK_IMPORTED_MODULE_0__.default({}, (0, _config_js__WEBPACK_IMPORTED_MODULE_1__.createDefaultConfig)());
                    var loaderType = ioctl.loaderType;
                    ioctl.destroy();
                    return loaderType == "fetch-stream-loader" || loaderType == "xhr-moz-chunked-loader";
                  };
                  Features2.getNetworkLoaderTypeName = function() {
                    var ioctl = new _io_io_controller_js__WEBPACK_IMPORTED_MODULE_0__.default({}, (0, _config_js__WEBPACK_IMPORTED_MODULE_1__.createDefaultConfig)());
                    var loaderType = ioctl.loaderType;
                    ioctl.destroy();
                    return loaderType;
                  };
                  Features2.supportNativeMediaPlayback = function(mimeType) {
                    if (Features2.videoElement == void 0) {
                      Features2.videoElement = window.document.createElement("video");
                    }
                    var canPlay = Features2.videoElement.canPlayType(mimeType);
                    return canPlay === "probably" || canPlay == "maybe";
                  };
                  Features2.getFeatureList = function() {
                    var features = {
                      mseFlvPlayback: false,
                      mseLiveFlvPlayback: false,
                      networkStreamIO: false,
                      networkLoaderName: "",
                      nativeMP4H264Playback: false,
                      nativeWebmVP8Playback: false,
                      nativeWebmVP9Playback: false
                    };
                    features.mseFlvPlayback = Features2.supportMSEH264Playback();
                    features.networkStreamIO = Features2.supportNetworkStreamIO();
                    features.networkLoaderName = Features2.getNetworkLoaderTypeName();
                    features.mseLiveFlvPlayback = features.mseFlvPlayback && features.networkStreamIO;
                    features.nativeMP4H264Playback = Features2.supportNativeMediaPlayback('video/mp4; codecs="avc1.42001E, mp4a.40.2"');
                    features.nativeWebmVP8Playback = Features2.supportNativeMediaPlayback('video/webm; codecs="vp8.0, vorbis"');
                    features.nativeWebmVP9Playback = Features2.supportNativeMediaPlayback('video/webm; codecs="vp9"');
                    return features;
                  };
                  return Features2;
                }()
              );
              __webpack_exports__2["default"] = Features;
            }
          ),
          /***/
          "./src/core/media-info.js": (
            /*!********************************!*\
              !*** ./src/core/media-info.js ***!
              \********************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var MediaInfo = (
                /** @class */
                function() {
                  function MediaInfo2() {
                    this.mimeType = null;
                    this.duration = null;
                    this.hasAudio = null;
                    this.hasVideo = null;
                    this.audioCodec = null;
                    this.videoCodec = null;
                    this.audioDataRate = null;
                    this.videoDataRate = null;
                    this.audioSampleRate = null;
                    this.audioChannelCount = null;
                    this.width = null;
                    this.height = null;
                    this.fps = null;
                    this.profile = null;
                    this.level = null;
                    this.refFrames = null;
                    this.chromaFormat = null;
                    this.sarNum = null;
                    this.sarDen = null;
                    this.metadata = null;
                    this.segments = null;
                    this.segmentCount = null;
                    this.hasKeyframesIndex = null;
                    this.keyframesIndex = null;
                  }
                  MediaInfo2.prototype.isComplete = function() {
                    var audioInfoComplete = this.hasAudio === false || this.hasAudio === true && this.audioCodec != null && this.audioSampleRate != null && this.audioChannelCount != null;
                    var videoInfoComplete = this.hasVideo === false || this.hasVideo === true && this.videoCodec != null && this.width != null && this.height != null && this.fps != null && this.profile != null && this.level != null && this.refFrames != null && this.chromaFormat != null && this.sarNum != null && this.sarDen != null;
                    return this.mimeType != null && this.duration != null && this.metadata != null && this.hasKeyframesIndex != null && audioInfoComplete && videoInfoComplete;
                  };
                  MediaInfo2.prototype.isSeekable = function() {
                    return this.hasKeyframesIndex === true;
                  };
                  MediaInfo2.prototype.getNearestKeyframe = function(milliseconds) {
                    if (this.keyframesIndex == null) {
                      return null;
                    }
                    var table = this.keyframesIndex;
                    var keyframeIdx = this._search(table.times, milliseconds);
                    return {
                      index: keyframeIdx,
                      milliseconds: table.times[keyframeIdx],
                      fileposition: table.filepositions[keyframeIdx]
                    };
                  };
                  MediaInfo2.prototype._search = function(list, value) {
                    var idx = 0;
                    var last = list.length - 1;
                    var mid = 0;
                    var lbound = 0;
                    var ubound = last;
                    if (value < list[0]) {
                      idx = 0;
                      lbound = ubound + 1;
                    }
                    while (lbound <= ubound) {
                      mid = lbound + Math.floor((ubound - lbound) / 2);
                      if (mid === last || value >= list[mid] && value < list[mid + 1]) {
                        idx = mid;
                        break;
                      } else if (list[mid] < value) {
                        lbound = mid + 1;
                      } else {
                        ubound = mid - 1;
                      }
                    }
                    return idx;
                  };
                  return MediaInfo2;
                }()
              );
              __webpack_exports__2["default"] = MediaInfo;
            }
          ),
          /***/
          "./src/core/media-segment-info.js": (
            /*!****************************************!*\
              !*** ./src/core/media-segment-info.js ***!
              \****************************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "SampleInfo": function() {
                  return (
                    /* binding */
                    SampleInfo
                  );
                },
                /* harmony export */
                "MediaSegmentInfo": function() {
                  return (
                    /* binding */
                    MediaSegmentInfo
                  );
                },
                /* harmony export */
                "IDRSampleList": function() {
                  return (
                    /* binding */
                    IDRSampleList
                  );
                },
                /* harmony export */
                "MediaSegmentInfoList": function() {
                  return (
                    /* binding */
                    MediaSegmentInfoList
                  );
                }
                /* harmony export */
              });
              var SampleInfo = (
                /** @class */
                function() {
                  function SampleInfo2(dts, pts, duration, originalDts, isSync) {
                    this.dts = dts;
                    this.pts = pts;
                    this.duration = duration;
                    this.originalDts = originalDts;
                    this.isSyncPoint = isSync;
                    this.fileposition = null;
                  }
                  return SampleInfo2;
                }()
              );
              var MediaSegmentInfo = (
                /** @class */
                function() {
                  function MediaSegmentInfo2() {
                    this.beginDts = 0;
                    this.endDts = 0;
                    this.beginPts = 0;
                    this.endPts = 0;
                    this.originalBeginDts = 0;
                    this.originalEndDts = 0;
                    this.syncPoints = [];
                    this.firstSample = null;
                    this.lastSample = null;
                  }
                  MediaSegmentInfo2.prototype.appendSyncPoint = function(sampleInfo) {
                    sampleInfo.isSyncPoint = true;
                    this.syncPoints.push(sampleInfo);
                  };
                  return MediaSegmentInfo2;
                }()
              );
              var IDRSampleList = (
                /** @class */
                function() {
                  function IDRSampleList2() {
                    this._list = [];
                  }
                  IDRSampleList2.prototype.clear = function() {
                    this._list = [];
                  };
                  IDRSampleList2.prototype.appendArray = function(syncPoints) {
                    var list = this._list;
                    if (syncPoints.length === 0) {
                      return;
                    }
                    if (list.length > 0 && syncPoints[0].originalDts < list[list.length - 1].originalDts) {
                      this.clear();
                    }
                    Array.prototype.push.apply(list, syncPoints);
                  };
                  IDRSampleList2.prototype.getLastSyncPointBeforeDts = function(dts) {
                    if (this._list.length == 0) {
                      return null;
                    }
                    var list = this._list;
                    var idx = 0;
                    var last = list.length - 1;
                    var mid = 0;
                    var lbound = 0;
                    var ubound = last;
                    if (dts < list[0].dts) {
                      idx = 0;
                      lbound = ubound + 1;
                    }
                    while (lbound <= ubound) {
                      mid = lbound + Math.floor((ubound - lbound) / 2);
                      if (mid === last || dts >= list[mid].dts && dts < list[mid + 1].dts) {
                        idx = mid;
                        break;
                      } else if (list[mid].dts < dts) {
                        lbound = mid + 1;
                      } else {
                        ubound = mid - 1;
                      }
                    }
                    return this._list[idx];
                  };
                  return IDRSampleList2;
                }()
              );
              var MediaSegmentInfoList = (
                /** @class */
                function() {
                  function MediaSegmentInfoList2(type2) {
                    this._type = type2;
                    this._list = [];
                    this._lastAppendLocation = -1;
                  }
                  Object.defineProperty(MediaSegmentInfoList2.prototype, "type", {
                    get: function() {
                      return this._type;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(MediaSegmentInfoList2.prototype, "length", {
                    get: function() {
                      return this._list.length;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  MediaSegmentInfoList2.prototype.isEmpty = function() {
                    return this._list.length === 0;
                  };
                  MediaSegmentInfoList2.prototype.clear = function() {
                    this._list = [];
                    this._lastAppendLocation = -1;
                  };
                  MediaSegmentInfoList2.prototype._searchNearestSegmentBefore = function(originalBeginDts) {
                    var list = this._list;
                    if (list.length === 0) {
                      return -2;
                    }
                    var last = list.length - 1;
                    var mid = 0;
                    var lbound = 0;
                    var ubound = last;
                    var idx = 0;
                    if (originalBeginDts < list[0].originalBeginDts) {
                      idx = -1;
                      return idx;
                    }
                    while (lbound <= ubound) {
                      mid = lbound + Math.floor((ubound - lbound) / 2);
                      if (mid === last || originalBeginDts > list[mid].lastSample.originalDts && originalBeginDts < list[mid + 1].originalBeginDts) {
                        idx = mid;
                        break;
                      } else if (list[mid].originalBeginDts < originalBeginDts) {
                        lbound = mid + 1;
                      } else {
                        ubound = mid - 1;
                      }
                    }
                    return idx;
                  };
                  MediaSegmentInfoList2.prototype._searchNearestSegmentAfter = function(originalBeginDts) {
                    return this._searchNearestSegmentBefore(originalBeginDts) + 1;
                  };
                  MediaSegmentInfoList2.prototype.append = function(mediaSegmentInfo) {
                    var list = this._list;
                    var msi = mediaSegmentInfo;
                    var lastAppendIdx = this._lastAppendLocation;
                    var insertIdx = 0;
                    if (lastAppendIdx !== -1 && lastAppendIdx < list.length && msi.originalBeginDts >= list[lastAppendIdx].lastSample.originalDts && (lastAppendIdx === list.length - 1 || lastAppendIdx < list.length - 1 && msi.originalBeginDts < list[lastAppendIdx + 1].originalBeginDts)) {
                      insertIdx = lastAppendIdx + 1;
                    } else {
                      if (list.length > 0) {
                        insertIdx = this._searchNearestSegmentBefore(msi.originalBeginDts) + 1;
                      }
                    }
                    this._lastAppendLocation = insertIdx;
                    this._list.splice(insertIdx, 0, msi);
                  };
                  MediaSegmentInfoList2.prototype.getLastSegmentBefore = function(originalBeginDts) {
                    var idx = this._searchNearestSegmentBefore(originalBeginDts);
                    if (idx >= 0) {
                      return this._list[idx];
                    } else {
                      return null;
                    }
                  };
                  MediaSegmentInfoList2.prototype.getLastSampleBefore = function(originalBeginDts) {
                    var segment = this.getLastSegmentBefore(originalBeginDts);
                    if (segment != null) {
                      return segment.lastSample;
                    } else {
                      return null;
                    }
                  };
                  MediaSegmentInfoList2.prototype.getLastSyncPointBefore = function(originalBeginDts) {
                    var segmentIdx = this._searchNearestSegmentBefore(originalBeginDts);
                    var syncPoints = this._list[segmentIdx].syncPoints;
                    while (syncPoints.length === 0 && segmentIdx > 0) {
                      segmentIdx--;
                      syncPoints = this._list[segmentIdx].syncPoints;
                    }
                    if (syncPoints.length > 0) {
                      return syncPoints[syncPoints.length - 1];
                    } else {
                      return null;
                    }
                  };
                  return MediaSegmentInfoList2;
                }()
              );
            }
          ),
          /***/
          "./src/core/mse-controller.js": (
            /*!************************************!*\
              !*** ./src/core/mse-controller.js ***!
              \************************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! events */
                "./node_modules/events/events.js"
              );
              var events__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(events__WEBPACK_IMPORTED_MODULE_0__);
              var _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ../utils/logger.js */
                "./src/utils/logger.js"
              );
              var _utils_browser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ../utils/browser.js */
                "./src/utils/browser.js"
              );
              var _mse_events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./mse-events.js */
                "./src/core/mse-events.js"
              );
              var _media_segment_info_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./media-segment-info.js */
                "./src/core/media-segment-info.js"
              );
              var _utils_exception_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              );
              var MSEController = (
                /** @class */
                function() {
                  function MSEController2(config) {
                    this.TAG = "MSEController";
                    this._config = config;
                    this._emitter = new (events__WEBPACK_IMPORTED_MODULE_0___default())();
                    if (this._config.isLive && this._config.autoCleanupSourceBuffer == void 0) {
                      this._config.autoCleanupSourceBuffer = true;
                    }
                    this.e = {
                      onSourceOpen: this._onSourceOpen.bind(this),
                      onSourceEnded: this._onSourceEnded.bind(this),
                      onSourceClose: this._onSourceClose.bind(this),
                      onSourceBufferError: this._onSourceBufferError.bind(this),
                      onSourceBufferUpdateEnd: this._onSourceBufferUpdateEnd.bind(this)
                    };
                    this._mediaSource = null;
                    this._mediaSourceObjectURL = null;
                    this._mediaElement = null;
                    this._isBufferFull = false;
                    this._hasPendingEos = false;
                    this._requireSetMediaDuration = false;
                    this._pendingMediaDuration = 0;
                    this._pendingSourceBufferInit = [];
                    this._mimeTypes = {
                      video: null,
                      audio: null
                    };
                    this._sourceBuffers = {
                      video: null,
                      audio: null
                    };
                    this._lastInitSegments = {
                      video: null,
                      audio: null
                    };
                    this._pendingSegments = {
                      video: [],
                      audio: []
                    };
                    this._pendingRemoveRanges = {
                      video: [],
                      audio: []
                    };
                    this._idrList = new _media_segment_info_js__WEBPACK_IMPORTED_MODULE_4__.IDRSampleList();
                  }
                  MSEController2.prototype.destroy = function() {
                    if (this._mediaElement || this._mediaSource) {
                      this.detachMediaElement();
                    }
                    this.e = null;
                    this._emitter.removeAllListeners();
                    this._emitter = null;
                  };
                  MSEController2.prototype.on = function(event, listener) {
                    this._emitter.addListener(event, listener);
                  };
                  MSEController2.prototype.off = function(event, listener) {
                    this._emitter.removeListener(event, listener);
                  };
                  MSEController2.prototype.attachMediaElement = function(mediaElement) {
                    if (this._mediaSource) {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_5__.IllegalStateException("MediaSource has been attached to an HTMLMediaElement!");
                    }
                    var ms = this._mediaSource = new window.MediaSource();
                    ms.addEventListener("sourceopen", this.e.onSourceOpen);
                    ms.addEventListener("sourceended", this.e.onSourceEnded);
                    ms.addEventListener("sourceclose", this.e.onSourceClose);
                    this._mediaElement = mediaElement;
                    this._mediaSourceObjectURL = window.URL.createObjectURL(this._mediaSource);
                    mediaElement.src = this._mediaSourceObjectURL;
                  };
                  MSEController2.prototype.detachMediaElement = function() {
                    if (this._mediaSource) {
                      var ms = this._mediaSource;
                      for (var type2 in this._sourceBuffers) {
                        var ps = this._pendingSegments[type2];
                        ps.splice(0, ps.length);
                        this._pendingSegments[type2] = null;
                        this._pendingRemoveRanges[type2] = null;
                        this._lastInitSegments[type2] = null;
                        var sb2 = this._sourceBuffers[type2];
                        if (sb2) {
                          if (ms.readyState !== "closed") {
                            try {
                              ms.removeSourceBuffer(sb2);
                            } catch (error2) {
                              _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.e(this.TAG, error2.message);
                            }
                            sb2.removeEventListener("error", this.e.onSourceBufferError);
                            sb2.removeEventListener("updateend", this.e.onSourceBufferUpdateEnd);
                          }
                          this._mimeTypes[type2] = null;
                          this._sourceBuffers[type2] = null;
                        }
                      }
                      if (ms.readyState === "open") {
                        try {
                          ms.endOfStream();
                        } catch (error2) {
                          _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.e(this.TAG, error2.message);
                        }
                      }
                      ms.removeEventListener("sourceopen", this.e.onSourceOpen);
                      ms.removeEventListener("sourceended", this.e.onSourceEnded);
                      ms.removeEventListener("sourceclose", this.e.onSourceClose);
                      this._pendingSourceBufferInit = [];
                      this._isBufferFull = false;
                      this._idrList.clear();
                      this._mediaSource = null;
                    }
                    if (this._mediaElement) {
                      this._mediaElement.src = "";
                      this._mediaElement.removeAttribute("src");
                      this._mediaElement = null;
                    }
                    if (this._mediaSourceObjectURL) {
                      window.URL.revokeObjectURL(this._mediaSourceObjectURL);
                      this._mediaSourceObjectURL = null;
                    }
                  };
                  MSEController2.prototype.appendInitSegment = function(initSegment, deferred) {
                    if (!this._mediaSource || this._mediaSource.readyState !== "open") {
                      this._pendingSourceBufferInit.push(initSegment);
                      this._pendingSegments[initSegment.type].push(initSegment);
                      return;
                    }
                    var is = initSegment;
                    var mimeType = "" + is.container;
                    if (is.codec && is.codec.length > 0) {
                      mimeType += ";codecs=" + is.codec;
                    }
                    var firstInitSegment = false;
                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.v(this.TAG, "Received Initialization Segment, mimeType: " + mimeType);
                    this._lastInitSegments[is.type] = is;
                    if (mimeType !== this._mimeTypes[is.type]) {
                      if (!this._mimeTypes[is.type]) {
                        firstInitSegment = true;
                        try {
                          var sb2 = this._sourceBuffers[is.type] = this._mediaSource.addSourceBuffer(mimeType);
                          sb2.addEventListener("error", this.e.onSourceBufferError);
                          sb2.addEventListener("updateend", this.e.onSourceBufferUpdateEnd);
                        } catch (error2) {
                          _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.e(this.TAG, error2.message);
                          this._emitter.emit(_mse_events_js__WEBPACK_IMPORTED_MODULE_3__.default.ERROR, { code: error2.code, msg: error2.message });
                          return;
                        }
                      } else {
                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.v(this.TAG, "Notice: " + is.type + " mimeType changed, origin: " + this._mimeTypes[is.type] + ", target: " + mimeType);
                      }
                      this._mimeTypes[is.type] = mimeType;
                    }
                    if (!deferred) {
                      this._pendingSegments[is.type].push(is);
                    }
                    if (!firstInitSegment) {
                      if (this._sourceBuffers[is.type] && !this._sourceBuffers[is.type].updating) {
                        this._doAppendSegments();
                      }
                    }
                    if (_utils_browser_js__WEBPACK_IMPORTED_MODULE_2__.default.safari && is.container === "audio/mpeg" && is.mediaDuration > 0) {
                      this._requireSetMediaDuration = true;
                      this._pendingMediaDuration = is.mediaDuration / 1e3;
                      this._updateMediaSourceDuration();
                    }
                  };
                  MSEController2.prototype.appendMediaSegment = function(mediaSegment) {
                    var ms = mediaSegment;
                    this._pendingSegments[ms.type].push(ms);
                    if (this._config.autoCleanupSourceBuffer && this._needCleanupSourceBuffer()) {
                      this._doCleanupSourceBuffer();
                    }
                    var sb2 = this._sourceBuffers[ms.type];
                    if (sb2 && !sb2.updating && !this._hasPendingRemoveRanges()) {
                      this._doAppendSegments();
                    }
                  };
                  MSEController2.prototype.seek = function(seconds) {
                    for (var type2 in this._sourceBuffers) {
                      if (!this._sourceBuffers[type2]) {
                        continue;
                      }
                      var sb2 = this._sourceBuffers[type2];
                      if (this._mediaSource.readyState === "open") {
                        try {
                          sb2.abort();
                        } catch (error2) {
                          _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.e(this.TAG, error2.message);
                        }
                      }
                      this._idrList.clear();
                      var ps = this._pendingSegments[type2];
                      ps.splice(0, ps.length);
                      if (this._mediaSource.readyState === "closed") {
                        continue;
                      }
                      for (var i2 = 0; i2 < sb2.buffered.length; i2++) {
                        var start = sb2.buffered.start(i2);
                        var end2 = sb2.buffered.end(i2);
                        this._pendingRemoveRanges[type2].push({ start, end: end2 });
                      }
                      if (!sb2.updating) {
                        this._doRemoveRanges();
                      }
                      if (_utils_browser_js__WEBPACK_IMPORTED_MODULE_2__.default.safari) {
                        var lastInitSegment = this._lastInitSegments[type2];
                        if (lastInitSegment) {
                          this._pendingSegments[type2].push(lastInitSegment);
                          if (!sb2.updating) {
                            this._doAppendSegments();
                          }
                        }
                      }
                    }
                  };
                  MSEController2.prototype.endOfStream = function() {
                    var ms = this._mediaSource;
                    var sb2 = this._sourceBuffers;
                    if (!ms || ms.readyState !== "open") {
                      if (ms && ms.readyState === "closed" && this._hasPendingSegments()) {
                        this._hasPendingEos = true;
                      }
                      return;
                    }
                    if (sb2.video && sb2.video.updating || sb2.audio && sb2.audio.updating) {
                      this._hasPendingEos = true;
                    } else {
                      this._hasPendingEos = false;
                      ms.endOfStream();
                    }
                  };
                  MSEController2.prototype.getNearestKeyframe = function(dts) {
                    return this._idrList.getLastSyncPointBeforeDts(dts);
                  };
                  MSEController2.prototype._needCleanupSourceBuffer = function() {
                    if (!this._config.autoCleanupSourceBuffer) {
                      return false;
                    }
                    var currentTime = this._mediaElement.currentTime;
                    for (var type2 in this._sourceBuffers) {
                      var sb2 = this._sourceBuffers[type2];
                      if (sb2) {
                        var buffered = sb2.buffered;
                        if (buffered.length >= 1) {
                          if (currentTime - buffered.start(0) >= this._config.autoCleanupMaxBackwardDuration) {
                            return true;
                          }
                        }
                      }
                    }
                    return false;
                  };
                  MSEController2.prototype._doCleanupSourceBuffer = function() {
                    var currentTime = this._mediaElement.currentTime;
                    for (var type2 in this._sourceBuffers) {
                      var sb2 = this._sourceBuffers[type2];
                      if (sb2) {
                        var buffered = sb2.buffered;
                        var doRemove = false;
                        for (var i2 = 0; i2 < buffered.length; i2++) {
                          var start = buffered.start(i2);
                          var end2 = buffered.end(i2);
                          if (start <= currentTime && currentTime < end2 + 3) {
                            if (currentTime - start >= this._config.autoCleanupMaxBackwardDuration) {
                              doRemove = true;
                              var removeEnd = currentTime - this._config.autoCleanupMinBackwardDuration;
                              this._pendingRemoveRanges[type2].push({ start, end: removeEnd });
                            }
                          } else if (end2 < currentTime) {
                            doRemove = true;
                            this._pendingRemoveRanges[type2].push({ start, end: end2 });
                          }
                        }
                        if (doRemove && !sb2.updating) {
                          this._doRemoveRanges();
                        }
                      }
                    }
                  };
                  MSEController2.prototype._updateMediaSourceDuration = function() {
                    var sb2 = this._sourceBuffers;
                    if (this._mediaElement.readyState === 0 || this._mediaSource.readyState !== "open") {
                      return;
                    }
                    if (sb2.video && sb2.video.updating || sb2.audio && sb2.audio.updating) {
                      return;
                    }
                    var current = this._mediaSource.duration;
                    var target = this._pendingMediaDuration;
                    if (target > 0 && (isNaN(current) || target > current)) {
                      _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.v(this.TAG, "Update MediaSource duration from " + current + " to " + target);
                      this._mediaSource.duration = target;
                    }
                    this._requireSetMediaDuration = false;
                    this._pendingMediaDuration = 0;
                  };
                  MSEController2.prototype._doRemoveRanges = function() {
                    for (var type2 in this._pendingRemoveRanges) {
                      if (!this._sourceBuffers[type2] || this._sourceBuffers[type2].updating) {
                        continue;
                      }
                      var sb2 = this._sourceBuffers[type2];
                      var ranges = this._pendingRemoveRanges[type2];
                      while (ranges.length && !sb2.updating) {
                        var range2 = ranges.shift();
                        sb2.remove(range2.start, range2.end);
                      }
                    }
                  };
                  MSEController2.prototype._doAppendSegments = function() {
                    var pendingSegments = this._pendingSegments;
                    for (var type2 in pendingSegments) {
                      if (!this._sourceBuffers[type2] || this._sourceBuffers[type2].updating) {
                        continue;
                      }
                      if (pendingSegments[type2].length > 0) {
                        var segment = pendingSegments[type2].shift();
                        if (segment.timestampOffset) {
                          var currentOffset = this._sourceBuffers[type2].timestampOffset;
                          var targetOffset = segment.timestampOffset / 1e3;
                          var delta = Math.abs(currentOffset - targetOffset);
                          if (delta > 0.1) {
                            _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.v(this.TAG, "Update MPEG audio timestampOffset from " + currentOffset + " to " + targetOffset);
                            this._sourceBuffers[type2].timestampOffset = targetOffset;
                          }
                          delete segment.timestampOffset;
                        }
                        if (!segment.data || segment.data.byteLength === 0) {
                          continue;
                        }
                        try {
                          this._sourceBuffers[type2].appendBuffer(segment.data);
                          this._isBufferFull = false;
                          if (type2 === "video" && segment.hasOwnProperty("info")) {
                            this._idrList.appendArray(segment.info.syncPoints);
                          }
                        } catch (error2) {
                          this._pendingSegments[type2].unshift(segment);
                          if (error2.code === 22) {
                            if (!this._isBufferFull) {
                              this._emitter.emit(_mse_events_js__WEBPACK_IMPORTED_MODULE_3__.default.BUFFER_FULL);
                            }
                            this._isBufferFull = true;
                          } else {
                            _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.e(this.TAG, error2.message);
                            this._emitter.emit(_mse_events_js__WEBPACK_IMPORTED_MODULE_3__.default.ERROR, { code: error2.code, msg: error2.message });
                          }
                        }
                      }
                    }
                  };
                  MSEController2.prototype._onSourceOpen = function() {
                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.v(this.TAG, "MediaSource onSourceOpen");
                    this._mediaSource.removeEventListener("sourceopen", this.e.onSourceOpen);
                    if (this._pendingSourceBufferInit.length > 0) {
                      var pendings = this._pendingSourceBufferInit;
                      while (pendings.length) {
                        var segment = pendings.shift();
                        this.appendInitSegment(segment, true);
                      }
                    }
                    if (this._hasPendingSegments()) {
                      this._doAppendSegments();
                    }
                    this._emitter.emit(_mse_events_js__WEBPACK_IMPORTED_MODULE_3__.default.SOURCE_OPEN);
                  };
                  MSEController2.prototype._onSourceEnded = function() {
                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.v(this.TAG, "MediaSource onSourceEnded");
                  };
                  MSEController2.prototype._onSourceClose = function() {
                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.v(this.TAG, "MediaSource onSourceClose");
                    if (this._mediaSource && this.e != null) {
                      this._mediaSource.removeEventListener("sourceopen", this.e.onSourceOpen);
                      this._mediaSource.removeEventListener("sourceended", this.e.onSourceEnded);
                      this._mediaSource.removeEventListener("sourceclose", this.e.onSourceClose);
                    }
                  };
                  MSEController2.prototype._hasPendingSegments = function() {
                    var ps = this._pendingSegments;
                    return ps.video.length > 0 || ps.audio.length > 0;
                  };
                  MSEController2.prototype._hasPendingRemoveRanges = function() {
                    var prr = this._pendingRemoveRanges;
                    return prr.video.length > 0 || prr.audio.length > 0;
                  };
                  MSEController2.prototype._onSourceBufferUpdateEnd = function() {
                    if (this._requireSetMediaDuration) {
                      this._updateMediaSourceDuration();
                    } else if (this._hasPendingRemoveRanges()) {
                      this._doRemoveRanges();
                    } else if (this._hasPendingSegments()) {
                      this._doAppendSegments();
                    } else if (this._hasPendingEos) {
                      this.endOfStream();
                    }
                    this._emitter.emit(_mse_events_js__WEBPACK_IMPORTED_MODULE_3__.default.UPDATE_END);
                  };
                  MSEController2.prototype._onSourceBufferError = function(e2) {
                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.e(this.TAG, "SourceBuffer Error: " + e2);
                  };
                  return MSEController2;
                }()
              );
              __webpack_exports__2["default"] = MSEController;
            }
          ),
          /***/
          "./src/core/mse-events.js": (
            /*!********************************!*\
              !*** ./src/core/mse-events.js ***!
              \********************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var MSEEvents = {
                ERROR: "error",
                SOURCE_OPEN: "source_open",
                UPDATE_END: "update_end",
                BUFFER_FULL: "buffer_full"
              };
              __webpack_exports__2["default"] = MSEEvents;
            }
          ),
          /***/
          "./src/core/transmuxer.js": (
            /*!********************************!*\
              !*** ./src/core/transmuxer.js ***!
              \********************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! events */
                "./node_modules/events/events.js"
              );
              var events__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(events__WEBPACK_IMPORTED_MODULE_0__);
              var webworkify_webpack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! webworkify-webpack */
                "./node_modules/webworkify-webpack/index.js"
              );
              var webworkify_webpack__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__2.n(webworkify_webpack__WEBPACK_IMPORTED_MODULE_1__);
              var _utils_logger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ../utils/logger.js */
                "./src/utils/logger.js"
              );
              var _utils_logging_control_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ../utils/logging-control.js */
                "./src/utils/logging-control.js"
              );
              var _transmuxing_controller_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./transmuxing-controller.js */
                "./src/core/transmuxing-controller.js"
              );
              var _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ./transmuxing-events.js */
                "./src/core/transmuxing-events.js"
              );
              var _media_info_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                /*! ./media-info.js */
                "./src/core/media-info.js"
              );
              var Transmuxer = (
                /** @class */
                function() {
                  function Transmuxer2(mediaDataSource, config) {
                    this.TAG = "Transmuxer";
                    this._emitter = new (events__WEBPACK_IMPORTED_MODULE_0___default())();
                    if (config.enableWorker && typeof Worker !== "undefined") {
                      try {
                        this._worker = webworkify_webpack__WEBPACK_IMPORTED_MODULE_1___default()(
                          /*require.resolve*/
                          /*! ./transmuxing-worker */
                          "./src/core/transmuxing-worker.js"
                        );
                        this._workerDestroying = false;
                        this._worker.addEventListener("message", this._onWorkerMessage.bind(this));
                        this._worker.postMessage({ cmd: "init", param: [mediaDataSource, config] });
                        this.e = {
                          onLoggingConfigChanged: this._onLoggingConfigChanged.bind(this)
                        };
                        _utils_logging_control_js__WEBPACK_IMPORTED_MODULE_3__.default.registerListener(this.e.onLoggingConfigChanged);
                        this._worker.postMessage({ cmd: "logging_config", param: _utils_logging_control_js__WEBPACK_IMPORTED_MODULE_3__.default.getConfig() });
                      } catch (error2) {
                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_2__.default.e(this.TAG, "Error while initialize transmuxing worker, fallback to inline transmuxing");
                        this._worker = null;
                        this._controller = new _transmuxing_controller_js__WEBPACK_IMPORTED_MODULE_4__.default(mediaDataSource, config);
                      }
                    } else {
                      this._controller = new _transmuxing_controller_js__WEBPACK_IMPORTED_MODULE_4__.default(mediaDataSource, config);
                    }
                    if (this._controller) {
                      var ctl = this._controller;
                      ctl.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.IO_ERROR, this._onIOError.bind(this));
                      ctl.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.DEMUX_ERROR, this._onDemuxError.bind(this));
                      ctl.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.INIT_SEGMENT, this._onInitSegment.bind(this));
                      ctl.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.MEDIA_SEGMENT, this._onMediaSegment.bind(this));
                      ctl.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.LOADING_COMPLETE, this._onLoadingComplete.bind(this));
                      ctl.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.RECOVERED_EARLY_EOF, this._onRecoveredEarlyEof.bind(this));
                      ctl.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.MEDIA_INFO, this._onMediaInfo.bind(this));
                      ctl.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.METADATA_ARRIVED, this._onMetaDataArrived.bind(this));
                      ctl.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.SCRIPTDATA_ARRIVED, this._onScriptDataArrived.bind(this));
                      ctl.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.STATISTICS_INFO, this._onStatisticsInfo.bind(this));
                      ctl.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.RECOMMEND_SEEKPOINT, this._onRecommendSeekpoint.bind(this));
                    }
                  }
                  Transmuxer2.prototype.destroy = function() {
                    if (this._worker) {
                      if (!this._workerDestroying) {
                        this._workerDestroying = true;
                        this._worker.postMessage({ cmd: "destroy" });
                        _utils_logging_control_js__WEBPACK_IMPORTED_MODULE_3__.default.removeListener(this.e.onLoggingConfigChanged);
                        this.e = null;
                      }
                    } else {
                      this._controller.destroy();
                      this._controller = null;
                    }
                    this._emitter.removeAllListeners();
                    this._emitter = null;
                  };
                  Transmuxer2.prototype.on = function(event, listener) {
                    this._emitter.addListener(event, listener);
                  };
                  Transmuxer2.prototype.off = function(event, listener) {
                    this._emitter.removeListener(event, listener);
                  };
                  Transmuxer2.prototype.hasWorker = function() {
                    return this._worker != null;
                  };
                  Transmuxer2.prototype.open = function() {
                    if (this._worker) {
                      this._worker.postMessage({ cmd: "start" });
                    } else {
                      this._controller.start();
                    }
                  };
                  Transmuxer2.prototype.close = function() {
                    if (this._worker) {
                      this._worker.postMessage({ cmd: "stop" });
                    } else {
                      this._controller.stop();
                    }
                  };
                  Transmuxer2.prototype.seek = function(milliseconds) {
                    if (this._worker) {
                      this._worker.postMessage({ cmd: "seek", param: milliseconds });
                    } else {
                      this._controller.seek(milliseconds);
                    }
                  };
                  Transmuxer2.prototype.pause = function() {
                    if (this._worker) {
                      this._worker.postMessage({ cmd: "pause" });
                    } else {
                      this._controller.pause();
                    }
                  };
                  Transmuxer2.prototype.resume = function() {
                    if (this._worker) {
                      this._worker.postMessage({ cmd: "resume" });
                    } else {
                      this._controller.resume();
                    }
                  };
                  Transmuxer2.prototype._onInitSegment = function(type2, initSegment) {
                    var _this = this;
                    Promise.resolve().then(function() {
                      _this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.INIT_SEGMENT, type2, initSegment);
                    });
                  };
                  Transmuxer2.prototype._onMediaSegment = function(type2, mediaSegment) {
                    var _this = this;
                    Promise.resolve().then(function() {
                      _this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.MEDIA_SEGMENT, type2, mediaSegment);
                    });
                  };
                  Transmuxer2.prototype._onLoadingComplete = function() {
                    var _this = this;
                    Promise.resolve().then(function() {
                      _this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.LOADING_COMPLETE);
                    });
                  };
                  Transmuxer2.prototype._onRecoveredEarlyEof = function() {
                    var _this = this;
                    Promise.resolve().then(function() {
                      _this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.RECOVERED_EARLY_EOF);
                    });
                  };
                  Transmuxer2.prototype._onMediaInfo = function(mediaInfo) {
                    var _this = this;
                    Promise.resolve().then(function() {
                      _this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.MEDIA_INFO, mediaInfo);
                    });
                  };
                  Transmuxer2.prototype._onMetaDataArrived = function(metadata) {
                    var _this = this;
                    Promise.resolve().then(function() {
                      _this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.METADATA_ARRIVED, metadata);
                    });
                  };
                  Transmuxer2.prototype._onScriptDataArrived = function(data2) {
                    var _this = this;
                    Promise.resolve().then(function() {
                      _this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.SCRIPTDATA_ARRIVED, data2);
                    });
                  };
                  Transmuxer2.prototype._onStatisticsInfo = function(statisticsInfo) {
                    var _this = this;
                    Promise.resolve().then(function() {
                      _this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.STATISTICS_INFO, statisticsInfo);
                    });
                  };
                  Transmuxer2.prototype._onIOError = function(type2, info) {
                    var _this = this;
                    Promise.resolve().then(function() {
                      _this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.IO_ERROR, type2, info);
                    });
                  };
                  Transmuxer2.prototype._onDemuxError = function(type2, info) {
                    var _this = this;
                    Promise.resolve().then(function() {
                      _this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.DEMUX_ERROR, type2, info);
                    });
                  };
                  Transmuxer2.prototype._onRecommendSeekpoint = function(milliseconds) {
                    var _this = this;
                    Promise.resolve().then(function() {
                      _this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.RECOMMEND_SEEKPOINT, milliseconds);
                    });
                  };
                  Transmuxer2.prototype._onLoggingConfigChanged = function(config) {
                    if (this._worker) {
                      this._worker.postMessage({ cmd: "logging_config", param: config });
                    }
                  };
                  Transmuxer2.prototype._onWorkerMessage = function(e2) {
                    var message = e2.data;
                    var data2 = message.data;
                    if (message.msg === "destroyed" || this._workerDestroying) {
                      this._workerDestroying = false;
                      this._worker.terminate();
                      this._worker = null;
                      return;
                    }
                    switch (message.msg) {
                      case _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.INIT_SEGMENT:
                      case _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.MEDIA_SEGMENT:
                        this._emitter.emit(message.msg, data2.type, data2.data);
                        break;
                      case _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.LOADING_COMPLETE:
                      case _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.RECOVERED_EARLY_EOF:
                        this._emitter.emit(message.msg);
                        break;
                      case _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.MEDIA_INFO:
                        Object.setPrototypeOf(data2, _media_info_js__WEBPACK_IMPORTED_MODULE_6__.default.prototype);
                        this._emitter.emit(message.msg, data2);
                        break;
                      case _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.METADATA_ARRIVED:
                      case _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.SCRIPTDATA_ARRIVED:
                      case _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.STATISTICS_INFO:
                        this._emitter.emit(message.msg, data2);
                        break;
                      case _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.IO_ERROR:
                      case _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.DEMUX_ERROR:
                        this._emitter.emit(message.msg, data2.type, data2.info);
                        break;
                      case _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.RECOMMEND_SEEKPOINT:
                        this._emitter.emit(message.msg, data2);
                        break;
                      case "logcat_callback":
                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_2__.default.emitter.emit("log", data2.type, data2.logcat);
                        break;
                    }
                  };
                  return Transmuxer2;
                }()
              );
              __webpack_exports__2["default"] = Transmuxer;
            }
          ),
          /***/
          "./src/core/transmuxing-controller.js": (
            /*!********************************************!*\
              !*** ./src/core/transmuxing-controller.js ***!
              \********************************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! events */
                "./node_modules/events/events.js"
              );
              var events__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(events__WEBPACK_IMPORTED_MODULE_0__);
              var _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ../utils/logger.js */
                "./src/utils/logger.js"
              );
              var _utils_browser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ../utils/browser.js */
                "./src/utils/browser.js"
              );
              var _media_info_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./media-info.js */
                "./src/core/media-info.js"
              );
              var _demux_flv_demuxer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ../demux/flv-demuxer.js */
                "./src/demux/flv-demuxer.js"
              );
              var _remux_mp4_remuxer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ../remux/mp4-remuxer.js */
                "./src/remux/mp4-remuxer.js"
              );
              var _demux_demux_errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                /*! ../demux/demux-errors.js */
                "./src/demux/demux-errors.js"
              );
              var _io_io_controller_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                /*! ../io/io-controller.js */
                "./src/io/io-controller.js"
              );
              var _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                /*! ./transmuxing-events.js */
                "./src/core/transmuxing-events.js"
              );
              var TransmuxingController = (
                /** @class */
                function() {
                  function TransmuxingController2(mediaDataSource, config) {
                    this.TAG = "TransmuxingController";
                    this._emitter = new (events__WEBPACK_IMPORTED_MODULE_0___default())();
                    this._config = config;
                    if (!mediaDataSource.segments) {
                      mediaDataSource.segments = [{
                        duration: mediaDataSource.duration,
                        filesize: mediaDataSource.filesize,
                        url: mediaDataSource.url
                      }];
                    }
                    if (typeof mediaDataSource.cors !== "boolean") {
                      mediaDataSource.cors = true;
                    }
                    if (typeof mediaDataSource.withCredentials !== "boolean") {
                      mediaDataSource.withCredentials = false;
                    }
                    this._mediaDataSource = mediaDataSource;
                    this._currentSegmentIndex = 0;
                    var totalDuration = 0;
                    this._mediaDataSource.segments.forEach(function(segment) {
                      segment.timestampBase = totalDuration;
                      totalDuration += segment.duration;
                      segment.cors = mediaDataSource.cors;
                      segment.withCredentials = mediaDataSource.withCredentials;
                      if (config.referrerPolicy) {
                        segment.referrerPolicy = config.referrerPolicy;
                      }
                    });
                    if (!isNaN(totalDuration) && this._mediaDataSource.duration !== totalDuration) {
                      this._mediaDataSource.duration = totalDuration;
                    }
                    this._mediaInfo = null;
                    this._demuxer = null;
                    this._remuxer = null;
                    this._ioctl = null;
                    this._pendingSeekTime = null;
                    this._pendingResolveSeekPoint = null;
                    this._statisticsReporter = null;
                  }
                  TransmuxingController2.prototype.destroy = function() {
                    this._mediaInfo = null;
                    this._mediaDataSource = null;
                    if (this._statisticsReporter) {
                      this._disableStatisticsReporter();
                    }
                    if (this._ioctl) {
                      this._ioctl.destroy();
                      this._ioctl = null;
                    }
                    if (this._demuxer) {
                      this._demuxer.destroy();
                      this._demuxer = null;
                    }
                    if (this._remuxer) {
                      this._remuxer.destroy();
                      this._remuxer = null;
                    }
                    this._emitter.removeAllListeners();
                    this._emitter = null;
                  };
                  TransmuxingController2.prototype.on = function(event, listener) {
                    this._emitter.addListener(event, listener);
                  };
                  TransmuxingController2.prototype.off = function(event, listener) {
                    this._emitter.removeListener(event, listener);
                  };
                  TransmuxingController2.prototype.start = function() {
                    this._loadSegment(0);
                    this._enableStatisticsReporter();
                  };
                  TransmuxingController2.prototype._loadSegment = function(segmentIndex, optionalFrom) {
                    this._currentSegmentIndex = segmentIndex;
                    var dataSource = this._mediaDataSource.segments[segmentIndex];
                    var ioctl = this._ioctl = new _io_io_controller_js__WEBPACK_IMPORTED_MODULE_7__.default(dataSource, this._config, segmentIndex);
                    ioctl.onError = this._onIOException.bind(this);
                    ioctl.onSeeked = this._onIOSeeked.bind(this);
                    ioctl.onComplete = this._onIOComplete.bind(this);
                    ioctl.onRedirect = this._onIORedirect.bind(this);
                    ioctl.onRecoveredEarlyEof = this._onIORecoveredEarlyEof.bind(this);
                    if (optionalFrom) {
                      this._demuxer.bindDataSource(this._ioctl);
                    } else {
                      ioctl.onDataArrival = this._onInitChunkArrival.bind(this);
                    }
                    ioctl.open(optionalFrom);
                  };
                  TransmuxingController2.prototype.stop = function() {
                    this._internalAbort();
                    this._disableStatisticsReporter();
                  };
                  TransmuxingController2.prototype._internalAbort = function() {
                    if (this._ioctl) {
                      this._ioctl.destroy();
                      this._ioctl = null;
                    }
                  };
                  TransmuxingController2.prototype.pause = function() {
                    if (this._ioctl && this._ioctl.isWorking()) {
                      this._ioctl.pause();
                      this._disableStatisticsReporter();
                    }
                  };
                  TransmuxingController2.prototype.resume = function() {
                    if (this._ioctl && this._ioctl.isPaused()) {
                      this._ioctl.resume();
                      this._enableStatisticsReporter();
                    }
                  };
                  TransmuxingController2.prototype.seek = function(milliseconds) {
                    if (this._mediaInfo == null || !this._mediaInfo.isSeekable()) {
                      return;
                    }
                    var targetSegmentIndex = this._searchSegmentIndexContains(milliseconds);
                    if (targetSegmentIndex === this._currentSegmentIndex) {
                      var segmentInfo = this._mediaInfo.segments[targetSegmentIndex];
                      if (segmentInfo == void 0) {
                        this._pendingSeekTime = milliseconds;
                      } else {
                        var keyframe = segmentInfo.getNearestKeyframe(milliseconds);
                        this._remuxer.seek(keyframe.milliseconds);
                        this._ioctl.seek(keyframe.fileposition);
                        this._pendingResolveSeekPoint = keyframe.milliseconds;
                      }
                    } else {
                      var targetSegmentInfo = this._mediaInfo.segments[targetSegmentIndex];
                      if (targetSegmentInfo == void 0) {
                        this._pendingSeekTime = milliseconds;
                        this._internalAbort();
                        this._remuxer.seek();
                        this._remuxer.insertDiscontinuity();
                        this._loadSegment(targetSegmentIndex);
                      } else {
                        var keyframe = targetSegmentInfo.getNearestKeyframe(milliseconds);
                        this._internalAbort();
                        this._remuxer.seek(milliseconds);
                        this._remuxer.insertDiscontinuity();
                        this._demuxer.resetMediaInfo();
                        this._demuxer.timestampBase = this._mediaDataSource.segments[targetSegmentIndex].timestampBase;
                        this._loadSegment(targetSegmentIndex, keyframe.fileposition);
                        this._pendingResolveSeekPoint = keyframe.milliseconds;
                        this._reportSegmentMediaInfo(targetSegmentIndex);
                      }
                    }
                    this._enableStatisticsReporter();
                  };
                  TransmuxingController2.prototype._searchSegmentIndexContains = function(milliseconds) {
                    var segments = this._mediaDataSource.segments;
                    var idx = segments.length - 1;
                    for (var i2 = 0; i2 < segments.length; i2++) {
                      if (milliseconds < segments[i2].timestampBase) {
                        idx = i2 - 1;
                        break;
                      }
                    }
                    return idx;
                  };
                  TransmuxingController2.prototype._onInitChunkArrival = function(data2, byteStart) {
                    var _this = this;
                    var probeData = null;
                    var consumed = 0;
                    if (byteStart > 0) {
                      this._demuxer.bindDataSource(this._ioctl);
                      this._demuxer.timestampBase = this._mediaDataSource.segments[this._currentSegmentIndex].timestampBase;
                      consumed = this._demuxer.parseChunks(data2, byteStart);
                    } else if ((probeData = _demux_flv_demuxer_js__WEBPACK_IMPORTED_MODULE_4__.default.probe(data2)).match) {
                      this._demuxer = new _demux_flv_demuxer_js__WEBPACK_IMPORTED_MODULE_4__.default(probeData, this._config);
                      if (!this._remuxer) {
                        this._remuxer = new _remux_mp4_remuxer_js__WEBPACK_IMPORTED_MODULE_5__.default(this._config);
                      }
                      var mds = this._mediaDataSource;
                      if (mds.duration != void 0 && !isNaN(mds.duration)) {
                        this._demuxer.overridedDuration = mds.duration;
                      }
                      if (typeof mds.hasAudio === "boolean") {
                        this._demuxer.overridedHasAudio = mds.hasAudio;
                      }
                      if (typeof mds.hasVideo === "boolean") {
                        this._demuxer.overridedHasVideo = mds.hasVideo;
                      }
                      this._demuxer.timestampBase = mds.segments[this._currentSegmentIndex].timestampBase;
                      this._demuxer.onError = this._onDemuxException.bind(this);
                      this._demuxer.onMediaInfo = this._onMediaInfo.bind(this);
                      this._demuxer.onMetaDataArrived = this._onMetaDataArrived.bind(this);
                      this._demuxer.onScriptDataArrived = this._onScriptDataArrived.bind(this);
                      this._remuxer.bindDataSource(this._demuxer.bindDataSource(this._ioctl));
                      this._remuxer.onInitSegment = this._onRemuxerInitSegmentArrival.bind(this);
                      this._remuxer.onMediaSegment = this._onRemuxerMediaSegmentArrival.bind(this);
                      consumed = this._demuxer.parseChunks(data2, byteStart);
                    } else {
                      probeData = null;
                      _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.e(this.TAG, "Non-FLV, Unsupported media type!");
                      Promise.resolve().then(function() {
                        _this._internalAbort();
                      });
                      this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_8__.default.DEMUX_ERROR, _demux_demux_errors_js__WEBPACK_IMPORTED_MODULE_6__.default.FORMAT_UNSUPPORTED, "Non-FLV, Unsupported media type");
                      consumed = 0;
                    }
                    return consumed;
                  };
                  TransmuxingController2.prototype._onMediaInfo = function(mediaInfo) {
                    var _this = this;
                    if (this._mediaInfo == null) {
                      this._mediaInfo = Object.assign({}, mediaInfo);
                      this._mediaInfo.keyframesIndex = null;
                      this._mediaInfo.segments = [];
                      this._mediaInfo.segmentCount = this._mediaDataSource.segments.length;
                      Object.setPrototypeOf(this._mediaInfo, _media_info_js__WEBPACK_IMPORTED_MODULE_3__.default.prototype);
                    }
                    var segmentInfo = Object.assign({}, mediaInfo);
                    Object.setPrototypeOf(segmentInfo, _media_info_js__WEBPACK_IMPORTED_MODULE_3__.default.prototype);
                    this._mediaInfo.segments[this._currentSegmentIndex] = segmentInfo;
                    this._reportSegmentMediaInfo(this._currentSegmentIndex);
                    if (this._pendingSeekTime != null) {
                      Promise.resolve().then(function() {
                        var target = _this._pendingSeekTime;
                        _this._pendingSeekTime = null;
                        _this.seek(target);
                      });
                    }
                  };
                  TransmuxingController2.prototype._onMetaDataArrived = function(metadata) {
                    this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_8__.default.METADATA_ARRIVED, metadata);
                  };
                  TransmuxingController2.prototype._onScriptDataArrived = function(data2) {
                    this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_8__.default.SCRIPTDATA_ARRIVED, data2);
                  };
                  TransmuxingController2.prototype._onIOSeeked = function() {
                    this._remuxer.insertDiscontinuity();
                  };
                  TransmuxingController2.prototype._onIOComplete = function(extraData) {
                    var segmentIndex = extraData;
                    var nextSegmentIndex = segmentIndex + 1;
                    if (nextSegmentIndex < this._mediaDataSource.segments.length) {
                      this._internalAbort();
                      this._remuxer.flushStashedSamples();
                      this._loadSegment(nextSegmentIndex);
                    } else {
                      this._remuxer.flushStashedSamples();
                      this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_8__.default.LOADING_COMPLETE);
                      this._disableStatisticsReporter();
                    }
                  };
                  TransmuxingController2.prototype._onIORedirect = function(redirectedURL) {
                    var segmentIndex = this._ioctl.extraData;
                    this._mediaDataSource.segments[segmentIndex].redirectedURL = redirectedURL;
                  };
                  TransmuxingController2.prototype._onIORecoveredEarlyEof = function() {
                    this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_8__.default.RECOVERED_EARLY_EOF);
                  };
                  TransmuxingController2.prototype._onIOException = function(type2, info) {
                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.e(this.TAG, "IOException: type = " + type2 + ", code = " + info.code + ", msg = " + info.msg);
                    this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_8__.default.IO_ERROR, type2, info);
                    this._disableStatisticsReporter();
                  };
                  TransmuxingController2.prototype._onDemuxException = function(type2, info) {
                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.e(this.TAG, "DemuxException: type = " + type2 + ", info = " + info);
                    this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_8__.default.DEMUX_ERROR, type2, info);
                  };
                  TransmuxingController2.prototype._onRemuxerInitSegmentArrival = function(type2, initSegment) {
                    this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_8__.default.INIT_SEGMENT, type2, initSegment);
                  };
                  TransmuxingController2.prototype._onRemuxerMediaSegmentArrival = function(type2, mediaSegment) {
                    if (this._pendingSeekTime != null) {
                      return;
                    }
                    this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_8__.default.MEDIA_SEGMENT, type2, mediaSegment);
                    if (this._pendingResolveSeekPoint != null && type2 === "video") {
                      var syncPoints = mediaSegment.info.syncPoints;
                      var seekpoint = this._pendingResolveSeekPoint;
                      this._pendingResolveSeekPoint = null;
                      if (_utils_browser_js__WEBPACK_IMPORTED_MODULE_2__.default.safari && syncPoints.length > 0 && syncPoints[0].originalDts === seekpoint) {
                        seekpoint = syncPoints[0].pts;
                      }
                      this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_8__.default.RECOMMEND_SEEKPOINT, seekpoint);
                    }
                  };
                  TransmuxingController2.prototype._enableStatisticsReporter = function() {
                    if (this._statisticsReporter == null) {
                      this._statisticsReporter = self.setInterval(this._reportStatisticsInfo.bind(this), this._config.statisticsInfoReportInterval);
                    }
                  };
                  TransmuxingController2.prototype._disableStatisticsReporter = function() {
                    if (this._statisticsReporter) {
                      self.clearInterval(this._statisticsReporter);
                      this._statisticsReporter = null;
                    }
                  };
                  TransmuxingController2.prototype._reportSegmentMediaInfo = function(segmentIndex) {
                    var segmentInfo = this._mediaInfo.segments[segmentIndex];
                    var exportInfo = Object.assign({}, segmentInfo);
                    exportInfo.duration = this._mediaInfo.duration;
                    exportInfo.segmentCount = this._mediaInfo.segmentCount;
                    delete exportInfo.segments;
                    delete exportInfo.keyframesIndex;
                    this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_8__.default.MEDIA_INFO, exportInfo);
                  };
                  TransmuxingController2.prototype._reportStatisticsInfo = function() {
                    var info = {};
                    info.url = this._ioctl.currentURL;
                    info.hasRedirect = this._ioctl.hasRedirect;
                    if (info.hasRedirect) {
                      info.redirectedURL = this._ioctl.currentRedirectedURL;
                    }
                    info.speed = this._ioctl.currentSpeed;
                    info.loaderType = this._ioctl.loaderType;
                    info.currentSegmentIndex = this._currentSegmentIndex;
                    info.totalSegmentCount = this._mediaDataSource.segments.length;
                    this._emitter.emit(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_8__.default.STATISTICS_INFO, info);
                  };
                  return TransmuxingController2;
                }()
              );
              __webpack_exports__2["default"] = TransmuxingController;
            }
          ),
          /***/
          "./src/core/transmuxing-events.js": (
            /*!****************************************!*\
              !*** ./src/core/transmuxing-events.js ***!
              \****************************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var TransmuxingEvents = {
                IO_ERROR: "io_error",
                DEMUX_ERROR: "demux_error",
                INIT_SEGMENT: "init_segment",
                MEDIA_SEGMENT: "media_segment",
                LOADING_COMPLETE: "loading_complete",
                RECOVERED_EARLY_EOF: "recovered_early_eof",
                MEDIA_INFO: "media_info",
                METADATA_ARRIVED: "metadata_arrived",
                SCRIPTDATA_ARRIVED: "scriptdata_arrived",
                STATISTICS_INFO: "statistics_info",
                RECOMMEND_SEEKPOINT: "recommend_seekpoint"
              };
              __webpack_exports__2["default"] = TransmuxingEvents;
            }
          ),
          /***/
          "./src/core/transmuxing-worker.js": (
            /*!****************************************!*\
              !*** ./src/core/transmuxing-worker.js ***!
              \****************************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var _utils_logging_control_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../utils/logging-control.js */
                "./src/utils/logging-control.js"
              );
              var _utils_polyfill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ../utils/polyfill.js */
                "./src/utils/polyfill.js"
              );
              var _transmuxing_controller_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./transmuxing-controller.js */
                "./src/core/transmuxing-controller.js"
              );
              var _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./transmuxing-events.js */
                "./src/core/transmuxing-events.js"
              );
              var TransmuxingWorker = function(self2) {
                var controller = null;
                var logcatListener = onLogcatCallback.bind(this);
                _utils_polyfill_js__WEBPACK_IMPORTED_MODULE_1__.default.install();
                self2.addEventListener("message", function(e2) {
                  switch (e2.data.cmd) {
                    case "init":
                      controller = new _transmuxing_controller_js__WEBPACK_IMPORTED_MODULE_2__.default(e2.data.param[0], e2.data.param[1]);
                      controller.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.IO_ERROR, onIOError.bind(this));
                      controller.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.DEMUX_ERROR, onDemuxError.bind(this));
                      controller.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.INIT_SEGMENT, onInitSegment.bind(this));
                      controller.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.MEDIA_SEGMENT, onMediaSegment.bind(this));
                      controller.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.LOADING_COMPLETE, onLoadingComplete.bind(this));
                      controller.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.RECOVERED_EARLY_EOF, onRecoveredEarlyEof.bind(this));
                      controller.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.MEDIA_INFO, onMediaInfo.bind(this));
                      controller.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.METADATA_ARRIVED, onMetaDataArrived.bind(this));
                      controller.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.SCRIPTDATA_ARRIVED, onScriptDataArrived.bind(this));
                      controller.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.STATISTICS_INFO, onStatisticsInfo.bind(this));
                      controller.on(_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.RECOMMEND_SEEKPOINT, onRecommendSeekpoint.bind(this));
                      break;
                    case "destroy":
                      if (controller) {
                        controller.destroy();
                        controller = null;
                      }
                      self2.postMessage({ msg: "destroyed" });
                      break;
                    case "start":
                      controller.start();
                      break;
                    case "stop":
                      controller.stop();
                      break;
                    case "seek":
                      controller.seek(e2.data.param);
                      break;
                    case "pause":
                      controller.pause();
                      break;
                    case "resume":
                      controller.resume();
                      break;
                    case "logging_config": {
                      var config = e2.data.param;
                      _utils_logging_control_js__WEBPACK_IMPORTED_MODULE_0__.default.applyConfig(config);
                      if (config.enableCallback === true) {
                        _utils_logging_control_js__WEBPACK_IMPORTED_MODULE_0__.default.addLogListener(logcatListener);
                      } else {
                        _utils_logging_control_js__WEBPACK_IMPORTED_MODULE_0__.default.removeLogListener(logcatListener);
                      }
                      break;
                    }
                  }
                });
                function onInitSegment(type2, initSegment) {
                  var obj = {
                    msg: _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.INIT_SEGMENT,
                    data: {
                      type: type2,
                      data: initSegment
                    }
                  };
                  self2.postMessage(obj, [initSegment.data]);
                }
                function onMediaSegment(type2, mediaSegment) {
                  var obj = {
                    msg: _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.MEDIA_SEGMENT,
                    data: {
                      type: type2,
                      data: mediaSegment
                    }
                  };
                  self2.postMessage(obj, [mediaSegment.data]);
                }
                function onLoadingComplete() {
                  var obj = {
                    msg: _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.LOADING_COMPLETE
                  };
                  self2.postMessage(obj);
                }
                function onRecoveredEarlyEof() {
                  var obj = {
                    msg: _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.RECOVERED_EARLY_EOF
                  };
                  self2.postMessage(obj);
                }
                function onMediaInfo(mediaInfo) {
                  var obj = {
                    msg: _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.MEDIA_INFO,
                    data: mediaInfo
                  };
                  self2.postMessage(obj);
                }
                function onMetaDataArrived(metadata) {
                  var obj = {
                    msg: _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.METADATA_ARRIVED,
                    data: metadata
                  };
                  self2.postMessage(obj);
                }
                function onScriptDataArrived(data2) {
                  var obj = {
                    msg: _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.SCRIPTDATA_ARRIVED,
                    data: data2
                  };
                  self2.postMessage(obj);
                }
                function onStatisticsInfo(statInfo) {
                  var obj = {
                    msg: _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.STATISTICS_INFO,
                    data: statInfo
                  };
                  self2.postMessage(obj);
                }
                function onIOError(type2, info) {
                  self2.postMessage({
                    msg: _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.IO_ERROR,
                    data: {
                      type: type2,
                      info
                    }
                  });
                }
                function onDemuxError(type2, info) {
                  self2.postMessage({
                    msg: _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.DEMUX_ERROR,
                    data: {
                      type: type2,
                      info
                    }
                  });
                }
                function onRecommendSeekpoint(milliseconds) {
                  self2.postMessage({
                    msg: _transmuxing_events_js__WEBPACK_IMPORTED_MODULE_3__.default.RECOMMEND_SEEKPOINT,
                    data: milliseconds
                  });
                }
                function onLogcatCallback(type2, str) {
                  self2.postMessage({
                    msg: "logcat_callback",
                    data: {
                      type: type2,
                      logcat: str
                    }
                  });
                }
              };
              __webpack_exports__2["default"] = TransmuxingWorker;
            }
          ),
          /***/
          "./src/demux/amf-parser.js": (
            /*!*********************************!*\
              !*** ./src/demux/amf-parser.js ***!
              \*********************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../utils/logger.js */
                "./src/utils/logger.js"
              );
              var _utils_utf8_conv_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ../utils/utf8-conv.js */
                "./src/utils/utf8-conv.js"
              );
              var _utils_exception_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              );
              var le2 = function() {
                var buf = new ArrayBuffer(2);
                new DataView(buf).setInt16(0, 256, true);
                return new Int16Array(buf)[0] === 256;
              }();
              var AMF = (
                /** @class */
                function() {
                  function AMF2() {
                  }
                  AMF2.parseScriptData = function(arrayBuffer, dataOffset, dataSize) {
                    var data2 = {};
                    try {
                      var name_1 = AMF2.parseValue(arrayBuffer, dataOffset, dataSize);
                      var value = AMF2.parseValue(arrayBuffer, dataOffset + name_1.size, dataSize - name_1.size);
                      data2[name_1.data] = value.data;
                    } catch (e2) {
                      _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.e("AMF", e2.toString());
                    }
                    return data2;
                  };
                  AMF2.parseObject = function(arrayBuffer, dataOffset, dataSize) {
                    if (dataSize < 3) {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_2__.IllegalStateException("Data not enough when parse ScriptDataObject");
                    }
                    var name = AMF2.parseString(arrayBuffer, dataOffset, dataSize);
                    var value = AMF2.parseValue(arrayBuffer, dataOffset + name.size, dataSize - name.size);
                    var isObjectEnd = value.objectEnd;
                    return {
                      data: {
                        name: name.data,
                        value: value.data
                      },
                      size: name.size + value.size,
                      objectEnd: isObjectEnd
                    };
                  };
                  AMF2.parseVariable = function(arrayBuffer, dataOffset, dataSize) {
                    return AMF2.parseObject(arrayBuffer, dataOffset, dataSize);
                  };
                  AMF2.parseString = function(arrayBuffer, dataOffset, dataSize) {
                    if (dataSize < 2) {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_2__.IllegalStateException("Data not enough when parse String");
                    }
                    var v2 = new DataView(arrayBuffer, dataOffset, dataSize);
                    var length2 = v2.getUint16(0, !le2);
                    var str;
                    if (length2 > 0) {
                      str = (0, _utils_utf8_conv_js__WEBPACK_IMPORTED_MODULE_1__.default)(new Uint8Array(arrayBuffer, dataOffset + 2, length2));
                    } else {
                      str = "";
                    }
                    return {
                      data: str,
                      size: 2 + length2
                    };
                  };
                  AMF2.parseLongString = function(arrayBuffer, dataOffset, dataSize) {
                    if (dataSize < 4) {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_2__.IllegalStateException("Data not enough when parse LongString");
                    }
                    var v2 = new DataView(arrayBuffer, dataOffset, dataSize);
                    var length2 = v2.getUint32(0, !le2);
                    var str;
                    if (length2 > 0) {
                      str = (0, _utils_utf8_conv_js__WEBPACK_IMPORTED_MODULE_1__.default)(new Uint8Array(arrayBuffer, dataOffset + 4, length2));
                    } else {
                      str = "";
                    }
                    return {
                      data: str,
                      size: 4 + length2
                    };
                  };
                  AMF2.parseDate = function(arrayBuffer, dataOffset, dataSize) {
                    if (dataSize < 10) {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_2__.IllegalStateException("Data size invalid when parse Date");
                    }
                    var v2 = new DataView(arrayBuffer, dataOffset, dataSize);
                    var timestamp = v2.getFloat64(0, !le2);
                    var localTimeOffset = v2.getInt16(8, !le2);
                    timestamp += localTimeOffset * 60 * 1e3;
                    return {
                      data: new Date(timestamp),
                      size: 8 + 2
                    };
                  };
                  AMF2.parseValue = function(arrayBuffer, dataOffset, dataSize) {
                    if (dataSize < 1) {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_2__.IllegalStateException("Data not enough when parse Value");
                    }
                    var v2 = new DataView(arrayBuffer, dataOffset, dataSize);
                    var offset = 1;
                    var type2 = v2.getUint8(0);
                    var value;
                    var objectEnd = false;
                    try {
                      switch (type2) {
                        case 0:
                          value = v2.getFloat64(1, !le2);
                          offset += 8;
                          break;
                        case 1: {
                          var b2 = v2.getUint8(1);
                          value = b2 ? true : false;
                          offset += 1;
                          break;
                        }
                        case 2: {
                          var amfstr = AMF2.parseString(arrayBuffer, dataOffset + 1, dataSize - 1);
                          value = amfstr.data;
                          offset += amfstr.size;
                          break;
                        }
                        case 3: {
                          value = {};
                          var terminal = 0;
                          if ((v2.getUint32(dataSize - 4, !le2) & 16777215) === 9) {
                            terminal = 3;
                          }
                          while (offset < dataSize - 4) {
                            var amfobj = AMF2.parseObject(arrayBuffer, dataOffset + offset, dataSize - offset - terminal);
                            if (amfobj.objectEnd)
                              break;
                            value[amfobj.data.name] = amfobj.data.value;
                            offset += amfobj.size;
                          }
                          if (offset <= dataSize - 3) {
                            var marker = v2.getUint32(offset - 1, !le2) & 16777215;
                            if (marker === 9) {
                              offset += 3;
                            }
                          }
                          break;
                        }
                        case 8: {
                          value = {};
                          offset += 4;
                          var terminal = 0;
                          if ((v2.getUint32(dataSize - 4, !le2) & 16777215) === 9) {
                            terminal = 3;
                          }
                          while (offset < dataSize - 8) {
                            var amfvar = AMF2.parseVariable(arrayBuffer, dataOffset + offset, dataSize - offset - terminal);
                            if (amfvar.objectEnd)
                              break;
                            value[amfvar.data.name] = amfvar.data.value;
                            offset += amfvar.size;
                          }
                          if (offset <= dataSize - 3) {
                            var marker = v2.getUint32(offset - 1, !le2) & 16777215;
                            if (marker === 9) {
                              offset += 3;
                            }
                          }
                          break;
                        }
                        case 9:
                          value = void 0;
                          offset = 1;
                          objectEnd = true;
                          break;
                        case 10: {
                          value = [];
                          var strictArrayLength = v2.getUint32(1, !le2);
                          offset += 4;
                          for (var i2 = 0; i2 < strictArrayLength; i2++) {
                            var val = AMF2.parseValue(arrayBuffer, dataOffset + offset, dataSize - offset);
                            value.push(val.data);
                            offset += val.size;
                          }
                          break;
                        }
                        case 11: {
                          var date = AMF2.parseDate(arrayBuffer, dataOffset + 1, dataSize - 1);
                          value = date.data;
                          offset += date.size;
                          break;
                        }
                        case 12: {
                          var amfLongStr = AMF2.parseString(arrayBuffer, dataOffset + 1, dataSize - 1);
                          value = amfLongStr.data;
                          offset += amfLongStr.size;
                          break;
                        }
                        default:
                          offset = dataSize;
                          _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w("AMF", "Unsupported AMF value type " + type2);
                      }
                    } catch (e2) {
                      _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.e("AMF", e2.toString());
                    }
                    return {
                      data: value,
                      size: offset,
                      objectEnd
                    };
                  };
                  return AMF2;
                }()
              );
              __webpack_exports__2["default"] = AMF;
            }
          ),
          /***/
          "./src/demux/demux-errors.js": (
            /*!***********************************!*\
              !*** ./src/demux/demux-errors.js ***!
              \***********************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var DemuxErrors = {
                OK: "OK",
                FORMAT_ERROR: "FormatError",
                FORMAT_UNSUPPORTED: "FormatUnsupported",
                CODEC_UNSUPPORTED: "CodecUnsupported"
              };
              __webpack_exports__2["default"] = DemuxErrors;
            }
          ),
          /***/
          "./src/demux/exp-golomb.js": (
            /*!*********************************!*\
              !*** ./src/demux/exp-golomb.js ***!
              \*********************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var _utils_exception_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              );
              var ExpGolomb = (
                /** @class */
                function() {
                  function ExpGolomb2(uint8array) {
                    this.TAG = "ExpGolomb";
                    this._buffer = uint8array;
                    this._buffer_index = 0;
                    this._total_bytes = uint8array.byteLength;
                    this._total_bits = uint8array.byteLength * 8;
                    this._current_word = 0;
                    this._current_word_bits_left = 0;
                  }
                  ExpGolomb2.prototype.destroy = function() {
                    this._buffer = null;
                  };
                  ExpGolomb2.prototype._fillCurrentWord = function() {
                    var buffer_bytes_left = this._total_bytes - this._buffer_index;
                    if (buffer_bytes_left <= 0)
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_0__.IllegalStateException("ExpGolomb: _fillCurrentWord() but no bytes available");
                    var bytes_read = Math.min(4, buffer_bytes_left);
                    var word = new Uint8Array(4);
                    word.set(this._buffer.subarray(this._buffer_index, this._buffer_index + bytes_read));
                    this._current_word = new DataView(word.buffer).getUint32(0, false);
                    this._buffer_index += bytes_read;
                    this._current_word_bits_left = bytes_read * 8;
                  };
                  ExpGolomb2.prototype.readBits = function(bits) {
                    if (bits > 32)
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentException("ExpGolomb: readBits() bits exceeded max 32bits!");
                    if (bits <= this._current_word_bits_left) {
                      var result_1 = this._current_word >>> 32 - bits;
                      this._current_word <<= bits;
                      this._current_word_bits_left -= bits;
                      return result_1;
                    }
                    var result = this._current_word_bits_left ? this._current_word : 0;
                    result = result >>> 32 - this._current_word_bits_left;
                    var bits_need_left = bits - this._current_word_bits_left;
                    this._fillCurrentWord();
                    var bits_read_next = Math.min(bits_need_left, this._current_word_bits_left);
                    var result2 = this._current_word >>> 32 - bits_read_next;
                    this._current_word <<= bits_read_next;
                    this._current_word_bits_left -= bits_read_next;
                    result = result << bits_read_next | result2;
                    return result;
                  };
                  ExpGolomb2.prototype.readBool = function() {
                    return this.readBits(1) === 1;
                  };
                  ExpGolomb2.prototype.readByte = function() {
                    return this.readBits(8);
                  };
                  ExpGolomb2.prototype._skipLeadingZero = function() {
                    var zero_count;
                    for (zero_count = 0; zero_count < this._current_word_bits_left; zero_count++) {
                      if (0 !== (this._current_word & 2147483648 >>> zero_count)) {
                        this._current_word <<= zero_count;
                        this._current_word_bits_left -= zero_count;
                        return zero_count;
                      }
                    }
                    this._fillCurrentWord();
                    return zero_count + this._skipLeadingZero();
                  };
                  ExpGolomb2.prototype.readUEG = function() {
                    var leading_zeros = this._skipLeadingZero();
                    return this.readBits(leading_zeros + 1) - 1;
                  };
                  ExpGolomb2.prototype.readSEG = function() {
                    var value = this.readUEG();
                    if (value & 1) {
                      return value + 1 >>> 1;
                    } else {
                      return -1 * (value >>> 1);
                    }
                  };
                  return ExpGolomb2;
                }()
              );
              __webpack_exports__2["default"] = ExpGolomb;
            }
          ),
          /***/
          "./src/demux/flv-demuxer.js": (
            /*!**********************************!*\
              !*** ./src/demux/flv-demuxer.js ***!
              \**********************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../utils/logger.js */
                "./src/utils/logger.js"
              );
              var _amf_parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./amf-parser.js */
                "./src/demux/amf-parser.js"
              );
              var _sps_parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./sps-parser.js */
                "./src/demux/sps-parser.js"
              );
              var _demux_errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./demux-errors.js */
                "./src/demux/demux-errors.js"
              );
              var _core_media_info_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ../core/media-info.js */
                "./src/core/media-info.js"
              );
              var _utils_exception_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              );
              function ReadBig32(array, index2) {
                return array[index2] << 24 | array[index2 + 1] << 16 | array[index2 + 2] << 8 | array[index2 + 3];
              }
              var FLVDemuxer = (
                /** @class */
                function() {
                  function FLVDemuxer2(probeData, config) {
                    this.TAG = "FLVDemuxer";
                    this._config = config;
                    this._onError = null;
                    this._onMediaInfo = null;
                    this._onMetaDataArrived = null;
                    this._onScriptDataArrived = null;
                    this._onTrackMetadata = null;
                    this._onDataAvailable = null;
                    this._dataOffset = probeData.dataOffset;
                    this._firstParse = true;
                    this._dispatch = false;
                    this._hasAudio = probeData.hasAudioTrack;
                    this._hasVideo = probeData.hasVideoTrack;
                    this._hasAudioFlagOverrided = false;
                    this._hasVideoFlagOverrided = false;
                    this._audioInitialMetadataDispatched = false;
                    this._videoInitialMetadataDispatched = false;
                    this._mediaInfo = new _core_media_info_js__WEBPACK_IMPORTED_MODULE_4__.default();
                    this._mediaInfo.hasAudio = this._hasAudio;
                    this._mediaInfo.hasVideo = this._hasVideo;
                    this._metadata = null;
                    this._audioMetadata = null;
                    this._videoMetadata = null;
                    this._naluLengthSize = 4;
                    this._timestampBase = 0;
                    this._timescale = 1e3;
                    this._duration = 0;
                    this._durationOverrided = false;
                    this._referenceFrameRate = {
                      fixed: true,
                      fps: 23.976,
                      fps_num: 23976,
                      fps_den: 1e3
                    };
                    this._flvSoundRateTable = [5500, 11025, 22050, 44100, 48e3];
                    this._mpegSamplingRates = [
                      96e3,
                      88200,
                      64e3,
                      48e3,
                      44100,
                      32e3,
                      24e3,
                      22050,
                      16e3,
                      12e3,
                      11025,
                      8e3,
                      7350
                    ];
                    this._mpegAudioV10SampleRateTable = [44100, 48e3, 32e3, 0];
                    this._mpegAudioV20SampleRateTable = [22050, 24e3, 16e3, 0];
                    this._mpegAudioV25SampleRateTable = [11025, 12e3, 8e3, 0];
                    this._mpegAudioL1BitRateTable = [0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1];
                    this._mpegAudioL2BitRateTable = [0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, -1];
                    this._mpegAudioL3BitRateTable = [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1];
                    this._videoTrack = { type: "video", id: 1, sequenceNumber: 0, samples: [], length: 0 };
                    this._audioTrack = { type: "audio", id: 2, sequenceNumber: 0, samples: [], length: 0 };
                    this._littleEndian = function() {
                      var buf = new ArrayBuffer(2);
                      new DataView(buf).setInt16(0, 256, true);
                      return new Int16Array(buf)[0] === 256;
                    }();
                  }
                  FLVDemuxer2.prototype.destroy = function() {
                    this._mediaInfo = null;
                    this._metadata = null;
                    this._audioMetadata = null;
                    this._videoMetadata = null;
                    this._videoTrack = null;
                    this._audioTrack = null;
                    this._onError = null;
                    this._onMediaInfo = null;
                    this._onMetaDataArrived = null;
                    this._onScriptDataArrived = null;
                    this._onTrackMetadata = null;
                    this._onDataAvailable = null;
                  };
                  FLVDemuxer2.probe = function(buffer) {
                    var data2 = new Uint8Array(buffer);
                    var mismatch = { match: false };
                    if (data2[0] !== 70 || data2[1] !== 76 || data2[2] !== 86 || data2[3] !== 1) {
                      return mismatch;
                    }
                    var hasAudio = (data2[4] & 4) >>> 2 !== 0;
                    var hasVideo = (data2[4] & 1) !== 0;
                    var offset = ReadBig32(data2, 5);
                    if (offset < 9) {
                      return mismatch;
                    }
                    return {
                      match: true,
                      consumed: offset,
                      dataOffset: offset,
                      hasAudioTrack: hasAudio,
                      hasVideoTrack: hasVideo
                    };
                  };
                  FLVDemuxer2.prototype.bindDataSource = function(loader) {
                    loader.onDataArrival = this.parseChunks.bind(this);
                    return this;
                  };
                  Object.defineProperty(FLVDemuxer2.prototype, "onTrackMetadata", {
                    // prototype: function(type: string, metadata: any): void
                    get: function() {
                      return this._onTrackMetadata;
                    },
                    set: function(callback) {
                      this._onTrackMetadata = callback;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(FLVDemuxer2.prototype, "onMediaInfo", {
                    // prototype: function(mediaInfo: MediaInfo): void
                    get: function() {
                      return this._onMediaInfo;
                    },
                    set: function(callback) {
                      this._onMediaInfo = callback;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(FLVDemuxer2.prototype, "onMetaDataArrived", {
                    get: function() {
                      return this._onMetaDataArrived;
                    },
                    set: function(callback) {
                      this._onMetaDataArrived = callback;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(FLVDemuxer2.prototype, "onScriptDataArrived", {
                    get: function() {
                      return this._onScriptDataArrived;
                    },
                    set: function(callback) {
                      this._onScriptDataArrived = callback;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(FLVDemuxer2.prototype, "onError", {
                    // prototype: function(type: number, info: string): void
                    get: function() {
                      return this._onError;
                    },
                    set: function(callback) {
                      this._onError = callback;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(FLVDemuxer2.prototype, "onDataAvailable", {
                    // prototype: function(videoTrack: any, audioTrack: any): void
                    get: function() {
                      return this._onDataAvailable;
                    },
                    set: function(callback) {
                      this._onDataAvailable = callback;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(FLVDemuxer2.prototype, "timestampBase", {
                    // timestamp base for output samples, must be in milliseconds
                    get: function() {
                      return this._timestampBase;
                    },
                    set: function(base) {
                      this._timestampBase = base;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(FLVDemuxer2.prototype, "overridedDuration", {
                    get: function() {
                      return this._duration;
                    },
                    // Force-override media duration. Must be in milliseconds, int32
                    set: function(duration) {
                      this._durationOverrided = true;
                      this._duration = duration;
                      this._mediaInfo.duration = duration;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(FLVDemuxer2.prototype, "overridedHasAudio", {
                    // Force-override audio track present flag, boolean
                    set: function(hasAudio) {
                      this._hasAudioFlagOverrided = true;
                      this._hasAudio = hasAudio;
                      this._mediaInfo.hasAudio = hasAudio;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(FLVDemuxer2.prototype, "overridedHasVideo", {
                    // Force-override video track present flag, boolean
                    set: function(hasVideo) {
                      this._hasVideoFlagOverrided = true;
                      this._hasVideo = hasVideo;
                      this._mediaInfo.hasVideo = hasVideo;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  FLVDemuxer2.prototype.resetMediaInfo = function() {
                    this._mediaInfo = new _core_media_info_js__WEBPACK_IMPORTED_MODULE_4__.default();
                  };
                  FLVDemuxer2.prototype._isInitialMetadataDispatched = function() {
                    if (this._hasAudio && this._hasVideo) {
                      return this._audioInitialMetadataDispatched && this._videoInitialMetadataDispatched;
                    }
                    if (this._hasAudio && !this._hasVideo) {
                      return this._audioInitialMetadataDispatched;
                    }
                    if (!this._hasAudio && this._hasVideo) {
                      return this._videoInitialMetadataDispatched;
                    }
                    return false;
                  };
                  FLVDemuxer2.prototype.parseChunks = function(chunk, byteStart) {
                    if (!this._onError || !this._onMediaInfo || !this._onTrackMetadata || !this._onDataAvailable) {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_5__.IllegalStateException("Flv: onError & onMediaInfo & onTrackMetadata & onDataAvailable callback must be specified");
                    }
                    var offset = 0;
                    var le2 = this._littleEndian;
                    if (byteStart === 0) {
                      if (chunk.byteLength > 13) {
                        var probeData = FLVDemuxer2.probe(chunk);
                        offset = probeData.dataOffset;
                      } else {
                        return 0;
                      }
                    }
                    if (this._firstParse) {
                      this._firstParse = false;
                      if (byteStart + offset !== this._dataOffset) {
                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "First time parsing but chunk byteStart invalid!");
                      }
                      var v2 = new DataView(chunk, offset);
                      var prevTagSize0 = v2.getUint32(0, !le2);
                      if (prevTagSize0 !== 0) {
                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "PrevTagSize0 !== 0 !!!");
                      }
                      offset += 4;
                    }
                    while (offset < chunk.byteLength) {
                      this._dispatch = true;
                      var v2 = new DataView(chunk, offset);
                      if (offset + 11 + 4 > chunk.byteLength) {
                        break;
                      }
                      var tagType = v2.getUint8(0);
                      var dataSize = v2.getUint32(0, !le2) & 16777215;
                      if (offset + 11 + dataSize + 4 > chunk.byteLength) {
                        break;
                      }
                      if (tagType !== 8 && tagType !== 9 && tagType !== 18) {
                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "Unsupported tag type " + tagType + ", skipped");
                        offset += 11 + dataSize + 4;
                        continue;
                      }
                      var ts2 = v2.getUint8(4);
                      var ts1 = v2.getUint8(5);
                      var ts0 = v2.getUint8(6);
                      var ts3 = v2.getUint8(7);
                      var timestamp = ts0 | ts1 << 8 | ts2 << 16 | ts3 << 24;
                      var streamId = v2.getUint32(7, !le2) & 16777215;
                      if (streamId !== 0) {
                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "Meet tag which has StreamID != 0!");
                      }
                      var dataOffset = offset + 11;
                      switch (tagType) {
                        case 8:
                          this._parseAudioData(chunk, dataOffset, dataSize, timestamp);
                          break;
                        case 9:
                          this._parseVideoData(chunk, dataOffset, dataSize, timestamp, byteStart + offset);
                          break;
                        case 18:
                          this._parseScriptData(chunk, dataOffset, dataSize);
                          break;
                      }
                      var prevTagSize = v2.getUint32(11 + dataSize, !le2);
                      if (prevTagSize !== 11 + dataSize) {
                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "Invalid PrevTagSize " + prevTagSize);
                      }
                      offset += 11 + dataSize + 4;
                    }
                    if (this._isInitialMetadataDispatched()) {
                      if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {
                        this._onDataAvailable(this._audioTrack, this._videoTrack);
                      }
                    }
                    return offset;
                  };
                  FLVDemuxer2.prototype._parseScriptData = function(arrayBuffer, dataOffset, dataSize) {
                    var scriptData = _amf_parser_js__WEBPACK_IMPORTED_MODULE_1__.default.parseScriptData(arrayBuffer, dataOffset, dataSize);
                    if (scriptData.hasOwnProperty("onMetaData")) {
                      if (scriptData.onMetaData == null || typeof scriptData.onMetaData !== "object") {
                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "Invalid onMetaData structure!");
                        return;
                      }
                      if (this._metadata) {
                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "Found another onMetaData tag!");
                      }
                      this._metadata = scriptData;
                      var onMetaData = this._metadata.onMetaData;
                      if (this._onMetaDataArrived) {
                        this._onMetaDataArrived(Object.assign({}, onMetaData));
                      }
                      if (typeof onMetaData.hasAudio === "boolean") {
                        if (this._hasAudioFlagOverrided === false) {
                          this._hasAudio = onMetaData.hasAudio;
                          this._mediaInfo.hasAudio = this._hasAudio;
                        }
                      }
                      if (typeof onMetaData.hasVideo === "boolean") {
                        if (this._hasVideoFlagOverrided === false) {
                          this._hasVideo = onMetaData.hasVideo;
                          this._mediaInfo.hasVideo = this._hasVideo;
                        }
                      }
                      if (typeof onMetaData.audiodatarate === "number") {
                        this._mediaInfo.audioDataRate = onMetaData.audiodatarate;
                      }
                      if (typeof onMetaData.videodatarate === "number") {
                        this._mediaInfo.videoDataRate = onMetaData.videodatarate;
                      }
                      if (typeof onMetaData.width === "number") {
                        this._mediaInfo.width = onMetaData.width;
                      }
                      if (typeof onMetaData.height === "number") {
                        this._mediaInfo.height = onMetaData.height;
                      }
                      if (typeof onMetaData.duration === "number") {
                        if (!this._durationOverrided) {
                          var duration = Math.floor(onMetaData.duration * this._timescale);
                          this._duration = duration;
                          this._mediaInfo.duration = duration;
                        }
                      } else {
                        this._mediaInfo.duration = 0;
                      }
                      if (typeof onMetaData.framerate === "number") {
                        var fps_num = Math.floor(onMetaData.framerate * 1e3);
                        if (fps_num > 0) {
                          var fps = fps_num / 1e3;
                          this._referenceFrameRate.fixed = true;
                          this._referenceFrameRate.fps = fps;
                          this._referenceFrameRate.fps_num = fps_num;
                          this._referenceFrameRate.fps_den = 1e3;
                          this._mediaInfo.fps = fps;
                        }
                      }
                      if (typeof onMetaData.keyframes === "object") {
                        this._mediaInfo.hasKeyframesIndex = true;
                        var keyframes2 = onMetaData.keyframes;
                        this._mediaInfo.keyframesIndex = this._parseKeyframesIndex(keyframes2);
                        onMetaData.keyframes = null;
                      } else {
                        this._mediaInfo.hasKeyframesIndex = false;
                      }
                      this._dispatch = false;
                      this._mediaInfo.metadata = onMetaData;
                      _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.v(this.TAG, "Parsed onMetaData");
                      if (this._mediaInfo.isComplete()) {
                        this._onMediaInfo(this._mediaInfo);
                      }
                    }
                    if (Object.keys(scriptData).length > 0) {
                      if (this._onScriptDataArrived) {
                        this._onScriptDataArrived(Object.assign({}, scriptData));
                      }
                    }
                  };
                  FLVDemuxer2.prototype._parseKeyframesIndex = function(keyframes2) {
                    var times = [];
                    var filepositions = [];
                    for (var i2 = 1; i2 < keyframes2.times.length; i2++) {
                      var time = this._timestampBase + Math.floor(keyframes2.times[i2] * 1e3);
                      times.push(time);
                      filepositions.push(keyframes2.filepositions[i2]);
                    }
                    return {
                      times,
                      filepositions
                    };
                  };
                  FLVDemuxer2.prototype._parseAudioData = function(arrayBuffer, dataOffset, dataSize, tagTimestamp) {
                    if (dataSize <= 1) {
                      _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "Flv: Invalid audio packet, missing SoundData payload!");
                      return;
                    }
                    if (this._hasAudioFlagOverrided === true && this._hasAudio === false) {
                      return;
                    }
                    this._littleEndian;
                    var v2 = new DataView(arrayBuffer, dataOffset, dataSize);
                    var soundSpec = v2.getUint8(0);
                    var soundFormat = soundSpec >>> 4;
                    if (soundFormat !== 2 && soundFormat !== 10) {
                      this._onError(_demux_errors_js__WEBPACK_IMPORTED_MODULE_3__.default.CODEC_UNSUPPORTED, "Flv: Unsupported audio codec idx: " + soundFormat);
                      return;
                    }
                    var soundRate = 0;
                    var soundRateIndex = (soundSpec & 12) >>> 2;
                    if (soundRateIndex >= 0 && soundRateIndex <= 4) {
                      soundRate = this._flvSoundRateTable[soundRateIndex];
                    } else {
                      this._onError(_demux_errors_js__WEBPACK_IMPORTED_MODULE_3__.default.FORMAT_ERROR, "Flv: Invalid audio sample rate idx: " + soundRateIndex);
                      return;
                    }
                    var soundType = soundSpec & 1;
                    var meta = this._audioMetadata;
                    var track = this._audioTrack;
                    if (!meta) {
                      if (this._hasAudio === false && this._hasAudioFlagOverrided === false) {
                        this._hasAudio = true;
                        this._mediaInfo.hasAudio = true;
                      }
                      meta = this._audioMetadata = {};
                      meta.type = "audio";
                      meta.id = track.id;
                      meta.timescale = this._timescale;
                      meta.duration = this._duration;
                      meta.audioSampleRate = soundRate;
                      meta.channelCount = soundType === 0 ? 1 : 2;
                    }
                    if (soundFormat === 10) {
                      var aacData = this._parseAACAudioData(arrayBuffer, dataOffset + 1, dataSize - 1);
                      if (aacData == void 0) {
                        return;
                      }
                      if (aacData.packetType === 0) {
                        if (meta.config) {
                          _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "Found another AudioSpecificConfig!");
                        }
                        var misc = aacData.data;
                        meta.audioSampleRate = misc.samplingRate;
                        meta.channelCount = misc.channelCount;
                        meta.codec = misc.codec;
                        meta.originalCodec = misc.originalCodec;
                        meta.config = misc.config;
                        meta.refSampleDuration = 1024 / meta.audioSampleRate * meta.timescale;
                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.v(this.TAG, "Parsed AudioSpecificConfig");
                        if (this._isInitialMetadataDispatched()) {
                          if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {
                            this._onDataAvailable(this._audioTrack, this._videoTrack);
                          }
                        } else {
                          this._audioInitialMetadataDispatched = true;
                        }
                        this._dispatch = false;
                        this._onTrackMetadata("audio", meta);
                        var mi2 = this._mediaInfo;
                        mi2.audioCodec = meta.originalCodec;
                        mi2.audioSampleRate = meta.audioSampleRate;
                        mi2.audioChannelCount = meta.channelCount;
                        if (mi2.hasVideo) {
                          if (mi2.videoCodec != null) {
                            mi2.mimeType = 'video/x-flv; codecs="' + mi2.videoCodec + "," + mi2.audioCodec + '"';
                          }
                        } else {
                          mi2.mimeType = 'video/x-flv; codecs="' + mi2.audioCodec + '"';
                        }
                        if (mi2.isComplete()) {
                          this._onMediaInfo(mi2);
                        }
                      } else if (aacData.packetType === 1) {
                        var dts = this._timestampBase + tagTimestamp;
                        var aacSample = { unit: aacData.data, length: aacData.data.byteLength, dts, pts: dts };
                        track.samples.push(aacSample);
                        track.length += aacData.data.length;
                      } else {
                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.e(this.TAG, "Flv: Unsupported AAC data type " + aacData.packetType);
                      }
                    } else if (soundFormat === 2) {
                      if (!meta.codec) {
                        var misc = this._parseMP3AudioData(arrayBuffer, dataOffset + 1, dataSize - 1, true);
                        if (misc == void 0) {
                          return;
                        }
                        meta.audioSampleRate = misc.samplingRate;
                        meta.channelCount = misc.channelCount;
                        meta.codec = misc.codec;
                        meta.originalCodec = misc.originalCodec;
                        meta.refSampleDuration = 1152 / meta.audioSampleRate * meta.timescale;
                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.v(this.TAG, "Parsed MPEG Audio Frame Header");
                        this._audioInitialMetadataDispatched = true;
                        this._onTrackMetadata("audio", meta);
                        var mi2 = this._mediaInfo;
                        mi2.audioCodec = meta.codec;
                        mi2.audioSampleRate = meta.audioSampleRate;
                        mi2.audioChannelCount = meta.channelCount;
                        mi2.audioDataRate = misc.bitRate;
                        if (mi2.hasVideo) {
                          if (mi2.videoCodec != null) {
                            mi2.mimeType = 'video/x-flv; codecs="' + mi2.videoCodec + "," + mi2.audioCodec + '"';
                          }
                        } else {
                          mi2.mimeType = 'video/x-flv; codecs="' + mi2.audioCodec + '"';
                        }
                        if (mi2.isComplete()) {
                          this._onMediaInfo(mi2);
                        }
                      }
                      var data2 = this._parseMP3AudioData(arrayBuffer, dataOffset + 1, dataSize - 1, false);
                      if (data2 == void 0) {
                        return;
                      }
                      var dts = this._timestampBase + tagTimestamp;
                      var mp3Sample = { unit: data2, length: data2.byteLength, dts, pts: dts };
                      track.samples.push(mp3Sample);
                      track.length += data2.length;
                    }
                  };
                  FLVDemuxer2.prototype._parseAACAudioData = function(arrayBuffer, dataOffset, dataSize) {
                    if (dataSize <= 1) {
                      _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "Flv: Invalid AAC packet, missing AACPacketType or/and Data!");
                      return;
                    }
                    var result = {};
                    var array = new Uint8Array(arrayBuffer, dataOffset, dataSize);
                    result.packetType = array[0];
                    if (array[0] === 0) {
                      result.data = this._parseAACAudioSpecificConfig(arrayBuffer, dataOffset + 1, dataSize - 1);
                    } else {
                      result.data = array.subarray(1);
                    }
                    return result;
                  };
                  FLVDemuxer2.prototype._parseAACAudioSpecificConfig = function(arrayBuffer, dataOffset, dataSize) {
                    var array = new Uint8Array(arrayBuffer, dataOffset, dataSize);
                    var config = null;
                    var audioObjectType = 0;
                    var originalAudioObjectType = 0;
                    var samplingIndex = 0;
                    var extensionSamplingIndex = null;
                    audioObjectType = originalAudioObjectType = array[0] >>> 3;
                    samplingIndex = (array[0] & 7) << 1 | array[1] >>> 7;
                    if (samplingIndex < 0 || samplingIndex >= this._mpegSamplingRates.length) {
                      this._onError(_demux_errors_js__WEBPACK_IMPORTED_MODULE_3__.default.FORMAT_ERROR, "Flv: AAC invalid sampling frequency index!");
                      return;
                    }
                    var samplingFrequence = this._mpegSamplingRates[samplingIndex];
                    var channelConfig = (array[1] & 120) >>> 3;
                    if (channelConfig < 0 || channelConfig >= 8) {
                      this._onError(_demux_errors_js__WEBPACK_IMPORTED_MODULE_3__.default.FORMAT_ERROR, "Flv: AAC invalid channel configuration");
                      return;
                    }
                    if (audioObjectType === 5) {
                      extensionSamplingIndex = (array[1] & 7) << 1 | array[2] >>> 7;
                      (array[2] & 124) >>> 2;
                    }
                    var userAgent2 = self.navigator.userAgent.toLowerCase();
                    if (userAgent2.indexOf("firefox") !== -1) {
                      if (samplingIndex >= 6) {
                        audioObjectType = 5;
                        config = new Array(4);
                        extensionSamplingIndex = samplingIndex - 3;
                      } else {
                        audioObjectType = 2;
                        config = new Array(2);
                        extensionSamplingIndex = samplingIndex;
                      }
                    } else if (userAgent2.indexOf("android") !== -1) {
                      audioObjectType = 2;
                      config = new Array(2);
                      extensionSamplingIndex = samplingIndex;
                    } else {
                      audioObjectType = 5;
                      extensionSamplingIndex = samplingIndex;
                      config = new Array(4);
                      if (samplingIndex >= 6) {
                        extensionSamplingIndex = samplingIndex - 3;
                      } else if (channelConfig === 1) {
                        audioObjectType = 2;
                        config = new Array(2);
                        extensionSamplingIndex = samplingIndex;
                      }
                    }
                    config[0] = audioObjectType << 3;
                    config[0] |= (samplingIndex & 15) >>> 1;
                    config[1] = (samplingIndex & 15) << 7;
                    config[1] |= (channelConfig & 15) << 3;
                    if (audioObjectType === 5) {
                      config[1] |= (extensionSamplingIndex & 15) >>> 1;
                      config[2] = (extensionSamplingIndex & 1) << 7;
                      config[2] |= 2 << 2;
                      config[3] = 0;
                    }
                    return {
                      config,
                      samplingRate: samplingFrequence,
                      channelCount: channelConfig,
                      codec: "mp4a.40." + audioObjectType,
                      originalCodec: "mp4a.40." + originalAudioObjectType
                    };
                  };
                  FLVDemuxer2.prototype._parseMP3AudioData = function(arrayBuffer, dataOffset, dataSize, requestHeader) {
                    if (dataSize < 4) {
                      _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "Flv: Invalid MP3 packet, header missing!");
                      return;
                    }
                    this._littleEndian;
                    var array = new Uint8Array(arrayBuffer, dataOffset, dataSize);
                    var result = null;
                    if (requestHeader) {
                      if (array[0] !== 255) {
                        return;
                      }
                      var ver = array[1] >>> 3 & 3;
                      var layer = (array[1] & 6) >> 1;
                      var bitrate_index = (array[2] & 240) >>> 4;
                      var sampling_freq_index = (array[2] & 12) >>> 2;
                      var channel_mode = array[3] >>> 6 & 3;
                      var channel_count = channel_mode !== 3 ? 2 : 1;
                      var sample_rate = 0;
                      var bit_rate = 0;
                      var codec = "mp3";
                      switch (ver) {
                        case 0:
                          sample_rate = this._mpegAudioV25SampleRateTable[sampling_freq_index];
                          break;
                        case 2:
                          sample_rate = this._mpegAudioV20SampleRateTable[sampling_freq_index];
                          break;
                        case 3:
                          sample_rate = this._mpegAudioV10SampleRateTable[sampling_freq_index];
                          break;
                      }
                      switch (layer) {
                        case 1:
                          if (bitrate_index < this._mpegAudioL3BitRateTable.length) {
                            bit_rate = this._mpegAudioL3BitRateTable[bitrate_index];
                          }
                          break;
                        case 2:
                          if (bitrate_index < this._mpegAudioL2BitRateTable.length) {
                            bit_rate = this._mpegAudioL2BitRateTable[bitrate_index];
                          }
                          break;
                        case 3:
                          if (bitrate_index < this._mpegAudioL1BitRateTable.length) {
                            bit_rate = this._mpegAudioL1BitRateTable[bitrate_index];
                          }
                          break;
                      }
                      result = {
                        bitRate: bit_rate,
                        samplingRate: sample_rate,
                        channelCount: channel_count,
                        codec,
                        originalCodec: codec
                      };
                    } else {
                      result = array;
                    }
                    return result;
                  };
                  FLVDemuxer2.prototype._parseVideoData = function(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition) {
                    if (dataSize <= 1) {
                      _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "Flv: Invalid video packet, missing VideoData payload!");
                      return;
                    }
                    if (this._hasVideoFlagOverrided === true && this._hasVideo === false) {
                      return;
                    }
                    var spec = new Uint8Array(arrayBuffer, dataOffset, dataSize)[0];
                    var frameType = (spec & 240) >>> 4;
                    var codecId = spec & 15;
                    if (codecId !== 7) {
                      this._onError(_demux_errors_js__WEBPACK_IMPORTED_MODULE_3__.default.CODEC_UNSUPPORTED, "Flv: Unsupported codec in video frame: " + codecId);
                      return;
                    }
                    this._parseAVCVideoPacket(arrayBuffer, dataOffset + 1, dataSize - 1, tagTimestamp, tagPosition, frameType);
                  };
                  FLVDemuxer2.prototype._parseAVCVideoPacket = function(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition, frameType) {
                    if (dataSize < 4) {
                      _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "Flv: Invalid AVC packet, missing AVCPacketType or/and CompositionTime");
                      return;
                    }
                    var le2 = this._littleEndian;
                    var v2 = new DataView(arrayBuffer, dataOffset, dataSize);
                    var packetType = v2.getUint8(0);
                    var cts_unsigned = v2.getUint32(0, !le2) & 16777215;
                    var cts = cts_unsigned << 8 >> 8;
                    if (packetType === 0) {
                      this._parseAVCDecoderConfigurationRecord(arrayBuffer, dataOffset + 4, dataSize - 4);
                    } else if (packetType === 1) {
                      this._parseAVCVideoData(arrayBuffer, dataOffset + 4, dataSize - 4, tagTimestamp, tagPosition, frameType, cts);
                    } else if (packetType === 2)
                      ;
                    else {
                      this._onError(_demux_errors_js__WEBPACK_IMPORTED_MODULE_3__.default.FORMAT_ERROR, "Flv: Invalid video packet type " + packetType);
                      return;
                    }
                  };
                  FLVDemuxer2.prototype._parseAVCDecoderConfigurationRecord = function(arrayBuffer, dataOffset, dataSize) {
                    if (dataSize < 7) {
                      _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "Flv: Invalid AVCDecoderConfigurationRecord, lack of data!");
                      return;
                    }
                    var meta = this._videoMetadata;
                    var track = this._videoTrack;
                    var le2 = this._littleEndian;
                    var v2 = new DataView(arrayBuffer, dataOffset, dataSize);
                    if (!meta) {
                      if (this._hasVideo === false && this._hasVideoFlagOverrided === false) {
                        this._hasVideo = true;
                        this._mediaInfo.hasVideo = true;
                      }
                      meta = this._videoMetadata = {};
                      meta.type = "video";
                      meta.id = track.id;
                      meta.timescale = this._timescale;
                      meta.duration = this._duration;
                    } else {
                      if (typeof meta.avcc !== "undefined") {
                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "Found another AVCDecoderConfigurationRecord!");
                      }
                    }
                    var version = v2.getUint8(0);
                    var avcProfile = v2.getUint8(1);
                    v2.getUint8(2);
                    v2.getUint8(3);
                    if (version !== 1 || avcProfile === 0) {
                      this._onError(_demux_errors_js__WEBPACK_IMPORTED_MODULE_3__.default.FORMAT_ERROR, "Flv: Invalid AVCDecoderConfigurationRecord");
                      return;
                    }
                    this._naluLengthSize = (v2.getUint8(4) & 3) + 1;
                    if (this._naluLengthSize !== 3 && this._naluLengthSize !== 4) {
                      this._onError(_demux_errors_js__WEBPACK_IMPORTED_MODULE_3__.default.FORMAT_ERROR, "Flv: Strange NaluLengthSizeMinusOne: " + (this._naluLengthSize - 1));
                      return;
                    }
                    var spsCount = v2.getUint8(5) & 31;
                    if (spsCount === 0) {
                      this._onError(_demux_errors_js__WEBPACK_IMPORTED_MODULE_3__.default.FORMAT_ERROR, "Flv: Invalid AVCDecoderConfigurationRecord: No SPS");
                      return;
                    } else if (spsCount > 1) {
                      _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "Flv: Strange AVCDecoderConfigurationRecord: SPS Count = " + spsCount);
                    }
                    var offset = 6;
                    for (var i2 = 0; i2 < spsCount; i2++) {
                      var len = v2.getUint16(offset, !le2);
                      offset += 2;
                      if (len === 0) {
                        continue;
                      }
                      var sps = new Uint8Array(arrayBuffer, dataOffset + offset, len);
                      offset += len;
                      var config = _sps_parser_js__WEBPACK_IMPORTED_MODULE_2__.default.parseSPS(sps);
                      if (i2 !== 0) {
                        continue;
                      }
                      meta.codecWidth = config.codec_size.width;
                      meta.codecHeight = config.codec_size.height;
                      meta.presentWidth = config.present_size.width;
                      meta.presentHeight = config.present_size.height;
                      meta.profile = config.profile_string;
                      meta.level = config.level_string;
                      meta.bitDepth = config.bit_depth;
                      meta.chromaFormat = config.chroma_format;
                      meta.sarRatio = config.sar_ratio;
                      meta.frameRate = config.frame_rate;
                      if (config.frame_rate.fixed === false || config.frame_rate.fps_num === 0 || config.frame_rate.fps_den === 0) {
                        meta.frameRate = this._referenceFrameRate;
                      }
                      var fps_den = meta.frameRate.fps_den;
                      var fps_num = meta.frameRate.fps_num;
                      meta.refSampleDuration = meta.timescale * (fps_den / fps_num);
                      var codecArray = sps.subarray(1, 4);
                      var codecString = "avc1.";
                      for (var j2 = 0; j2 < 3; j2++) {
                        var h2 = codecArray[j2].toString(16);
                        if (h2.length < 2) {
                          h2 = "0" + h2;
                        }
                        codecString += h2;
                      }
                      meta.codec = codecString;
                      var mi2 = this._mediaInfo;
                      mi2.width = meta.codecWidth;
                      mi2.height = meta.codecHeight;
                      mi2.fps = meta.frameRate.fps;
                      mi2.profile = meta.profile;
                      mi2.level = meta.level;
                      mi2.refFrames = config.ref_frames;
                      mi2.chromaFormat = config.chroma_format_string;
                      mi2.sarNum = meta.sarRatio.width;
                      mi2.sarDen = meta.sarRatio.height;
                      mi2.videoCodec = codecString;
                      if (mi2.hasAudio) {
                        if (mi2.audioCodec != null) {
                          mi2.mimeType = 'video/x-flv; codecs="' + mi2.videoCodec + "," + mi2.audioCodec + '"';
                        }
                      } else {
                        mi2.mimeType = 'video/x-flv; codecs="' + mi2.videoCodec + '"';
                      }
                      if (mi2.isComplete()) {
                        this._onMediaInfo(mi2);
                      }
                    }
                    var ppsCount = v2.getUint8(offset);
                    if (ppsCount === 0) {
                      this._onError(_demux_errors_js__WEBPACK_IMPORTED_MODULE_3__.default.FORMAT_ERROR, "Flv: Invalid AVCDecoderConfigurationRecord: No PPS");
                      return;
                    } else if (ppsCount > 1) {
                      _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "Flv: Strange AVCDecoderConfigurationRecord: PPS Count = " + ppsCount);
                    }
                    offset++;
                    for (var i2 = 0; i2 < ppsCount; i2++) {
                      var len = v2.getUint16(offset, !le2);
                      offset += 2;
                      if (len === 0) {
                        continue;
                      }
                      offset += len;
                    }
                    meta.avcc = new Uint8Array(dataSize);
                    meta.avcc.set(new Uint8Array(arrayBuffer, dataOffset, dataSize), 0);
                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.v(this.TAG, "Parsed AVCDecoderConfigurationRecord");
                    if (this._isInitialMetadataDispatched()) {
                      if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {
                        this._onDataAvailable(this._audioTrack, this._videoTrack);
                      }
                    } else {
                      this._videoInitialMetadataDispatched = true;
                    }
                    this._dispatch = false;
                    this._onTrackMetadata("video", meta);
                  };
                  FLVDemuxer2.prototype._parseAVCVideoData = function(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition, frameType, cts) {
                    var le2 = this._littleEndian;
                    var v2 = new DataView(arrayBuffer, dataOffset, dataSize);
                    var units = [], length2 = 0;
                    var offset = 0;
                    var lengthSize = this._naluLengthSize;
                    var dts = this._timestampBase + tagTimestamp;
                    var keyframe = frameType === 1;
                    while (offset < dataSize) {
                      if (offset + 4 >= dataSize) {
                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "Malformed Nalu near timestamp " + dts + ", offset = " + offset + ", dataSize = " + dataSize);
                        break;
                      }
                      var naluSize = v2.getUint32(offset, !le2);
                      if (lengthSize === 3) {
                        naluSize >>>= 8;
                      }
                      if (naluSize > dataSize - lengthSize) {
                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "Malformed Nalus near timestamp " + dts + ", NaluSize > DataSize!");
                        return;
                      }
                      var unitType = v2.getUint8(offset + lengthSize) & 31;
                      if (unitType === 5) {
                        keyframe = true;
                      }
                      var data2 = new Uint8Array(arrayBuffer, dataOffset + offset, lengthSize + naluSize);
                      var unit = { type: unitType, data: data2 };
                      units.push(unit);
                      length2 += data2.byteLength;
                      offset += lengthSize + naluSize;
                    }
                    if (units.length) {
                      var track = this._videoTrack;
                      var avcSample = {
                        units,
                        length: length2,
                        isKeyframe: keyframe,
                        dts,
                        cts,
                        pts: dts + cts
                      };
                      if (keyframe) {
                        avcSample.fileposition = tagPosition;
                      }
                      track.samples.push(avcSample);
                      track.length += length2;
                    }
                  };
                  return FLVDemuxer2;
                }()
              );
              __webpack_exports__2["default"] = FLVDemuxer;
            }
          ),
          /***/
          "./src/demux/sps-parser.js": (
            /*!*********************************!*\
              !*** ./src/demux/sps-parser.js ***!
              \*********************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var _exp_golomb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./exp-golomb.js */
                "./src/demux/exp-golomb.js"
              );
              var SPSParser = (
                /** @class */
                function() {
                  function SPSParser2() {
                  }
                  SPSParser2._ebsp2rbsp = function(uint8array) {
                    var src = uint8array;
                    var src_length = src.byteLength;
                    var dst = new Uint8Array(src_length);
                    var dst_idx = 0;
                    for (var i2 = 0; i2 < src_length; i2++) {
                      if (i2 >= 2) {
                        if (src[i2] === 3 && src[i2 - 1] === 0 && src[i2 - 2] === 0) {
                          continue;
                        }
                      }
                      dst[dst_idx] = src[i2];
                      dst_idx++;
                    }
                    return new Uint8Array(dst.buffer, 0, dst_idx);
                  };
                  SPSParser2.parseSPS = function(uint8array) {
                    var rbsp = SPSParser2._ebsp2rbsp(uint8array);
                    var gb2 = new _exp_golomb_js__WEBPACK_IMPORTED_MODULE_0__.default(rbsp);
                    gb2.readByte();
                    var profile_idc = gb2.readByte();
                    gb2.readByte();
                    var level_idc = gb2.readByte();
                    gb2.readUEG();
                    var profile_string = SPSParser2.getProfileString(profile_idc);
                    var level_string = SPSParser2.getLevelString(level_idc);
                    var chroma_format_idc = 1;
                    var chroma_format = 420;
                    var chroma_format_table = [0, 420, 422, 444];
                    var bit_depth = 8;
                    if (profile_idc === 100 || profile_idc === 110 || profile_idc === 122 || profile_idc === 244 || profile_idc === 44 || profile_idc === 83 || profile_idc === 86 || profile_idc === 118 || profile_idc === 128 || profile_idc === 138 || profile_idc === 144) {
                      chroma_format_idc = gb2.readUEG();
                      if (chroma_format_idc === 3) {
                        gb2.readBits(1);
                      }
                      if (chroma_format_idc <= 3) {
                        chroma_format = chroma_format_table[chroma_format_idc];
                      }
                      bit_depth = gb2.readUEG() + 8;
                      gb2.readUEG();
                      gb2.readBits(1);
                      if (gb2.readBool()) {
                        var scaling_list_count = chroma_format_idc !== 3 ? 8 : 12;
                        for (var i2 = 0; i2 < scaling_list_count; i2++) {
                          if (gb2.readBool()) {
                            if (i2 < 6) {
                              SPSParser2._skipScalingList(gb2, 16);
                            } else {
                              SPSParser2._skipScalingList(gb2, 64);
                            }
                          }
                        }
                      }
                    }
                    gb2.readUEG();
                    var pic_order_cnt_type = gb2.readUEG();
                    if (pic_order_cnt_type === 0) {
                      gb2.readUEG();
                    } else if (pic_order_cnt_type === 1) {
                      gb2.readBits(1);
                      gb2.readSEG();
                      gb2.readSEG();
                      var num_ref_frames_in_pic_order_cnt_cycle = gb2.readUEG();
                      for (var i2 = 0; i2 < num_ref_frames_in_pic_order_cnt_cycle; i2++) {
                        gb2.readSEG();
                      }
                    }
                    var ref_frames = gb2.readUEG();
                    gb2.readBits(1);
                    var pic_width_in_mbs_minus1 = gb2.readUEG();
                    var pic_height_in_map_units_minus1 = gb2.readUEG();
                    var frame_mbs_only_flag = gb2.readBits(1);
                    if (frame_mbs_only_flag === 0) {
                      gb2.readBits(1);
                    }
                    gb2.readBits(1);
                    var frame_crop_left_offset = 0;
                    var frame_crop_right_offset = 0;
                    var frame_crop_top_offset = 0;
                    var frame_crop_bottom_offset = 0;
                    var frame_cropping_flag = gb2.readBool();
                    if (frame_cropping_flag) {
                      frame_crop_left_offset = gb2.readUEG();
                      frame_crop_right_offset = gb2.readUEG();
                      frame_crop_top_offset = gb2.readUEG();
                      frame_crop_bottom_offset = gb2.readUEG();
                    }
                    var sar_width = 1, sar_height = 1;
                    var fps = 0, fps_fixed = true, fps_num = 0, fps_den = 0;
                    var vui_parameters_present_flag = gb2.readBool();
                    if (vui_parameters_present_flag) {
                      if (gb2.readBool()) {
                        var aspect_ratio_idc = gb2.readByte();
                        var sar_w_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];
                        var sar_h_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];
                        if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {
                          sar_width = sar_w_table[aspect_ratio_idc - 1];
                          sar_height = sar_h_table[aspect_ratio_idc - 1];
                        } else if (aspect_ratio_idc === 255) {
                          sar_width = gb2.readByte() << 8 | gb2.readByte();
                          sar_height = gb2.readByte() << 8 | gb2.readByte();
                        }
                      }
                      if (gb2.readBool()) {
                        gb2.readBool();
                      }
                      if (gb2.readBool()) {
                        gb2.readBits(4);
                        if (gb2.readBool()) {
                          gb2.readBits(24);
                        }
                      }
                      if (gb2.readBool()) {
                        gb2.readUEG();
                        gb2.readUEG();
                      }
                      if (gb2.readBool()) {
                        var num_units_in_tick = gb2.readBits(32);
                        var time_scale = gb2.readBits(32);
                        fps_fixed = gb2.readBool();
                        fps_num = time_scale;
                        fps_den = num_units_in_tick * 2;
                        fps = fps_num / fps_den;
                      }
                    }
                    var sarScale = 1;
                    if (sar_width !== 1 || sar_height !== 1) {
                      sarScale = sar_width / sar_height;
                    }
                    var crop_unit_x = 0, crop_unit_y = 0;
                    if (chroma_format_idc === 0) {
                      crop_unit_x = 1;
                      crop_unit_y = 2 - frame_mbs_only_flag;
                    } else {
                      var sub_wc = chroma_format_idc === 3 ? 1 : 2;
                      var sub_hc = chroma_format_idc === 1 ? 2 : 1;
                      crop_unit_x = sub_wc;
                      crop_unit_y = sub_hc * (2 - frame_mbs_only_flag);
                    }
                    var codec_width = (pic_width_in_mbs_minus1 + 1) * 16;
                    var codec_height = (2 - frame_mbs_only_flag) * ((pic_height_in_map_units_minus1 + 1) * 16);
                    codec_width -= (frame_crop_left_offset + frame_crop_right_offset) * crop_unit_x;
                    codec_height -= (frame_crop_top_offset + frame_crop_bottom_offset) * crop_unit_y;
                    var present_width = Math.ceil(codec_width * sarScale);
                    gb2.destroy();
                    gb2 = null;
                    return {
                      profile_string,
                      level_string,
                      bit_depth,
                      ref_frames,
                      chroma_format,
                      chroma_format_string: SPSParser2.getChromaFormatString(chroma_format),
                      frame_rate: {
                        fixed: fps_fixed,
                        fps,
                        fps_den,
                        fps_num
                      },
                      sar_ratio: {
                        width: sar_width,
                        height: sar_height
                      },
                      codec_size: {
                        width: codec_width,
                        height: codec_height
                      },
                      present_size: {
                        width: present_width,
                        height: codec_height
                      }
                    };
                  };
                  SPSParser2._skipScalingList = function(gb2, count) {
                    var last_scale = 8, next_scale = 8;
                    var delta_scale = 0;
                    for (var i2 = 0; i2 < count; i2++) {
                      if (next_scale !== 0) {
                        delta_scale = gb2.readSEG();
                        next_scale = (last_scale + delta_scale + 256) % 256;
                      }
                      last_scale = next_scale === 0 ? last_scale : next_scale;
                    }
                  };
                  SPSParser2.getProfileString = function(profile_idc) {
                    switch (profile_idc) {
                      case 66:
                        return "Baseline";
                      case 77:
                        return "Main";
                      case 88:
                        return "Extended";
                      case 100:
                        return "High";
                      case 110:
                        return "High10";
                      case 122:
                        return "High422";
                      case 244:
                        return "High444";
                      default:
                        return "Unknown";
                    }
                  };
                  SPSParser2.getLevelString = function(level_idc) {
                    return (level_idc / 10).toFixed(1);
                  };
                  SPSParser2.getChromaFormatString = function(chroma) {
                    switch (chroma) {
                      case 420:
                        return "4:2:0";
                      case 422:
                        return "4:2:2";
                      case 444:
                        return "4:4:4";
                      default:
                        return "Unknown";
                    }
                  };
                  return SPSParser2;
                }()
              );
              __webpack_exports__2["default"] = SPSParser;
            }
          ),
          /***/
          "./src/flv.js": (
            /*!********************!*\
              !*** ./src/flv.js ***!
              \********************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var _utils_polyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./utils/polyfill.js */
                "./src/utils/polyfill.js"
              );
              var _core_features_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./core/features.js */
                "./src/core/features.js"
              );
              var _io_loader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./io/loader.js */
                "./src/io/loader.js"
              );
              var _player_flv_player_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./player/flv-player.js */
                "./src/player/flv-player.js"
              );
              var _player_native_player_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./player/native-player.js */
                "./src/player/native-player.js"
              );
              var _player_player_events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ./player/player-events.js */
                "./src/player/player-events.js"
              );
              var _player_player_errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                /*! ./player/player-errors.js */
                "./src/player/player-errors.js"
              );
              var _utils_logging_control_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                /*! ./utils/logging-control.js */
                "./src/utils/logging-control.js"
              );
              var _utils_exception_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                /*! ./utils/exception.js */
                "./src/utils/exception.js"
              );
              _utils_polyfill_js__WEBPACK_IMPORTED_MODULE_0__.default.install();
              function createPlayer(mediaDataSource, optionalConfig) {
                var mds = mediaDataSource;
                if (mds == null || typeof mds !== "object") {
                  throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentException("MediaDataSource must be an javascript object!");
                }
                if (!mds.hasOwnProperty("type")) {
                  throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentException("MediaDataSource must has type field to indicate video file type!");
                }
                switch (mds.type) {
                  case "flv":
                    return new _player_flv_player_js__WEBPACK_IMPORTED_MODULE_3__.default(mds, optionalConfig);
                  default:
                    return new _player_native_player_js__WEBPACK_IMPORTED_MODULE_4__.default(mds, optionalConfig);
                }
              }
              function isSupported() {
                return _core_features_js__WEBPACK_IMPORTED_MODULE_1__.default.supportMSEH264Playback();
              }
              function getFeatureList() {
                return _core_features_js__WEBPACK_IMPORTED_MODULE_1__.default.getFeatureList();
              }
              var flvjs = {};
              flvjs.createPlayer = createPlayer;
              flvjs.isSupported = isSupported;
              flvjs.getFeatureList = getFeatureList;
              flvjs.BaseLoader = _io_loader_js__WEBPACK_IMPORTED_MODULE_2__.BaseLoader;
              flvjs.LoaderStatus = _io_loader_js__WEBPACK_IMPORTED_MODULE_2__.LoaderStatus;
              flvjs.LoaderErrors = _io_loader_js__WEBPACK_IMPORTED_MODULE_2__.LoaderErrors;
              flvjs.Events = _player_player_events_js__WEBPACK_IMPORTED_MODULE_5__.default;
              flvjs.ErrorTypes = _player_player_errors_js__WEBPACK_IMPORTED_MODULE_6__.ErrorTypes;
              flvjs.ErrorDetails = _player_player_errors_js__WEBPACK_IMPORTED_MODULE_6__.ErrorDetails;
              flvjs.FlvPlayer = _player_flv_player_js__WEBPACK_IMPORTED_MODULE_3__.default;
              flvjs.NativePlayer = _player_native_player_js__WEBPACK_IMPORTED_MODULE_4__.default;
              flvjs.LoggingControl = _utils_logging_control_js__WEBPACK_IMPORTED_MODULE_7__.default;
              Object.defineProperty(flvjs, "version", {
                enumerable: true,
                get: function() {
                  return "1.6.2";
                }
              });
              __webpack_exports__2["default"] = flvjs;
            }
          ),
          /***/
          "./src/index.js": (
            /*!**********************!*\
              !*** ./src/index.js ***!
              \**********************/
            /***/
            function(module2, __unused_webpack_exports, __webpack_require__2) {
              module2.exports = __webpack_require__2(
                /*! ./flv.js */
                "./src/flv.js"
              ).default;
            }
          ),
          /***/
          "./src/io/fetch-stream-loader.js": (
            /*!***************************************!*\
              !*** ./src/io/fetch-stream-loader.js ***!
              \***************************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var _utils_browser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../utils/browser.js */
                "./src/utils/browser.js"
              );
              var _loader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./loader.js */
                "./src/io/loader.js"
              );
              var _utils_exception_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              );
              var __extends2 = function() {
                var extendStatics2 = function(d2, b2) {
                  extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
                    d3.__proto__ = b3;
                  } || function(d3, b3) {
                    for (var p in b3)
                      if (Object.prototype.hasOwnProperty.call(b3, p))
                        d3[p] = b3[p];
                  };
                  return extendStatics2(d2, b2);
                };
                return function(d2, b2) {
                  if (typeof b2 !== "function" && b2 !== null)
                    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
                  extendStatics2(d2, b2);
                  function __() {
                    this.constructor = d2;
                  }
                  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
                };
              }();
              var FetchStreamLoader = (
                /** @class */
                function(_super) {
                  __extends2(FetchStreamLoader2, _super);
                  function FetchStreamLoader2(seekHandler, config) {
                    var _this = _super.call(this, "fetch-stream-loader") || this;
                    _this.TAG = "FetchStreamLoader";
                    _this._seekHandler = seekHandler;
                    _this._config = config;
                    _this._needStash = true;
                    _this._requestAbort = false;
                    _this._contentLength = null;
                    _this._receivedLength = 0;
                    return _this;
                  }
                  FetchStreamLoader2.isSupported = function() {
                    try {
                      var isWorkWellEdge = _utils_browser_js__WEBPACK_IMPORTED_MODULE_0__.default.msedge && _utils_browser_js__WEBPACK_IMPORTED_MODULE_0__.default.version.minor >= 15048;
                      var browserNotBlacklisted = _utils_browser_js__WEBPACK_IMPORTED_MODULE_0__.default.msedge ? isWorkWellEdge : true;
                      return self.fetch && self.ReadableStream && browserNotBlacklisted;
                    } catch (e2) {
                      return false;
                    }
                  };
                  FetchStreamLoader2.prototype.destroy = function() {
                    if (this.isWorking()) {
                      this.abort();
                    }
                    _super.prototype.destroy.call(this);
                  };
                  FetchStreamLoader2.prototype.open = function(dataSource, range2) {
                    var _this = this;
                    this._dataSource = dataSource;
                    this._range = range2;
                    var sourceURL = dataSource.url;
                    if (this._config.reuseRedirectedURL && dataSource.redirectedURL != void 0) {
                      sourceURL = dataSource.redirectedURL;
                    }
                    var seekConfig = this._seekHandler.getConfig(sourceURL, range2);
                    var headers = new self.Headers();
                    if (typeof seekConfig.headers === "object") {
                      var configHeaders = seekConfig.headers;
                      for (var key in configHeaders) {
                        if (configHeaders.hasOwnProperty(key)) {
                          headers.append(key, configHeaders[key]);
                        }
                      }
                    }
                    var params = {
                      method: "GET",
                      headers,
                      mode: "cors",
                      cache: "default",
                      // The default policy of Fetch API in the whatwg standard
                      // Safari incorrectly indicates 'no-referrer' as default policy, fuck it
                      referrerPolicy: "no-referrer-when-downgrade"
                    };
                    if (typeof this._config.headers === "object") {
                      for (var key in this._config.headers) {
                        headers.append(key, this._config.headers[key]);
                      }
                    }
                    if (dataSource.cors === false) {
                      params.mode = "same-origin";
                    }
                    if (dataSource.withCredentials) {
                      params.credentials = "include";
                    }
                    if (dataSource.referrerPolicy) {
                      params.referrerPolicy = dataSource.referrerPolicy;
                    }
                    if (self.AbortController) {
                      this._abortController = new self.AbortController();
                      params.signal = this._abortController.signal;
                    }
                    this._status = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderStatus.kConnecting;
                    self.fetch(seekConfig.url, params).then(function(res) {
                      if (_this._requestAbort) {
                        _this._status = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderStatus.kIdle;
                        res.body.cancel();
                        return;
                      }
                      if (res.ok && (res.status >= 200 && res.status <= 299)) {
                        if (res.url !== seekConfig.url) {
                          if (_this._onURLRedirect) {
                            var redirectedURL = _this._seekHandler.removeURLParameters(res.url);
                            _this._onURLRedirect(redirectedURL);
                          }
                        }
                        var lengthHeader = res.headers.get("Content-Length");
                        if (lengthHeader != null) {
                          _this._contentLength = parseInt(lengthHeader);
                          if (_this._contentLength !== 0) {
                            if (_this._onContentLengthKnown) {
                              _this._onContentLengthKnown(_this._contentLength);
                            }
                          }
                        }
                        return _this._pump.call(_this, res.body.getReader());
                      } else {
                        _this._status = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderStatus.kError;
                        if (_this._onError) {
                          _this._onError(_loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderErrors.HTTP_STATUS_CODE_INVALID, { code: res.status, msg: res.statusText });
                        } else {
                          throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_2__.RuntimeException("FetchStreamLoader: Http code invalid, " + res.status + " " + res.statusText);
                        }
                      }
                    }).catch(function(e2) {
                      if (_this._abortController && _this._abortController.signal.aborted) {
                        return;
                      }
                      _this._status = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderStatus.kError;
                      if (_this._onError) {
                        _this._onError(_loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderErrors.EXCEPTION, { code: -1, msg: e2.message });
                      } else {
                        throw e2;
                      }
                    });
                  };
                  FetchStreamLoader2.prototype.abort = function() {
                    this._requestAbort = true;
                    if (this._status !== _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderStatus.kBuffering || !_utils_browser_js__WEBPACK_IMPORTED_MODULE_0__.default.chrome) {
                      if (this._abortController) {
                        try {
                          this._abortController.abort();
                        } catch (e2) {
                        }
                      }
                    }
                  };
                  FetchStreamLoader2.prototype._pump = function(reader) {
                    var _this = this;
                    return reader.read().then(function(result) {
                      if (result.done) {
                        if (_this._contentLength !== null && _this._receivedLength < _this._contentLength) {
                          _this._status = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderStatus.kError;
                          var type2 = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderErrors.EARLY_EOF;
                          var info = { code: -1, msg: "Fetch stream meet Early-EOF" };
                          if (_this._onError) {
                            _this._onError(type2, info);
                          } else {
                            throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_2__.RuntimeException(info.msg);
                          }
                        } else {
                          _this._status = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderStatus.kComplete;
                          if (_this._onComplete) {
                            _this._onComplete(_this._range.from, _this._range.from + _this._receivedLength - 1);
                          }
                        }
                      } else {
                        if (_this._abortController && _this._abortController.signal.aborted) {
                          _this._status = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderStatus.kComplete;
                          return;
                        } else if (_this._requestAbort === true) {
                          _this._status = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderStatus.kComplete;
                          return reader.cancel();
                        }
                        _this._status = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderStatus.kBuffering;
                        var chunk = result.value.buffer;
                        var byteStart = _this._range.from + _this._receivedLength;
                        _this._receivedLength += chunk.byteLength;
                        if (_this._onDataArrival) {
                          _this._onDataArrival(chunk, byteStart, _this._receivedLength);
                        }
                        _this._pump(reader);
                      }
                    }).catch(function(e2) {
                      if (_this._abortController && _this._abortController.signal.aborted) {
                        _this._status = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderStatus.kComplete;
                        return;
                      }
                      if (e2.code === 11 && _utils_browser_js__WEBPACK_IMPORTED_MODULE_0__.default.msedge) {
                        return;
                      }
                      _this._status = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderStatus.kError;
                      var type2 = 0;
                      var info = null;
                      if ((e2.code === 19 || e2.message === "network error") && // NETWORK_ERR
                      (_this._contentLength === null || _this._contentLength !== null && _this._receivedLength < _this._contentLength)) {
                        type2 = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderErrors.EARLY_EOF;
                        info = { code: e2.code, msg: "Fetch stream meet Early-EOF" };
                      } else {
                        type2 = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderErrors.EXCEPTION;
                        info = { code: e2.code, msg: e2.message };
                      }
                      if (_this._onError) {
                        _this._onError(type2, info);
                      } else {
                        throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_2__.RuntimeException(info.msg);
                      }
                    });
                  };
                  return FetchStreamLoader2;
                }(_loader_js__WEBPACK_IMPORTED_MODULE_1__.BaseLoader)
              );
              __webpack_exports__2["default"] = FetchStreamLoader;
            }
          ),
          /***/
          "./src/io/io-controller.js": (
            /*!*********************************!*\
              !*** ./src/io/io-controller.js ***!
              \*********************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../utils/logger.js */
                "./src/utils/logger.js"
              );
              var _speed_sampler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./speed-sampler.js */
                "./src/io/speed-sampler.js"
              );
              var _loader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./loader.js */
                "./src/io/loader.js"
              );
              var _fetch_stream_loader_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./fetch-stream-loader.js */
                "./src/io/fetch-stream-loader.js"
              );
              var _xhr_moz_chunked_loader_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ./xhr-moz-chunked-loader.js */
                "./src/io/xhr-moz-chunked-loader.js"
              );
              var _xhr_range_loader_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ./xhr-range-loader.js */
                "./src/io/xhr-range-loader.js"
              );
              var _websocket_loader_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                /*! ./websocket-loader.js */
                "./src/io/websocket-loader.js"
              );
              var _range_seek_handler_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                /*! ./range-seek-handler.js */
                "./src/io/range-seek-handler.js"
              );
              var _param_seek_handler_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                /*! ./param-seek-handler.js */
                "./src/io/param-seek-handler.js"
              );
              var _utils_exception_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__2(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              );
              var IOController = (
                /** @class */
                function() {
                  function IOController2(dataSource, config, extraData) {
                    this.TAG = "IOController";
                    this._config = config;
                    this._extraData = extraData;
                    this._stashInitialSize = 1024 * 384;
                    if (config.stashInitialSize != void 0 && config.stashInitialSize > 0) {
                      this._stashInitialSize = config.stashInitialSize;
                    }
                    this._stashUsed = 0;
                    this._stashSize = this._stashInitialSize;
                    this._bufferSize = 1024 * 1024 * 3;
                    this._stashBuffer = new ArrayBuffer(this._bufferSize);
                    this._stashByteStart = 0;
                    this._enableStash = true;
                    if (config.enableStashBuffer === false) {
                      this._enableStash = false;
                    }
                    this._loader = null;
                    this._loaderClass = null;
                    this._seekHandler = null;
                    this._dataSource = dataSource;
                    this._isWebSocketURL = /wss?:\/\/(.+?)/.test(dataSource.url);
                    this._refTotalLength = dataSource.filesize ? dataSource.filesize : null;
                    this._totalLength = this._refTotalLength;
                    this._fullRequestFlag = false;
                    this._currentRange = null;
                    this._redirectedURL = null;
                    this._speedNormalized = 0;
                    this._speedSampler = new _speed_sampler_js__WEBPACK_IMPORTED_MODULE_1__.default();
                    this._speedNormalizeList = [64, 128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096];
                    this._isEarlyEofReconnecting = false;
                    this._paused = false;
                    this._resumeFrom = 0;
                    this._onDataArrival = null;
                    this._onSeeked = null;
                    this._onError = null;
                    this._onComplete = null;
                    this._onRedirect = null;
                    this._onRecoveredEarlyEof = null;
                    this._selectSeekHandler();
                    this._selectLoader();
                    this._createLoader();
                  }
                  IOController2.prototype.destroy = function() {
                    if (this._loader.isWorking()) {
                      this._loader.abort();
                    }
                    this._loader.destroy();
                    this._loader = null;
                    this._loaderClass = null;
                    this._dataSource = null;
                    this._stashBuffer = null;
                    this._stashUsed = this._stashSize = this._bufferSize = this._stashByteStart = 0;
                    this._currentRange = null;
                    this._speedSampler = null;
                    this._isEarlyEofReconnecting = false;
                    this._onDataArrival = null;
                    this._onSeeked = null;
                    this._onError = null;
                    this._onComplete = null;
                    this._onRedirect = null;
                    this._onRecoveredEarlyEof = null;
                    this._extraData = null;
                  };
                  IOController2.prototype.isWorking = function() {
                    return this._loader && this._loader.isWorking() && !this._paused;
                  };
                  IOController2.prototype.isPaused = function() {
                    return this._paused;
                  };
                  Object.defineProperty(IOController2.prototype, "status", {
                    get: function() {
                      return this._loader.status;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(IOController2.prototype, "extraData", {
                    get: function() {
                      return this._extraData;
                    },
                    set: function(data2) {
                      this._extraData = data2;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(IOController2.prototype, "onDataArrival", {
                    // prototype: function onDataArrival(chunks: ArrayBuffer, byteStart: number): number
                    get: function() {
                      return this._onDataArrival;
                    },
                    set: function(callback) {
                      this._onDataArrival = callback;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(IOController2.prototype, "onSeeked", {
                    get: function() {
                      return this._onSeeked;
                    },
                    set: function(callback) {
                      this._onSeeked = callback;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(IOController2.prototype, "onError", {
                    // prototype: function onError(type: number, info: {code: number, msg: string}): void
                    get: function() {
                      return this._onError;
                    },
                    set: function(callback) {
                      this._onError = callback;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(IOController2.prototype, "onComplete", {
                    get: function() {
                      return this._onComplete;
                    },
                    set: function(callback) {
                      this._onComplete = callback;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(IOController2.prototype, "onRedirect", {
                    get: function() {
                      return this._onRedirect;
                    },
                    set: function(callback) {
                      this._onRedirect = callback;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(IOController2.prototype, "onRecoveredEarlyEof", {
                    get: function() {
                      return this._onRecoveredEarlyEof;
                    },
                    set: function(callback) {
                      this._onRecoveredEarlyEof = callback;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(IOController2.prototype, "currentURL", {
                    get: function() {
                      return this._dataSource.url;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(IOController2.prototype, "hasRedirect", {
                    get: function() {
                      return this._redirectedURL != null || this._dataSource.redirectedURL != void 0;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(IOController2.prototype, "currentRedirectedURL", {
                    get: function() {
                      return this._redirectedURL || this._dataSource.redirectedURL;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(IOController2.prototype, "currentSpeed", {
                    // in KB/s
                    get: function() {
                      if (this._loaderClass === _xhr_range_loader_js__WEBPACK_IMPORTED_MODULE_5__.default) {
                        return this._loader.currentSpeed;
                      }
                      return this._speedSampler.lastSecondKBps;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(IOController2.prototype, "loaderType", {
                    get: function() {
                      return this._loader.type;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  IOController2.prototype._selectSeekHandler = function() {
                    var config = this._config;
                    if (config.seekType === "range") {
                      this._seekHandler = new _range_seek_handler_js__WEBPACK_IMPORTED_MODULE_7__.default(this._config.rangeLoadZeroStart);
                    } else if (config.seekType === "param") {
                      var paramStart = config.seekParamStart || "bstart";
                      var paramEnd = config.seekParamEnd || "bend";
                      this._seekHandler = new _param_seek_handler_js__WEBPACK_IMPORTED_MODULE_8__.default(paramStart, paramEnd);
                    } else if (config.seekType === "custom") {
                      if (typeof config.customSeekHandler !== "function") {
                        throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_9__.InvalidArgumentException("Custom seekType specified in config but invalid customSeekHandler!");
                      }
                      this._seekHandler = new config.customSeekHandler();
                    } else {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_9__.InvalidArgumentException("Invalid seekType in config: " + config.seekType);
                    }
                  };
                  IOController2.prototype._selectLoader = function() {
                    if (this._config.customLoader != null) {
                      this._loaderClass = this._config.customLoader;
                    } else if (this._isWebSocketURL) {
                      this._loaderClass = _websocket_loader_js__WEBPACK_IMPORTED_MODULE_6__.default;
                    } else if (_fetch_stream_loader_js__WEBPACK_IMPORTED_MODULE_3__.default.isSupported()) {
                      this._loaderClass = _fetch_stream_loader_js__WEBPACK_IMPORTED_MODULE_3__.default;
                    } else if (_xhr_moz_chunked_loader_js__WEBPACK_IMPORTED_MODULE_4__.default.isSupported()) {
                      this._loaderClass = _xhr_moz_chunked_loader_js__WEBPACK_IMPORTED_MODULE_4__.default;
                    } else if (_xhr_range_loader_js__WEBPACK_IMPORTED_MODULE_5__.default.isSupported()) {
                      this._loaderClass = _xhr_range_loader_js__WEBPACK_IMPORTED_MODULE_5__.default;
                    } else {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_9__.RuntimeException("Your browser doesn't support xhr with arraybuffer responseType!");
                    }
                  };
                  IOController2.prototype._createLoader = function() {
                    this._loader = new this._loaderClass(this._seekHandler, this._config);
                    if (this._loader.needStashBuffer === false) {
                      this._enableStash = false;
                    }
                    this._loader.onContentLengthKnown = this._onContentLengthKnown.bind(this);
                    this._loader.onURLRedirect = this._onURLRedirect.bind(this);
                    this._loader.onDataArrival = this._onLoaderChunkArrival.bind(this);
                    this._loader.onComplete = this._onLoaderComplete.bind(this);
                    this._loader.onError = this._onLoaderError.bind(this);
                  };
                  IOController2.prototype.open = function(optionalFrom) {
                    this._currentRange = { from: 0, to: -1 };
                    if (optionalFrom) {
                      this._currentRange.from = optionalFrom;
                    }
                    this._speedSampler.reset();
                    if (!optionalFrom) {
                      this._fullRequestFlag = true;
                    }
                    this._loader.open(this._dataSource, Object.assign({}, this._currentRange));
                  };
                  IOController2.prototype.abort = function() {
                    this._loader.abort();
                    if (this._paused) {
                      this._paused = false;
                      this._resumeFrom = 0;
                    }
                  };
                  IOController2.prototype.pause = function() {
                    if (this.isWorking()) {
                      this._loader.abort();
                      if (this._stashUsed !== 0) {
                        this._resumeFrom = this._stashByteStart;
                        this._currentRange.to = this._stashByteStart - 1;
                      } else {
                        this._resumeFrom = this._currentRange.to + 1;
                      }
                      this._stashUsed = 0;
                      this._stashByteStart = 0;
                      this._paused = true;
                    }
                  };
                  IOController2.prototype.resume = function() {
                    if (this._paused) {
                      this._paused = false;
                      var bytes = this._resumeFrom;
                      this._resumeFrom = 0;
                      this._internalSeek(bytes, true);
                    }
                  };
                  IOController2.prototype.seek = function(bytes) {
                    this._paused = false;
                    this._stashUsed = 0;
                    this._stashByteStart = 0;
                    this._internalSeek(bytes, true);
                  };
                  IOController2.prototype._internalSeek = function(bytes, dropUnconsumed) {
                    if (this._loader.isWorking()) {
                      this._loader.abort();
                    }
                    this._flushStashBuffer(dropUnconsumed);
                    this._loader.destroy();
                    this._loader = null;
                    var requestRange = { from: bytes, to: -1 };
                    this._currentRange = { from: requestRange.from, to: -1 };
                    this._speedSampler.reset();
                    this._stashSize = this._stashInitialSize;
                    this._createLoader();
                    this._loader.open(this._dataSource, requestRange);
                    if (this._onSeeked) {
                      this._onSeeked();
                    }
                  };
                  IOController2.prototype.updateUrl = function(url2) {
                    if (!url2 || typeof url2 !== "string" || url2.length === 0) {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_9__.InvalidArgumentException("Url must be a non-empty string!");
                    }
                    this._dataSource.url = url2;
                  };
                  IOController2.prototype._expandBuffer = function(expectedBytes) {
                    var bufferNewSize = this._stashSize;
                    while (bufferNewSize + 1024 * 1024 * 1 < expectedBytes) {
                      bufferNewSize *= 2;
                    }
                    bufferNewSize += 1024 * 1024 * 1;
                    if (bufferNewSize === this._bufferSize) {
                      return;
                    }
                    var newBuffer = new ArrayBuffer(bufferNewSize);
                    if (this._stashUsed > 0) {
                      var stashOldArray = new Uint8Array(this._stashBuffer, 0, this._stashUsed);
                      var stashNewArray = new Uint8Array(newBuffer, 0, bufferNewSize);
                      stashNewArray.set(stashOldArray, 0);
                    }
                    this._stashBuffer = newBuffer;
                    this._bufferSize = bufferNewSize;
                  };
                  IOController2.prototype._normalizeSpeed = function(input) {
                    var list = this._speedNormalizeList;
                    var last = list.length - 1;
                    var mid = 0;
                    var lbound = 0;
                    var ubound = last;
                    if (input < list[0]) {
                      return list[0];
                    }
                    while (lbound <= ubound) {
                      mid = lbound + Math.floor((ubound - lbound) / 2);
                      if (mid === last || input >= list[mid] && input < list[mid + 1]) {
                        return list[mid];
                      } else if (list[mid] < input) {
                        lbound = mid + 1;
                      } else {
                        ubound = mid - 1;
                      }
                    }
                  };
                  IOController2.prototype._adjustStashSize = function(normalized) {
                    var stashSizeKB = 0;
                    if (this._config.isLive) {
                      stashSizeKB = normalized;
                    } else {
                      if (normalized < 512) {
                        stashSizeKB = normalized;
                      } else if (normalized >= 512 && normalized <= 1024) {
                        stashSizeKB = Math.floor(normalized * 1.5);
                      } else {
                        stashSizeKB = normalized * 2;
                      }
                    }
                    if (stashSizeKB > 8192) {
                      stashSizeKB = 8192;
                    }
                    var bufferSize = stashSizeKB * 1024 + 1024 * 1024 * 1;
                    if (this._bufferSize < bufferSize) {
                      this._expandBuffer(bufferSize);
                    }
                    this._stashSize = stashSizeKB * 1024;
                  };
                  IOController2.prototype._dispatchChunks = function(chunks, byteStart) {
                    this._currentRange.to = byteStart + chunks.byteLength - 1;
                    return this._onDataArrival(chunks, byteStart);
                  };
                  IOController2.prototype._onURLRedirect = function(redirectedURL) {
                    this._redirectedURL = redirectedURL;
                    if (this._onRedirect) {
                      this._onRedirect(redirectedURL);
                    }
                  };
                  IOController2.prototype._onContentLengthKnown = function(contentLength) {
                    if (contentLength && this._fullRequestFlag) {
                      this._totalLength = contentLength;
                      this._fullRequestFlag = false;
                    }
                  };
                  IOController2.prototype._onLoaderChunkArrival = function(chunk, byteStart, receivedLength) {
                    if (!this._onDataArrival) {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_9__.IllegalStateException("IOController: No existing consumer (onDataArrival) callback!");
                    }
                    if (this._paused) {
                      return;
                    }
                    if (this._isEarlyEofReconnecting) {
                      this._isEarlyEofReconnecting = false;
                      if (this._onRecoveredEarlyEof) {
                        this._onRecoveredEarlyEof();
                      }
                    }
                    this._speedSampler.addBytes(chunk.byteLength);
                    var KBps = this._speedSampler.lastSecondKBps;
                    if (KBps !== 0) {
                      var normalized = this._normalizeSpeed(KBps);
                      if (this._speedNormalized !== normalized) {
                        this._speedNormalized = normalized;
                        this._adjustStashSize(normalized);
                      }
                    }
                    if (!this._enableStash) {
                      if (this._stashUsed === 0) {
                        var consumed = this._dispatchChunks(chunk, byteStart);
                        if (consumed < chunk.byteLength) {
                          var remain = chunk.byteLength - consumed;
                          if (remain > this._bufferSize) {
                            this._expandBuffer(remain);
                          }
                          var stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);
                          stashArray.set(new Uint8Array(chunk, consumed), 0);
                          this._stashUsed += remain;
                          this._stashByteStart = byteStart + consumed;
                        }
                      } else {
                        if (this._stashUsed + chunk.byteLength > this._bufferSize) {
                          this._expandBuffer(this._stashUsed + chunk.byteLength);
                        }
                        var stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);
                        stashArray.set(new Uint8Array(chunk), this._stashUsed);
                        this._stashUsed += chunk.byteLength;
                        var consumed = this._dispatchChunks(this._stashBuffer.slice(0, this._stashUsed), this._stashByteStart);
                        if (consumed < this._stashUsed && consumed > 0) {
                          var remainArray = new Uint8Array(this._stashBuffer, consumed);
                          stashArray.set(remainArray, 0);
                        }
                        this._stashUsed -= consumed;
                        this._stashByteStart += consumed;
                      }
                    } else {
                      if (this._stashUsed === 0 && this._stashByteStart === 0) {
                        this._stashByteStart = byteStart;
                      }
                      if (this._stashUsed + chunk.byteLength <= this._stashSize) {
                        var stashArray = new Uint8Array(this._stashBuffer, 0, this._stashSize);
                        stashArray.set(new Uint8Array(chunk), this._stashUsed);
                        this._stashUsed += chunk.byteLength;
                      } else {
                        var stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);
                        if (this._stashUsed > 0) {
                          var buffer = this._stashBuffer.slice(0, this._stashUsed);
                          var consumed = this._dispatchChunks(buffer, this._stashByteStart);
                          if (consumed < buffer.byteLength) {
                            if (consumed > 0) {
                              var remainArray = new Uint8Array(buffer, consumed);
                              stashArray.set(remainArray, 0);
                              this._stashUsed = remainArray.byteLength;
                              this._stashByteStart += consumed;
                            }
                          } else {
                            this._stashUsed = 0;
                            this._stashByteStart += consumed;
                          }
                          if (this._stashUsed + chunk.byteLength > this._bufferSize) {
                            this._expandBuffer(this._stashUsed + chunk.byteLength);
                            stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);
                          }
                          stashArray.set(new Uint8Array(chunk), this._stashUsed);
                          this._stashUsed += chunk.byteLength;
                        } else {
                          var consumed = this._dispatchChunks(chunk, byteStart);
                          if (consumed < chunk.byteLength) {
                            var remain = chunk.byteLength - consumed;
                            if (remain > this._bufferSize) {
                              this._expandBuffer(remain);
                              stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);
                            }
                            stashArray.set(new Uint8Array(chunk, consumed), 0);
                            this._stashUsed += remain;
                            this._stashByteStart = byteStart + consumed;
                          }
                        }
                      }
                    }
                  };
                  IOController2.prototype._flushStashBuffer = function(dropUnconsumed) {
                    if (this._stashUsed > 0) {
                      var buffer = this._stashBuffer.slice(0, this._stashUsed);
                      var consumed = this._dispatchChunks(buffer, this._stashByteStart);
                      var remain = buffer.byteLength - consumed;
                      if (consumed < buffer.byteLength) {
                        if (dropUnconsumed) {
                          _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, remain + " bytes unconsumed data remain when flush buffer, dropped");
                        } else {
                          if (consumed > 0) {
                            var stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);
                            var remainArray = new Uint8Array(buffer, consumed);
                            stashArray.set(remainArray, 0);
                            this._stashUsed = remainArray.byteLength;
                            this._stashByteStart += consumed;
                          }
                          return 0;
                        }
                      }
                      this._stashUsed = 0;
                      this._stashByteStart = 0;
                      return remain;
                    }
                    return 0;
                  };
                  IOController2.prototype._onLoaderComplete = function(from2, to) {
                    this._flushStashBuffer(true);
                    if (this._onComplete) {
                      this._onComplete(this._extraData);
                    }
                  };
                  IOController2.prototype._onLoaderError = function(type2, data2) {
                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.e(this.TAG, "Loader error, code = " + data2.code + ", msg = " + data2.msg);
                    this._flushStashBuffer(false);
                    if (this._isEarlyEofReconnecting) {
                      this._isEarlyEofReconnecting = false;
                      type2 = _loader_js__WEBPACK_IMPORTED_MODULE_2__.LoaderErrors.UNRECOVERABLE_EARLY_EOF;
                    }
                    switch (type2) {
                      case _loader_js__WEBPACK_IMPORTED_MODULE_2__.LoaderErrors.EARLY_EOF: {
                        if (!this._config.isLive) {
                          if (this._totalLength) {
                            var nextFrom = this._currentRange.to + 1;
                            if (nextFrom < this._totalLength) {
                              _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "Connection lost, trying reconnect...");
                              this._isEarlyEofReconnecting = true;
                              this._internalSeek(nextFrom, false);
                            }
                            return;
                          }
                        }
                        type2 = _loader_js__WEBPACK_IMPORTED_MODULE_2__.LoaderErrors.UNRECOVERABLE_EARLY_EOF;
                        break;
                      }
                      case _loader_js__WEBPACK_IMPORTED_MODULE_2__.LoaderErrors.UNRECOVERABLE_EARLY_EOF:
                      case _loader_js__WEBPACK_IMPORTED_MODULE_2__.LoaderErrors.CONNECTING_TIMEOUT:
                      case _loader_js__WEBPACK_IMPORTED_MODULE_2__.LoaderErrors.HTTP_STATUS_CODE_INVALID:
                      case _loader_js__WEBPACK_IMPORTED_MODULE_2__.LoaderErrors.EXCEPTION:
                        break;
                    }
                    if (this._onError) {
                      this._onError(type2, data2);
                    } else {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_9__.RuntimeException("IOException: " + data2.msg);
                    }
                  };
                  return IOController2;
                }()
              );
              __webpack_exports__2["default"] = IOController;
            }
          ),
          /***/
          "./src/io/loader.js": (
            /*!**************************!*\
              !*** ./src/io/loader.js ***!
              \**************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "LoaderStatus": function() {
                  return (
                    /* binding */
                    LoaderStatus
                  );
                },
                /* harmony export */
                "LoaderErrors": function() {
                  return (
                    /* binding */
                    LoaderErrors
                  );
                },
                /* harmony export */
                "BaseLoader": function() {
                  return (
                    /* binding */
                    BaseLoader
                  );
                }
                /* harmony export */
              });
              var _utils_exception_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              );
              var LoaderStatus = {
                kIdle: 0,
                kConnecting: 1,
                kBuffering: 2,
                kError: 3,
                kComplete: 4
              };
              var LoaderErrors = {
                OK: "OK",
                EXCEPTION: "Exception",
                HTTP_STATUS_CODE_INVALID: "HttpStatusCodeInvalid",
                CONNECTING_TIMEOUT: "ConnectingTimeout",
                EARLY_EOF: "EarlyEof",
                UNRECOVERABLE_EARLY_EOF: "UnrecoverableEarlyEof"
              };
              var BaseLoader = (
                /** @class */
                function() {
                  function BaseLoader2(typeName) {
                    this._type = typeName || "undefined";
                    this._status = LoaderStatus.kIdle;
                    this._needStash = false;
                    this._onContentLengthKnown = null;
                    this._onURLRedirect = null;
                    this._onDataArrival = null;
                    this._onError = null;
                    this._onComplete = null;
                  }
                  BaseLoader2.prototype.destroy = function() {
                    this._status = LoaderStatus.kIdle;
                    this._onContentLengthKnown = null;
                    this._onURLRedirect = null;
                    this._onDataArrival = null;
                    this._onError = null;
                    this._onComplete = null;
                  };
                  BaseLoader2.prototype.isWorking = function() {
                    return this._status === LoaderStatus.kConnecting || this._status === LoaderStatus.kBuffering;
                  };
                  Object.defineProperty(BaseLoader2.prototype, "type", {
                    get: function() {
                      return this._type;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(BaseLoader2.prototype, "status", {
                    get: function() {
                      return this._status;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(BaseLoader2.prototype, "needStashBuffer", {
                    get: function() {
                      return this._needStash;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(BaseLoader2.prototype, "onContentLengthKnown", {
                    get: function() {
                      return this._onContentLengthKnown;
                    },
                    set: function(callback) {
                      this._onContentLengthKnown = callback;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(BaseLoader2.prototype, "onURLRedirect", {
                    get: function() {
                      return this._onURLRedirect;
                    },
                    set: function(callback) {
                      this._onURLRedirect = callback;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(BaseLoader2.prototype, "onDataArrival", {
                    get: function() {
                      return this._onDataArrival;
                    },
                    set: function(callback) {
                      this._onDataArrival = callback;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(BaseLoader2.prototype, "onError", {
                    get: function() {
                      return this._onError;
                    },
                    set: function(callback) {
                      this._onError = callback;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(BaseLoader2.prototype, "onComplete", {
                    get: function() {
                      return this._onComplete;
                    },
                    set: function(callback) {
                      this._onComplete = callback;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  BaseLoader2.prototype.open = function(dataSource, range2) {
                    throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException("Unimplemented abstract function!");
                  };
                  BaseLoader2.prototype.abort = function() {
                    throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException("Unimplemented abstract function!");
                  };
                  return BaseLoader2;
                }()
              );
            }
          ),
          /***/
          "./src/io/param-seek-handler.js": (
            /*!**************************************!*\
              !*** ./src/io/param-seek-handler.js ***!
              \**************************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var ParamSeekHandler = (
                /** @class */
                function() {
                  function ParamSeekHandler2(paramStart, paramEnd) {
                    this._startName = paramStart;
                    this._endName = paramEnd;
                  }
                  ParamSeekHandler2.prototype.getConfig = function(baseUrl, range2) {
                    var url2 = baseUrl;
                    if (range2.from !== 0 || range2.to !== -1) {
                      var needAnd = true;
                      if (url2.indexOf("?") === -1) {
                        url2 += "?";
                        needAnd = false;
                      }
                      if (needAnd) {
                        url2 += "&";
                      }
                      url2 += this._startName + "=" + range2.from.toString();
                      if (range2.to !== -1) {
                        url2 += "&" + this._endName + "=" + range2.to.toString();
                      }
                    }
                    return {
                      url: url2,
                      headers: {}
                    };
                  };
                  ParamSeekHandler2.prototype.removeURLParameters = function(seekedURL) {
                    var baseURL = seekedURL.split("?")[0];
                    var params = void 0;
                    var queryIndex = seekedURL.indexOf("?");
                    if (queryIndex !== -1) {
                      params = seekedURL.substring(queryIndex + 1);
                    }
                    var resultParams = "";
                    if (params != void 0 && params.length > 0) {
                      var pairs = params.split("&");
                      for (var i2 = 0; i2 < pairs.length; i2++) {
                        var pair = pairs[i2].split("=");
                        var requireAnd = i2 > 0;
                        if (pair[0] !== this._startName && pair[0] !== this._endName) {
                          if (requireAnd) {
                            resultParams += "&";
                          }
                          resultParams += pairs[i2];
                        }
                      }
                    }
                    return resultParams.length === 0 ? baseURL : baseURL + "?" + resultParams;
                  };
                  return ParamSeekHandler2;
                }()
              );
              __webpack_exports__2["default"] = ParamSeekHandler;
            }
          ),
          /***/
          "./src/io/range-seek-handler.js": (
            /*!**************************************!*\
              !*** ./src/io/range-seek-handler.js ***!
              \**************************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var RangeSeekHandler = (
                /** @class */
                function() {
                  function RangeSeekHandler2(zeroStart) {
                    this._zeroStart = zeroStart || false;
                  }
                  RangeSeekHandler2.prototype.getConfig = function(url2, range2) {
                    var headers = {};
                    if (range2.from !== 0 || range2.to !== -1) {
                      var param = void 0;
                      if (range2.to !== -1) {
                        param = "bytes=" + range2.from.toString() + "-" + range2.to.toString();
                      } else {
                        param = "bytes=" + range2.from.toString() + "-";
                      }
                      headers["Range"] = param;
                    } else if (this._zeroStart) {
                      headers["Range"] = "bytes=0-";
                    }
                    return {
                      url: url2,
                      headers
                    };
                  };
                  RangeSeekHandler2.prototype.removeURLParameters = function(seekedURL) {
                    return seekedURL;
                  };
                  return RangeSeekHandler2;
                }()
              );
              __webpack_exports__2["default"] = RangeSeekHandler;
            }
          ),
          /***/
          "./src/io/speed-sampler.js": (
            /*!*********************************!*\
              !*** ./src/io/speed-sampler.js ***!
              \*********************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var SpeedSampler = (
                /** @class */
                function() {
                  function SpeedSampler2() {
                    this._firstCheckpoint = 0;
                    this._lastCheckpoint = 0;
                    this._intervalBytes = 0;
                    this._totalBytes = 0;
                    this._lastSecondBytes = 0;
                    if (self.performance && self.performance.now) {
                      this._now = self.performance.now.bind(self.performance);
                    } else {
                      this._now = Date.now;
                    }
                  }
                  SpeedSampler2.prototype.reset = function() {
                    this._firstCheckpoint = this._lastCheckpoint = 0;
                    this._totalBytes = this._intervalBytes = 0;
                    this._lastSecondBytes = 0;
                  };
                  SpeedSampler2.prototype.addBytes = function(bytes) {
                    if (this._firstCheckpoint === 0) {
                      this._firstCheckpoint = this._now();
                      this._lastCheckpoint = this._firstCheckpoint;
                      this._intervalBytes += bytes;
                      this._totalBytes += bytes;
                    } else if (this._now() - this._lastCheckpoint < 1e3) {
                      this._intervalBytes += bytes;
                      this._totalBytes += bytes;
                    } else {
                      this._lastSecondBytes = this._intervalBytes;
                      this._intervalBytes = bytes;
                      this._totalBytes += bytes;
                      this._lastCheckpoint = this._now();
                    }
                  };
                  Object.defineProperty(SpeedSampler2.prototype, "currentKBps", {
                    get: function() {
                      this.addBytes(0);
                      var durationSeconds = (this._now() - this._lastCheckpoint) / 1e3;
                      if (durationSeconds == 0)
                        durationSeconds = 1;
                      return this._intervalBytes / durationSeconds / 1024;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(SpeedSampler2.prototype, "lastSecondKBps", {
                    get: function() {
                      this.addBytes(0);
                      if (this._lastSecondBytes !== 0) {
                        return this._lastSecondBytes / 1024;
                      } else {
                        if (this._now() - this._lastCheckpoint >= 500) {
                          return this.currentKBps;
                        } else {
                          return 0;
                        }
                      }
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(SpeedSampler2.prototype, "averageKBps", {
                    get: function() {
                      var durationSeconds = (this._now() - this._firstCheckpoint) / 1e3;
                      return this._totalBytes / durationSeconds / 1024;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  return SpeedSampler2;
                }()
              );
              __webpack_exports__2["default"] = SpeedSampler;
            }
          ),
          /***/
          "./src/io/websocket-loader.js": (
            /*!************************************!*\
              !*** ./src/io/websocket-loader.js ***!
              \************************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var _loader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ./loader.js */
                "./src/io/loader.js"
              );
              var _utils_exception_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              );
              var __extends2 = function() {
                var extendStatics2 = function(d2, b2) {
                  extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
                    d3.__proto__ = b3;
                  } || function(d3, b3) {
                    for (var p in b3)
                      if (Object.prototype.hasOwnProperty.call(b3, p))
                        d3[p] = b3[p];
                  };
                  return extendStatics2(d2, b2);
                };
                return function(d2, b2) {
                  if (typeof b2 !== "function" && b2 !== null)
                    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
                  extendStatics2(d2, b2);
                  function __() {
                    this.constructor = d2;
                  }
                  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
                };
              }();
              var WebSocketLoader = (
                /** @class */
                function(_super) {
                  __extends2(WebSocketLoader2, _super);
                  function WebSocketLoader2() {
                    var _this = _super.call(this, "websocket-loader") || this;
                    _this.TAG = "WebSocketLoader";
                    _this._needStash = true;
                    _this._ws = null;
                    _this._requestAbort = false;
                    _this._receivedLength = 0;
                    return _this;
                  }
                  WebSocketLoader2.isSupported = function() {
                    try {
                      return typeof self.WebSocket !== "undefined";
                    } catch (e2) {
                      return false;
                    }
                  };
                  WebSocketLoader2.prototype.destroy = function() {
                    if (this._ws) {
                      this.abort();
                    }
                    _super.prototype.destroy.call(this);
                  };
                  WebSocketLoader2.prototype.open = function(dataSource) {
                    try {
                      var ws = this._ws = new self.WebSocket(dataSource.url);
                      ws.binaryType = "arraybuffer";
                      ws.onopen = this._onWebSocketOpen.bind(this);
                      ws.onclose = this._onWebSocketClose.bind(this);
                      ws.onmessage = this._onWebSocketMessage.bind(this);
                      ws.onerror = this._onWebSocketError.bind(this);
                      this._status = _loader_js__WEBPACK_IMPORTED_MODULE_0__.LoaderStatus.kConnecting;
                    } catch (e2) {
                      this._status = _loader_js__WEBPACK_IMPORTED_MODULE_0__.LoaderStatus.kError;
                      var info = { code: e2.code, msg: e2.message };
                      if (this._onError) {
                        this._onError(_loader_js__WEBPACK_IMPORTED_MODULE_0__.LoaderErrors.EXCEPTION, info);
                      } else {
                        throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_1__.RuntimeException(info.msg);
                      }
                    }
                  };
                  WebSocketLoader2.prototype.abort = function() {
                    var ws = this._ws;
                    if (ws && (ws.readyState === 0 || ws.readyState === 1)) {
                      this._requestAbort = true;
                      ws.close();
                    }
                    this._ws = null;
                    this._status = _loader_js__WEBPACK_IMPORTED_MODULE_0__.LoaderStatus.kComplete;
                  };
                  WebSocketLoader2.prototype._onWebSocketOpen = function(e2) {
                    this._status = _loader_js__WEBPACK_IMPORTED_MODULE_0__.LoaderStatus.kBuffering;
                  };
                  WebSocketLoader2.prototype._onWebSocketClose = function(e2) {
                    if (this._requestAbort === true) {
                      this._requestAbort = false;
                      return;
                    }
                    this._status = _loader_js__WEBPACK_IMPORTED_MODULE_0__.LoaderStatus.kComplete;
                    if (this._onComplete) {
                      this._onComplete(0, this._receivedLength - 1);
                    }
                  };
                  WebSocketLoader2.prototype._onWebSocketMessage = function(e2) {
                    var _this = this;
                    if (e2.data instanceof ArrayBuffer) {
                      this._dispatchArrayBuffer(e2.data);
                    } else if (e2.data instanceof Blob) {
                      var reader_1 = new FileReader();
                      reader_1.onload = function() {
                        _this._dispatchArrayBuffer(reader_1.result);
                      };
                      reader_1.readAsArrayBuffer(e2.data);
                    } else {
                      this._status = _loader_js__WEBPACK_IMPORTED_MODULE_0__.LoaderStatus.kError;
                      var info = { code: -1, msg: "Unsupported WebSocket message type: " + e2.data.constructor.name };
                      if (this._onError) {
                        this._onError(_loader_js__WEBPACK_IMPORTED_MODULE_0__.LoaderErrors.EXCEPTION, info);
                      } else {
                        throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_1__.RuntimeException(info.msg);
                      }
                    }
                  };
                  WebSocketLoader2.prototype._dispatchArrayBuffer = function(arraybuffer) {
                    var chunk = arraybuffer;
                    var byteStart = this._receivedLength;
                    this._receivedLength += chunk.byteLength;
                    if (this._onDataArrival) {
                      this._onDataArrival(chunk, byteStart, this._receivedLength);
                    }
                  };
                  WebSocketLoader2.prototype._onWebSocketError = function(e2) {
                    this._status = _loader_js__WEBPACK_IMPORTED_MODULE_0__.LoaderStatus.kError;
                    var info = {
                      code: e2.code,
                      msg: e2.message
                    };
                    if (this._onError) {
                      this._onError(_loader_js__WEBPACK_IMPORTED_MODULE_0__.LoaderErrors.EXCEPTION, info);
                    } else {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_1__.RuntimeException(info.msg);
                    }
                  };
                  return WebSocketLoader2;
                }(_loader_js__WEBPACK_IMPORTED_MODULE_0__.BaseLoader)
              );
              __webpack_exports__2["default"] = WebSocketLoader;
            }
          ),
          /***/
          "./src/io/xhr-moz-chunked-loader.js": (
            /*!******************************************!*\
              !*** ./src/io/xhr-moz-chunked-loader.js ***!
              \******************************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../utils/logger.js */
                "./src/utils/logger.js"
              );
              var _loader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./loader.js */
                "./src/io/loader.js"
              );
              var _utils_exception_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              );
              var __extends2 = function() {
                var extendStatics2 = function(d2, b2) {
                  extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
                    d3.__proto__ = b3;
                  } || function(d3, b3) {
                    for (var p in b3)
                      if (Object.prototype.hasOwnProperty.call(b3, p))
                        d3[p] = b3[p];
                  };
                  return extendStatics2(d2, b2);
                };
                return function(d2, b2) {
                  if (typeof b2 !== "function" && b2 !== null)
                    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
                  extendStatics2(d2, b2);
                  function __() {
                    this.constructor = d2;
                  }
                  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
                };
              }();
              var MozChunkedLoader = (
                /** @class */
                function(_super) {
                  __extends2(MozChunkedLoader2, _super);
                  function MozChunkedLoader2(seekHandler, config) {
                    var _this = _super.call(this, "xhr-moz-chunked-loader") || this;
                    _this.TAG = "MozChunkedLoader";
                    _this._seekHandler = seekHandler;
                    _this._config = config;
                    _this._needStash = true;
                    _this._xhr = null;
                    _this._requestAbort = false;
                    _this._contentLength = null;
                    _this._receivedLength = 0;
                    return _this;
                  }
                  MozChunkedLoader2.isSupported = function() {
                    try {
                      var xhr2 = new XMLHttpRequest();
                      xhr2.open("GET", "https://example.com", true);
                      xhr2.responseType = "moz-chunked-arraybuffer";
                      return xhr2.responseType === "moz-chunked-arraybuffer";
                    } catch (e2) {
                      _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w("MozChunkedLoader", e2.message);
                      return false;
                    }
                  };
                  MozChunkedLoader2.prototype.destroy = function() {
                    if (this.isWorking()) {
                      this.abort();
                    }
                    if (this._xhr) {
                      this._xhr.onreadystatechange = null;
                      this._xhr.onprogress = null;
                      this._xhr.onloadend = null;
                      this._xhr.onerror = null;
                      this._xhr = null;
                    }
                    _super.prototype.destroy.call(this);
                  };
                  MozChunkedLoader2.prototype.open = function(dataSource, range2) {
                    this._dataSource = dataSource;
                    this._range = range2;
                    var sourceURL = dataSource.url;
                    if (this._config.reuseRedirectedURL && dataSource.redirectedURL != void 0) {
                      sourceURL = dataSource.redirectedURL;
                    }
                    var seekConfig = this._seekHandler.getConfig(sourceURL, range2);
                    this._requestURL = seekConfig.url;
                    var xhr2 = this._xhr = new XMLHttpRequest();
                    xhr2.open("GET", seekConfig.url, true);
                    xhr2.responseType = "moz-chunked-arraybuffer";
                    xhr2.onreadystatechange = this._onReadyStateChange.bind(this);
                    xhr2.onprogress = this._onProgress.bind(this);
                    xhr2.onloadend = this._onLoadEnd.bind(this);
                    xhr2.onerror = this._onXhrError.bind(this);
                    if (dataSource.withCredentials) {
                      xhr2.withCredentials = true;
                    }
                    if (typeof seekConfig.headers === "object") {
                      var headers = seekConfig.headers;
                      for (var key in headers) {
                        if (headers.hasOwnProperty(key)) {
                          xhr2.setRequestHeader(key, headers[key]);
                        }
                      }
                    }
                    if (typeof this._config.headers === "object") {
                      var headers = this._config.headers;
                      for (var key in headers) {
                        if (headers.hasOwnProperty(key)) {
                          xhr2.setRequestHeader(key, headers[key]);
                        }
                      }
                    }
                    this._status = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderStatus.kConnecting;
                    xhr2.send();
                  };
                  MozChunkedLoader2.prototype.abort = function() {
                    this._requestAbort = true;
                    if (this._xhr) {
                      this._xhr.abort();
                    }
                    this._status = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderStatus.kComplete;
                  };
                  MozChunkedLoader2.prototype._onReadyStateChange = function(e2) {
                    var xhr2 = e2.target;
                    if (xhr2.readyState === 2) {
                      if (xhr2.responseURL != void 0 && xhr2.responseURL !== this._requestURL) {
                        if (this._onURLRedirect) {
                          var redirectedURL = this._seekHandler.removeURLParameters(xhr2.responseURL);
                          this._onURLRedirect(redirectedURL);
                        }
                      }
                      if (xhr2.status !== 0 && (xhr2.status < 200 || xhr2.status > 299)) {
                        this._status = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderStatus.kError;
                        if (this._onError) {
                          this._onError(_loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderErrors.HTTP_STATUS_CODE_INVALID, { code: xhr2.status, msg: xhr2.statusText });
                        } else {
                          throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_2__.RuntimeException("MozChunkedLoader: Http code invalid, " + xhr2.status + " " + xhr2.statusText);
                        }
                      } else {
                        this._status = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderStatus.kBuffering;
                      }
                    }
                  };
                  MozChunkedLoader2.prototype._onProgress = function(e2) {
                    if (this._status === _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderStatus.kError) {
                      return;
                    }
                    if (this._contentLength === null) {
                      if (e2.total !== null && e2.total !== 0) {
                        this._contentLength = e2.total;
                        if (this._onContentLengthKnown) {
                          this._onContentLengthKnown(this._contentLength);
                        }
                      }
                    }
                    var chunk = e2.target.response;
                    var byteStart = this._range.from + this._receivedLength;
                    this._receivedLength += chunk.byteLength;
                    if (this._onDataArrival) {
                      this._onDataArrival(chunk, byteStart, this._receivedLength);
                    }
                  };
                  MozChunkedLoader2.prototype._onLoadEnd = function(e2) {
                    if (this._requestAbort === true) {
                      this._requestAbort = false;
                      return;
                    } else if (this._status === _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderStatus.kError) {
                      return;
                    }
                    this._status = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderStatus.kComplete;
                    if (this._onComplete) {
                      this._onComplete(this._range.from, this._range.from + this._receivedLength - 1);
                    }
                  };
                  MozChunkedLoader2.prototype._onXhrError = function(e2) {
                    this._status = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderStatus.kError;
                    var type2 = 0;
                    var info = null;
                    if (this._contentLength && e2.loaded < this._contentLength) {
                      type2 = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderErrors.EARLY_EOF;
                      info = { code: -1, msg: "Moz-Chunked stream meet Early-Eof" };
                    } else {
                      type2 = _loader_js__WEBPACK_IMPORTED_MODULE_1__.LoaderErrors.EXCEPTION;
                      info = { code: -1, msg: e2.constructor.name + " " + e2.type };
                    }
                    if (this._onError) {
                      this._onError(type2, info);
                    } else {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_2__.RuntimeException(info.msg);
                    }
                  };
                  return MozChunkedLoader2;
                }(_loader_js__WEBPACK_IMPORTED_MODULE_1__.BaseLoader)
              );
              __webpack_exports__2["default"] = MozChunkedLoader;
            }
          ),
          /***/
          "./src/io/xhr-range-loader.js": (
            /*!************************************!*\
              !*** ./src/io/xhr-range-loader.js ***!
              \************************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../utils/logger.js */
                "./src/utils/logger.js"
              );
              var _speed_sampler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./speed-sampler.js */
                "./src/io/speed-sampler.js"
              );
              var _loader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./loader.js */
                "./src/io/loader.js"
              );
              var _utils_exception_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              );
              var __extends2 = function() {
                var extendStatics2 = function(d2, b2) {
                  extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
                    d3.__proto__ = b3;
                  } || function(d3, b3) {
                    for (var p in b3)
                      if (Object.prototype.hasOwnProperty.call(b3, p))
                        d3[p] = b3[p];
                  };
                  return extendStatics2(d2, b2);
                };
                return function(d2, b2) {
                  if (typeof b2 !== "function" && b2 !== null)
                    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
                  extendStatics2(d2, b2);
                  function __() {
                    this.constructor = d2;
                  }
                  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
                };
              }();
              var RangeLoader = (
                /** @class */
                function(_super) {
                  __extends2(RangeLoader2, _super);
                  function RangeLoader2(seekHandler, config) {
                    var _this = _super.call(this, "xhr-range-loader") || this;
                    _this.TAG = "RangeLoader";
                    _this._seekHandler = seekHandler;
                    _this._config = config;
                    _this._needStash = false;
                    _this._chunkSizeKBList = [
                      128,
                      256,
                      384,
                      512,
                      768,
                      1024,
                      1536,
                      2048,
                      3072,
                      4096,
                      5120,
                      6144,
                      7168,
                      8192
                    ];
                    _this._currentChunkSizeKB = 384;
                    _this._currentSpeedNormalized = 0;
                    _this._zeroSpeedChunkCount = 0;
                    _this._xhr = null;
                    _this._speedSampler = new _speed_sampler_js__WEBPACK_IMPORTED_MODULE_1__.default();
                    _this._requestAbort = false;
                    _this._waitForTotalLength = false;
                    _this._totalLengthReceived = false;
                    _this._currentRequestURL = null;
                    _this._currentRedirectedURL = null;
                    _this._currentRequestRange = null;
                    _this._totalLength = null;
                    _this._contentLength = null;
                    _this._receivedLength = 0;
                    _this._lastTimeLoaded = 0;
                    return _this;
                  }
                  RangeLoader2.isSupported = function() {
                    try {
                      var xhr2 = new XMLHttpRequest();
                      xhr2.open("GET", "https://example.com", true);
                      xhr2.responseType = "arraybuffer";
                      return xhr2.responseType === "arraybuffer";
                    } catch (e2) {
                      _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w("RangeLoader", e2.message);
                      return false;
                    }
                  };
                  RangeLoader2.prototype.destroy = function() {
                    if (this.isWorking()) {
                      this.abort();
                    }
                    if (this._xhr) {
                      this._xhr.onreadystatechange = null;
                      this._xhr.onprogress = null;
                      this._xhr.onload = null;
                      this._xhr.onerror = null;
                      this._xhr = null;
                    }
                    _super.prototype.destroy.call(this);
                  };
                  Object.defineProperty(RangeLoader2.prototype, "currentSpeed", {
                    get: function() {
                      return this._speedSampler.lastSecondKBps;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  RangeLoader2.prototype.open = function(dataSource, range2) {
                    this._dataSource = dataSource;
                    this._range = range2;
                    this._status = _loader_js__WEBPACK_IMPORTED_MODULE_2__.LoaderStatus.kConnecting;
                    var useRefTotalLength = false;
                    if (this._dataSource.filesize != void 0 && this._dataSource.filesize !== 0) {
                      useRefTotalLength = true;
                      this._totalLength = this._dataSource.filesize;
                    }
                    if (!this._totalLengthReceived && !useRefTotalLength) {
                      this._waitForTotalLength = true;
                      this._internalOpen(this._dataSource, { from: 0, to: -1 });
                    } else {
                      this._openSubRange();
                    }
                  };
                  RangeLoader2.prototype._openSubRange = function() {
                    var chunkSize = this._currentChunkSizeKB * 1024;
                    var from2 = this._range.from + this._receivedLength;
                    var to = from2 + chunkSize;
                    if (this._contentLength != null) {
                      if (to - this._range.from >= this._contentLength) {
                        to = this._range.from + this._contentLength - 1;
                      }
                    }
                    this._currentRequestRange = { from: from2, to };
                    this._internalOpen(this._dataSource, this._currentRequestRange);
                  };
                  RangeLoader2.prototype._internalOpen = function(dataSource, range2) {
                    this._lastTimeLoaded = 0;
                    var sourceURL = dataSource.url;
                    if (this._config.reuseRedirectedURL) {
                      if (this._currentRedirectedURL != void 0) {
                        sourceURL = this._currentRedirectedURL;
                      } else if (dataSource.redirectedURL != void 0) {
                        sourceURL = dataSource.redirectedURL;
                      }
                    }
                    var seekConfig = this._seekHandler.getConfig(sourceURL, range2);
                    this._currentRequestURL = seekConfig.url;
                    var xhr2 = this._xhr = new XMLHttpRequest();
                    xhr2.open("GET", seekConfig.url, true);
                    xhr2.responseType = "arraybuffer";
                    xhr2.onreadystatechange = this._onReadyStateChange.bind(this);
                    xhr2.onprogress = this._onProgress.bind(this);
                    xhr2.onload = this._onLoad.bind(this);
                    xhr2.onerror = this._onXhrError.bind(this);
                    if (dataSource.withCredentials) {
                      xhr2.withCredentials = true;
                    }
                    if (typeof seekConfig.headers === "object") {
                      var headers = seekConfig.headers;
                      for (var key in headers) {
                        if (headers.hasOwnProperty(key)) {
                          xhr2.setRequestHeader(key, headers[key]);
                        }
                      }
                    }
                    if (typeof this._config.headers === "object") {
                      var headers = this._config.headers;
                      for (var key in headers) {
                        if (headers.hasOwnProperty(key)) {
                          xhr2.setRequestHeader(key, headers[key]);
                        }
                      }
                    }
                    xhr2.send();
                  };
                  RangeLoader2.prototype.abort = function() {
                    this._requestAbort = true;
                    this._internalAbort();
                    this._status = _loader_js__WEBPACK_IMPORTED_MODULE_2__.LoaderStatus.kComplete;
                  };
                  RangeLoader2.prototype._internalAbort = function() {
                    if (this._xhr) {
                      this._xhr.onreadystatechange = null;
                      this._xhr.onprogress = null;
                      this._xhr.onload = null;
                      this._xhr.onerror = null;
                      this._xhr.abort();
                      this._xhr = null;
                    }
                  };
                  RangeLoader2.prototype._onReadyStateChange = function(e2) {
                    var xhr2 = e2.target;
                    if (xhr2.readyState === 2) {
                      if (xhr2.responseURL != void 0) {
                        var redirectedURL = this._seekHandler.removeURLParameters(xhr2.responseURL);
                        if (xhr2.responseURL !== this._currentRequestURL && redirectedURL !== this._currentRedirectedURL) {
                          this._currentRedirectedURL = redirectedURL;
                          if (this._onURLRedirect) {
                            this._onURLRedirect(redirectedURL);
                          }
                        }
                      }
                      if (xhr2.status >= 200 && xhr2.status <= 299) {
                        if (this._waitForTotalLength) {
                          return;
                        }
                        this._status = _loader_js__WEBPACK_IMPORTED_MODULE_2__.LoaderStatus.kBuffering;
                      } else {
                        this._status = _loader_js__WEBPACK_IMPORTED_MODULE_2__.LoaderStatus.kError;
                        if (this._onError) {
                          this._onError(_loader_js__WEBPACK_IMPORTED_MODULE_2__.LoaderErrors.HTTP_STATUS_CODE_INVALID, { code: xhr2.status, msg: xhr2.statusText });
                        } else {
                          throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_3__.RuntimeException("RangeLoader: Http code invalid, " + xhr2.status + " " + xhr2.statusText);
                        }
                      }
                    }
                  };
                  RangeLoader2.prototype._onProgress = function(e2) {
                    if (this._status === _loader_js__WEBPACK_IMPORTED_MODULE_2__.LoaderStatus.kError) {
                      return;
                    }
                    if (this._contentLength === null) {
                      var openNextRange = false;
                      if (this._waitForTotalLength) {
                        this._waitForTotalLength = false;
                        this._totalLengthReceived = true;
                        openNextRange = true;
                        var total = e2.total;
                        this._internalAbort();
                        if (total != null & total !== 0) {
                          this._totalLength = total;
                        }
                      }
                      if (this._range.to === -1) {
                        this._contentLength = this._totalLength - this._range.from;
                      } else {
                        this._contentLength = this._range.to - this._range.from + 1;
                      }
                      if (openNextRange) {
                        this._openSubRange();
                        return;
                      }
                      if (this._onContentLengthKnown) {
                        this._onContentLengthKnown(this._contentLength);
                      }
                    }
                    var delta = e2.loaded - this._lastTimeLoaded;
                    this._lastTimeLoaded = e2.loaded;
                    this._speedSampler.addBytes(delta);
                  };
                  RangeLoader2.prototype._normalizeSpeed = function(input) {
                    var list = this._chunkSizeKBList;
                    var last = list.length - 1;
                    var mid = 0;
                    var lbound = 0;
                    var ubound = last;
                    if (input < list[0]) {
                      return list[0];
                    }
                    while (lbound <= ubound) {
                      mid = lbound + Math.floor((ubound - lbound) / 2);
                      if (mid === last || input >= list[mid] && input < list[mid + 1]) {
                        return list[mid];
                      } else if (list[mid] < input) {
                        lbound = mid + 1;
                      } else {
                        ubound = mid - 1;
                      }
                    }
                  };
                  RangeLoader2.prototype._onLoad = function(e2) {
                    if (this._status === _loader_js__WEBPACK_IMPORTED_MODULE_2__.LoaderStatus.kError) {
                      return;
                    }
                    if (this._waitForTotalLength) {
                      this._waitForTotalLength = false;
                      return;
                    }
                    this._lastTimeLoaded = 0;
                    var KBps = this._speedSampler.lastSecondKBps;
                    if (KBps === 0) {
                      this._zeroSpeedChunkCount++;
                      if (this._zeroSpeedChunkCount >= 3) {
                        KBps = this._speedSampler.currentKBps;
                      }
                    }
                    if (KBps !== 0) {
                      var normalized = this._normalizeSpeed(KBps);
                      if (this._currentSpeedNormalized !== normalized) {
                        this._currentSpeedNormalized = normalized;
                        this._currentChunkSizeKB = normalized;
                      }
                    }
                    var chunk = e2.target.response;
                    var byteStart = this._range.from + this._receivedLength;
                    this._receivedLength += chunk.byteLength;
                    var reportComplete = false;
                    if (this._contentLength != null && this._receivedLength < this._contentLength) {
                      this._openSubRange();
                    } else {
                      reportComplete = true;
                    }
                    if (this._onDataArrival) {
                      this._onDataArrival(chunk, byteStart, this._receivedLength);
                    }
                    if (reportComplete) {
                      this._status = _loader_js__WEBPACK_IMPORTED_MODULE_2__.LoaderStatus.kComplete;
                      if (this._onComplete) {
                        this._onComplete(this._range.from, this._range.from + this._receivedLength - 1);
                      }
                    }
                  };
                  RangeLoader2.prototype._onXhrError = function(e2) {
                    this._status = _loader_js__WEBPACK_IMPORTED_MODULE_2__.LoaderStatus.kError;
                    var type2 = 0;
                    var info = null;
                    if (this._contentLength && this._receivedLength > 0 && this._receivedLength < this._contentLength) {
                      type2 = _loader_js__WEBPACK_IMPORTED_MODULE_2__.LoaderErrors.EARLY_EOF;
                      info = { code: -1, msg: "RangeLoader meet Early-Eof" };
                    } else {
                      type2 = _loader_js__WEBPACK_IMPORTED_MODULE_2__.LoaderErrors.EXCEPTION;
                      info = { code: -1, msg: e2.constructor.name + " " + e2.type };
                    }
                    if (this._onError) {
                      this._onError(type2, info);
                    } else {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_3__.RuntimeException(info.msg);
                    }
                  };
                  return RangeLoader2;
                }(_loader_js__WEBPACK_IMPORTED_MODULE_2__.BaseLoader)
              );
              __webpack_exports__2["default"] = RangeLoader;
            }
          ),
          /***/
          "./src/player/flv-player.js": (
            /*!**********************************!*\
              !*** ./src/player/flv-player.js ***!
              \**********************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! events */
                "./node_modules/events/events.js"
              );
              var events__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(events__WEBPACK_IMPORTED_MODULE_0__);
              var _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ../utils/logger.js */
                "./src/utils/logger.js"
              );
              var _utils_browser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ../utils/browser.js */
                "./src/utils/browser.js"
              );
              var _player_events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ./player-events.js */
                "./src/player/player-events.js"
              );
              var _core_transmuxer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ../core/transmuxer.js */
                "./src/core/transmuxer.js"
              );
              var _core_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ../core/transmuxing-events.js */
                "./src/core/transmuxing-events.js"
              );
              var _core_mse_controller_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                /*! ../core/mse-controller.js */
                "./src/core/mse-controller.js"
              );
              var _core_mse_events_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                /*! ../core/mse-events.js */
                "./src/core/mse-events.js"
              );
              var _player_errors_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                /*! ./player-errors.js */
                "./src/player/player-errors.js"
              );
              var _config_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__2(
                /*! ../config.js */
                "./src/config.js"
              );
              var _utils_exception_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__2(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              );
              var FlvPlayer = (
                /** @class */
                function() {
                  function FlvPlayer2(mediaDataSource, config) {
                    this.TAG = "FlvPlayer";
                    this._type = "FlvPlayer";
                    this._emitter = new (events__WEBPACK_IMPORTED_MODULE_0___default())();
                    this._config = (0, _config_js__WEBPACK_IMPORTED_MODULE_9__.createDefaultConfig)();
                    if (typeof config === "object") {
                      Object.assign(this._config, config);
                    }
                    if (mediaDataSource.type.toLowerCase() !== "flv") {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_10__.InvalidArgumentException("FlvPlayer requires an flv MediaDataSource input!");
                    }
                    if (mediaDataSource.isLive === true) {
                      this._config.isLive = true;
                    }
                    this.e = {
                      onvLoadedMetadata: this._onvLoadedMetadata.bind(this),
                      onvSeeking: this._onvSeeking.bind(this),
                      onvCanPlay: this._onvCanPlay.bind(this),
                      onvStalled: this._onvStalled.bind(this),
                      onvProgress: this._onvProgress.bind(this)
                    };
                    if (self.performance && self.performance.now) {
                      this._now = self.performance.now.bind(self.performance);
                    } else {
                      this._now = Date.now;
                    }
                    this._pendingSeekTime = null;
                    this._requestSetTime = false;
                    this._seekpointRecord = null;
                    this._progressChecker = null;
                    this._mediaDataSource = mediaDataSource;
                    this._mediaElement = null;
                    this._msectl = null;
                    this._transmuxer = null;
                    this._mseSourceOpened = false;
                    this._hasPendingLoad = false;
                    this._receivedCanPlay = false;
                    this._mediaInfo = null;
                    this._statisticsInfo = null;
                    var chromeNeedIDRFix = _utils_browser_js__WEBPACK_IMPORTED_MODULE_2__.default.chrome && (_utils_browser_js__WEBPACK_IMPORTED_MODULE_2__.default.version.major < 50 || _utils_browser_js__WEBPACK_IMPORTED_MODULE_2__.default.version.major === 50 && _utils_browser_js__WEBPACK_IMPORTED_MODULE_2__.default.version.build < 2661);
                    this._alwaysSeekKeyframe = chromeNeedIDRFix || _utils_browser_js__WEBPACK_IMPORTED_MODULE_2__.default.msedge || _utils_browser_js__WEBPACK_IMPORTED_MODULE_2__.default.msie ? true : false;
                    if (this._alwaysSeekKeyframe) {
                      this._config.accurateSeek = false;
                    }
                  }
                  FlvPlayer2.prototype.destroy = function() {
                    if (this._progressChecker != null) {
                      window.clearInterval(this._progressChecker);
                      this._progressChecker = null;
                    }
                    if (this._transmuxer) {
                      this.unload();
                    }
                    if (this._mediaElement) {
                      this.detachMediaElement();
                    }
                    this.e = null;
                    this._mediaDataSource = null;
                    this._emitter.removeAllListeners();
                    this._emitter = null;
                  };
                  FlvPlayer2.prototype.on = function(event, listener) {
                    var _this = this;
                    if (event === _player_events_js__WEBPACK_IMPORTED_MODULE_3__.default.MEDIA_INFO) {
                      if (this._mediaInfo != null) {
                        Promise.resolve().then(function() {
                          _this._emitter.emit(_player_events_js__WEBPACK_IMPORTED_MODULE_3__.default.MEDIA_INFO, _this.mediaInfo);
                        });
                      }
                    } else if (event === _player_events_js__WEBPACK_IMPORTED_MODULE_3__.default.STATISTICS_INFO) {
                      if (this._statisticsInfo != null) {
                        Promise.resolve().then(function() {
                          _this._emitter.emit(_player_events_js__WEBPACK_IMPORTED_MODULE_3__.default.STATISTICS_INFO, _this.statisticsInfo);
                        });
                      }
                    }
                    this._emitter.addListener(event, listener);
                  };
                  FlvPlayer2.prototype.off = function(event, listener) {
                    this._emitter.removeListener(event, listener);
                  };
                  FlvPlayer2.prototype.attachMediaElement = function(mediaElement) {
                    var _this = this;
                    this._mediaElement = mediaElement;
                    mediaElement.addEventListener("loadedmetadata", this.e.onvLoadedMetadata);
                    mediaElement.addEventListener("seeking", this.e.onvSeeking);
                    mediaElement.addEventListener("canplay", this.e.onvCanPlay);
                    mediaElement.addEventListener("stalled", this.e.onvStalled);
                    mediaElement.addEventListener("progress", this.e.onvProgress);
                    this._msectl = new _core_mse_controller_js__WEBPACK_IMPORTED_MODULE_6__.default(this._config);
                    this._msectl.on(_core_mse_events_js__WEBPACK_IMPORTED_MODULE_7__.default.UPDATE_END, this._onmseUpdateEnd.bind(this));
                    this._msectl.on(_core_mse_events_js__WEBPACK_IMPORTED_MODULE_7__.default.BUFFER_FULL, this._onmseBufferFull.bind(this));
                    this._msectl.on(_core_mse_events_js__WEBPACK_IMPORTED_MODULE_7__.default.SOURCE_OPEN, function() {
                      _this._mseSourceOpened = true;
                      if (_this._hasPendingLoad) {
                        _this._hasPendingLoad = false;
                        _this.load();
                      }
                    });
                    this._msectl.on(_core_mse_events_js__WEBPACK_IMPORTED_MODULE_7__.default.ERROR, function(info) {
                      _this._emitter.emit(_player_events_js__WEBPACK_IMPORTED_MODULE_3__.default.ERROR, _player_errors_js__WEBPACK_IMPORTED_MODULE_8__.ErrorTypes.MEDIA_ERROR, _player_errors_js__WEBPACK_IMPORTED_MODULE_8__.ErrorDetails.MEDIA_MSE_ERROR, info);
                    });
                    this._msectl.attachMediaElement(mediaElement);
                    if (this._pendingSeekTime != null) {
                      try {
                        mediaElement.currentTime = this._pendingSeekTime;
                        this._pendingSeekTime = null;
                      } catch (e2) {
                      }
                    }
                  };
                  FlvPlayer2.prototype.detachMediaElement = function() {
                    if (this._mediaElement) {
                      this._msectl.detachMediaElement();
                      this._mediaElement.removeEventListener("loadedmetadata", this.e.onvLoadedMetadata);
                      this._mediaElement.removeEventListener("seeking", this.e.onvSeeking);
                      this._mediaElement.removeEventListener("canplay", this.e.onvCanPlay);
                      this._mediaElement.removeEventListener("stalled", this.e.onvStalled);
                      this._mediaElement.removeEventListener("progress", this.e.onvProgress);
                      this._mediaElement = null;
                    }
                    if (this._msectl) {
                      this._msectl.destroy();
                      this._msectl = null;
                    }
                  };
                  FlvPlayer2.prototype.load = function() {
                    var _this = this;
                    if (!this._mediaElement) {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_10__.IllegalStateException("HTMLMediaElement must be attached before load()!");
                    }
                    if (this._transmuxer) {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_10__.IllegalStateException("FlvPlayer.load() has been called, please call unload() first!");
                    }
                    if (this._hasPendingLoad) {
                      return;
                    }
                    if (this._config.deferLoadAfterSourceOpen && this._mseSourceOpened === false) {
                      this._hasPendingLoad = true;
                      return;
                    }
                    if (this._mediaElement.readyState > 0) {
                      this._requestSetTime = true;
                      this._mediaElement.currentTime = 0;
                    }
                    this._transmuxer = new _core_transmuxer_js__WEBPACK_IMPORTED_MODULE_4__.default(this._mediaDataSource, this._config);
                    this._transmuxer.on(_core_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.INIT_SEGMENT, function(type2, is) {
                      _this._msectl.appendInitSegment(is);
                    });
                    this._transmuxer.on(_core_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.MEDIA_SEGMENT, function(type2, ms) {
                      _this._msectl.appendMediaSegment(ms);
                      if (_this._config.lazyLoad && !_this._config.isLive) {
                        var currentTime = _this._mediaElement.currentTime;
                        if (ms.info.endDts >= (currentTime + _this._config.lazyLoadMaxDuration) * 1e3) {
                          if (_this._progressChecker == null) {
                            _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.v(_this.TAG, "Maximum buffering duration exceeded, suspend transmuxing task");
                            _this._suspendTransmuxer();
                          }
                        }
                      }
                    });
                    this._transmuxer.on(_core_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.LOADING_COMPLETE, function() {
                      _this._msectl.endOfStream();
                      _this._emitter.emit(_player_events_js__WEBPACK_IMPORTED_MODULE_3__.default.LOADING_COMPLETE);
                    });
                    this._transmuxer.on(_core_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.RECOVERED_EARLY_EOF, function() {
                      _this._emitter.emit(_player_events_js__WEBPACK_IMPORTED_MODULE_3__.default.RECOVERED_EARLY_EOF);
                    });
                    this._transmuxer.on(_core_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.IO_ERROR, function(detail, info) {
                      _this._emitter.emit(_player_events_js__WEBPACK_IMPORTED_MODULE_3__.default.ERROR, _player_errors_js__WEBPACK_IMPORTED_MODULE_8__.ErrorTypes.NETWORK_ERROR, detail, info);
                    });
                    this._transmuxer.on(_core_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.DEMUX_ERROR, function(detail, info) {
                      _this._emitter.emit(_player_events_js__WEBPACK_IMPORTED_MODULE_3__.default.ERROR, _player_errors_js__WEBPACK_IMPORTED_MODULE_8__.ErrorTypes.MEDIA_ERROR, detail, { code: -1, msg: info });
                    });
                    this._transmuxer.on(_core_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.MEDIA_INFO, function(mediaInfo) {
                      _this._mediaInfo = mediaInfo;
                      _this._emitter.emit(_player_events_js__WEBPACK_IMPORTED_MODULE_3__.default.MEDIA_INFO, Object.assign({}, mediaInfo));
                    });
                    this._transmuxer.on(_core_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.METADATA_ARRIVED, function(metadata) {
                      _this._emitter.emit(_player_events_js__WEBPACK_IMPORTED_MODULE_3__.default.METADATA_ARRIVED, metadata);
                    });
                    this._transmuxer.on(_core_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.SCRIPTDATA_ARRIVED, function(data2) {
                      _this._emitter.emit(_player_events_js__WEBPACK_IMPORTED_MODULE_3__.default.SCRIPTDATA_ARRIVED, data2);
                    });
                    this._transmuxer.on(_core_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.STATISTICS_INFO, function(statInfo) {
                      _this._statisticsInfo = _this._fillStatisticsInfo(statInfo);
                      _this._emitter.emit(_player_events_js__WEBPACK_IMPORTED_MODULE_3__.default.STATISTICS_INFO, Object.assign({}, _this._statisticsInfo));
                    });
                    this._transmuxer.on(_core_transmuxing_events_js__WEBPACK_IMPORTED_MODULE_5__.default.RECOMMEND_SEEKPOINT, function(milliseconds) {
                      if (_this._mediaElement && !_this._config.accurateSeek) {
                        _this._requestSetTime = true;
                        _this._mediaElement.currentTime = milliseconds / 1e3;
                      }
                    });
                    this._transmuxer.open();
                  };
                  FlvPlayer2.prototype.unload = function() {
                    if (this._mediaElement) {
                      this._mediaElement.pause();
                    }
                    if (this._msectl) {
                      this._msectl.seek(0);
                    }
                    if (this._transmuxer) {
                      this._transmuxer.close();
                      this._transmuxer.destroy();
                      this._transmuxer = null;
                    }
                  };
                  FlvPlayer2.prototype.play = function() {
                    return this._mediaElement.play();
                  };
                  FlvPlayer2.prototype.pause = function() {
                    this._mediaElement.pause();
                  };
                  Object.defineProperty(FlvPlayer2.prototype, "type", {
                    get: function() {
                      return this._type;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(FlvPlayer2.prototype, "buffered", {
                    get: function() {
                      return this._mediaElement.buffered;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(FlvPlayer2.prototype, "duration", {
                    get: function() {
                      return this._mediaElement.duration;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(FlvPlayer2.prototype, "volume", {
                    get: function() {
                      return this._mediaElement.volume;
                    },
                    set: function(value) {
                      this._mediaElement.volume = value;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(FlvPlayer2.prototype, "muted", {
                    get: function() {
                      return this._mediaElement.muted;
                    },
                    set: function(muted) {
                      this._mediaElement.muted = muted;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(FlvPlayer2.prototype, "currentTime", {
                    get: function() {
                      if (this._mediaElement) {
                        return this._mediaElement.currentTime;
                      }
                      return 0;
                    },
                    set: function(seconds) {
                      if (this._mediaElement) {
                        this._internalSeek(seconds);
                      } else {
                        this._pendingSeekTime = seconds;
                      }
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(FlvPlayer2.prototype, "mediaInfo", {
                    get: function() {
                      return Object.assign({}, this._mediaInfo);
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(FlvPlayer2.prototype, "statisticsInfo", {
                    get: function() {
                      if (this._statisticsInfo == null) {
                        this._statisticsInfo = {};
                      }
                      this._statisticsInfo = this._fillStatisticsInfo(this._statisticsInfo);
                      return Object.assign({}, this._statisticsInfo);
                    },
                    enumerable: false,
                    configurable: true
                  });
                  FlvPlayer2.prototype._fillStatisticsInfo = function(statInfo) {
                    statInfo.playerType = this._type;
                    if (!(this._mediaElement instanceof HTMLVideoElement)) {
                      return statInfo;
                    }
                    var hasQualityInfo = true;
                    var decoded = 0;
                    var dropped = 0;
                    if (this._mediaElement.getVideoPlaybackQuality) {
                      var quality = this._mediaElement.getVideoPlaybackQuality();
                      decoded = quality.totalVideoFrames;
                      dropped = quality.droppedVideoFrames;
                    } else if (this._mediaElement.webkitDecodedFrameCount != void 0) {
                      decoded = this._mediaElement.webkitDecodedFrameCount;
                      dropped = this._mediaElement.webkitDroppedFrameCount;
                    } else {
                      hasQualityInfo = false;
                    }
                    if (hasQualityInfo) {
                      statInfo.decodedFrames = decoded;
                      statInfo.droppedFrames = dropped;
                    }
                    return statInfo;
                  };
                  FlvPlayer2.prototype._onmseUpdateEnd = function() {
                    if (!this._config.lazyLoad || this._config.isLive) {
                      return;
                    }
                    var buffered = this._mediaElement.buffered;
                    var currentTime = this._mediaElement.currentTime;
                    var currentRangeEnd = 0;
                    for (var i2 = 0; i2 < buffered.length; i2++) {
                      var start = buffered.start(i2);
                      var end2 = buffered.end(i2);
                      if (start <= currentTime && currentTime < end2) {
                        currentRangeEnd = end2;
                        break;
                      }
                    }
                    if (currentRangeEnd >= currentTime + this._config.lazyLoadMaxDuration && this._progressChecker == null) {
                      _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.v(this.TAG, "Maximum buffering duration exceeded, suspend transmuxing task");
                      this._suspendTransmuxer();
                    }
                  };
                  FlvPlayer2.prototype._onmseBufferFull = function() {
                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.v(this.TAG, "MSE SourceBuffer is full, suspend transmuxing task");
                    if (this._progressChecker == null) {
                      this._suspendTransmuxer();
                    }
                  };
                  FlvPlayer2.prototype._suspendTransmuxer = function() {
                    if (this._transmuxer) {
                      this._transmuxer.pause();
                      if (this._progressChecker == null) {
                        this._progressChecker = window.setInterval(this._checkProgressAndResume.bind(this), 1e3);
                      }
                    }
                  };
                  FlvPlayer2.prototype._checkProgressAndResume = function() {
                    var currentTime = this._mediaElement.currentTime;
                    var buffered = this._mediaElement.buffered;
                    var needResume = false;
                    for (var i2 = 0; i2 < buffered.length; i2++) {
                      var from2 = buffered.start(i2);
                      var to = buffered.end(i2);
                      if (currentTime >= from2 && currentTime < to) {
                        if (currentTime >= to - this._config.lazyLoadRecoverDuration) {
                          needResume = true;
                        }
                        break;
                      }
                    }
                    if (needResume) {
                      window.clearInterval(this._progressChecker);
                      this._progressChecker = null;
                      if (needResume) {
                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.v(this.TAG, "Continue loading from paused position");
                        this._transmuxer.resume();
                      }
                    }
                  };
                  FlvPlayer2.prototype._isTimepointBuffered = function(seconds) {
                    var buffered = this._mediaElement.buffered;
                    for (var i2 = 0; i2 < buffered.length; i2++) {
                      var from2 = buffered.start(i2);
                      var to = buffered.end(i2);
                      if (seconds >= from2 && seconds < to) {
                        return true;
                      }
                    }
                    return false;
                  };
                  FlvPlayer2.prototype._internalSeek = function(seconds) {
                    var directSeek = this._isTimepointBuffered(seconds);
                    var directSeekBegin = false;
                    var directSeekBeginTime = 0;
                    if (seconds < 1 && this._mediaElement.buffered.length > 0) {
                      var videoBeginTime = this._mediaElement.buffered.start(0);
                      if (videoBeginTime < 1 && seconds < videoBeginTime || _utils_browser_js__WEBPACK_IMPORTED_MODULE_2__.default.safari) {
                        directSeekBegin = true;
                        directSeekBeginTime = _utils_browser_js__WEBPACK_IMPORTED_MODULE_2__.default.safari ? 0.1 : videoBeginTime;
                      }
                    }
                    if (directSeekBegin) {
                      this._requestSetTime = true;
                      this._mediaElement.currentTime = directSeekBeginTime;
                    } else if (directSeek) {
                      if (!this._alwaysSeekKeyframe) {
                        this._requestSetTime = true;
                        this._mediaElement.currentTime = seconds;
                      } else {
                        var idr = this._msectl.getNearestKeyframe(Math.floor(seconds * 1e3));
                        this._requestSetTime = true;
                        if (idr != null) {
                          this._mediaElement.currentTime = idr.dts / 1e3;
                        } else {
                          this._mediaElement.currentTime = seconds;
                        }
                      }
                      if (this._progressChecker != null) {
                        this._checkProgressAndResume();
                      }
                    } else {
                      if (this._progressChecker != null) {
                        window.clearInterval(this._progressChecker);
                        this._progressChecker = null;
                      }
                      this._msectl.seek(seconds);
                      this._transmuxer.seek(Math.floor(seconds * 1e3));
                      if (this._config.accurateSeek) {
                        this._requestSetTime = true;
                        this._mediaElement.currentTime = seconds;
                      }
                    }
                  };
                  FlvPlayer2.prototype._checkAndApplyUnbufferedSeekpoint = function() {
                    if (this._seekpointRecord) {
                      if (this._seekpointRecord.recordTime <= this._now() - 100) {
                        var target = this._mediaElement.currentTime;
                        this._seekpointRecord = null;
                        if (!this._isTimepointBuffered(target)) {
                          if (this._progressChecker != null) {
                            window.clearTimeout(this._progressChecker);
                            this._progressChecker = null;
                          }
                          this._msectl.seek(target);
                          this._transmuxer.seek(Math.floor(target * 1e3));
                          if (this._config.accurateSeek) {
                            this._requestSetTime = true;
                            this._mediaElement.currentTime = target;
                          }
                        }
                      } else {
                        window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50);
                      }
                    }
                  };
                  FlvPlayer2.prototype._checkAndResumeStuckPlayback = function(stalled) {
                    var media = this._mediaElement;
                    if (stalled || !this._receivedCanPlay || media.readyState < 2) {
                      var buffered = media.buffered;
                      if (buffered.length > 0 && media.currentTime < buffered.start(0)) {
                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.w(this.TAG, "Playback seems stuck at " + media.currentTime + ", seek to " + buffered.start(0));
                        this._requestSetTime = true;
                        this._mediaElement.currentTime = buffered.start(0);
                        this._mediaElement.removeEventListener("progress", this.e.onvProgress);
                      }
                    } else {
                      this._mediaElement.removeEventListener("progress", this.e.onvProgress);
                    }
                  };
                  FlvPlayer2.prototype._onvLoadedMetadata = function(e2) {
                    if (this._pendingSeekTime != null) {
                      this._mediaElement.currentTime = this._pendingSeekTime;
                      this._pendingSeekTime = null;
                    }
                  };
                  FlvPlayer2.prototype._onvSeeking = function(e2) {
                    var target = this._mediaElement.currentTime;
                    var buffered = this._mediaElement.buffered;
                    if (this._requestSetTime) {
                      this._requestSetTime = false;
                      return;
                    }
                    if (target < 1 && buffered.length > 0) {
                      var videoBeginTime = buffered.start(0);
                      if (videoBeginTime < 1 && target < videoBeginTime || _utils_browser_js__WEBPACK_IMPORTED_MODULE_2__.default.safari) {
                        this._requestSetTime = true;
                        this._mediaElement.currentTime = _utils_browser_js__WEBPACK_IMPORTED_MODULE_2__.default.safari ? 0.1 : videoBeginTime;
                        return;
                      }
                    }
                    if (this._isTimepointBuffered(target)) {
                      if (this._alwaysSeekKeyframe) {
                        var idr = this._msectl.getNearestKeyframe(Math.floor(target * 1e3));
                        if (idr != null) {
                          this._requestSetTime = true;
                          this._mediaElement.currentTime = idr.dts / 1e3;
                        }
                      }
                      if (this._progressChecker != null) {
                        this._checkProgressAndResume();
                      }
                      return;
                    }
                    this._seekpointRecord = {
                      seekPoint: target,
                      recordTime: this._now()
                    };
                    window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50);
                  };
                  FlvPlayer2.prototype._onvCanPlay = function(e2) {
                    this._receivedCanPlay = true;
                    this._mediaElement.removeEventListener("canplay", this.e.onvCanPlay);
                  };
                  FlvPlayer2.prototype._onvStalled = function(e2) {
                    this._checkAndResumeStuckPlayback(true);
                  };
                  FlvPlayer2.prototype._onvProgress = function(e2) {
                    this._checkAndResumeStuckPlayback();
                  };
                  return FlvPlayer2;
                }()
              );
              __webpack_exports__2["default"] = FlvPlayer;
            }
          ),
          /***/
          "./src/player/native-player.js": (
            /*!*************************************!*\
              !*** ./src/player/native-player.js ***!
              \*************************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! events */
                "./node_modules/events/events.js"
              );
              var events__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(events__WEBPACK_IMPORTED_MODULE_0__);
              var _player_events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./player-events.js */
                "./src/player/player-events.js"
              );
              var _config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ../config.js */
                "./src/config.js"
              );
              var _utils_exception_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              );
              var NativePlayer = (
                /** @class */
                function() {
                  function NativePlayer2(mediaDataSource, config) {
                    this.TAG = "NativePlayer";
                    this._type = "NativePlayer";
                    this._emitter = new (events__WEBPACK_IMPORTED_MODULE_0___default())();
                    this._config = (0, _config_js__WEBPACK_IMPORTED_MODULE_2__.createDefaultConfig)();
                    if (typeof config === "object") {
                      Object.assign(this._config, config);
                    }
                    if (mediaDataSource.type.toLowerCase() === "flv") {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentException("NativePlayer does't support flv MediaDataSource input!");
                    }
                    if (mediaDataSource.hasOwnProperty("segments")) {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentException("NativePlayer(" + mediaDataSource.type + ") doesn't support multipart playback!");
                    }
                    this.e = {
                      onvLoadedMetadata: this._onvLoadedMetadata.bind(this)
                    };
                    this._pendingSeekTime = null;
                    this._statisticsReporter = null;
                    this._mediaDataSource = mediaDataSource;
                    this._mediaElement = null;
                  }
                  NativePlayer2.prototype.destroy = function() {
                    if (this._mediaElement) {
                      this.unload();
                      this.detachMediaElement();
                    }
                    this.e = null;
                    this._mediaDataSource = null;
                    this._emitter.removeAllListeners();
                    this._emitter = null;
                  };
                  NativePlayer2.prototype.on = function(event, listener) {
                    var _this = this;
                    if (event === _player_events_js__WEBPACK_IMPORTED_MODULE_1__.default.MEDIA_INFO) {
                      if (this._mediaElement != null && this._mediaElement.readyState !== 0) {
                        Promise.resolve().then(function() {
                          _this._emitter.emit(_player_events_js__WEBPACK_IMPORTED_MODULE_1__.default.MEDIA_INFO, _this.mediaInfo);
                        });
                      }
                    } else if (event === _player_events_js__WEBPACK_IMPORTED_MODULE_1__.default.STATISTICS_INFO) {
                      if (this._mediaElement != null && this._mediaElement.readyState !== 0) {
                        Promise.resolve().then(function() {
                          _this._emitter.emit(_player_events_js__WEBPACK_IMPORTED_MODULE_1__.default.STATISTICS_INFO, _this.statisticsInfo);
                        });
                      }
                    }
                    this._emitter.addListener(event, listener);
                  };
                  NativePlayer2.prototype.off = function(event, listener) {
                    this._emitter.removeListener(event, listener);
                  };
                  NativePlayer2.prototype.attachMediaElement = function(mediaElement) {
                    this._mediaElement = mediaElement;
                    mediaElement.addEventListener("loadedmetadata", this.e.onvLoadedMetadata);
                    if (this._pendingSeekTime != null) {
                      try {
                        mediaElement.currentTime = this._pendingSeekTime;
                        this._pendingSeekTime = null;
                      } catch (e2) {
                      }
                    }
                  };
                  NativePlayer2.prototype.detachMediaElement = function() {
                    if (this._mediaElement) {
                      this._mediaElement.src = "";
                      this._mediaElement.removeAttribute("src");
                      this._mediaElement.removeEventListener("loadedmetadata", this.e.onvLoadedMetadata);
                      this._mediaElement = null;
                    }
                    if (this._statisticsReporter != null) {
                      window.clearInterval(this._statisticsReporter);
                      this._statisticsReporter = null;
                    }
                  };
                  NativePlayer2.prototype.load = function() {
                    if (!this._mediaElement) {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_3__.IllegalStateException("HTMLMediaElement must be attached before load()!");
                    }
                    this._mediaElement.src = this._mediaDataSource.url;
                    if (this._mediaElement.readyState > 0) {
                      this._mediaElement.currentTime = 0;
                    }
                    this._mediaElement.preload = "auto";
                    this._mediaElement.load();
                    this._statisticsReporter = window.setInterval(this._reportStatisticsInfo.bind(this), this._config.statisticsInfoReportInterval);
                  };
                  NativePlayer2.prototype.unload = function() {
                    if (this._mediaElement) {
                      this._mediaElement.src = "";
                      this._mediaElement.removeAttribute("src");
                    }
                    if (this._statisticsReporter != null) {
                      window.clearInterval(this._statisticsReporter);
                      this._statisticsReporter = null;
                    }
                  };
                  NativePlayer2.prototype.play = function() {
                    return this._mediaElement.play();
                  };
                  NativePlayer2.prototype.pause = function() {
                    this._mediaElement.pause();
                  };
                  Object.defineProperty(NativePlayer2.prototype, "type", {
                    get: function() {
                      return this._type;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(NativePlayer2.prototype, "buffered", {
                    get: function() {
                      return this._mediaElement.buffered;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(NativePlayer2.prototype, "duration", {
                    get: function() {
                      return this._mediaElement.duration;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(NativePlayer2.prototype, "volume", {
                    get: function() {
                      return this._mediaElement.volume;
                    },
                    set: function(value) {
                      this._mediaElement.volume = value;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(NativePlayer2.prototype, "muted", {
                    get: function() {
                      return this._mediaElement.muted;
                    },
                    set: function(muted) {
                      this._mediaElement.muted = muted;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(NativePlayer2.prototype, "currentTime", {
                    get: function() {
                      if (this._mediaElement) {
                        return this._mediaElement.currentTime;
                      }
                      return 0;
                    },
                    set: function(seconds) {
                      if (this._mediaElement) {
                        this._mediaElement.currentTime = seconds;
                      } else {
                        this._pendingSeekTime = seconds;
                      }
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(NativePlayer2.prototype, "mediaInfo", {
                    get: function() {
                      var mediaPrefix = this._mediaElement instanceof HTMLAudioElement ? "audio/" : "video/";
                      var info = {
                        mimeType: mediaPrefix + this._mediaDataSource.type
                      };
                      if (this._mediaElement) {
                        info.duration = Math.floor(this._mediaElement.duration * 1e3);
                        if (this._mediaElement instanceof HTMLVideoElement) {
                          info.width = this._mediaElement.videoWidth;
                          info.height = this._mediaElement.videoHeight;
                        }
                      }
                      return info;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(NativePlayer2.prototype, "statisticsInfo", {
                    get: function() {
                      var info = {
                        playerType: this._type,
                        url: this._mediaDataSource.url
                      };
                      if (!(this._mediaElement instanceof HTMLVideoElement)) {
                        return info;
                      }
                      var hasQualityInfo = true;
                      var decoded = 0;
                      var dropped = 0;
                      if (this._mediaElement.getVideoPlaybackQuality) {
                        var quality = this._mediaElement.getVideoPlaybackQuality();
                        decoded = quality.totalVideoFrames;
                        dropped = quality.droppedVideoFrames;
                      } else if (this._mediaElement.webkitDecodedFrameCount != void 0) {
                        decoded = this._mediaElement.webkitDecodedFrameCount;
                        dropped = this._mediaElement.webkitDroppedFrameCount;
                      } else {
                        hasQualityInfo = false;
                      }
                      if (hasQualityInfo) {
                        info.decodedFrames = decoded;
                        info.droppedFrames = dropped;
                      }
                      return info;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  NativePlayer2.prototype._onvLoadedMetadata = function(e2) {
                    if (this._pendingSeekTime != null) {
                      this._mediaElement.currentTime = this._pendingSeekTime;
                      this._pendingSeekTime = null;
                    }
                    this._emitter.emit(_player_events_js__WEBPACK_IMPORTED_MODULE_1__.default.MEDIA_INFO, this.mediaInfo);
                  };
                  NativePlayer2.prototype._reportStatisticsInfo = function() {
                    this._emitter.emit(_player_events_js__WEBPACK_IMPORTED_MODULE_1__.default.STATISTICS_INFO, this.statisticsInfo);
                  };
                  return NativePlayer2;
                }()
              );
              __webpack_exports__2["default"] = NativePlayer;
            }
          ),
          /***/
          "./src/player/player-errors.js": (
            /*!*************************************!*\
              !*** ./src/player/player-errors.js ***!
              \*************************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "ErrorTypes": function() {
                  return (
                    /* binding */
                    ErrorTypes
                  );
                },
                /* harmony export */
                "ErrorDetails": function() {
                  return (
                    /* binding */
                    ErrorDetails
                  );
                }
                /* harmony export */
              });
              var _io_loader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../io/loader.js */
                "./src/io/loader.js"
              );
              var _demux_demux_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ../demux/demux-errors.js */
                "./src/demux/demux-errors.js"
              );
              var ErrorTypes = {
                NETWORK_ERROR: "NetworkError",
                MEDIA_ERROR: "MediaError",
                OTHER_ERROR: "OtherError"
              };
              var ErrorDetails = {
                NETWORK_EXCEPTION: _io_loader_js__WEBPACK_IMPORTED_MODULE_0__.LoaderErrors.EXCEPTION,
                NETWORK_STATUS_CODE_INVALID: _io_loader_js__WEBPACK_IMPORTED_MODULE_0__.LoaderErrors.HTTP_STATUS_CODE_INVALID,
                NETWORK_TIMEOUT: _io_loader_js__WEBPACK_IMPORTED_MODULE_0__.LoaderErrors.CONNECTING_TIMEOUT,
                NETWORK_UNRECOVERABLE_EARLY_EOF: _io_loader_js__WEBPACK_IMPORTED_MODULE_0__.LoaderErrors.UNRECOVERABLE_EARLY_EOF,
                MEDIA_MSE_ERROR: "MediaMSEError",
                MEDIA_FORMAT_ERROR: _demux_demux_errors_js__WEBPACK_IMPORTED_MODULE_1__.default.FORMAT_ERROR,
                MEDIA_FORMAT_UNSUPPORTED: _demux_demux_errors_js__WEBPACK_IMPORTED_MODULE_1__.default.FORMAT_UNSUPPORTED,
                MEDIA_CODEC_UNSUPPORTED: _demux_demux_errors_js__WEBPACK_IMPORTED_MODULE_1__.default.CODEC_UNSUPPORTED
              };
            }
          ),
          /***/
          "./src/player/player-events.js": (
            /*!*************************************!*\
              !*** ./src/player/player-events.js ***!
              \*************************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var PlayerEvents = {
                ERROR: "error",
                LOADING_COMPLETE: "loading_complete",
                RECOVERED_EARLY_EOF: "recovered_early_eof",
                MEDIA_INFO: "media_info",
                METADATA_ARRIVED: "metadata_arrived",
                SCRIPTDATA_ARRIVED: "scriptdata_arrived",
                STATISTICS_INFO: "statistics_info"
              };
              __webpack_exports__2["default"] = PlayerEvents;
            }
          ),
          /***/
          "./src/remux/aac-silent.js": (
            /*!*********************************!*\
              !*** ./src/remux/aac-silent.js ***!
              \*********************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var AAC = (
                /** @class */
                function() {
                  function AAC2() {
                  }
                  AAC2.getSilentFrame = function(codec, channelCount) {
                    if (codec === "mp4a.40.2") {
                      if (channelCount === 1) {
                        return new Uint8Array([0, 200, 0, 128, 35, 128]);
                      } else if (channelCount === 2) {
                        return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
                      } else if (channelCount === 3) {
                        return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
                      } else if (channelCount === 4) {
                        return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
                      } else if (channelCount === 5) {
                        return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
                      } else if (channelCount === 6) {
                        return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
                      }
                    } else {
                      if (channelCount === 1) {
                        return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                      } else if (channelCount === 2) {
                        return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                      } else if (channelCount === 3) {
                        return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                      }
                    }
                    return null;
                  };
                  return AAC2;
                }()
              );
              __webpack_exports__2["default"] = AAC;
            }
          ),
          /***/
          "./src/remux/mp4-generator.js": (
            /*!************************************!*\
              !*** ./src/remux/mp4-generator.js ***!
              \************************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var MP4 = (
                /** @class */
                function() {
                  function MP42() {
                  }
                  MP42.init = function() {
                    MP42.types = {
                      avc1: [],
                      avcC: [],
                      btrt: [],
                      dinf: [],
                      dref: [],
                      esds: [],
                      ftyp: [],
                      hdlr: [],
                      mdat: [],
                      mdhd: [],
                      mdia: [],
                      mfhd: [],
                      minf: [],
                      moof: [],
                      moov: [],
                      mp4a: [],
                      mvex: [],
                      mvhd: [],
                      sdtp: [],
                      stbl: [],
                      stco: [],
                      stsc: [],
                      stsd: [],
                      stsz: [],
                      stts: [],
                      tfdt: [],
                      tfhd: [],
                      traf: [],
                      trak: [],
                      trun: [],
                      trex: [],
                      tkhd: [],
                      vmhd: [],
                      smhd: [],
                      ".mp3": []
                    };
                    for (var name_1 in MP42.types) {
                      if (MP42.types.hasOwnProperty(name_1)) {
                        MP42.types[name_1] = [
                          name_1.charCodeAt(0),
                          name_1.charCodeAt(1),
                          name_1.charCodeAt(2),
                          name_1.charCodeAt(3)
                        ];
                      }
                    }
                    var constants2 = MP42.constants = {};
                    constants2.FTYP = new Uint8Array([
                      105,
                      115,
                      111,
                      109,
                      0,
                      0,
                      0,
                      1,
                      105,
                      115,
                      111,
                      109,
                      97,
                      118,
                      99,
                      49
                      // avc1
                    ]);
                    constants2.STSD_PREFIX = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1
                      // entry_count
                    ]);
                    constants2.STTS = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0
                      // entry_count
                    ]);
                    constants2.STSC = constants2.STCO = constants2.STTS;
                    constants2.STSZ = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0
                      // sample_count
                    ]);
                    constants2.HDLR_VIDEO = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      118,
                      105,
                      100,
                      101,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      86,
                      105,
                      100,
                      101,
                      111,
                      72,
                      97,
                      110,
                      100,
                      108,
                      101,
                      114,
                      0
                      // name: VideoHandler
                    ]);
                    constants2.HDLR_AUDIO = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      115,
                      111,
                      117,
                      110,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      83,
                      111,
                      117,
                      110,
                      100,
                      72,
                      97,
                      110,
                      100,
                      108,
                      101,
                      114,
                      0
                      // name: SoundHandler
                    ]);
                    constants2.DREF = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      12,
                      117,
                      114,
                      108,
                      32,
                      0,
                      0,
                      0,
                      1
                      // version(0) + flags
                    ]);
                    constants2.SMHD = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0
                      // balance(2) + reserved(2)
                    ]);
                    constants2.VMHD = new Uint8Array([
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0
                    ]);
                  };
                  MP42.box = function(type2) {
                    var size = 8;
                    var result = null;
                    var datas = Array.prototype.slice.call(arguments, 1);
                    var arrayCount = datas.length;
                    for (var i2 = 0; i2 < arrayCount; i2++) {
                      size += datas[i2].byteLength;
                    }
                    result = new Uint8Array(size);
                    result[0] = size >>> 24 & 255;
                    result[1] = size >>> 16 & 255;
                    result[2] = size >>> 8 & 255;
                    result[3] = size & 255;
                    result.set(type2, 4);
                    var offset = 8;
                    for (var i2 = 0; i2 < arrayCount; i2++) {
                      result.set(datas[i2], offset);
                      offset += datas[i2].byteLength;
                    }
                    return result;
                  };
                  MP42.generateInitSegment = function(meta) {
                    var ftyp = MP42.box(MP42.types.ftyp, MP42.constants.FTYP);
                    var moov = MP42.moov(meta);
                    var result = new Uint8Array(ftyp.byteLength + moov.byteLength);
                    result.set(ftyp, 0);
                    result.set(moov, ftyp.byteLength);
                    return result;
                  };
                  MP42.moov = function(meta) {
                    var mvhd = MP42.mvhd(meta.timescale, meta.duration);
                    var trak = MP42.trak(meta);
                    var mvex = MP42.mvex(meta);
                    return MP42.box(MP42.types.moov, mvhd, trak, mvex);
                  };
                  MP42.mvhd = function(timescale, duration) {
                    return MP42.box(MP42.types.mvhd, new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      timescale >>> 24 & 255,
                      timescale >>> 16 & 255,
                      timescale >>> 8 & 255,
                      timescale & 255,
                      duration >>> 24 & 255,
                      duration >>> 16 & 255,
                      duration >>> 8 & 255,
                      duration & 255,
                      0,
                      1,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      64,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      255,
                      255,
                      255,
                      255
                      // next_track_ID
                    ]));
                  };
                  MP42.trak = function(meta) {
                    return MP42.box(MP42.types.trak, MP42.tkhd(meta), MP42.mdia(meta));
                  };
                  MP42.tkhd = function(meta) {
                    var trackId = meta.id, duration = meta.duration;
                    var width = meta.presentWidth, height = meta.presentHeight;
                    return MP42.box(MP42.types.tkhd, new Uint8Array([
                      0,
                      0,
                      0,
                      7,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      trackId >>> 24 & 255,
                      trackId >>> 16 & 255,
                      trackId >>> 8 & 255,
                      trackId & 255,
                      0,
                      0,
                      0,
                      0,
                      duration >>> 24 & 255,
                      duration >>> 16 & 255,
                      duration >>> 8 & 255,
                      duration & 255,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      64,
                      0,
                      0,
                      0,
                      width >>> 8 & 255,
                      width & 255,
                      0,
                      0,
                      height >>> 8 & 255,
                      height & 255,
                      0,
                      0
                    ]));
                  };
                  MP42.mdia = function(meta) {
                    return MP42.box(MP42.types.mdia, MP42.mdhd(meta), MP42.hdlr(meta), MP42.minf(meta));
                  };
                  MP42.mdhd = function(meta) {
                    var timescale = meta.timescale;
                    var duration = meta.duration;
                    return MP42.box(MP42.types.mdhd, new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      timescale >>> 24 & 255,
                      timescale >>> 16 & 255,
                      timescale >>> 8 & 255,
                      timescale & 255,
                      duration >>> 24 & 255,
                      duration >>> 16 & 255,
                      duration >>> 8 & 255,
                      duration & 255,
                      85,
                      196,
                      0,
                      0
                      // pre_defined = 0
                    ]));
                  };
                  MP42.hdlr = function(meta) {
                    var data2 = null;
                    if (meta.type === "audio") {
                      data2 = MP42.constants.HDLR_AUDIO;
                    } else {
                      data2 = MP42.constants.HDLR_VIDEO;
                    }
                    return MP42.box(MP42.types.hdlr, data2);
                  };
                  MP42.minf = function(meta) {
                    var xmhd = null;
                    if (meta.type === "audio") {
                      xmhd = MP42.box(MP42.types.smhd, MP42.constants.SMHD);
                    } else {
                      xmhd = MP42.box(MP42.types.vmhd, MP42.constants.VMHD);
                    }
                    return MP42.box(MP42.types.minf, xmhd, MP42.dinf(), MP42.stbl(meta));
                  };
                  MP42.dinf = function() {
                    var result = MP42.box(MP42.types.dinf, MP42.box(MP42.types.dref, MP42.constants.DREF));
                    return result;
                  };
                  MP42.stbl = function(meta) {
                    var result = MP42.box(
                      MP42.types.stbl,
                      // type: stbl
                      MP42.stsd(meta),
                      // Sample Description Table
                      MP42.box(MP42.types.stts, MP42.constants.STTS),
                      // Time-To-Sample
                      MP42.box(MP42.types.stsc, MP42.constants.STSC),
                      // Sample-To-Chunk
                      MP42.box(MP42.types.stsz, MP42.constants.STSZ),
                      // Sample size
                      MP42.box(MP42.types.stco, MP42.constants.STCO)
                      // Chunk offset
                    );
                    return result;
                  };
                  MP42.stsd = function(meta) {
                    if (meta.type === "audio") {
                      if (meta.codec === "mp3") {
                        return MP42.box(MP42.types.stsd, MP42.constants.STSD_PREFIX, MP42.mp3(meta));
                      }
                      return MP42.box(MP42.types.stsd, MP42.constants.STSD_PREFIX, MP42.mp4a(meta));
                    } else {
                      return MP42.box(MP42.types.stsd, MP42.constants.STSD_PREFIX, MP42.avc1(meta));
                    }
                  };
                  MP42.mp3 = function(meta) {
                    var channelCount = meta.channelCount;
                    var sampleRate = meta.audioSampleRate;
                    var data2 = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      channelCount,
                      0,
                      16,
                      0,
                      0,
                      0,
                      0,
                      sampleRate >>> 8 & 255,
                      sampleRate & 255,
                      0,
                      0
                    ]);
                    return MP42.box(MP42.types[".mp3"], data2);
                  };
                  MP42.mp4a = function(meta) {
                    var channelCount = meta.channelCount;
                    var sampleRate = meta.audioSampleRate;
                    var data2 = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      channelCount,
                      0,
                      16,
                      0,
                      0,
                      0,
                      0,
                      sampleRate >>> 8 & 255,
                      sampleRate & 255,
                      0,
                      0
                    ]);
                    return MP42.box(MP42.types.mp4a, data2, MP42.esds(meta));
                  };
                  MP42.esds = function(meta) {
                    var config = meta.config || [];
                    var configSize = config.length;
                    var data2 = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      3,
                      23 + configSize,
                      0,
                      1,
                      0,
                      4,
                      15 + configSize,
                      64,
                      21,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      5
                      // descriptor_type
                    ].concat([
                      configSize
                    ]).concat(config).concat([
                      6,
                      1,
                      2
                      // GASpecificConfig
                    ]));
                    return MP42.box(MP42.types.esds, data2);
                  };
                  MP42.avc1 = function(meta) {
                    var avcc = meta.avcc;
                    var width = meta.codecWidth, height = meta.codecHeight;
                    var data2 = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      width >>> 8 & 255,
                      width & 255,
                      height >>> 8 & 255,
                      height & 255,
                      0,
                      72,
                      0,
                      0,
                      0,
                      72,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      10,
                      120,
                      113,
                      113,
                      47,
                      102,
                      108,
                      118,
                      46,
                      106,
                      115,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      24,
                      255,
                      255
                      // pre_defined = -1
                    ]);
                    return MP42.box(MP42.types.avc1, data2, MP42.box(MP42.types.avcC, avcc));
                  };
                  MP42.mvex = function(meta) {
                    return MP42.box(MP42.types.mvex, MP42.trex(meta));
                  };
                  MP42.trex = function(meta) {
                    var trackId = meta.id;
                    var data2 = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      trackId >>> 24 & 255,
                      trackId >>> 16 & 255,
                      trackId >>> 8 & 255,
                      trackId & 255,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      1
                      // default_sample_flags
                    ]);
                    return MP42.box(MP42.types.trex, data2);
                  };
                  MP42.moof = function(track, baseMediaDecodeTime) {
                    return MP42.box(MP42.types.moof, MP42.mfhd(track.sequenceNumber), MP42.traf(track, baseMediaDecodeTime));
                  };
                  MP42.mfhd = function(sequenceNumber) {
                    var data2 = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      sequenceNumber >>> 24 & 255,
                      sequenceNumber >>> 16 & 255,
                      sequenceNumber >>> 8 & 255,
                      sequenceNumber & 255
                    ]);
                    return MP42.box(MP42.types.mfhd, data2);
                  };
                  MP42.traf = function(track, baseMediaDecodeTime) {
                    var trackId = track.id;
                    var tfhd = MP42.box(MP42.types.tfhd, new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      trackId >>> 24 & 255,
                      trackId >>> 16 & 255,
                      trackId >>> 8 & 255,
                      trackId & 255
                    ]));
                    var tfdt = MP42.box(MP42.types.tfdt, new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      baseMediaDecodeTime >>> 24 & 255,
                      baseMediaDecodeTime >>> 16 & 255,
                      baseMediaDecodeTime >>> 8 & 255,
                      baseMediaDecodeTime & 255
                    ]));
                    var sdtp = MP42.sdtp(track);
                    var trun = MP42.trun(track, sdtp.byteLength + 16 + 16 + 8 + 16 + 8 + 8);
                    return MP42.box(MP42.types.traf, tfhd, tfdt, trun, sdtp);
                  };
                  MP42.sdtp = function(track) {
                    var samples = track.samples || [];
                    var sampleCount = samples.length;
                    var data2 = new Uint8Array(4 + sampleCount);
                    for (var i2 = 0; i2 < sampleCount; i2++) {
                      var flags = samples[i2].flags;
                      data2[i2 + 4] = flags.isLeading << 6 | flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
                    }
                    return MP42.box(MP42.types.sdtp, data2);
                  };
                  MP42.trun = function(track, offset) {
                    var samples = track.samples || [];
                    var sampleCount = samples.length;
                    var dataSize = 12 + 16 * sampleCount;
                    var data2 = new Uint8Array(dataSize);
                    offset += 8 + dataSize;
                    data2.set([
                      0,
                      0,
                      15,
                      1,
                      sampleCount >>> 24 & 255,
                      sampleCount >>> 16 & 255,
                      sampleCount >>> 8 & 255,
                      sampleCount & 255,
                      offset >>> 24 & 255,
                      offset >>> 16 & 255,
                      offset >>> 8 & 255,
                      offset & 255
                    ], 0);
                    for (var i2 = 0; i2 < sampleCount; i2++) {
                      var duration = samples[i2].duration;
                      var size = samples[i2].size;
                      var flags = samples[i2].flags;
                      var cts = samples[i2].cts;
                      data2.set([
                        duration >>> 24 & 255,
                        duration >>> 16 & 255,
                        duration >>> 8 & 255,
                        duration & 255,
                        size >>> 24 & 255,
                        size >>> 16 & 255,
                        size >>> 8 & 255,
                        size & 255,
                        flags.isLeading << 2 | flags.dependsOn,
                        flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.isNonSync,
                        0,
                        0,
                        cts >>> 24 & 255,
                        cts >>> 16 & 255,
                        cts >>> 8 & 255,
                        cts & 255
                      ], 12 + 16 * i2);
                    }
                    return MP42.box(MP42.types.trun, data2);
                  };
                  MP42.mdat = function(data2) {
                    return MP42.box(MP42.types.mdat, data2);
                  };
                  return MP42;
                }()
              );
              MP4.init();
              __webpack_exports__2["default"] = MP4;
            }
          ),
          /***/
          "./src/remux/mp4-remuxer.js": (
            /*!**********************************!*\
              !*** ./src/remux/mp4-remuxer.js ***!
              \**********************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! ../utils/logger.js */
                "./src/utils/logger.js"
              );
              var _mp4_generator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./mp4-generator.js */
                "./src/remux/mp4-generator.js"
              );
              var _aac_silent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                /*! ./aac-silent.js */
                "./src/remux/aac-silent.js"
              );
              var _utils_browser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                /*! ../utils/browser.js */
                "./src/utils/browser.js"
              );
              var _core_media_segment_info_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                /*! ../core/media-segment-info.js */
                "./src/core/media-segment-info.js"
              );
              var _utils_exception_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                /*! ../utils/exception.js */
                "./src/utils/exception.js"
              );
              var MP4Remuxer = (
                /** @class */
                function() {
                  function MP4Remuxer2(config) {
                    this.TAG = "MP4Remuxer";
                    this._config = config;
                    this._isLive = config.isLive === true ? true : false;
                    this._dtsBase = -1;
                    this._dtsBaseInited = false;
                    this._audioDtsBase = Infinity;
                    this._videoDtsBase = Infinity;
                    this._audioNextDts = void 0;
                    this._videoNextDts = void 0;
                    this._audioStashedLastSample = null;
                    this._videoStashedLastSample = null;
                    this._audioMeta = null;
                    this._videoMeta = null;
                    this._audioSegmentInfoList = new _core_media_segment_info_js__WEBPACK_IMPORTED_MODULE_4__.MediaSegmentInfoList("audio");
                    this._videoSegmentInfoList = new _core_media_segment_info_js__WEBPACK_IMPORTED_MODULE_4__.MediaSegmentInfoList("video");
                    this._onInitSegment = null;
                    this._onMediaSegment = null;
                    this._forceFirstIDR = _utils_browser_js__WEBPACK_IMPORTED_MODULE_3__.default.chrome && (_utils_browser_js__WEBPACK_IMPORTED_MODULE_3__.default.version.major < 50 || _utils_browser_js__WEBPACK_IMPORTED_MODULE_3__.default.version.major === 50 && _utils_browser_js__WEBPACK_IMPORTED_MODULE_3__.default.version.build < 2661) ? true : false;
                    this._fillSilentAfterSeek = _utils_browser_js__WEBPACK_IMPORTED_MODULE_3__.default.msedge || _utils_browser_js__WEBPACK_IMPORTED_MODULE_3__.default.msie;
                    this._mp3UseMpegAudio = !_utils_browser_js__WEBPACK_IMPORTED_MODULE_3__.default.firefox;
                    this._fillAudioTimestampGap = this._config.fixAudioTimestampGap;
                  }
                  MP4Remuxer2.prototype.destroy = function() {
                    this._dtsBase = -1;
                    this._dtsBaseInited = false;
                    this._audioMeta = null;
                    this._videoMeta = null;
                    this._audioSegmentInfoList.clear();
                    this._audioSegmentInfoList = null;
                    this._videoSegmentInfoList.clear();
                    this._videoSegmentInfoList = null;
                    this._onInitSegment = null;
                    this._onMediaSegment = null;
                  };
                  MP4Remuxer2.prototype.bindDataSource = function(producer) {
                    producer.onDataAvailable = this.remux.bind(this);
                    producer.onTrackMetadata = this._onTrackMetadataReceived.bind(this);
                    return this;
                  };
                  Object.defineProperty(MP4Remuxer2.prototype, "onInitSegment", {
                    /* prototype: function onInitSegment(type: string, initSegment: ArrayBuffer): void
                       InitSegment: {
                           type: string,
                           data: ArrayBuffer,
                           codec: string,
                           container: string
                       }
                    */
                    get: function() {
                      return this._onInitSegment;
                    },
                    set: function(callback) {
                      this._onInitSegment = callback;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(MP4Remuxer2.prototype, "onMediaSegment", {
                    /* prototype: function onMediaSegment(type: string, mediaSegment: MediaSegment): void
                       MediaSegment: {
                           type: string,
                           data: ArrayBuffer,
                           sampleCount: int32
                           info: MediaSegmentInfo
                       }
                    */
                    get: function() {
                      return this._onMediaSegment;
                    },
                    set: function(callback) {
                      this._onMediaSegment = callback;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  MP4Remuxer2.prototype.insertDiscontinuity = function() {
                    this._audioNextDts = this._videoNextDts = void 0;
                  };
                  MP4Remuxer2.prototype.seek = function(originalDts) {
                    this._audioStashedLastSample = null;
                    this._videoStashedLastSample = null;
                    this._videoSegmentInfoList.clear();
                    this._audioSegmentInfoList.clear();
                  };
                  MP4Remuxer2.prototype.remux = function(audioTrack, videoTrack) {
                    if (!this._onMediaSegment) {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_5__.IllegalStateException("MP4Remuxer: onMediaSegment callback must be specificed!");
                    }
                    if (!this._dtsBaseInited) {
                      this._calculateDtsBase(audioTrack, videoTrack);
                    }
                    this._remuxVideo(videoTrack);
                    this._remuxAudio(audioTrack);
                  };
                  MP4Remuxer2.prototype._onTrackMetadataReceived = function(type2, metadata) {
                    var metabox = null;
                    var container2 = "mp4";
                    var codec = metadata.codec;
                    if (type2 === "audio") {
                      this._audioMeta = metadata;
                      if (metadata.codec === "mp3" && this._mp3UseMpegAudio) {
                        container2 = "mpeg";
                        codec = "";
                        metabox = new Uint8Array();
                      } else {
                        metabox = _mp4_generator_js__WEBPACK_IMPORTED_MODULE_1__.default.generateInitSegment(metadata);
                      }
                    } else if (type2 === "video") {
                      this._videoMeta = metadata;
                      metabox = _mp4_generator_js__WEBPACK_IMPORTED_MODULE_1__.default.generateInitSegment(metadata);
                    } else {
                      return;
                    }
                    if (!this._onInitSegment) {
                      throw new _utils_exception_js__WEBPACK_IMPORTED_MODULE_5__.IllegalStateException("MP4Remuxer: onInitSegment callback must be specified!");
                    }
                    this._onInitSegment(type2, {
                      type: type2,
                      data: metabox.buffer,
                      codec,
                      container: type2 + "/" + container2,
                      mediaDuration: metadata.duration
                      // in timescale 1000 (milliseconds)
                    });
                  };
                  MP4Remuxer2.prototype._calculateDtsBase = function(audioTrack, videoTrack) {
                    if (this._dtsBaseInited) {
                      return;
                    }
                    if (audioTrack.samples && audioTrack.samples.length) {
                      this._audioDtsBase = audioTrack.samples[0].dts;
                    }
                    if (videoTrack.samples && videoTrack.samples.length) {
                      this._videoDtsBase = videoTrack.samples[0].dts;
                    }
                    this._dtsBase = Math.min(this._audioDtsBase, this._videoDtsBase);
                    this._dtsBaseInited = true;
                  };
                  MP4Remuxer2.prototype.flushStashedSamples = function() {
                    var videoSample = this._videoStashedLastSample;
                    var audioSample = this._audioStashedLastSample;
                    var videoTrack = {
                      type: "video",
                      id: 1,
                      sequenceNumber: 0,
                      samples: [],
                      length: 0
                    };
                    if (videoSample != null) {
                      videoTrack.samples.push(videoSample);
                      videoTrack.length = videoSample.length;
                    }
                    var audioTrack = {
                      type: "audio",
                      id: 2,
                      sequenceNumber: 0,
                      samples: [],
                      length: 0
                    };
                    if (audioSample != null) {
                      audioTrack.samples.push(audioSample);
                      audioTrack.length = audioSample.length;
                    }
                    this._videoStashedLastSample = null;
                    this._audioStashedLastSample = null;
                    this._remuxVideo(videoTrack, true);
                    this._remuxAudio(audioTrack, true);
                  };
                  MP4Remuxer2.prototype._remuxAudio = function(audioTrack, force) {
                    if (this._audioMeta == null) {
                      return;
                    }
                    var track = audioTrack;
                    var samples = track.samples;
                    var dtsCorrection = void 0;
                    var firstDts = -1, lastDts = -1;
                    var refSampleDuration = this._audioMeta.refSampleDuration;
                    var mpegRawTrack = this._audioMeta.codec === "mp3" && this._mp3UseMpegAudio;
                    var firstSegmentAfterSeek = this._dtsBaseInited && this._audioNextDts === void 0;
                    var insertPrefixSilentFrame = false;
                    if (!samples || samples.length === 0) {
                      return;
                    }
                    if (samples.length === 1 && !force) {
                      return;
                    }
                    var offset = 0;
                    var mdatbox = null;
                    var mdatBytes = 0;
                    if (mpegRawTrack) {
                      offset = 0;
                      mdatBytes = track.length;
                    } else {
                      offset = 8;
                      mdatBytes = 8 + track.length;
                    }
                    var lastSample = null;
                    if (samples.length > 1) {
                      lastSample = samples.pop();
                      mdatBytes -= lastSample.length;
                    }
                    if (this._audioStashedLastSample != null) {
                      var sample = this._audioStashedLastSample;
                      this._audioStashedLastSample = null;
                      samples.unshift(sample);
                      mdatBytes += sample.length;
                    }
                    if (lastSample != null) {
                      this._audioStashedLastSample = lastSample;
                    }
                    var firstSampleOriginalDts = samples[0].dts - this._dtsBase;
                    if (this._audioNextDts) {
                      dtsCorrection = firstSampleOriginalDts - this._audioNextDts;
                    } else {
                      if (this._audioSegmentInfoList.isEmpty()) {
                        dtsCorrection = 0;
                        if (this._fillSilentAfterSeek && !this._videoSegmentInfoList.isEmpty()) {
                          if (this._audioMeta.originalCodec !== "mp3") {
                            insertPrefixSilentFrame = true;
                          }
                        }
                      } else {
                        var lastSample_1 = this._audioSegmentInfoList.getLastSampleBefore(firstSampleOriginalDts);
                        if (lastSample_1 != null) {
                          var distance = firstSampleOriginalDts - (lastSample_1.originalDts + lastSample_1.duration);
                          if (distance <= 3) {
                            distance = 0;
                          }
                          var expectedDts = lastSample_1.dts + lastSample_1.duration + distance;
                          dtsCorrection = firstSampleOriginalDts - expectedDts;
                        } else {
                          dtsCorrection = 0;
                        }
                      }
                    }
                    if (insertPrefixSilentFrame) {
                      var firstSampleDts = firstSampleOriginalDts - dtsCorrection;
                      var videoSegment = this._videoSegmentInfoList.getLastSegmentBefore(firstSampleOriginalDts);
                      if (videoSegment != null && videoSegment.beginDts < firstSampleDts) {
                        var silentUnit = _aac_silent_js__WEBPACK_IMPORTED_MODULE_2__.default.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);
                        if (silentUnit) {
                          var dts = videoSegment.beginDts;
                          var silentFrameDuration = firstSampleDts - videoSegment.beginDts;
                          _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.v(this.TAG, "InsertPrefixSilentAudio: dts: " + dts + ", duration: " + silentFrameDuration);
                          samples.unshift({ unit: silentUnit, dts, pts: dts });
                          mdatBytes += silentUnit.byteLength;
                        }
                      } else {
                        insertPrefixSilentFrame = false;
                      }
                    }
                    var mp4Samples = [];
                    for (var i2 = 0; i2 < samples.length; i2++) {
                      var sample = samples[i2];
                      var unit = sample.unit;
                      var originalDts = sample.dts - this._dtsBase;
                      var dts = originalDts;
                      var needFillSilentFrames = false;
                      var silentFrames = null;
                      var sampleDuration = 0;
                      if (originalDts < -1e-3) {
                        continue;
                      }
                      if (this._audioMeta.codec !== "mp3") {
                        var curRefDts = originalDts;
                        var maxAudioFramesDrift = 3;
                        if (this._audioNextDts) {
                          curRefDts = this._audioNextDts;
                        }
                        dtsCorrection = originalDts - curRefDts;
                        if (dtsCorrection <= -maxAudioFramesDrift * refSampleDuration) {
                          _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "Dropping 1 audio frame (originalDts: " + originalDts + " ms ,curRefDts: " + curRefDts + " ms)  due to dtsCorrection: " + dtsCorrection + " ms overlap.");
                          continue;
                        } else if (dtsCorrection >= maxAudioFramesDrift * refSampleDuration && this._fillAudioTimestampGap && !_utils_browser_js__WEBPACK_IMPORTED_MODULE_3__.default.safari) {
                          needFillSilentFrames = true;
                          var frameCount = Math.floor(dtsCorrection / refSampleDuration);
                          _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "Large audio timestamp gap detected, may cause AV sync to drift. Silent frames will be generated to avoid unsync.\n" + ("originalDts: " + originalDts + " ms, curRefDts: " + curRefDts + " ms, ") + ("dtsCorrection: " + Math.round(dtsCorrection) + " ms, generate: " + frameCount + " frames"));
                          dts = Math.floor(curRefDts);
                          sampleDuration = Math.floor(curRefDts + refSampleDuration) - dts;
                          var silentUnit = _aac_silent_js__WEBPACK_IMPORTED_MODULE_2__.default.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);
                          if (silentUnit == null) {
                            _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.default.w(this.TAG, "Unable to generate silent frame for " + (this._audioMeta.originalCodec + " with " + this._audioMeta.channelCount + " channels, repeat last frame"));
                            silentUnit = unit;
                          }
                          silentFrames = [];
                          for (var j2 = 0; j2 < frameCount; j2++) {
                            curRefDts = curRefDts + refSampleDuration;
                            var intDts = Math.floor(curRefDts);
                            var intDuration = Math.floor(curRefDts + refSampleDuration) - intDts;
                            var frame2 = {
                              dts: intDts,
                              pts: intDts,
                              cts: 0,
                              unit: silentUnit,
                              size: silentUnit.byteLength,
                              duration: intDuration,
                              originalDts,
                              flags: {
                                isLeading: 0,
                                dependsOn: 1,
                                isDependedOn: 0,
                                hasRedundancy: 0
                              }
                            };
                            silentFrames.push(frame2);
                            mdatBytes += frame2.size;
                          }
                          this._audioNextDts = curRefDts + refSampleDuration;
                        } else {
                          dts = Math.floor(curRefDts);
                          sampleDuration = Math.floor(curRefDts + refSampleDuration) - dts;
                          this._audioNextDts = curRefDts + refSampleDuration;
                        }
                      } else {
                        dts = originalDts - dtsCorrection;
                        if (i2 !== samples.length - 1) {
                          var nextDts = samples[i2 + 1].dts - this._dtsBase - dtsCorrection;
                          sampleDuration = nextDts - dts;
                        } else {
                          if (lastSample != null) {
                            var nextDts = lastSample.dts - this._dtsBase - dtsCorrection;
                            sampleDuration = nextDts - dts;
                          } else if (mp4Samples.length >= 1) {
                            sampleDuration = mp4Samples[mp4Samples.length - 1].duration;
                          } else {
                            sampleDuration = Math.floor(refSampleDuration);
                          }
                        }
                        this._audioNextDts = dts + sampleDuration;
                      }
                      if (firstDts === -1) {
                        firstDts = dts;
                      }
                      mp4Samples.push({
                        dts,
                        pts: dts,
                        cts: 0,
                        unit: sample.unit,
                        size: sample.unit.byteLength,
                        duration: sampleDuration,
                        originalDts,
                        flags: {
                          isLeading: 0,
                          dependsOn: 1,
                          isDependedOn: 0,
                          hasRedundancy: 0
                        }
                      });
                      if (needFillSilentFrames) {
                        mp4Samples.push.apply(mp4Samples, silentFrames);
                      }
                    }
                    if (mp4Samples.length === 0) {
                      track.samples = [];
                      track.length = 0;
                      return;
                    }
                    if (mpegRawTrack) {
                      mdatbox = new Uint8Array(mdatBytes);
                    } else {
                      mdatbox = new Uint8Array(mdatBytes);
                      mdatbox[0] = mdatBytes >>> 24 & 255;
                      mdatbox[1] = mdatBytes >>> 16 & 255;
                      mdatbox[2] = mdatBytes >>> 8 & 255;
                      mdatbox[3] = mdatBytes & 255;
                      mdatbox.set(_mp4_generator_js__WEBPACK_IMPORTED_MODULE_1__.default.types.mdat, 4);
                    }
                    for (var i2 = 0; i2 < mp4Samples.length; i2++) {
                      var unit = mp4Samples[i2].unit;
                      mdatbox.set(unit, offset);
                      offset += unit.byteLength;
                    }
                    var latest = mp4Samples[mp4Samples.length - 1];
                    lastDts = latest.dts + latest.duration;
                    var info = new _core_media_segment_info_js__WEBPACK_IMPORTED_MODULE_4__.MediaSegmentInfo();
                    info.beginDts = firstDts;
                    info.endDts = lastDts;
                    info.beginPts = firstDts;
                    info.endPts = lastDts;
                    info.originalBeginDts = mp4Samples[0].originalDts;
                    info.originalEndDts = latest.originalDts + latest.duration;
                    info.firstSample = new _core_media_segment_info_js__WEBPACK_IMPORTED_MODULE_4__.SampleInfo(mp4Samples[0].dts, mp4Samples[0].pts, mp4Samples[0].duration, mp4Samples[0].originalDts, false);
                    info.lastSample = new _core_media_segment_info_js__WEBPACK_IMPORTED_MODULE_4__.SampleInfo(latest.dts, latest.pts, latest.duration, latest.originalDts, false);
                    if (!this._isLive) {
                      this._audioSegmentInfoList.append(info);
                    }
                    track.samples = mp4Samples;
                    track.sequenceNumber++;
                    var moofbox = null;
                    if (mpegRawTrack) {
                      moofbox = new Uint8Array();
                    } else {
                      moofbox = _mp4_generator_js__WEBPACK_IMPORTED_MODULE_1__.default.moof(track, firstDts);
                    }
                    track.samples = [];
                    track.length = 0;
                    var segment = {
                      type: "audio",
                      data: this._mergeBoxes(moofbox, mdatbox).buffer,
                      sampleCount: mp4Samples.length,
                      info
                    };
                    if (mpegRawTrack && firstSegmentAfterSeek) {
                      segment.timestampOffset = firstDts;
                    }
                    this._onMediaSegment("audio", segment);
                  };
                  MP4Remuxer2.prototype._remuxVideo = function(videoTrack, force) {
                    if (this._videoMeta == null) {
                      return;
                    }
                    var track = videoTrack;
                    var samples = track.samples;
                    var dtsCorrection = void 0;
                    var firstDts = -1, lastDts = -1;
                    var firstPts = -1, lastPts = -1;
                    if (!samples || samples.length === 0) {
                      return;
                    }
                    if (samples.length === 1 && !force) {
                      return;
                    }
                    var offset = 8;
                    var mdatbox = null;
                    var mdatBytes = 8 + videoTrack.length;
                    var lastSample = null;
                    if (samples.length > 1) {
                      lastSample = samples.pop();
                      mdatBytes -= lastSample.length;
                    }
                    if (this._videoStashedLastSample != null) {
                      var sample = this._videoStashedLastSample;
                      this._videoStashedLastSample = null;
                      samples.unshift(sample);
                      mdatBytes += sample.length;
                    }
                    if (lastSample != null) {
                      this._videoStashedLastSample = lastSample;
                    }
                    var firstSampleOriginalDts = samples[0].dts - this._dtsBase;
                    if (this._videoNextDts) {
                      dtsCorrection = firstSampleOriginalDts - this._videoNextDts;
                    } else {
                      if (this._videoSegmentInfoList.isEmpty()) {
                        dtsCorrection = 0;
                      } else {
                        var lastSample_2 = this._videoSegmentInfoList.getLastSampleBefore(firstSampleOriginalDts);
                        if (lastSample_2 != null) {
                          var distance = firstSampleOriginalDts - (lastSample_2.originalDts + lastSample_2.duration);
                          if (distance <= 3) {
                            distance = 0;
                          }
                          var expectedDts = lastSample_2.dts + lastSample_2.duration + distance;
                          dtsCorrection = firstSampleOriginalDts - expectedDts;
                        } else {
                          dtsCorrection = 0;
                        }
                      }
                    }
                    var info = new _core_media_segment_info_js__WEBPACK_IMPORTED_MODULE_4__.MediaSegmentInfo();
                    var mp4Samples = [];
                    for (var i2 = 0; i2 < samples.length; i2++) {
                      var sample = samples[i2];
                      var originalDts = sample.dts - this._dtsBase;
                      var isKeyframe = sample.isKeyframe;
                      var dts = originalDts - dtsCorrection;
                      var cts = sample.cts;
                      var pts = dts + cts;
                      if (firstDts === -1) {
                        firstDts = dts;
                        firstPts = pts;
                      }
                      var sampleDuration = 0;
                      if (i2 !== samples.length - 1) {
                        var nextDts = samples[i2 + 1].dts - this._dtsBase - dtsCorrection;
                        sampleDuration = nextDts - dts;
                      } else {
                        if (lastSample != null) {
                          var nextDts = lastSample.dts - this._dtsBase - dtsCorrection;
                          sampleDuration = nextDts - dts;
                        } else if (mp4Samples.length >= 1) {
                          sampleDuration = mp4Samples[mp4Samples.length - 1].duration;
                        } else {
                          sampleDuration = Math.floor(this._videoMeta.refSampleDuration);
                        }
                      }
                      if (isKeyframe) {
                        var syncPoint = new _core_media_segment_info_js__WEBPACK_IMPORTED_MODULE_4__.SampleInfo(dts, pts, sampleDuration, sample.dts, true);
                        syncPoint.fileposition = sample.fileposition;
                        info.appendSyncPoint(syncPoint);
                      }
                      mp4Samples.push({
                        dts,
                        pts,
                        cts,
                        units: sample.units,
                        size: sample.length,
                        isKeyframe,
                        duration: sampleDuration,
                        originalDts,
                        flags: {
                          isLeading: 0,
                          dependsOn: isKeyframe ? 2 : 1,
                          isDependedOn: isKeyframe ? 1 : 0,
                          hasRedundancy: 0,
                          isNonSync: isKeyframe ? 0 : 1
                        }
                      });
                    }
                    mdatbox = new Uint8Array(mdatBytes);
                    mdatbox[0] = mdatBytes >>> 24 & 255;
                    mdatbox[1] = mdatBytes >>> 16 & 255;
                    mdatbox[2] = mdatBytes >>> 8 & 255;
                    mdatbox[3] = mdatBytes & 255;
                    mdatbox.set(_mp4_generator_js__WEBPACK_IMPORTED_MODULE_1__.default.types.mdat, 4);
                    for (var i2 = 0; i2 < mp4Samples.length; i2++) {
                      var units = mp4Samples[i2].units;
                      while (units.length) {
                        var unit = units.shift();
                        var data2 = unit.data;
                        mdatbox.set(data2, offset);
                        offset += data2.byteLength;
                      }
                    }
                    var latest = mp4Samples[mp4Samples.length - 1];
                    lastDts = latest.dts + latest.duration;
                    lastPts = latest.pts + latest.duration;
                    this._videoNextDts = lastDts;
                    info.beginDts = firstDts;
                    info.endDts = lastDts;
                    info.beginPts = firstPts;
                    info.endPts = lastPts;
                    info.originalBeginDts = mp4Samples[0].originalDts;
                    info.originalEndDts = latest.originalDts + latest.duration;
                    info.firstSample = new _core_media_segment_info_js__WEBPACK_IMPORTED_MODULE_4__.SampleInfo(mp4Samples[0].dts, mp4Samples[0].pts, mp4Samples[0].duration, mp4Samples[0].originalDts, mp4Samples[0].isKeyframe);
                    info.lastSample = new _core_media_segment_info_js__WEBPACK_IMPORTED_MODULE_4__.SampleInfo(latest.dts, latest.pts, latest.duration, latest.originalDts, latest.isKeyframe);
                    if (!this._isLive) {
                      this._videoSegmentInfoList.append(info);
                    }
                    track.samples = mp4Samples;
                    track.sequenceNumber++;
                    if (this._forceFirstIDR) {
                      var flags = mp4Samples[0].flags;
                      flags.dependsOn = 2;
                      flags.isNonSync = 0;
                    }
                    var moofbox = _mp4_generator_js__WEBPACK_IMPORTED_MODULE_1__.default.moof(track, firstDts);
                    track.samples = [];
                    track.length = 0;
                    this._onMediaSegment("video", {
                      type: "video",
                      data: this._mergeBoxes(moofbox, mdatbox).buffer,
                      sampleCount: mp4Samples.length,
                      info
                    });
                  };
                  MP4Remuxer2.prototype._mergeBoxes = function(moof, mdat) {
                    var result = new Uint8Array(moof.byteLength + mdat.byteLength);
                    result.set(moof, 0);
                    result.set(mdat, moof.byteLength);
                    return result;
                  };
                  return MP4Remuxer2;
                }()
              );
              __webpack_exports__2["default"] = MP4Remuxer;
            }
          ),
          /***/
          "./src/utils/browser.js": (
            /*!******************************!*\
              !*** ./src/utils/browser.js ***!
              \******************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var Browser = {};
              function detect() {
                var ua2 = self.navigator.userAgent.toLowerCase();
                var match2 = /(edge)\/([\w.]+)/.exec(ua2) || /(opr)[\/]([\w.]+)/.exec(ua2) || /(chrome)[ \/]([\w.]+)/.exec(ua2) || /(iemobile)[\/]([\w.]+)/.exec(ua2) || /(version)(applewebkit)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(ua2) || /(webkit)[ \/]([\w.]+).*(version)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(ua2) || /(webkit)[ \/]([\w.]+)/.exec(ua2) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua2) || /(msie) ([\w.]+)/.exec(ua2) || ua2.indexOf("trident") >= 0 && /(rv)(?::| )([\w.]+)/.exec(ua2) || ua2.indexOf("compatible") < 0 && /(firefox)[ \/]([\w.]+)/.exec(ua2) || [];
                var platform_match = /(ipad)/.exec(ua2) || /(ipod)/.exec(ua2) || /(windows phone)/.exec(ua2) || /(iphone)/.exec(ua2) || /(kindle)/.exec(ua2) || /(android)/.exec(ua2) || /(windows)/.exec(ua2) || /(mac)/.exec(ua2) || /(linux)/.exec(ua2) || /(cros)/.exec(ua2) || [];
                var matched = {
                  browser: match2[5] || match2[3] || match2[1] || "",
                  version: match2[2] || match2[4] || "0",
                  majorVersion: match2[4] || match2[2] || "0",
                  platform: platform_match[0] || ""
                };
                var browser2 = {};
                if (matched.browser) {
                  browser2[matched.browser] = true;
                  var versionArray = matched.majorVersion.split(".");
                  browser2.version = {
                    major: parseInt(matched.majorVersion, 10),
                    string: matched.version
                  };
                  if (versionArray.length > 1) {
                    browser2.version.minor = parseInt(versionArray[1], 10);
                  }
                  if (versionArray.length > 2) {
                    browser2.version.build = parseInt(versionArray[2], 10);
                  }
                }
                if (matched.platform) {
                  browser2[matched.platform] = true;
                }
                if (browser2.chrome || browser2.opr || browser2.safari) {
                  browser2.webkit = true;
                }
                if (browser2.rv || browser2.iemobile) {
                  if (browser2.rv) {
                    delete browser2.rv;
                  }
                  var msie = "msie";
                  matched.browser = msie;
                  browser2[msie] = true;
                }
                if (browser2.edge) {
                  delete browser2.edge;
                  var msedge = "msedge";
                  matched.browser = msedge;
                  browser2[msedge] = true;
                }
                if (browser2.opr) {
                  var opera = "opera";
                  matched.browser = opera;
                  browser2[opera] = true;
                }
                if (browser2.safari && browser2.android) {
                  var android = "android";
                  matched.browser = android;
                  browser2[android] = true;
                }
                browser2.name = matched.browser;
                browser2.platform = matched.platform;
                for (var key in Browser) {
                  if (Browser.hasOwnProperty(key)) {
                    delete Browser[key];
                  }
                }
                Object.assign(Browser, browser2);
              }
              detect();
              __webpack_exports__2["default"] = Browser;
            }
          ),
          /***/
          "./src/utils/exception.js": (
            /*!********************************!*\
              !*** ./src/utils/exception.js ***!
              \********************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "RuntimeException": function() {
                  return (
                    /* binding */
                    RuntimeException
                  );
                },
                /* harmony export */
                "IllegalStateException": function() {
                  return (
                    /* binding */
                    IllegalStateException
                  );
                },
                /* harmony export */
                "InvalidArgumentException": function() {
                  return (
                    /* binding */
                    InvalidArgumentException
                  );
                },
                /* harmony export */
                "NotImplementedException": function() {
                  return (
                    /* binding */
                    NotImplementedException
                  );
                }
                /* harmony export */
              });
              var __extends2 = function() {
                var extendStatics2 = function(d2, b2) {
                  extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
                    d3.__proto__ = b3;
                  } || function(d3, b3) {
                    for (var p in b3)
                      if (Object.prototype.hasOwnProperty.call(b3, p))
                        d3[p] = b3[p];
                  };
                  return extendStatics2(d2, b2);
                };
                return function(d2, b2) {
                  if (typeof b2 !== "function" && b2 !== null)
                    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
                  extendStatics2(d2, b2);
                  function __() {
                    this.constructor = d2;
                  }
                  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
                };
              }();
              var RuntimeException = (
                /** @class */
                function() {
                  function RuntimeException2(message) {
                    this._message = message;
                  }
                  Object.defineProperty(RuntimeException2.prototype, "name", {
                    get: function() {
                      return "RuntimeException";
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(RuntimeException2.prototype, "message", {
                    get: function() {
                      return this._message;
                    },
                    enumerable: false,
                    configurable: true
                  });
                  RuntimeException2.prototype.toString = function() {
                    return this.name + ": " + this.message;
                  };
                  return RuntimeException2;
                }()
              );
              var IllegalStateException = (
                /** @class */
                function(_super) {
                  __extends2(IllegalStateException2, _super);
                  function IllegalStateException2(message) {
                    return _super.call(this, message) || this;
                  }
                  Object.defineProperty(IllegalStateException2.prototype, "name", {
                    get: function() {
                      return "IllegalStateException";
                    },
                    enumerable: false,
                    configurable: true
                  });
                  return IllegalStateException2;
                }(RuntimeException)
              );
              var InvalidArgumentException = (
                /** @class */
                function(_super) {
                  __extends2(InvalidArgumentException2, _super);
                  function InvalidArgumentException2(message) {
                    return _super.call(this, message) || this;
                  }
                  Object.defineProperty(InvalidArgumentException2.prototype, "name", {
                    get: function() {
                      return "InvalidArgumentException";
                    },
                    enumerable: false,
                    configurable: true
                  });
                  return InvalidArgumentException2;
                }(RuntimeException)
              );
              var NotImplementedException = (
                /** @class */
                function(_super) {
                  __extends2(NotImplementedException2, _super);
                  function NotImplementedException2(message) {
                    return _super.call(this, message) || this;
                  }
                  Object.defineProperty(NotImplementedException2.prototype, "name", {
                    get: function() {
                      return "NotImplementedException";
                    },
                    enumerable: false,
                    configurable: true
                  });
                  return NotImplementedException2;
                }(RuntimeException)
              );
            }
          ),
          /***/
          "./src/utils/logger.js": (
            /*!*****************************!*\
              !*** ./src/utils/logger.js ***!
              \*****************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! events */
                "./node_modules/events/events.js"
              );
              var events__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(events__WEBPACK_IMPORTED_MODULE_0__);
              var Log = (
                /** @class */
                function() {
                  function Log2() {
                  }
                  Log2.e = function(tag2, msg) {
                    if (!tag2 || Log2.FORCE_GLOBAL_TAG)
                      tag2 = Log2.GLOBAL_TAG;
                    var str = "[" + tag2 + "] > " + msg;
                    if (Log2.ENABLE_CALLBACK) {
                      Log2.emitter.emit("log", "error", str);
                    }
                    if (!Log2.ENABLE_ERROR) {
                      return;
                    }
                    if (console.error) {
                      console.error(str);
                    } else if (console.warn) {
                      console.warn(str);
                    } else {
                      console.log(str);
                    }
                  };
                  Log2.i = function(tag2, msg) {
                    if (!tag2 || Log2.FORCE_GLOBAL_TAG)
                      tag2 = Log2.GLOBAL_TAG;
                    var str = "[" + tag2 + "] > " + msg;
                    if (Log2.ENABLE_CALLBACK) {
                      Log2.emitter.emit("log", "info", str);
                    }
                    if (!Log2.ENABLE_INFO) {
                      return;
                    }
                    if (console.info) {
                      console.info(str);
                    } else {
                      console.log(str);
                    }
                  };
                  Log2.w = function(tag2, msg) {
                    if (!tag2 || Log2.FORCE_GLOBAL_TAG)
                      tag2 = Log2.GLOBAL_TAG;
                    var str = "[" + tag2 + "] > " + msg;
                    if (Log2.ENABLE_CALLBACK) {
                      Log2.emitter.emit("log", "warn", str);
                    }
                    if (!Log2.ENABLE_WARN) {
                      return;
                    }
                    if (console.warn) {
                      console.warn(str);
                    } else {
                      console.log(str);
                    }
                  };
                  Log2.d = function(tag2, msg) {
                    if (!tag2 || Log2.FORCE_GLOBAL_TAG)
                      tag2 = Log2.GLOBAL_TAG;
                    var str = "[" + tag2 + "] > " + msg;
                    if (Log2.ENABLE_CALLBACK) {
                      Log2.emitter.emit("log", "debug", str);
                    }
                    if (!Log2.ENABLE_DEBUG) {
                      return;
                    }
                    if (console.debug) {
                      console.debug(str);
                    } else {
                      console.log(str);
                    }
                  };
                  Log2.v = function(tag2, msg) {
                    if (!tag2 || Log2.FORCE_GLOBAL_TAG)
                      tag2 = Log2.GLOBAL_TAG;
                    var str = "[" + tag2 + "] > " + msg;
                    if (Log2.ENABLE_CALLBACK) {
                      Log2.emitter.emit("log", "verbose", str);
                    }
                    if (!Log2.ENABLE_VERBOSE) {
                      return;
                    }
                    console.log(str);
                  };
                  return Log2;
                }()
              );
              Log.GLOBAL_TAG = "flv.js";
              Log.FORCE_GLOBAL_TAG = false;
              Log.ENABLE_ERROR = true;
              Log.ENABLE_INFO = true;
              Log.ENABLE_WARN = true;
              Log.ENABLE_DEBUG = true;
              Log.ENABLE_VERBOSE = true;
              Log.ENABLE_CALLBACK = false;
              Log.emitter = new (events__WEBPACK_IMPORTED_MODULE_0___default())();
              __webpack_exports__2["default"] = Log;
            }
          ),
          /***/
          "./src/utils/logging-control.js": (
            /*!**************************************!*\
              !*** ./src/utils/logging-control.js ***!
              \**************************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                /*! events */
                "./node_modules/events/events.js"
              );
              var events__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(events__WEBPACK_IMPORTED_MODULE_0__);
              var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                /*! ./logger.js */
                "./src/utils/logger.js"
              );
              var LoggingControl = (
                /** @class */
                function() {
                  function LoggingControl2() {
                  }
                  Object.defineProperty(LoggingControl2, "forceGlobalTag", {
                    get: function() {
                      return _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.FORCE_GLOBAL_TAG;
                    },
                    set: function(enable) {
                      _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.FORCE_GLOBAL_TAG = enable;
                      LoggingControl2._notifyChange();
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(LoggingControl2, "globalTag", {
                    get: function() {
                      return _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.GLOBAL_TAG;
                    },
                    set: function(tag2) {
                      _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.GLOBAL_TAG = tag2;
                      LoggingControl2._notifyChange();
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(LoggingControl2, "enableAll", {
                    get: function() {
                      return _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_VERBOSE && _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_DEBUG && _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_INFO && _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_WARN && _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_ERROR;
                    },
                    set: function(enable) {
                      _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_VERBOSE = enable;
                      _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_DEBUG = enable;
                      _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_INFO = enable;
                      _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_WARN = enable;
                      _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_ERROR = enable;
                      LoggingControl2._notifyChange();
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(LoggingControl2, "enableDebug", {
                    get: function() {
                      return _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_DEBUG;
                    },
                    set: function(enable) {
                      _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_DEBUG = enable;
                      LoggingControl2._notifyChange();
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(LoggingControl2, "enableVerbose", {
                    get: function() {
                      return _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_VERBOSE;
                    },
                    set: function(enable) {
                      _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_VERBOSE = enable;
                      LoggingControl2._notifyChange();
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(LoggingControl2, "enableInfo", {
                    get: function() {
                      return _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_INFO;
                    },
                    set: function(enable) {
                      _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_INFO = enable;
                      LoggingControl2._notifyChange();
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(LoggingControl2, "enableWarn", {
                    get: function() {
                      return _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_WARN;
                    },
                    set: function(enable) {
                      _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_WARN = enable;
                      LoggingControl2._notifyChange();
                    },
                    enumerable: false,
                    configurable: true
                  });
                  Object.defineProperty(LoggingControl2, "enableError", {
                    get: function() {
                      return _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_ERROR;
                    },
                    set: function(enable) {
                      _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_ERROR = enable;
                      LoggingControl2._notifyChange();
                    },
                    enumerable: false,
                    configurable: true
                  });
                  LoggingControl2.getConfig = function() {
                    return {
                      globalTag: _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.GLOBAL_TAG,
                      forceGlobalTag: _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.FORCE_GLOBAL_TAG,
                      enableVerbose: _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_VERBOSE,
                      enableDebug: _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_DEBUG,
                      enableInfo: _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_INFO,
                      enableWarn: _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_WARN,
                      enableError: _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_ERROR,
                      enableCallback: _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_CALLBACK
                    };
                  };
                  LoggingControl2.applyConfig = function(config) {
                    _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.GLOBAL_TAG = config.globalTag;
                    _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.FORCE_GLOBAL_TAG = config.forceGlobalTag;
                    _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_VERBOSE = config.enableVerbose;
                    _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_DEBUG = config.enableDebug;
                    _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_INFO = config.enableInfo;
                    _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_WARN = config.enableWarn;
                    _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_ERROR = config.enableError;
                    _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_CALLBACK = config.enableCallback;
                  };
                  LoggingControl2._notifyChange = function() {
                    var emitter = LoggingControl2.emitter;
                    if (emitter.listenerCount("change") > 0) {
                      var config = LoggingControl2.getConfig();
                      emitter.emit("change", config);
                    }
                  };
                  LoggingControl2.registerListener = function(listener) {
                    LoggingControl2.emitter.addListener("change", listener);
                  };
                  LoggingControl2.removeListener = function(listener) {
                    LoggingControl2.emitter.removeListener("change", listener);
                  };
                  LoggingControl2.addLogListener = function(listener) {
                    _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.emitter.addListener("log", listener);
                    if (_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.emitter.listenerCount("log") > 0) {
                      _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_CALLBACK = true;
                      LoggingControl2._notifyChange();
                    }
                  };
                  LoggingControl2.removeLogListener = function(listener) {
                    _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.emitter.removeListener("log", listener);
                    if (_logger_js__WEBPACK_IMPORTED_MODULE_1__.default.emitter.listenerCount("log") === 0) {
                      _logger_js__WEBPACK_IMPORTED_MODULE_1__.default.ENABLE_CALLBACK = false;
                      LoggingControl2._notifyChange();
                    }
                  };
                  return LoggingControl2;
                }()
              );
              LoggingControl.emitter = new (events__WEBPACK_IMPORTED_MODULE_0___default())();
              __webpack_exports__2["default"] = LoggingControl;
            }
          ),
          /***/
          "./src/utils/polyfill.js": (
            /*!*******************************!*\
              !*** ./src/utils/polyfill.js ***!
              \*******************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              var Polyfill = (
                /** @class */
                function() {
                  function Polyfill2() {
                  }
                  Polyfill2.install = function() {
                    Object.setPrototypeOf = Object.setPrototypeOf || function(obj, proto) {
                      obj.__proto__ = proto;
                      return obj;
                    };
                    Object.assign = Object.assign || function(target) {
                      if (target === void 0 || target === null) {
                        throw new TypeError("Cannot convert undefined or null to object");
                      }
                      var output2 = Object(target);
                      for (var i2 = 1; i2 < arguments.length; i2++) {
                        var source = arguments[i2];
                        if (source !== void 0 && source !== null) {
                          for (var key in source) {
                            if (source.hasOwnProperty(key)) {
                              output2[key] = source[key];
                            }
                          }
                        }
                      }
                      return output2;
                    };
                    if (typeof self.Promise !== "function") {
                      __webpack_require__2(
                        /*! es6-promise */
                        "./node_modules/es6-promise/dist/es6-promise.js"
                      ).polyfill();
                    }
                  };
                  return Polyfill2;
                }()
              );
              Polyfill.install();
              __webpack_exports__2["default"] = Polyfill;
            }
          ),
          /***/
          "./src/utils/utf8-conv.js": (
            /*!********************************!*\
              !*** ./src/utils/utf8-conv.js ***!
              \********************************/
            /***/
            function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              function checkContinuation(uint8array, start, checkLength) {
                var array = uint8array;
                if (start + checkLength < array.length) {
                  while (checkLength--) {
                    if ((array[++start] & 192) !== 128)
                      return false;
                  }
                  return true;
                } else {
                  return false;
                }
              }
              function decodeUTF8(uint8array) {
                var out = [];
                var input = uint8array;
                var i2 = 0;
                var length2 = uint8array.length;
                while (i2 < length2) {
                  if (input[i2] < 128) {
                    out.push(String.fromCharCode(input[i2]));
                    ++i2;
                    continue;
                  } else if (input[i2] < 192)
                    ;
                  else if (input[i2] < 224) {
                    if (checkContinuation(input, i2, 1)) {
                      var ucs4 = (input[i2] & 31) << 6 | input[i2 + 1] & 63;
                      if (ucs4 >= 128) {
                        out.push(String.fromCharCode(ucs4 & 65535));
                        i2 += 2;
                        continue;
                      }
                    }
                  } else if (input[i2] < 240) {
                    if (checkContinuation(input, i2, 2)) {
                      var ucs4 = (input[i2] & 15) << 12 | (input[i2 + 1] & 63) << 6 | input[i2 + 2] & 63;
                      if (ucs4 >= 2048 && (ucs4 & 63488) !== 55296) {
                        out.push(String.fromCharCode(ucs4 & 65535));
                        i2 += 3;
                        continue;
                      }
                    }
                  } else if (input[i2] < 248) {
                    if (checkContinuation(input, i2, 3)) {
                      var ucs4 = (input[i2] & 7) << 18 | (input[i2 + 1] & 63) << 12 | (input[i2 + 2] & 63) << 6 | input[i2 + 3] & 63;
                      if (ucs4 > 65536 && ucs4 < 1114112) {
                        ucs4 -= 65536;
                        out.push(String.fromCharCode(ucs4 >>> 10 | 55296));
                        out.push(String.fromCharCode(ucs4 & 1023 | 56320));
                        i2 += 4;
                        continue;
                      }
                    }
                  }
                  out.push(String.fromCharCode(65533));
                  ++i2;
                }
                return out.join("");
              }
              __webpack_exports__2["default"] = decodeUTF8;
            }
          )
          /******/
        };
        var __webpack_module_cache__ = {};
        function __webpack_require__(moduleId) {
          var cachedModule = __webpack_module_cache__[moduleId];
          if (cachedModule !== void 0) {
            return cachedModule.exports;
          }
          var module2 = __webpack_module_cache__[moduleId] = {
            /******/
            // no module.id needed
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          return module2.exports;
        }
        __webpack_require__.m = __webpack_modules__;
        !function() {
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function() {
                return module2["default"];
              }
            ) : (
              /******/
              function() {
                return module2;
              }
            );
            __webpack_require__.d(getter, { a: getter });
            return getter;
          };
        }();
        !function() {
          __webpack_require__.d = function(exports2, definition) {
            for (var key in definition) {
              if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
              }
            }
          };
        }();
        !function() {
          __webpack_require__.g = function() {
            if (typeof globalThis === "object")
              return globalThis;
            try {
              return this || new Function("return this")();
            } catch (e2) {
              if (typeof window === "object")
                return window;
            }
          }();
        }();
        !function() {
          __webpack_require__.o = function(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          };
        }();
        !function() {
          __webpack_require__.r = function(exports2) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports2, "__esModule", { value: true });
          };
        }();
        var __webpack_exports__ = __webpack_require__("./src/index.js");
        return __webpack_exports__;
      }()
    );
  });
})(flv);
var flvExports = flv.exports;
const FlvJs = /* @__PURE__ */ getDefaultExportFromCjs(flvExports);
class VideoManager {
  constructor() {
    __publicField(this, "videosByKey");
    __publicField(this, "videoIndex", 0);
    this.videosByKey = {};
  }
  preloadVideo(url2) {
    var _a2;
    if (this.videosByKey[url2]) {
      return;
    }
    console.info("", url2);
    const id2 = "video-" + this.videoIndex++;
    const videoContainerTag = document.createElement("div");
    const videoTag = document.createElement("video");
    videoContainerTag.setAttribute("id", id2);
    videoContainerTag.style.width = "100%";
    videoContainerTag.style.height = "100%";
    videoContainerTag.style.zIndex = "-99";
    videoContainerTag.style.display = "block";
    videoContainerTag.style.opacity = "0";
    videoContainerTag.style.background = "#000";
    videoContainerTag.style.position = "absolute";
    videoTag.style.width = "100%";
    videoTag.style.height = "100%";
    videoTag.style.zIndex = "11";
    videoTag.style.position = "absolute";
    videoTag.style.display = "block";
    videoTag.volume = 0;
    const onEndedHandler = () => {
      const callbacks = this.videosByKey[url2].events.ended.callbacks;
      callbacks.forEach((cb2) => cb2());
    };
    videoContainerTag.appendChild(videoTag);
    (_a2 = document.getElementById("videoContainer")) == null ? void 0 : _a2.appendChild(videoContainerTag);
    const flvPlayer = FlvJs.createPlayer({
      type: url2.endsWith(".mp4") ? "mp4" : "flv",
      url: url2
    });
    flvPlayer.attachMediaElement(videoTag);
    flvPlayer.load();
    this.videosByKey[url2] = {
      player: flvPlayer,
      id: id2,
      progressTimer: null,
      events: {
        ended: {
          callbacks: [],
          handler: onEndedHandler
        }
      }
    };
  }
  pauseVideo(key) {
    const videoItem = this.videosByKey[key];
    if (videoItem) {
      videoItem.player.pause();
    }
  }
  showVideo(key) {
    const videoItem = this.videosByKey[key];
    if (videoItem) {
      const videoContainerTag = document.getElementById(videoItem.id);
      if (videoContainerTag) {
        videoContainerTag.style.opacity = "1";
        videoContainerTag.style.zIndex = "11";
      }
    }
  }
  playVideo(key) {
    const videoItem = this.videosByKey[key];
    if (videoItem) {
      videoItem.player.play();
      this.checkProgress(key);
    }
  }
  setLoop(key, loopValue) {
    const videoItem = this.videosByKey[key];
    if (videoItem) {
      const videoTag = document.getElementById(videoItem.id);
      if (videoTag) {
        videoTag.loop = loopValue;
      }
    }
  }
  seek(key, time) {
    const videoItem = this.videosByKey[key];
    if (videoItem) {
      videoItem.player.currentTime = time;
    }
  }
  setVolume(key, volume) {
    const videoItem = this.videosByKey[key];
    if (videoItem) {
      videoItem.player.volume = volume;
    }
  }
  destory(key) {
    const videoItem = this.videosByKey[key];
    if (videoItem) {
      videoItem.player.pause();
      videoItem.player.volume = 0;
      const videoContainer2 = document.getElementById(videoItem.id);
      if (videoContainer2) {
        videoContainer2.style.opacity = "0";
        videoContainer2.style.zIndex = "-99";
      }
      if (videoItem.progressTimer) {
        clearTimeout(videoItem.progressTimer);
      }
      setTimeout(() => {
        try {
          const video = videoContainer2 == null ? void 0 : videoContainer2.getElementsByTagName("video");
          if (video == null ? void 0 : video.length) {
            videoItem.player.destroy();
          }
        } catch (error2) {
          console.warn(error2);
        }
        setTimeout(() => {
          videoContainer2 == null ? void 0 : videoContainer2.remove();
        }, 500);
        delete this.videosByKey[key];
      }, 2e3);
    }
  }
  destoryAll() {
    Object.keys(this.videosByKey).forEach((key) => {
      this.destory(key);
    });
    this.videosByKey = {};
  }
  onEnded(key, callback) {
    const videoItem = this.videosByKey[key];
    if (videoItem) {
      videoItem.events.ended.callbacks.push(callback);
    }
  }
  getDuration(key) {
    const videoItem = this.videosByKey[key];
    if (videoItem) {
      return videoItem.player.duration;
    }
  }
  destoryExcept(keys2) {
    Object.keys(this.videosByKey).forEach((key) => {
      if (!keys2.includes(key)) {
        this.destory(key);
      }
    });
  }
  checkProgress(key) {
    const videoItem = this.videosByKey[key];
    if (videoItem) {
      const player = videoItem.player;
      const currentTime = player.currentTime;
      const duration = player.duration;
      if (duration - currentTime <= 0.03) {
        clearTimeout(videoItem.progressTimer);
        videoItem.progressTimer = null;
        videoItem.events.ended.handler();
        return;
      }
      videoItem.progressTimer = setTimeout(() => {
        this.checkProgress(key);
      }, 100);
    }
  }
}
class WebgalCore {
  constructor() {
    __publicField(this, "sceneManager", new SceneManager());
    __publicField(this, "backlogManager", new BacklogManager(this.sceneManager));
    __publicField(this, "animationManager", new AnimationManager());
    __publicField(this, "gameplay", new Gameplay());
    __publicField(this, "gameName", "");
    __publicField(this, "gameKey", "");
    __publicField(this, "events", new Events());
    __publicField(this, "videoManager", new VideoManager());
  }
}
const WebGAL = new WebgalCore();
const setStorage = debounce$2(() => {
  const userDataState = webgalStore.getState().userData;
  localforageExports.setItem(WebGAL.gameKey, userDataState).then(() => {
    logger.info("");
  });
}, 100);
const getStorage = debounce$2(() => {
  localforageExports.getItem(WebGAL.gameKey).then((newUserData) => {
    if (!newUserData || !checkUserDataProperty(newUserData)) {
      logger.warn("");
      setStorage();
      return;
    }
    webgalStore.dispatch(resetUserData(newUserData));
  });
}, 100);
function debounce$2(func, wait) {
  let timeout;
  function context2(...args) {
    clearTimeout(timeout);
    let ret;
    timeout = setTimeout(() => {
      ret = func.apply(context2, args);
    }, wait);
    return ret;
  }
  return context2;
}
const dumpToStorageFast = () => {
  const userDataState = webgalStore.getState().userData;
  localforageExports.setItem(WebGAL.gameKey, userDataState).then(() => {
    localforageExports.getItem(WebGAL.gameKey).then((newUserData) => {
      if (!newUserData) {
        setStorage();
        return;
      }
      webgalStore.dispatch(resetUserData(newUserData));
    });
    logger.info("");
  });
};
function checkUserDataProperty(userData) {
  let result = true;
  for (const key in initState$2) {
    if (!userData.hasOwnProperty(key)) {
      result = false;
    }
  }
  return result;
}
var MenuPanelTag = /* @__PURE__ */ ((MenuPanelTag2) => {
  MenuPanelTag2[MenuPanelTag2["Save"] = 0] = "Save";
  MenuPanelTag2[MenuPanelTag2["Load"] = 1] = "Load";
  MenuPanelTag2[MenuPanelTag2["Option"] = 2] = "Option";
  return MenuPanelTag2;
})(MenuPanelTag || {});
const initState = {
  showBacklog: false,
  showStarter: true,
  showTitle: true,
  showMenuPanel: false,
  showTextBox: true,
  showControls: true,
  controlsVisibility: true,
  currentMenuTag: MenuPanelTag.Option,
  titleBg: "",
  titleBgm: "",
  logoImage: [],
  showExtra: false,
  showGlobalDialog: false,
  showPanicOverlay: false,
  isEnterGame: false,
  isShowLogo: true,
  isShowGameMenu: false
};
const GUISlice = createSlice({
  name: "gui",
  initialState: initState,
  reducers: {
    /**
     * GUI
     * @param state GUI
     * @param action Action
     */
    setVisibility: (state, action) => {
      getStorage();
      const { component, visibility } = action.payload;
      state[component] = visibility;
    },
    /**
     * MenuPanel
     * @param state GUI
     * @param action Action
     */
    setMenuPanelTag: (state, action) => {
      getStorage();
      state.currentMenuTag = action.payload;
    },
    /**
     * GUI
     * @param state GUI
     * @param action Action
     */
    setGuiAsset: (state, action) => {
      const { asset, value } = action.payload;
      state[asset] = value;
    },
    setLogoImage: (state, action) => {
      state.logoImage = [...action.payload];
    }
  }
});
const { setVisibility, setMenuPanelTag, setGuiAsset, setLogoImage } = GUISlice.actions;
const GUIReducer = GUISlice.reducer;
const webgalStore = configureStore({
  reducer: {
    stage: stageReducer,
    GUI: GUIReducer,
    userData: userDataReducer,
    saveData: savesReducer
  },
  middleware: getDefaultMiddleware({
    serializableCheck: false
  })
});
let emptyBgmTimeout;
function playBgm(url2, enter = 0, volume = 100) {
  logger.info("playing bgm" + url2);
  if (url2 === "") {
    emptyBgmTimeout = setTimeout(() => {
      webgalStore.dispatch(setStage({ key: "bgm", value: { src: "", enter: 0, volume: 100 } }));
    }, enter);
    const lastSrc = webgalStore.getState().stage.bgm.src;
    webgalStore.dispatch(setStage({ key: "bgm", value: { src: lastSrc, enter: -enter, volume } }));
  } else {
    clearTimeout(emptyBgmTimeout);
    webgalStore.dispatch(setStage({ key: "bgm", value: { src: url2, enter, volume } }));
  }
  const audioElement = document.getElementById("currentBgm");
  if (audioElement.src) {
    audioElement == null ? void 0 : audioElement.play();
  }
}
function setEbg(url2) {
  const ebg = document.getElementById("ebg");
  if (ebg) {
    ebg.style.backgroundImage = `url("${url2}")`;
  }
}
const stopAllPerform = () => {
  logger.warn("");
  for (let i2 = 0; i2 < WebGAL.gameplay.performController.performList.length; i2++) {
    const e2 = WebGAL.gameplay.performController.performList[i2];
    e2.stopFunction();
    clearTimeout(e2.stopTimeout);
    WebGAL.gameplay.performController.performList.splice(i2, 1);
    i2--;
  }
};
const restorePerform = () => {
  const stageState = webgalStore.getState().stage;
  stageState.PerformList.forEach((e2) => {
    runScript(e2.script);
  });
};
const loadGame = (index2) => {
  const userDataState = webgalStore.getState().saveData;
  const loadFile = userDataState.saveData[index2];
  logger.debug("", loadFile);
  loadGameFromStageData(loadFile);
};
function loadGameFromStageData(stageData) {
  if (!stageData) {
    logger.info("");
    return;
  }
  const loadFile = stageData;
  sceneFetcher(loadFile.sceneData.sceneUrl).then(async (rawScene) => {
    const scene = await WebGAL.sceneManager.setCurrentScene(
      rawScene,
      loadFile.sceneData.sceneName,
      loadFile.sceneData.sceneUrl,
      true
    );
    if (!scene)
      return;
    const subSceneList = WebGAL.sceneManager.sceneData.currentScene.subSceneList;
    WebGAL.sceneManager.settledScenes.push(WebGAL.sceneManager.sceneData.currentScene.sceneUrl);
    const subSceneListUniq = uniqWith$1(subSceneList);
    scenePrefetcher(subSceneListUniq);
  });
  WebGAL.sceneManager.sceneData.currentSentenceId = loadFile.sceneData.currentSentenceId;
  WebGAL.sceneManager.sceneData.sceneStack = cloneDeep$1(loadFile.sceneData.sceneStack);
  stopAllPerform();
  const newBacklog = loadFile.backlog;
  WebGAL.backlogManager.getBacklog().splice(0, WebGAL.backlogManager.getBacklog().length);
  for (const e2 of newBacklog) {
    WebGAL.backlogManager.getBacklog().push(e2);
  }
  const newStageState = cloneDeep$1(loadFile.nowStageState);
  const dispatch = webgalStore.dispatch;
  dispatch(resetStageState(newStageState));
  setTimeout(restorePerform, 0);
  dispatch(setVisibility({ component: "showTitle", visibility: false }));
  dispatch(setVisibility({ component: "showMenuPanel", visibility: false }));
  setEbg(webgalStore.getState().stage.bgName);
}
function dumpSavesToStorage(startIndex, endIndex) {
  for (let i2 = startIndex; i2 <= endIndex; i2++) {
    const save = webgalStore.getState().saveData.saveData[i2];
    localforage.setItem(`${WebGAL.gameKey}-saves${i2}`, save).then(() => {
      logger.info(`${i2}`);
    });
  }
}
function getSavesFromStorage(startIndex, endIndex) {
  for (let i2 = startIndex; i2 <= endIndex; i2++) {
    localforage.getItem(`${WebGAL.gameKey}-saves${i2}`).then((save) => {
      webgalStore.dispatch(saveActions.saveGame({ index: i2, saveData: save }));
      logger.info(`${i2}`);
    });
  }
}
async function dumpFastSaveToStorage() {
  const save = webgalStore.getState().saveData.quickSaveData;
  await localforage.setItem(`${WebGAL.gameKey}-saves-fast`, save);
  logger.info(``);
}
async function getFastSaveFromStorage() {
  const save = await localforage.getItem(`${WebGAL.gameKey}-saves-fast`);
  webgalStore.dispatch(saveActions.setFastSave(save));
  logger.info(``);
}
const saveGame = (index2) => {
  const saveData = generateCurrentStageData(index2);
  webgalStore.dispatch(saveActions.saveGame({ index: index2, saveData }));
  dumpSavesToStorage(index2, index2);
};
function generateCurrentStageData(index2, isSavePreviewImage = true) {
  const stageState = webgalStore.getState().stage;
  const saveBacklog = cloneDeep$1(WebGAL.backlogManager.getBacklog());
  let urlToSave = "";
  if (isSavePreviewImage) {
    const canvas = document.getElementById("pixiCanvas");
    const canvas2 = document.createElement("canvas");
    const context2 = canvas2.getContext("2d");
    canvas2.width = 480;
    canvas2.height = 270;
    context2.drawImage(canvas, 0, 0, 480, 270);
    urlToSave = canvas2.toDataURL("image/webp", 0.5);
    canvas2.remove();
  }
  const saveData = {
    nowStageState: cloneDeep$1(stageState),
    backlog: saveBacklog,
    // 
    index: index2,
    // 
    saveTime: (/* @__PURE__ */ new Date()).toLocaleDateString() + " " + (/* @__PURE__ */ new Date()).toLocaleTimeString("chinese", { hour12: false }),
    // 
    // 
    sceneData: {
      currentSentenceId: WebGAL.sceneManager.sceneData.currentSentenceId,
      // ID
      sceneStack: cloneDeep$1(WebGAL.sceneManager.sceneData.sceneStack),
      // 
      sceneName: WebGAL.sceneManager.sceneData.currentScene.sceneName,
      // 
      sceneUrl: WebGAL.sceneManager.sceneData.currentScene.sceneUrl
      // url
    },
    previewImage: urlToSave
  };
  return saveData;
}
function initKey() {
  `FastSaveKey-${WebGAL.gameName}-${WebGAL.gameKey}`;
  `FastSaveActive-${WebGAL.gameName}-${WebGAL.gameKey}`;
}
async function fastSaveGame() {
  const saveData = generateCurrentStageData(-1, false);
  const newSaveData = cloneDeep$1(saveData);
  webgalStore.dispatch(saveActions.setFastSave(newSaveData));
  await dumpFastSaveToStorage();
}
const startGame = () => {
  resetStage(true, true, false);
  const sceneUrl = assetSetter("start.txt", fileType$1.scene);
  sceneFetcher(sceneUrl).then((rawScene) => {
    WebGAL.sceneManager.setCurrentScene(rawScene, "start.txt", sceneUrl).then((scene) => {
      if (scene) {
        nextSentence();
      }
    });
  });
  webgalStore.dispatch(setVisibility({ component: "showTitle", visibility: false }));
};
function _objectWithoutProperties$1(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var voidElements = {
  "area": true,
  "base": true,
  "br": true,
  "col": true,
  "embed": true,
  "hr": true,
  "img": true,
  "input": true,
  "link": true,
  "meta": true,
  "param": true,
  "source": true,
  "track": true,
  "wbr": true
};
const e = /* @__PURE__ */ getDefaultExportFromCjs(voidElements);
var t = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;
function n(n2) {
  var r2 = { type: "tag", name: "", voidElement: false, attrs: {}, children: [] }, i2 = n2.match(/<\/?([^\s]+?)[/\s>]/);
  if (i2 && (r2.name = i2[1], (e[i2[1]] || "/" === n2.charAt(n2.length - 2)) && (r2.voidElement = true), r2.name.startsWith("!--"))) {
    var s2 = n2.indexOf("-->");
    return { type: "comment", comment: -1 !== s2 ? n2.slice(4, s2) : "" };
  }
  for (var a2 = new RegExp(t), c2 = null; null !== (c2 = a2.exec(n2)); )
    if (c2[0].trim())
      if (c2[1]) {
        var o2 = c2[1].trim(), l2 = [o2, ""];
        o2.indexOf("=") > -1 && (l2 = o2.split("=")), r2.attrs[l2[0]] = l2[1], a2.lastIndex--;
      } else
        c2[2] && (r2.attrs[c2[2]] = c2[3].trim().substring(1, c2[3].length - 1));
  return r2;
}
var r = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g, i = /^\s*$/, s$1 = /* @__PURE__ */ Object.create(null);
function a(e2, t2) {
  switch (t2.type) {
    case "text":
      return e2 + t2.content;
    case "tag":
      return e2 += "<" + t2.name + (t2.attrs ? function(e3) {
        var t3 = [];
        for (var n2 in e3)
          t3.push(n2 + '="' + e3[n2] + '"');
        return t3.length ? " " + t3.join(" ") : "";
      }(t2.attrs) : "") + (t2.voidElement ? "/>" : ">"), t2.voidElement ? e2 : e2 + t2.children.reduce(a, "") + "</" + t2.name + ">";
    case "comment":
      return e2 + "<!--" + t2.comment + "-->";
  }
}
var c = { parse: function(e2, t2) {
  t2 || (t2 = {}), t2.components || (t2.components = s$1);
  var a2, c2 = [], o2 = [], l2 = -1, m2 = false;
  if (0 !== e2.indexOf("<")) {
    var u2 = e2.indexOf("<");
    c2.push({ type: "text", content: -1 === u2 ? e2 : e2.substring(0, u2) });
  }
  return e2.replace(r, function(r2, s2) {
    if (m2) {
      if (r2 !== "</" + a2.name + ">")
        return;
      m2 = false;
    }
    var u3, f2 = "/" !== r2.charAt(1), h2 = r2.startsWith("<!--"), p = s2 + r2.length, d2 = e2.charAt(p);
    if (h2) {
      var v2 = n(r2);
      return l2 < 0 ? (c2.push(v2), c2) : ((u3 = o2[l2]).children.push(v2), c2);
    }
    if (f2 && (l2++, "tag" === (a2 = n(r2)).type && t2.components[a2.name] && (a2.type = "component", m2 = true), a2.voidElement || m2 || !d2 || "<" === d2 || a2.children.push({ type: "text", content: e2.slice(p, e2.indexOf("<", p)) }), 0 === l2 && c2.push(a2), (u3 = o2[l2 - 1]) && u3.children.push(a2), o2[l2] = a2), (!f2 || a2.voidElement) && (l2 > -1 && (a2.voidElement || a2.name === r2.slice(2, -1)) && (l2--, a2 = -1 === l2 ? c2 : o2[l2]), !m2 && "<" !== d2 && d2)) {
      u3 = -1 === l2 ? c2 : o2[l2].children;
      var x = e2.indexOf("<", p), g2 = e2.slice(p, -1 === x ? void 0 : x);
      i.test(g2) && (g2 = " "), (x > -1 && l2 + u3.length >= 0 || " " !== g2) && u3.push({ type: "text", content: g2 });
    }
  }), c2;
}, stringify: function(e2) {
  return e2.reduce(function(e3, t2) {
    return e3 + a("", t2);
  }, "");
} };
function warn() {
  if (console && console.warn) {
    var _console;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[0] === "string")
      args[0] = "react-i18next:: ".concat(args[0]);
    (_console = console).warn.apply(_console, args);
  }
}
var alreadyWarned = {};
function warnOnce() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  if (typeof args[0] === "string" && alreadyWarned[args[0]])
    return;
  if (typeof args[0] === "string")
    alreadyWarned[args[0]] = /* @__PURE__ */ new Date();
  warn.apply(void 0, args);
}
var loadedClb = function loadedClb2(i18n, cb2) {
  return function() {
    if (i18n.isInitialized) {
      cb2();
    } else {
      var initialized = function initialized2() {
        setTimeout(function() {
          i18n.off("initialized", initialized2);
        }, 0);
        cb2();
      };
      i18n.on("initialized", initialized);
    }
  };
};
function loadNamespaces(i18n, ns, cb2) {
  i18n.loadNamespaces(ns, loadedClb(i18n, cb2));
}
function loadLanguages(i18n, lng, ns, cb2) {
  if (typeof ns === "string")
    ns = [ns];
  ns.forEach(function(n2) {
    if (i18n.options.ns.indexOf(n2) < 0)
      i18n.options.ns.push(n2);
  });
  i18n.loadLanguages(lng, loadedClb(i18n, cb2));
}
function oldI18nextHasLoadedNamespace(ns, i18n) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var lng = i18n.languages[0];
  var fallbackLng = i18n.options ? i18n.options.fallbackLng : false;
  var lastLng = i18n.languages[i18n.languages.length - 1];
  if (lng.toLowerCase() === "cimode")
    return true;
  var loadNotPending = function loadNotPending2(l2, n2) {
    var loadState = i18n.services.backendConnector.state["".concat(l2, "|").concat(n2)];
    return loadState === -1 || loadState === 2;
  };
  if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18n.services.backendConnector.backend && i18n.isLanguageChangingTo && !loadNotPending(i18n.isLanguageChangingTo, ns))
    return false;
  if (i18n.hasResourceBundle(lng, ns))
    return true;
  if (!i18n.services.backendConnector.backend || i18n.options.resources && !i18n.options.partialBundledLanguages)
    return true;
  if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
    return true;
  return false;
}
function hasLoadedNamespace(ns, i18n) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!i18n.languages || !i18n.languages.length) {
    warnOnce("i18n.languages were undefined or empty", i18n.languages);
    return true;
  }
  var isNewerI18next = i18n.options.ignoreJSONStructure !== void 0;
  if (!isNewerI18next) {
    return oldI18nextHasLoadedNamespace(ns, i18n, options);
  }
  return i18n.hasLoadedNamespace(ns, {
    lng: options.lng,
    precheck: function precheck(i18nInstance2, loadNotPending) {
      if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18nInstance2.services.backendConnector.backend && i18nInstance2.isLanguageChangingTo && !loadNotPending(i18nInstance2.isLanguageChangingTo, ns))
        return false;
    }
  });
}
var matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
var htmlEntities = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "",
  "&#169;": "",
  "&reg;": "",
  "&#174;": "",
  "&hellip;": "",
  "&#8230;": "",
  "&#x2F;": "/",
  "&#47;": "/"
};
var unescapeHtmlEntity = function unescapeHtmlEntity2(m2) {
  return htmlEntities[m2];
};
var unescape$1 = function unescape2(text2) {
  return text2.replace(matchHtmlEntity, unescapeHtmlEntity);
};
function ownKeys$b(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$b(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$b(Object(source), true).forEach(function(key) {
        _defineProperty$2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$b(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var defaultOptions = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: true,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: true,
  unescape: unescape$1
};
function setDefaults() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  defaultOptions = _objectSpread$b(_objectSpread$b({}, defaultOptions), options);
}
function getDefaults() {
  return defaultOptions;
}
var i18nInstance;
function setI18n(instance2) {
  i18nInstance = instance2;
}
function getI18n() {
  return i18nInstance;
}
var _excluded$2 = ["format"], _excluded2 = ["children", "count", "parent", "i18nKey", "context", "tOptions", "values", "defaults", "components", "ns", "i18n", "t", "shouldUnescape"];
function ownKeys$a(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$a(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$a(Object(source), true).forEach(function(key) {
        _defineProperty$2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$a(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function hasChildren(node2, checkLength) {
  if (!node2)
    return false;
  var base = node2.props ? node2.props.children : node2.children;
  if (checkLength)
    return base.length > 0;
  return !!base;
}
function getChildren(node2) {
  if (!node2)
    return [];
  return node2.props ? node2.props.children : node2.children;
}
function hasValidReactChildren(children) {
  if (Object.prototype.toString.call(children) !== "[object Array]")
    return false;
  return children.every(function(child) {
    return reactExports.isValidElement(child);
  });
}
function getAsArray(data2) {
  return Array.isArray(data2) ? data2 : [data2];
}
function mergeProps(source, target) {
  var newTarget = _objectSpread$a({}, target);
  newTarget.props = Object.assign(source.props, target.props);
  return newTarget;
}
function nodesToString(children, i18nOptions) {
  if (!children)
    return "";
  var stringNode = "";
  var childrenArray = getAsArray(children);
  var keepArray = i18nOptions.transSupportBasicHtmlNodes && i18nOptions.transKeepBasicHtmlNodesFor ? i18nOptions.transKeepBasicHtmlNodesFor : [];
  childrenArray.forEach(function(child, childIndex) {
    if (typeof child === "string") {
      stringNode += "".concat(child);
    } else if (reactExports.isValidElement(child)) {
      var childPropsCount = Object.keys(child.props).length;
      var shouldKeepChild = keepArray.indexOf(child.type) > -1;
      var childChildren = child.props.children;
      if (!childChildren && shouldKeepChild && childPropsCount === 0) {
        stringNode += "<".concat(child.type, "/>");
      } else if (!childChildren && (!shouldKeepChild || childPropsCount !== 0)) {
        stringNode += "<".concat(childIndex, "></").concat(childIndex, ">");
      } else if (child.props.i18nIsDynamicList) {
        stringNode += "<".concat(childIndex, "></").concat(childIndex, ">");
      } else if (shouldKeepChild && childPropsCount === 1 && typeof childChildren === "string") {
        stringNode += "<".concat(child.type, ">").concat(childChildren, "</").concat(child.type, ">");
      } else {
        var content = nodesToString(childChildren, i18nOptions);
        stringNode += "<".concat(childIndex, ">").concat(content, "</").concat(childIndex, ">");
      }
    } else if (child === null) {
      warn("Trans: the passed in value is invalid - seems you passed in a null child.");
    } else if (_typeof(child) === "object") {
      var format2 = child.format, clone = _objectWithoutProperties$1(child, _excluded$2);
      var keys2 = Object.keys(clone);
      if (keys2.length === 1) {
        var value = format2 ? "".concat(keys2[0], ", ").concat(format2) : keys2[0];
        stringNode += "{{".concat(value, "}}");
      } else {
        warn("react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.", child);
      }
    } else {
      warn("Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.", child);
    }
  });
  return stringNode;
}
function renderNodes(children, targetString, i18n, i18nOptions, combinedTOpts, shouldUnescape) {
  if (targetString === "")
    return [];
  var keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];
  var emptyChildrenButNeedsHandling = targetString && new RegExp(keepArray.join("|")).test(targetString);
  if (!children && !emptyChildrenButNeedsHandling)
    return [targetString];
  var data2 = {};
  function getData(childs) {
    var childrenArray = getAsArray(childs);
    childrenArray.forEach(function(child) {
      if (typeof child === "string")
        return;
      if (hasChildren(child))
        getData(getChildren(child));
      else if (_typeof(child) === "object" && !reactExports.isValidElement(child))
        Object.assign(data2, child);
    });
  }
  getData(children);
  var ast = c.parse("<0>".concat(targetString, "</0>"));
  var opts = _objectSpread$a(_objectSpread$a({}, data2), combinedTOpts);
  function renderInner(child, node2, rootReactNode) {
    var childs = getChildren(child);
    var mappedChildren = mapAST(childs, node2.children, rootReactNode);
    return hasValidReactChildren(childs) && mappedChildren.length === 0 ? childs : mappedChildren;
  }
  function pushTranslatedJSX(child, inner2, mem, i2, isVoid) {
    if (child.dummy)
      child.children = inner2;
    mem.push(reactExports.cloneElement(child, _objectSpread$a(_objectSpread$a({}, child.props), {}, {
      key: i2
    }), isVoid ? void 0 : inner2));
  }
  function mapAST(reactNode, astNode, rootReactNode) {
    var reactNodes = getAsArray(reactNode);
    var astNodes = getAsArray(astNode);
    return astNodes.reduce(function(mem, node2, i2) {
      var translationContent = node2.children && node2.children[0] && node2.children[0].content && i18n.services.interpolator.interpolate(node2.children[0].content, opts, i18n.language);
      if (node2.type === "tag") {
        var tmp = reactNodes[parseInt(node2.name, 10)];
        if (!tmp && rootReactNode.length === 1 && rootReactNode[0][node2.name])
          tmp = rootReactNode[0][node2.name];
        if (!tmp)
          tmp = {};
        var child = Object.keys(node2.attrs).length !== 0 ? mergeProps({
          props: node2.attrs
        }, tmp) : tmp;
        var isElement2 = reactExports.isValidElement(child);
        var isValidTranslationWithChildren = isElement2 && hasChildren(node2, true) && !node2.voidElement;
        var isEmptyTransWithHTML = emptyChildrenButNeedsHandling && _typeof(child) === "object" && child.dummy && !isElement2;
        var isKnownComponent = _typeof(children) === "object" && children !== null && Object.hasOwnProperty.call(children, node2.name);
        if (typeof child === "string") {
          var value = i18n.services.interpolator.interpolate(child, opts, i18n.language);
          mem.push(value);
        } else if (hasChildren(child) || isValidTranslationWithChildren) {
          var inner2 = renderInner(child, node2, rootReactNode);
          pushTranslatedJSX(child, inner2, mem, i2);
        } else if (isEmptyTransWithHTML) {
          var _inner = mapAST(reactNodes, node2.children, rootReactNode);
          mem.push(reactExports.cloneElement(child, _objectSpread$a(_objectSpread$a({}, child.props), {}, {
            key: i2
          }), _inner));
        } else if (Number.isNaN(parseFloat(node2.name))) {
          if (isKnownComponent) {
            var _inner2 = renderInner(child, node2, rootReactNode);
            pushTranslatedJSX(child, _inner2, mem, i2, node2.voidElement);
          } else if (i18nOptions.transSupportBasicHtmlNodes && keepArray.indexOf(node2.name) > -1) {
            if (node2.voidElement) {
              mem.push(reactExports.createElement(node2.name, {
                key: "".concat(node2.name, "-").concat(i2)
              }));
            } else {
              var _inner3 = mapAST(reactNodes, node2.children, rootReactNode);
              mem.push(reactExports.createElement(node2.name, {
                key: "".concat(node2.name, "-").concat(i2)
              }, _inner3));
            }
          } else if (node2.voidElement) {
            mem.push("<".concat(node2.name, " />"));
          } else {
            var _inner4 = mapAST(reactNodes, node2.children, rootReactNode);
            mem.push("<".concat(node2.name, ">").concat(_inner4, "</").concat(node2.name, ">"));
          }
        } else if (_typeof(child) === "object" && !isElement2) {
          var content = node2.children[0] ? translationContent : null;
          if (content)
            mem.push(content);
        } else if (node2.children.length === 1 && translationContent) {
          mem.push(reactExports.cloneElement(child, _objectSpread$a(_objectSpread$a({}, child.props), {}, {
            key: i2
          }), translationContent));
        } else {
          mem.push(reactExports.cloneElement(child, _objectSpread$a(_objectSpread$a({}, child.props), {}, {
            key: i2
          })));
        }
      } else if (node2.type === "text") {
        var wrapTextNodes = i18nOptions.transWrapTextNodes;
        var _content = shouldUnescape ? i18nOptions.unescape(i18n.services.interpolator.interpolate(node2.content, opts, i18n.language)) : i18n.services.interpolator.interpolate(node2.content, opts, i18n.language);
        if (wrapTextNodes) {
          mem.push(reactExports.createElement(wrapTextNodes, {
            key: "".concat(node2.name, "-").concat(i2)
          }, _content));
        } else {
          mem.push(_content);
        }
      }
      return mem;
    }, []);
  }
  var result = mapAST([{
    dummy: true,
    children: children || []
  }], ast, getAsArray(children || []));
  return getChildren(result[0]);
}
function Trans$1(_ref) {
  var children = _ref.children, count = _ref.count, parent = _ref.parent, i18nKey = _ref.i18nKey, context2 = _ref.context, _ref$tOptions = _ref.tOptions, tOptions = _ref$tOptions === void 0 ? {} : _ref$tOptions, values = _ref.values, defaults2 = _ref.defaults, components = _ref.components, ns = _ref.ns, i18nFromProps = _ref.i18n, tFromProps = _ref.t, shouldUnescape = _ref.shouldUnescape, additionalProps = _objectWithoutProperties$1(_ref, _excluded2);
  var i18n = i18nFromProps || getI18n();
  if (!i18n) {
    warnOnce("You will need to pass in an i18next instance by using i18nextReactModule");
    return children;
  }
  var t2 = tFromProps || i18n.t.bind(i18n) || function(k2) {
    return k2;
  };
  if (context2)
    tOptions.context = context2;
  var reactI18nextOptions = _objectSpread$a(_objectSpread$a({}, getDefaults()), i18n.options && i18n.options.react);
  var namespaces = ns || t2.ns || i18n.options && i18n.options.defaultNS;
  namespaces = typeof namespaces === "string" ? [namespaces] : namespaces || ["translation"];
  var defaultValue2 = defaults2 || nodesToString(children, reactI18nextOptions) || reactI18nextOptions.transEmptyNodeValue || i18nKey;
  var hashTransKey = reactI18nextOptions.hashTransKey;
  var key = i18nKey || (hashTransKey ? hashTransKey(defaultValue2) : defaultValue2);
  var interpolationOverride = values ? tOptions.interpolation : {
    interpolation: _objectSpread$a(_objectSpread$a({}, tOptions.interpolation), {}, {
      prefix: "#$?",
      suffix: "?$#"
    })
  };
  var combinedTOpts = _objectSpread$a(_objectSpread$a(_objectSpread$a(_objectSpread$a({}, tOptions), {}, {
    count
  }, values), interpolationOverride), {}, {
    defaultValue: defaultValue2,
    ns: namespaces
  });
  var translation = key ? t2(key, combinedTOpts) : defaultValue2;
  var content = renderNodes(components || children, translation, i18n, reactI18nextOptions, combinedTOpts, shouldUnescape);
  var useAsParent = parent !== void 0 ? parent : reactI18nextOptions.defaultTransParent;
  return useAsParent ? reactExports.createElement(useAsParent, additionalProps, content) : content;
}
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
var initReactI18next = {
  type: "3rdParty",
  init: function init(instance2) {
    setDefaults(instance2.options.react);
    setI18n(instance2);
  }
};
var I18nContext = reactExports.createContext();
var ReportNamespaces = function() {
  function ReportNamespaces2() {
    _classCallCheck(this, ReportNamespaces2);
    this.usedNamespaces = {};
  }
  _createClass(ReportNamespaces2, [{
    key: "addUsedNamespaces",
    value: function addUsedNamespaces(namespaces) {
      var _this = this;
      namespaces.forEach(function(ns) {
        if (!_this.usedNamespaces[ns])
          _this.usedNamespaces[ns] = true;
      });
    }
  }, {
    key: "getUsedNamespaces",
    value: function getUsedNamespaces() {
      return Object.keys(this.usedNamespaces);
    }
  }]);
  return ReportNamespaces2;
}();
var _excluded$1 = ["children", "count", "parent", "i18nKey", "context", "tOptions", "values", "defaults", "components", "ns", "i18n", "t", "shouldUnescape"];
function ownKeys$9(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$9(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$9(Object(source), true).forEach(function(key) {
        _defineProperty$2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function Trans(_ref) {
  var children = _ref.children, count = _ref.count, parent = _ref.parent, i18nKey = _ref.i18nKey, context2 = _ref.context, _ref$tOptions = _ref.tOptions, tOptions = _ref$tOptions === void 0 ? {} : _ref$tOptions, values = _ref.values, defaults2 = _ref.defaults, components = _ref.components, ns = _ref.ns, i18nFromProps = _ref.i18n, tFromProps = _ref.t, shouldUnescape = _ref.shouldUnescape, additionalProps = _objectWithoutProperties$1(_ref, _excluded$1);
  var _ref2 = reactExports.useContext(I18nContext) || {}, i18nFromContext = _ref2.i18n, defaultNSFromContext = _ref2.defaultNS;
  var i18n = i18nFromProps || i18nFromContext || getI18n();
  var t2 = tFromProps || i18n && i18n.t.bind(i18n);
  return Trans$1(_objectSpread$9({
    children,
    count,
    parent,
    i18nKey,
    context: context2,
    tOptions,
    values,
    defaults: defaults2,
    components,
    ns: ns || t2 && t2.ns || defaultNSFromContext || i18n && i18n.options && i18n.options.defaultNS,
    i18n,
    t: tFromProps,
    shouldUnescape
  }, additionalProps));
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i2 = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f2 = false;
      } else
        for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true)
          ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2))
          return;
      } finally {
        if (o2)
          throw n2;
      }
    }
    return a2;
  }
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
}
function ownKeys$8(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$8(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$8(Object(source), true).forEach(function(key) {
        _defineProperty$2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$8(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var usePrevious = function usePrevious2(value, ignore) {
  var ref2 = reactExports.useRef();
  reactExports.useEffect(function() {
    ref2.current = ignore ? ref2.current : value;
  }, [value, ignore]);
  return ref2.current;
};
function useTranslation(ns) {
  var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var i18nFromProps = props.i18n;
  var _ref = reactExports.useContext(I18nContext) || {}, i18nFromContext = _ref.i18n, defaultNSFromContext = _ref.defaultNS;
  var i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces)
    i18n.reportNamespaces = new ReportNamespaces();
  if (!i18n) {
    warnOnce("You will need to pass in an i18next instance by using initReactI18next");
    var notReadyT = function notReadyT2(k2, optsOrDefaultValue) {
      if (typeof optsOrDefaultValue === "string")
        return optsOrDefaultValue;
      if (optsOrDefaultValue && _typeof(optsOrDefaultValue) === "object" && typeof optsOrDefaultValue.defaultValue === "string")
        return optsOrDefaultValue.defaultValue;
      return Array.isArray(k2) ? k2[k2.length - 1] : k2;
    };
    var retNotReady = [notReadyT, {}, false];
    retNotReady.t = notReadyT;
    retNotReady.i18n = {};
    retNotReady.ready = false;
    return retNotReady;
  }
  if (i18n.options.react && i18n.options.react.wait !== void 0)
    warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  var i18nOptions = _objectSpread$8(_objectSpread$8(_objectSpread$8({}, getDefaults()), i18n.options.react), props);
  var useSuspense = i18nOptions.useSuspense, keyPrefix = i18nOptions.keyPrefix;
  var namespaces = ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
  namespaces = typeof namespaces === "string" ? [namespaces] : namespaces || ["translation"];
  if (i18n.reportNamespaces.addUsedNamespaces)
    i18n.reportNamespaces.addUsedNamespaces(namespaces);
  var ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every(function(n2) {
    return hasLoadedNamespace(n2, i18n, i18nOptions);
  });
  function getT() {
    return i18n.getFixedT(props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
  }
  var _useState = reactExports.useState(getT), _useState2 = _slicedToArray(_useState, 2), t2 = _useState2[0], setT = _useState2[1];
  var joinedNS = namespaces.join();
  if (props.lng)
    joinedNS = "".concat(props.lng).concat(joinedNS);
  var previousJoinedNS = usePrevious(joinedNS);
  var isMounted = reactExports.useRef(true);
  reactExports.useEffect(function() {
    var bindI18n = i18nOptions.bindI18n, bindI18nStore = i18nOptions.bindI18nStore;
    isMounted.current = true;
    if (!ready && !useSuspense) {
      if (props.lng) {
        loadLanguages(i18n, props.lng, namespaces, function() {
          if (isMounted.current)
            setT(getT);
        });
      } else {
        loadNamespaces(i18n, namespaces, function() {
          if (isMounted.current)
            setT(getT);
        });
      }
    }
    if (ready && previousJoinedNS && previousJoinedNS !== joinedNS && isMounted.current) {
      setT(getT);
    }
    function boundReset() {
      if (isMounted.current)
        setT(getT);
    }
    if (bindI18n && i18n)
      i18n.on(bindI18n, boundReset);
    if (bindI18nStore && i18n)
      i18n.store.on(bindI18nStore, boundReset);
    return function() {
      isMounted.current = false;
      if (bindI18n && i18n)
        bindI18n.split(" ").forEach(function(e2) {
          return i18n.off(e2, boundReset);
        });
      if (bindI18nStore && i18n)
        bindI18nStore.split(" ").forEach(function(e2) {
          return i18n.store.off(e2, boundReset);
        });
    };
  }, [i18n, joinedNS]);
  var isInitial = reactExports.useRef(true);
  reactExports.useEffect(function() {
    if (isMounted.current && !isInitial.current) {
      setT(getT);
    }
    isInitial.current = false;
  }, [i18n, keyPrefix]);
  var ret = [t2, i18n, ready];
  ret.t = t2;
  ret.i18n = i18n;
  ret.ready = ready;
  if (ready)
    return ret;
  if (!ready && !useSuspense)
    return ret;
  throw new Promise(function(resolve2) {
    if (props.lng) {
      loadLanguages(i18n, props.lng, namespaces, function() {
        return resolve2();
      });
    } else {
      loadNamespaces(i18n, namespaces, function() {
        return resolve2();
      });
    }
  });
}
function useTrans(prefix2) {
  const { t: t2 } = useTranslation();
  const trans2 = (key) => t2(key[0] === "$" ? key.slice(1) : prefix2 + key);
  function translation(key, ...keys2) {
    if (keys2.length)
      return [trans2(key), ...keys2.map((v2) => trans2(v2))];
    return trans2(key);
  }
  return translation;
}
function scss2cssinjsParser(scssString) {
  return WebgalParser.parseScssToWebgalStyleObj(scssString);
}
function useValue(initialState) {
  const [value, setValue] = reactExports.useState(initialState);
  return {
    _value: value,
    set: function(newValue) {
      this._value = newValue;
      setValue(newValue);
    },
    get value() {
      return this._value;
    },
    set value(newValue) {
      this.set(newValue);
    }
  };
}
function sheetForTag(tag2) {
  if (tag2.sheet) {
    return tag2.sheet;
  }
  for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
    if (document.styleSheets[i2].ownerNode === tag2) {
      return document.styleSheets[i2];
    }
  }
}
function createStyleElement(options) {
  var tag2 = document.createElement("style");
  tag2.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag2.setAttribute("nonce", options.nonce);
  }
  tag2.appendChild(document.createTextNode(""));
  tag2.setAttribute("data-s", "");
  return tag2;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag2) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag2, before);
      _this.tags.push(tag2);
    };
    this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag2 = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag2);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag2.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag2) {
      return tag2.parentNode && tag2.parentNode.removeChild(tag2);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
var assign$1 = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace$1(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append2(value, array) {
  return array.push(value), value;
}
function combine$1(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root2, parent, type2, props, children, length2) {
  return { value, root: root2, parent, type: type2, props, children, line, column, length: length2, return: "" };
}
function copy$1(root2, props) {
  return assign$1(node("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end2) {
  return substr(characters, begin, end2);
}
function token(type2) {
  switch (type2) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type2) {
  return trim(slice(position - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
}
function whitespace(type2) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type2) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type2) {
  while (next())
    switch (character) {
      case type2:
        return position;
      case 34:
      case 39:
        if (type2 !== 34 && type2 !== 39)
          delimiter(character);
        break;
      case 40:
        if (type2 === 41)
          delimiter(type2);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type2, index2) {
  while (next())
    if (type2 + character === 47 + 10)
      break;
    else if (type2 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from(type2 === 47 ? type2 : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position);
}
function compile(value) {
  return dealloc(parse$3("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse$3(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property2 = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type2 = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type2;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace$1(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append2(comment(commenter(next(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1)
              characters2 = replace$1(characters2, /\f/g, "");
            if (property2 > 0 && strlen(characters2) - length2)
              append2(property2 > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace$1(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append2(reference = ruleset(characters2, root2, parent, index2, offset, rules, points, type2, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse$3(characters2, root2, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse$3(value, reference, reference, rule && append2(ruleset(value, reference, reference, 0, 0, rules, points, type2, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$3(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset = property2 = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property2 = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root2, parent, index2, offset, rules, points, type2, props, children, length2) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i2 = 0, j2 = 0, k2 = 0; i2 < index2; ++i2)
    for (var x = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i2])), z2 = value; x < size; ++x)
      if (z2 = trim(j2 > 0 ? rule[x] + " " + y2 : replace$1(y2, /&\f/g, rule[x])))
        props[k2++] = z2;
  return node(value, root2, parent, offset === 0 ? RULESET : type2, props, children, length2);
}
function comment(value, root2, parent) {
  return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root2, parent, length2) {
  return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize(children, callback) {
  var output2 = "";
  var length2 = sizeof(children);
  for (var i2 = 0; i2 < length2; i2++)
    output2 += callback(children[i2], i2, children, callback) || "";
  return output2;
}
function stringify$2(element, index2, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback) {
    var output2 = "";
    for (var i2 = 0; i2 < length2; i2++)
      output2 += collection[i2](element, index2, children, callback) || "";
    return output2;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function memoize(fn2) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0)
      cache[arg] = fn2(arg);
    return cache[arg];
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      default:
        parsed[index2] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i2 = 0, k2 = 0; i2 < rules.length; i2++) {
    for (var j2 = 0; j2 < parentRules.length; j2++, k2++) {
      element.props[k2] = points[i2] ? rules[i2].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i2];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix(value, length2) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace$1(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace$1(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace$1(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace$1(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace$1(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace$1(value, "-grow", "") + WEBKIT + value + MS + replace$1(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace$1(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace$1(replace$1(replace$1(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace$1(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace$1(replace$1(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace$1(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace$1(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace$1(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace$1(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace$1(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index2, children, callback) {
  if (element.length > -1) {
    if (!element["return"])
      switch (element.type) {
        case DECLARATION:
          element["return"] = prefix(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize([copy$1(element, {
            value: replace$1(element.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element.length)
            return combine$1(element.props, function(value) {
              switch (match(value, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize([copy$1(element, {
                    props: [replace$1(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                  })], callback);
                case "::placeholder":
                  return serialize([copy$1(element, {
                    props: [replace$1(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                  }), copy$1(element, {
                    props: [replace$1(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                  }), copy$1(element, {
                    props: [replace$1(value, /:(plac\w+)/, MS + "input-$1")]
                  })], callback);
              }
              return "";
            });
      }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container2;
  var nodesToHydrate = [];
  {
    container2 = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i2 = 1; i2 < attrib.length; i2++) {
          inserted[attrib[i2]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify$2, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container: container2,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
function murmur2(str) {
  var h2 = 0;
  var k2, i2 = 0, len = str.length;
  for (; len >= 4; ++i2, len -= 4) {
    k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i2) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property2) {
  return property2.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = interpolation.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i2 = 0; i2 < obj.length; i2++) {
      string += handleInterpolation(mergedProps, registered, obj[i2]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && false) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings2 = args[0];
  if (strings2 == null || strings2.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings2);
  } else {
    styles2 += strings2[0];
  }
  for (var i2 = 1; i2 < args.length; i2++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i2]);
    if (stringMode) {
      styles2 += strings2[i2];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + // $FlowFixMe we know it's not null
    match2[1];
  }
  var name = murmur2(styles2) + identifierName;
  return {
    name,
    styles: styles2,
    next: cursor
  };
};
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function insertWithoutScoping(cache, serialized) {
  if (cache.inserted[serialized.name] === void 0) {
    return cache.insert("", serialized, cache.sheet, true);
  }
}
function merge$1(registered, css2, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css2(registeredStyles);
}
var createEmotion = function createEmotion2(options) {
  var cache = createCache(options);
  cache.sheet.speedy = function(value) {
    this.isSpeedy = value;
  };
  cache.compat = true;
  var css2 = function css3() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var serialized = serializeStyles(args, cache.registered, void 0);
    insertStyles(cache, serialized, false);
    return cache.key + "-" + serialized.name;
  };
  var keyframes2 = function keyframes3() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    var serialized = serializeStyles(args, cache.registered);
    var animation2 = "animation-" + serialized.name;
    insertWithoutScoping(cache, {
      name: serialized.name,
      styles: "@keyframes " + animation2 + "{" + serialized.styles + "}"
    });
    return animation2;
  };
  var injectGlobal2 = function injectGlobal3() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    var serialized = serializeStyles(args, cache.registered);
    insertWithoutScoping(cache, serialized);
  };
  var cx = function cx2() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return merge$1(cache.registered, css2, classnames(args));
  };
  return {
    css: css2,
    cx,
    injectGlobal: injectGlobal2,
    keyframes: keyframes2,
    hydrate: function hydrate(ids) {
      ids.forEach(function(key) {
        cache.inserted[key] = true;
      });
    },
    flush: function flush() {
      cache.registered = {};
      cache.inserted = {};
      cache.sheet.flush();
    },
    // $FlowFixMe
    sheet: cache.sheet,
    cache,
    getRegisteredStyles: getRegisteredStyles.bind(null, cache.registered),
    merge: merge$1.bind(null, cache.registered, css2)
  };
};
var classnames = function classnames2(args) {
  var cls = "";
  for (var i2 = 0; i2 < args.length; i2++) {
    var arg = args[i2];
    if (arg == null)
      continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames2(arg);
        } else {
          toAdd = "";
          for (var k2 in arg) {
            if (arg[k2] && k2) {
              toAdd && (toAdd += " ");
              toAdd += k2;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};
var _createEmotion = createEmotion({
  key: "css"
}), injectGlobal = _createEmotion.injectGlobal, css = _createEmotion.css;
function useApplyStyle(url2) {
  const styleObject = useValue({ classNameStyles: {}, others: "" });
  const replaced = useSelector((state) => state.stage.replacedUIlable);
  const applyStyle2 = (classNameLable, fallbackClassName) => {
    var _a2;
    const className = (replaced == null ? void 0 : replaced[classNameLable]) ?? classNameLable;
    if (Object.keys(styleObject.value.classNameStyles).includes(className)) {
      const cijClassName = css(((_a2 = styleObject.value.classNameStyles) == null ? void 0 : _a2[className]) ?? "");
      return `${fallbackClassName} ${cijClassName}`;
    }
    return fallbackClassName;
  };
  const updateStyleFile = async () => {
    logger.debug(" Scss ", url2);
    const resp = await axios$1.get(`game/template/${url2}`);
    const scssStr = resp.data;
    styleObject.set(scss2cssinjsParser(scssStr));
  };
  reactExports.useEffect(() => {
    updateStyleFile();
  }, []);
  reactExports.useEffect(() => {
    injectGlobal(styleObject.value.others);
  }, [styleObject.value.others]);
  useRigisterStyleUpdate(updateStyleFile);
  return applyStyle2;
}
function useRigisterStyleUpdate(callback) {
  const handler = () => {
    callback();
  };
  reactExports.useEffect(() => {
    WebGAL.events.styleUpdate.on(handler);
    return () => WebGAL.events.styleUpdate.off(handler);
  }, []);
}
function useGenSyncRef(selector) {
  const Store = useSelector(selector);
  const Ref = reactExports.useRef(Store);
  reactExports.useEffect(() => {
    Ref.current = Store;
  }, [Store]);
  return Ref;
}
function useMounted(callback) {
  reactExports.useEffect(() => {
    callback();
  }, []);
}
function useUnMounted(callback) {
  reactExports.useEffect(() => {
    return function() {
      callback();
    };
  }, []);
}
function useUpdated(callback) {
  reactExports.useEffect(() => {
    callback();
  });
}
const main = "_main_1x2ym_1";
const button$2 = "_button_1x2ym_16";
const button_text$1 = "_button_text_1x2ym_23";
const button_on = "_button_on_1x2ym_31";
const singleButton$1 = "_singleButton_1x2ym_41";
const autoButton = "_autoButton_1x2ym_54";
const fastForwardButton = "_fastForwardButton_1x2ym_71";
const flashbackButton = "_flashbackButton_1x2ym_87";
const fastSlPreview = "_fastSlPreview_1x2ym_105";
const fastSlEnter = "_fastSlEnter_1x2ym_1";
const fastsave = "_fastsave_1x2ym_119";
const fastSPreview = "_fastSPreview_1x2ym_119";
const fastload = "_fastload_1x2ym_123";
const fastLPreview = "_fastLPreview_1x2ym_123";
const slPreviewMain = "_slPreviewMain_1x2ym_135";
const imgContainer = "_imgContainer_1x2ym_143";
const textContainer = "_textContainer_1x2ym_151";
const styles$i = {
  main,
  button: button$2,
  button_text: button_text$1,
  button_on,
  singleButton: singleButton$1,
  autoButton,
  fastForwardButton,
  flashbackButton,
  fastSlPreview,
  fastSlEnter,
  fastsave,
  fastSPreview,
  fastload,
  fastLPreview,
  slPreviewMain,
  imgContainer,
  textContainer
};
const setButton$1 = (on2) => {
  const autoIcon = document.getElementById("Button_ControlPanel_auto");
  if (autoIcon) {
    if (on2) {
      autoIcon.className = styles$i.button_on;
    } else
      autoIcon.className = styles$i.singleButton;
  }
};
const stopAuto = () => {
  WebGAL.gameplay.isAuto = false;
  setButton$1(false);
  if (WebGAL.gameplay.autoInterval !== null) {
    clearInterval(WebGAL.gameplay.autoInterval);
    WebGAL.gameplay.autoInterval = null;
  }
  if (WebGAL.gameplay.autoTimeout !== null) {
    clearTimeout(WebGAL.gameplay.autoTimeout);
    WebGAL.gameplay.autoTimeout = null;
  }
};
const switchAuto = () => {
  if (WebGAL.gameplay.isAuto) {
    stopAuto();
  } else {
    WebGAL.gameplay.isAuto = true;
    setButton$1(true);
    WebGAL.gameplay.autoInterval = setInterval(autoPlay, 100);
  }
};
const autoNextSentence = () => {
  nextSentence();
  WebGAL.gameplay.autoTimeout = null;
};
const autoPlay = () => {
  const delay = webgalStore.getState().userData.optionData.autoSpeed;
  const autoPlayDelay = 750 - 250 * delay;
  let isBlockingAuto = false;
  WebGAL.gameplay.performController.performList.forEach((e2) => {
    if (e2.blockingAuto())
      isBlockingAuto = true;
  });
  if (isBlockingAuto) {
    return;
  }
  if (WebGAL.gameplay.autoTimeout === null) {
    WebGAL.gameplay.autoTimeout = setTimeout(autoNextSentence, autoPlayDelay);
  }
};
const setButton = (on2) => {
  const autoIcon = document.getElementById("Button_ControlPanel_fast");
  if (autoIcon) {
    if (on2) {
      autoIcon.className = styles$i.button_on;
    } else
      autoIcon.className = styles$i.singleButton;
  }
};
const stopFast = () => {
  if (!isFast()) {
    return;
  }
  WebGAL.gameplay.isFast = false;
  setButton(false);
  if (WebGAL.gameplay.fastInterval !== null) {
    clearInterval(WebGAL.gameplay.fastInterval);
    WebGAL.gameplay.fastInterval = null;
  }
};
const startFast = () => {
  if (isFast()) {
    return;
  }
  WebGAL.gameplay.isFast = true;
  setButton(true);
  WebGAL.gameplay.fastInterval = setInterval(() => {
    nextSentence();
  }, SYSTEM_CONFIG.fast_timeout);
};
const isFast = function() {
  return WebGAL.gameplay.isFast;
};
const stopAll = () => {
  stopFast();
  stopAuto();
};
const switchFast = () => {
  if (WebGAL.gameplay.isFast) {
    stopFast();
  } else {
    startFast();
  }
};
const Backlog_main = "_Backlog_main_fwj4v_2";
const backlog_soft_in = "_backlog_soft_in_fwj4v_1";
const Backlog_main_out = "_Backlog_main_out_fwj4v_18";
const backlog_soft_out = "_backlog_soft_out_fwj4v_1";
const Backlog_main_out_IndexHide = "_Backlog_main_out_IndexHide_fwj4v_31";
const Backlog_main_DisableScroll = "_Backlog_main_DisableScroll_fwj4v_35";
const backlog_top = "_backlog_top_fwj4v_39";
const backlog_top_icon = "_backlog_top_icon_fwj4v_59";
const backlog_title = "_backlog_title_fwj4v_77";
const backlog_content = "_backlog_content_fwj4v_86";
const backlog_item = "_backlog_item_fwj4v_111";
const backlog_item_in = "_backlog_item_in_fwj4v_1";
const backlog_item_content_name = "_backlog_item_content_name_fwj4v_127";
const backlog_item_content = "_backlog_item_content_fwj4v_127";
const backlog_item_button_element = "_backlog_item_button_element_fwj4v_133";
const backlog_item_out = "_backlog_item_out_fwj4v_149";
const backlog_func_area = "_backlog_func_area_fwj4v_158";
const backlog_item_button_list = "_backlog_item_button_list_fwj4v_189";
const sound_icon = "_sound_icon_fwj4v_207";
const backlog_item_content_text = "_backlog_item_content_text_fwj4v_217";
const backlog_icon_softin = "_backlog_icon_softin_fwj4v_1";
const styles$h = {
  Backlog_main,
  backlog_soft_in,
  Backlog_main_out,
  backlog_soft_out,
  Backlog_main_out_IndexHide,
  Backlog_main_DisableScroll,
  backlog_top,
  backlog_top_icon,
  backlog_title,
  backlog_content,
  backlog_item,
  backlog_item_in,
  backlog_item_content_name,
  backlog_item_content,
  backlog_item_button_element,
  backlog_item_out,
  backlog_func_area,
  backlog_item_button_list,
  sound_icon,
  backlog_item_content_text,
  backlog_icon_softin
};
var root = _root$1;
var now$1 = function() {
  return root.Date.now();
};
var now_1 = now$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim = baseTrim$1;
var baseTrim = _baseTrim, isObject$2 = isObject_1$1, isSymbol$1 = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$1(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$1(value)) {
    return NAN;
  }
  if (isObject$2(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$2(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$1;
var isObject$1 = isObject_1$1, now = now_1, toNumber = toNumber_1;
var FUNC_ERROR_TEXT$1 = "Expected a function";
var nativeMax = Math.max, nativeMin = Math.min;
function debounce$1(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  wait = toNumber(wait) || 0;
  if (isObject$1(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_1 = debounce$1;
var debounce = debounce_1, isObject = isObject_1$1;
var FUNC_ERROR_TEXT = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_1 = throttle;
const throttle$1 = /* @__PURE__ */ getDefaultExportFromCjs(throttle_1);
const keyboard = "keyboard" in navigator && navigator.keyboard;
function useHotkey(opt) {
  useMouseRightClickHotKey();
  useMouseWheel();
  useSkip();
  usePanic();
  useFastSaveBeforeUnloadPage();
  useSpaceAndEnter();
  useToggleFullScreen();
}
function useMouseRightClickHotKey() {
  const GUIStore = useGenSyncRef((state) => state.GUI);
  const setComponentVisibility = useSetComponentVisibility();
  const isGameActive = useGameActive(GUIStore);
  const isInBackLog = useIsInBackLog(GUIStore);
  const isOpenedDialog = useIsOpenedDialog(GUIStore);
  const validMenuPanelTag = useValidMenuPanelTag(GUIStore);
  const isShowExtra = useIsOpenedExtra(GUIStore);
  const handleContextMenu = reactExports.useCallback((ev) => {
    if (isOpenedDialog()) {
      setComponentVisibility("showGlobalDialog", false);
      ev.preventDefault();
      return false;
    }
    if (isShowExtra()) {
      setComponentVisibility("showExtra", false);
    }
    if (isGameActive()) {
      setComponentVisibility("showTextBox", !GUIStore.current.showTextBox);
    }
    if (isInBackLog()) {
      setComponentVisibility("showBacklog", false);
      setComponentVisibility("showTextBox", true);
    }
    if (validMenuPanelTag()) {
      setComponentVisibility("showMenuPanel", false);
    }
    ev.preventDefault();
    return false;
  }, []);
  useMounted(() => {
    document.addEventListener("contextmenu", handleContextMenu);
  });
  useUnMounted(() => {
    document.removeEventListener("contextmenu", handleContextMenu);
  });
}
let wheelTimeout = setTimeout(() => {
}, 0);
function useMouseWheel() {
  const GUIStore = useGenSyncRef((state) => state.GUI);
  const setComponentVisibility = useSetComponentVisibility();
  const isGameActive = useGameActive(GUIStore);
  const isInBackLog = useIsInBackLog(GUIStore);
  const isPanicOverlayOpen = useIsPanicOverlayOpen(GUIStore);
  const next2 = reactExports.useCallback(
    throttle$1(() => {
      nextSentence();
    }, 100),
    []
  );
  const prevDownWheelTimeRef = reactExports.useRef(0);
  const handleMouseWheel = reactExports.useCallback((ev) => {
    if (isPanicOverlayOpen())
      return;
    const direction = ev.wheelDelta && (ev.wheelDelta > 0 ? "up" : "down") || ev.detail && (ev.detail < 0 ? "up" : "down") || "down";
    const ctrlKey = ev.ctrlKey;
    const dom = document.querySelector(`.${styles$h.backlog_content}`);
    if (isGameActive() && direction === "up" && !ctrlKey) {
      setComponentVisibility("showBacklog", true);
      setComponentVisibility("showTextBox", false);
    } else if (isInBackLog() && direction === "down" && !ctrlKey) {
      if (dom) {
        let flag = hasScrollToBottom(dom);
        let curTime = (/* @__PURE__ */ new Date()).getTime();
        if (flag && curTime - prevDownWheelTimeRef.current > 100) {
          setComponentVisibility("showBacklog", false);
          setComponentVisibility("showTextBox", true);
        }
        prevDownWheelTimeRef.current = curTime;
      }
    } else if (isGameActive() && direction === "down" && !ctrlKey) {
      clearTimeout(wheelTimeout);
      WebGAL.gameplay.isFast = true;
      setTimeout(() => {
        WebGAL.gameplay.isFast = false;
      }, 150);
      next2();
    }
  }, []);
  useMounted(() => {
    document.addEventListener("wheel", handleMouseWheel);
  });
  useUnMounted(() => {
    document.removeEventListener("wheel", handleMouseWheel);
  });
}
function usePanic() {
  const panicButtonList = ["Escape", "Backquote"];
  const isPanicButton = (ev) => !ev.isComposing && !ev.defaultPrevented && panicButtonList.includes(ev.code);
  const GUIStore = useGenSyncRef((state) => state.GUI);
  const isTitleShown = reactExports.useCallback(() => GUIStore.current.showTitle, [GUIStore]);
  const isPanicOverlayOpen = useIsPanicOverlayOpen(GUIStore);
  const setComponentVisibility = useSetComponentVisibility();
  const handlePressPanicButton = reactExports.useCallback((ev) => {
    if (!isPanicButton(ev) || isTitleShown())
      return;
    if (isPanicOverlayOpen()) {
      setComponentVisibility("showPanicOverlay", false);
    } else {
      setComponentVisibility("showPanicOverlay", true);
      stopAll();
    }
  }, []);
  useMounted(() => {
    document.addEventListener("keyup", handlePressPanicButton);
  });
  useUnMounted(() => {
    document.removeEventListener("keyup", handlePressPanicButton);
  });
}
function useSkip() {
  const GUIStore = useGenSyncRef((state) => state.GUI);
  const isGameActive = useGameActive(GUIStore);
  const isCtrlKey = reactExports.useCallback((e2) => e2.keyCode === 17, []);
  const handleCtrlKeydown = reactExports.useCallback((e2) => {
    if (isCtrlKey(e2) && isGameActive()) {
      startFast();
    }
  }, []);
  const handleCtrlKeyup = reactExports.useCallback((e2) => {
    if (isCtrlKey(e2) && isGameActive()) {
      stopFast();
    }
  }, []);
  const handleWindowBlur = reactExports.useCallback((e2) => {
    stopFast();
  }, []);
  useMounted(() => {
    document.addEventListener("keydown", handleCtrlKeydown);
    document.addEventListener("keyup", handleCtrlKeyup);
    window.addEventListener("blur", handleWindowBlur);
  });
  useUnMounted(() => {
    document.removeEventListener("keydown", handleCtrlKeydown);
    document.removeEventListener("keyup", handleCtrlKeyup);
    window.removeEventListener("blur", handleWindowBlur);
  });
  useUpdated(() => {
    if (!isGameActive()) {
      stopFast();
    }
  });
}
function useFastSaveBeforeUnloadPage() {
  const validMenuGameStart = useValidMenuGameStart();
  const handleWindowUnload = reactExports.useCallback(async (e2) => {
    if (validMenuGameStart()) {
      await fastSaveGame();
    }
  }, []);
  useMounted(() => {
    window.addEventListener("beforeunload", handleWindowUnload);
  });
  useUnMounted(() => {
    window.removeEventListener("beforeunload", handleWindowUnload);
  });
}
function useGameActive(GUIStore) {
  return reactExports.useCallback(() => {
    return !GUIStore.current.showTitle && !GUIStore.current.showMenuPanel && !GUIStore.current.showBacklog && !GUIStore.current.showPanicOverlay;
  }, [GUIStore]);
}
function useIsInBackLog(GUIStore) {
  return reactExports.useCallback(() => {
    return GUIStore.current.showBacklog;
  }, [GUIStore]);
}
function useIsOpenedDialog(GUIStore) {
  return reactExports.useCallback(() => {
    return GUIStore.current.showGlobalDialog;
  }, [GUIStore]);
}
function useIsOpenedExtra(GUIStore) {
  return reactExports.useCallback(() => {
    return GUIStore.current.showExtra;
  }, [GUIStore]);
}
function useIsPanicOverlayOpen(GUIStore) {
  return reactExports.useCallback(() => {
    return GUIStore.current.showPanicOverlay;
  }, [GUIStore]);
}
function useValidMenuPanelTag(GUIStore) {
  return reactExports.useCallback(() => {
    return [MenuPanelTag.Save, MenuPanelTag.Load, MenuPanelTag.Option].includes(GUIStore.current.currentMenuTag);
  }, [GUIStore]);
}
function useValidMenuGameStart() {
  return reactExports.useCallback(() => {
    return !(WebGAL.sceneManager.sceneData.currentSentenceId === 0);
  }, [WebGAL.sceneManager.sceneData]);
}
function useSetComponentVisibility() {
  const dispatch = useDispatch();
  return (component, visibility) => {
    dispatch(setVisibility({ component, visibility }));
  };
}
function useSpaceAndEnter() {
  const GUIStore = useGenSyncRef((state) => state.GUI);
  const isGameActive = useGameActive(GUIStore);
  const setComponentVisibility = useSetComponentVisibility();
  const lockRef = reactExports.useRef(false);
  const isSpaceOrEnter = reactExports.useCallback((e2) => {
    return e2.keyCode === 32 || e2.keyCode === 13;
  }, []);
  const handleKeydown = reactExports.useCallback((e2) => {
    if (isSpaceOrEnter(e2) && isGameActive() && !lockRef.current) {
      if (!GUIStore.current.showTextBox) {
        setComponentVisibility("showTextBox", true);
        return;
      }
      stopAll();
      nextSentence();
      lockRef.current = true;
    }
  }, []);
  const handleKeyup = reactExports.useCallback((e2) => {
    if (isSpaceOrEnter(e2) && isGameActive()) {
      lockRef.current = false;
    }
  }, []);
  const handleWindowBlur = reactExports.useCallback((e2) => {
    lockRef.current = false;
  }, []);
  useMounted(() => {
    document.addEventListener("keydown", handleKeydown);
    document.addEventListener("keyup", handleKeyup);
    document.addEventListener("blur", handleWindowBlur);
  });
  useUnMounted(() => {
    document.removeEventListener("keydown", handleKeydown);
    document.removeEventListener("keyup", handleKeyup);
    document.removeEventListener("blur", handleWindowBlur);
  });
}
function hasScrollToBottom(dom) {
  const { scrollTop, clientHeight, scrollHeight } = dom;
  return scrollTop === 0;
}
function useToggleFullScreen() {
  const userDataState = useSelector((state) => state.userData);
  const dispatch = useDispatch();
  const fullScreen = userDataState.optionData.fullScreen;
  reactExports.useEffect(() => {
    const handleKeyDown = (e2) => {
      if (e2.code === "F11") {
        e2.preventDefault();
        if (fullScreen !== fullScreenOption.on) {
          dispatch(setOptionData({ key: "fullScreen", value: fullScreenOption.on }));
          setStorage();
        } else {
          dispatch(setOptionData({ key: "fullScreen", value: fullScreenOption.off }));
          setStorage();
        }
      }
    };
    document.addEventListener("keydown", handleKeyDown);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [fullScreen]);
}
const Title = () => {
  const userDataState = useSelector((state) => state.userData);
  const GUIState = useSelector((state) => state.GUI);
  const dispatch = useDispatch();
  const fullScreen = userDataState.optionData.fullScreen;
  const background2 = GUIState.titleBg;
  const showBackground = background2 === "" ? "rgba(0,0,0,1)" : `url("${background2}")`;
  const t2 = useTrans("title.");
  const { playSeEnter, playSeClick } = useSoundEffect();
  const applyStyle2 = useApplyStyle("UI/Title/title.scss");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    GUIState.showTitle && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: applyStyle2("Title_backup_background", styles$m.Title_backup_background) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        id: "enter_game_target",
        onClick: () => {
          playBgm(GUIState.titleBgm);
          dispatch(setVisibility({ component: "isEnterGame", visibility: true }));
          if (fullScreen === fullScreenOption.on) {
            document.documentElement.requestFullscreen();
            if (keyboard)
              keyboard.lock(["Escape", "F11"]);
          }
        },
        onMouseEnter: playSeEnter
      }
    ),
    GUIState.showTitle && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: applyStyle2("Title_main", styles$m.Title_main),
        style: {
          backgroundImage: showBackground,
          backgroundSize: "cover"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: applyStyle2("Title_buttonList", styles$m.Title_buttonList), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: applyStyle2("Title_button", styles$m.Title_button),
              onClick: () => {
                startGame();
                playSeClick();
              },
              onMouseEnter: playSeEnter,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: applyStyle2("Title_button_text", styles$m.Title_button_text), children: t2("start.title") })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: applyStyle2("Title_button", styles$m.Title_button),
              onClick: () => {
                playSeClick();
                dispatch(setVisibility({ component: "showMenuPanel", visibility: true }));
                dispatch(setMenuPanelTag(MenuPanelTag.Load));
              },
              onMouseEnter: playSeEnter,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: applyStyle2("Title_button_text", styles$m.Title_button_text), children: t2("load.title") })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: applyStyle2("Title_button", styles$m.Title_button),
              onClick: () => {
                playSeClick();
                dispatch(setVisibility({ component: "showMenuPanel", visibility: true }));
                dispatch(setMenuPanelTag(MenuPanelTag.Option));
              },
              onMouseEnter: playSeEnter,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: applyStyle2("Title_button_text", styles$m.Title_button_text), children: t2("options.title") })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: applyStyle2("Title_button", styles$m.Title_button),
              onClick: () => {
                playSeClick();
                dispatch(setVisibility({ component: "showExtra", visibility: true }));
              },
              onMouseEnter: playSeEnter,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: applyStyle2("Title_button_text", styles$m.Title_button_text), children: t2("extra.title") })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: applyStyle2("Title_button", styles$m.Title_button),
              onClick: () => {
                playSeClick();
                window.history.back();
              },
              onMouseEnter: playSeEnter,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: applyStyle2("Title_button_text", styles$m.Title_button_text), children: t2("quit.title") })
            }
          )
        ] })
      }
    )
  ] });
};
const Logo_main = "_Logo_main_1bne2_1";
const Logo_Back = "_Logo_Back_1bne2_32";
const animationActive = "_animationActive_1bne2_46";
const fadeout = "_fadeout_1bne2_1";
const styles$g = {
  Logo_main,
  "change-img-anim": "_change-img-anim_1bne2_1",
  Logo_Back,
  animationActive,
  fadeout
};
const Logo = () => {
  const GUIState = useSelector((state) => state.GUI);
  const logoImage = GUIState.logoImage;
  const isEnterGame = GUIState.isEnterGame;
  const currentLogoIndex = useValue(-1);
  const currentTimeOutId = useValue(-1);
  const animationDuration = 5e3;
  const nextImg = () => {
    clearTimeout(currentTimeOutId.value);
    if (currentLogoIndex.value < logoImage.length - 1) {
      currentLogoIndex.set(currentLogoIndex.value + 1);
      currentTimeOutId.set(setTimeout(nextImg, animationDuration));
    } else {
      currentLogoIndex.set(-1);
    }
  };
  reactExports.useEffect(() => {
    if (isEnterGame && logoImage.length > 0) {
      currentLogoIndex.set(0);
      currentTimeOutId.set(setTimeout(nextImg, animationDuration));
    }
  }, [isEnterGame, logoImage]);
  const currentLogoUrl = currentLogoIndex.value === -1 ? "" : logoImage[currentLogoIndex.value];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    currentLogoIndex.value !== -1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: styles$g.Logo_Back + " " + (currentLogoIndex.value === logoImage.length - 1 ? styles$g.animationActive : ""),
        style: {
          animationDuration: `${animationDuration}ms`
        }
      },
      currentLogoIndex.value + "wh"
    ),
    currentLogoUrl !== "" && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: styles$g.Logo_main,
        onClick: nextImg,
        style: { backgroundImage: `url("${currentLogoUrl}")`, animationDuration: `${animationDuration}ms` }
      },
      currentLogoIndex.value + "bg"
    )
  ] });
};
const infoFetcher = (url2) => {
  const GUIState = webgalStore.getState().GUI;
  const dispatch = webgalStore.dispatch;
  axios$1.get(url2).then((r2) => {
    var _a2;
    let gameConfigRaw = r2.data;
    const gameConfig = WebgalParser.parseConfig(gameConfigRaw);
    logger.info("", gameConfig);
    if (GUIState) {
      gameConfig.forEach((e2) => {
        const { command, args } = e2;
        switch (command) {
          case "Title_img": {
            const titleUrl = assetSetter(args.join(""), fileType$1.background);
            dispatch(setGuiAsset({ asset: "titleBg", value: titleUrl }));
            setEbg(titleUrl);
            break;
          }
          case "Game_Logo": {
            const logoUrlList = args.map((url22) => assetSetter(url22, fileType$1.background));
            dispatch(setLogoImage(logoUrlList));
            break;
          }
          case "Title_bgm": {
            const bgmUrl = assetSetter(args[0], fileType$1.bgm);
            dispatch(setGuiAsset({ asset: "titleBgm", value: bgmUrl }));
            break;
          }
          case "Game_name": {
            WebGAL.gameName = args[0];
            document.title = args[0];
            break;
          }
          case "Game_key": {
            WebGAL.gameKey = args[0];
            getStorage();
            getFastSaveFromStorage();
            getSavesFromStorage(0, 0);
            break;
          }
        }
      });
    }
    (_a2 = window == null ? void 0 : window.renderPromise) == null ? void 0 : _a2.call(window);
    delete window.renderPromise;
    initKey();
  });
};
const syncWithOrigine = (sceneName, sentenceId) => {
  logger.warn("" + sceneName + ":" + sentenceId);
  const dispatch = webgalStore.dispatch;
  dispatch(setVisibility({ component: "showTitle", visibility: false }));
  dispatch(setVisibility({ component: "showMenuPanel", visibility: false }));
  dispatch(setVisibility({ component: "isShowLogo", visibility: false }));
  const title2 = document.getElementById("Title_enter_page");
  if (title2) {
    title2.style.display = "none";
  }
  resetStage(true);
  const sceneUrl = assetSetter(sceneName, fileType$1.scene);
  sceneFetcher(sceneUrl).then(async (rawScene) => {
    const scene = await WebGAL.sceneManager.setCurrentScene(rawScene, "start.txt", sceneUrl);
    if (!scene)
      return;
    const currentSceneName = WebGAL.sceneManager.sceneData.currentScene.sceneName;
    WebGAL.gameplay.isFast = true;
    syncFast(sentenceId, currentSceneName);
  });
};
function syncFast(sentenceId, currentSceneName) {
  if (WebGAL.sceneManager.sceneData.currentSentenceId < sentenceId && WebGAL.sceneManager.sceneData.currentScene.sceneName === currentSceneName) {
    nextSentence();
    setTimeout(() => syncFast(sentenceId, currentSceneName), 2);
  } else {
    WebGAL.gameplay.isFast = false;
  }
}
const bindExtraFunc = () => {
  window.JMP = syncFast;
};
var DebugCommand = /* @__PURE__ */ ((DebugCommand2) => {
  DebugCommand2[DebugCommand2["JUMP"] = 0] = "JUMP";
  DebugCommand2[DebugCommand2["SYNCFC"] = 1] = "SYNCFC";
  DebugCommand2[DebugCommand2["SYNCFE"] = 2] = "SYNCFE";
  DebugCommand2[DebugCommand2["EXE_COMMAND"] = 3] = "EXE_COMMAND";
  DebugCommand2[DebugCommand2["REFETCH_TEMPLATE_FILES"] = 4] = "REFETCH_TEMPLATE_FILES";
  return DebugCommand2;
})(DebugCommand || {});
const webSocketFunc = () => {
  const loc = window.location.hostname;
  const protocol = window.location.protocol;
  const port = window.location.port;
  let defaultPort = "";
  if (port && port !== "80" && port !== "443") {
    defaultPort = `:${port}`;
  }
  if (protocol !== "http:" && protocol !== "https:") {
    return;
  }
  let wsUrl = `ws://${loc}${defaultPort}/api/webgalsync`;
  if (protocol === "https:") {
    wsUrl = `wss://${loc}${defaultPort}/api/webgalsync`;
  }
  logger.info("socket" + wsUrl);
  const socket = new WebSocket(wsUrl);
  socket.onopen = () => {
    logger.info("socket");
    function sendStageSyncMessage() {
      const message = {
        event: "message",
        data: {
          command: DebugCommand.SYNCFC,
          sceneMsg: {
            scene: WebGAL.sceneManager.sceneData.currentScene.sceneName,
            sentence: WebGAL.sceneManager.sceneData.currentSentenceId
          },
          stageSyncMsg: webgalStore.getState().stage,
          message: "sync"
        }
      };
      socket.send(JSON.stringify(message));
      setTimeout(sendStageSyncMessage, 1e3);
    }
    sendStageSyncMessage();
  };
  socket.onmessage = (e2) => {
    const str = e2.data;
    const data2 = JSON.parse(str);
    const message = data2.data;
    if (message.command === DebugCommand.JUMP) {
      syncWithOrigine(message.sceneMsg.scene, message.sceneMsg.sentence);
    }
    if (message.command === DebugCommand.EXE_COMMAND) {
      const command = message.message;
      const scene = WebgalParser.parse(command, "temp.txt", "temp.txt");
      const sentence = scene.sentenceList[0];
      runScript(sentence);
    }
    if (message.command === DebugCommand.REFETCH_TEMPLATE_FILES) {
      const title2 = document.getElementById("Title_enter_page");
      if (title2) {
        title2.style.display = "none";
      }
      WebGAL.events.styleUpdate.emit();
    }
  };
  socket.onerror = (e2) => {
    logger.info(" Terre ");
  };
};
function finallyConstructor(callback) {
  var constructor = this.constructor;
  return this.then(
    function(value) {
      return constructor.resolve(callback()).then(function() {
        return value;
      });
    },
    function(reason) {
      return constructor.resolve(callback()).then(function() {
        return constructor.reject(reason);
      });
    }
  );
}
function allSettled(arr) {
  var P2 = this;
  return new P2(function(resolve2, reject2) {
    if (!(arr && typeof arr.length !== "undefined")) {
      return reject2(
        new TypeError(
          typeof arr + " " + arr + " is not iterable(cannot read property Symbol(Symbol.iterator))"
        )
      );
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0)
      return resolve2([]);
    var remaining = args.length;
    function res(i3, val) {
      if (val && (typeof val === "object" || typeof val === "function")) {
        var then = val.then;
        if (typeof then === "function") {
          then.call(
            val,
            function(val2) {
              res(i3, val2);
            },
            function(e2) {
              args[i3] = { status: "rejected", reason: e2 };
              if (--remaining === 0) {
                resolve2(args);
              }
            }
          );
          return;
        }
      }
      args[i3] = { status: "fulfilled", value: val };
      if (--remaining === 0) {
        resolve2(args);
      }
    }
    for (var i2 = 0; i2 < args.length; i2++) {
      res(i2, args[i2]);
    }
  });
}
function AggregateError$1(errors, message) {
  this.name = "AggregateError", this.errors = errors;
  this.message = message || "";
}
AggregateError$1.prototype = Error.prototype;
function any(arr) {
  var P2 = this;
  return new P2(function(resolve2, reject2) {
    if (!(arr && typeof arr.length !== "undefined")) {
      return reject2(new TypeError("Promise.any accepts an array"));
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0)
      return reject2();
    var rejectionReasons = [];
    for (var i2 = 0; i2 < args.length; i2++) {
      try {
        P2.resolve(args[i2]).then(resolve2).catch(function(error2) {
          rejectionReasons.push(error2);
          if (rejectionReasons.length === args.length) {
            reject2(
              new AggregateError$1(
                rejectionReasons,
                "All promises were rejected"
              )
            );
          }
        });
      } catch (ex) {
        reject2(ex);
      }
    }
  });
}
var setTimeoutFunc = setTimeout;
function isArray$4(x) {
  return Boolean(x && typeof x.length !== "undefined");
}
function noop$1() {
}
function bind$2(fn2, thisArg) {
  return function() {
    fn2.apply(thisArg, arguments);
  };
}
function Promise$1(fn2) {
  if (!(this instanceof Promise$1))
    throw new TypeError("Promises must be constructed via new");
  if (typeof fn2 !== "function")
    throw new TypeError("not a function");
  this._state = 0;
  this._handled = false;
  this._value = void 0;
  this._deferreds = [];
  doResolve(fn2, this);
}
function handle(self2, deferred) {
  while (self2._state === 3) {
    self2 = self2._value;
  }
  if (self2._state === 0) {
    self2._deferreds.push(deferred);
    return;
  }
  self2._handled = true;
  Promise$1._immediateFn(function() {
    var cb2 = self2._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb2 === null) {
      (self2._state === 1 ? resolve$1 : reject)(deferred.promise, self2._value);
      return;
    }
    var ret;
    try {
      ret = cb2(self2._value);
    } catch (e2) {
      reject(deferred.promise, e2);
      return;
    }
    resolve$1(deferred.promise, ret);
  });
}
function resolve$1(self2, newValue) {
  try {
    if (newValue === self2)
      throw new TypeError("A promise cannot be resolved with itself.");
    if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
      var then = newValue.then;
      if (newValue instanceof Promise$1) {
        self2._state = 3;
        self2._value = newValue;
        finale(self2);
        return;
      } else if (typeof then === "function") {
        doResolve(bind$2(then, newValue), self2);
        return;
      }
    }
    self2._state = 1;
    self2._value = newValue;
    finale(self2);
  } catch (e2) {
    reject(self2, e2);
  }
}
function reject(self2, newValue) {
  self2._state = 2;
  self2._value = newValue;
  finale(self2);
}
function finale(self2) {
  if (self2._state === 2 && self2._deferreds.length === 0) {
    Promise$1._immediateFn(function() {
      if (!self2._handled) {
        Promise$1._unhandledRejectionFn(self2._value);
      }
    });
  }
  for (var i2 = 0, len = self2._deferreds.length; i2 < len; i2++) {
    handle(self2, self2._deferreds[i2]);
  }
  self2._deferreds = null;
}
function Handler(onFulfilled, onRejected, promise2) {
  this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
  this.onRejected = typeof onRejected === "function" ? onRejected : null;
  this.promise = promise2;
}
function doResolve(fn2, self2) {
  var done = false;
  try {
    fn2(
      function(value) {
        if (done)
          return;
        done = true;
        resolve$1(self2, value);
      },
      function(reason) {
        if (done)
          return;
        done = true;
        reject(self2, reason);
      }
    );
  } catch (ex) {
    if (done)
      return;
    done = true;
    reject(self2, ex);
  }
}
Promise$1.prototype["catch"] = function(onRejected) {
  return this.then(null, onRejected);
};
Promise$1.prototype.then = function(onFulfilled, onRejected) {
  var prom = new this.constructor(noop$1);
  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};
Promise$1.prototype["finally"] = finallyConstructor;
Promise$1.all = function(arr) {
  return new Promise$1(function(resolve2, reject2) {
    if (!isArray$4(arr)) {
      return reject2(new TypeError("Promise.all accepts an array"));
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0)
      return resolve2([]);
    var remaining = args.length;
    function res(i3, val) {
      try {
        if (val && (typeof val === "object" || typeof val === "function")) {
          var then = val.then;
          if (typeof then === "function") {
            then.call(
              val,
              function(val2) {
                res(i3, val2);
              },
              reject2
            );
            return;
          }
        }
        args[i3] = val;
        if (--remaining === 0) {
          resolve2(args);
        }
      } catch (ex) {
        reject2(ex);
      }
    }
    for (var i2 = 0; i2 < args.length; i2++) {
      res(i2, args[i2]);
    }
  });
};
Promise$1.any = any;
Promise$1.allSettled = allSettled;
Promise$1.resolve = function(value) {
  if (value && typeof value === "object" && value.constructor === Promise$1) {
    return value;
  }
  return new Promise$1(function(resolve2) {
    resolve2(value);
  });
};
Promise$1.reject = function(value) {
  return new Promise$1(function(resolve2, reject2) {
    reject2(value);
  });
};
Promise$1.race = function(arr) {
  return new Promise$1(function(resolve2, reject2) {
    if (!isArray$4(arr)) {
      return reject2(new TypeError("Promise.race accepts an array"));
    }
    for (var i2 = 0, len = arr.length; i2 < len; i2++) {
      Promise$1.resolve(arr[i2]).then(resolve2, reject2);
    }
  });
};
Promise$1._immediateFn = // @ts-ignore
typeof setImmediate === "function" && function(fn2) {
  setImmediate(fn2);
} || function(fn2) {
  setTimeoutFunc(fn2, 0);
};
Promise$1._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== "undefined" && console) {
    console.warn("Possible Unhandled Promise Rejection:", err);
  }
};
/*!
 * @pixi/polyfill - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/polyfill is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
if (typeof globalThis === "undefined") {
  if (typeof self !== "undefined") {
    self.globalThis = self;
  } else if (typeof global !== "undefined") {
    global.globalThis = global;
  }
}
if (!globalThis.Promise) {
  globalThis.Promise = Promise$1;
}
if (!Object.assign) {
  Object.assign = objectAssign$1;
}
var ONE_FRAME_TIME = 16;
if (!(Date.now && Date.prototype.getTime)) {
  Date.now = function now2() {
    return (/* @__PURE__ */ new Date()).getTime();
  };
}
if (!(globalThis.performance && globalThis.performance.now)) {
  var startTime_1 = Date.now();
  if (!globalThis.performance) {
    globalThis.performance = {};
  }
  globalThis.performance.now = function() {
    return Date.now() - startTime_1;
  };
}
var lastTime = Date.now();
var vendors = ["ms", "moz", "webkit", "o"];
for (var x = 0; x < vendors.length && !globalThis.requestAnimationFrame; ++x) {
  var p = vendors[x];
  globalThis.requestAnimationFrame = globalThis[p + "RequestAnimationFrame"];
  globalThis.cancelAnimationFrame = globalThis[p + "CancelAnimationFrame"] || globalThis[p + "CancelRequestAnimationFrame"];
}
if (!globalThis.requestAnimationFrame) {
  globalThis.requestAnimationFrame = function(callback) {
    if (typeof callback !== "function") {
      throw new TypeError(callback + "is not a function");
    }
    var currentTime = Date.now();
    var delay = ONE_FRAME_TIME + lastTime - currentTime;
    if (delay < 0) {
      delay = 0;
    }
    lastTime = currentTime;
    return globalThis.self.setTimeout(function() {
      lastTime = Date.now();
      callback(performance.now());
    }, delay);
  };
}
if (!globalThis.cancelAnimationFrame) {
  globalThis.cancelAnimationFrame = function(id2) {
    return clearTimeout(id2);
  };
}
if (!Math.sign) {
  Math.sign = function mathSign(x) {
    x = Number(x);
    if (x === 0 || isNaN(x)) {
      return x;
    }
    return x > 0 ? 1 : -1;
  };
}
if (!Number.isInteger) {
  Number.isInteger = function numberIsInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  };
}
if (!globalThis.ArrayBuffer) {
  globalThis.ArrayBuffer = Array;
}
if (!globalThis.Float32Array) {
  globalThis.Float32Array = Array;
}
if (!globalThis.Uint32Array) {
  globalThis.Uint32Array = Array;
}
if (!globalThis.Uint16Array) {
  globalThis.Uint16Array = Array;
}
if (!globalThis.Uint8Array) {
  globalThis.Uint8Array = Array;
}
if (!globalThis.Int32Array) {
  globalThis.Int32Array = Array;
}
var appleIphone$1 = /iPhone/i;
var appleIpod$1 = /iPod/i;
var appleTablet$1 = /iPad/i;
var appleUniversal$1 = /\biOS-universal(?:.+)Mac\b/i;
var androidPhone$1 = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet$1 = /Android/i;
var amazonPhone$1 = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
var amazonTablet$1 = /Silk/i;
var windowsPhone$1 = /Windows Phone/i;
var windowsTablet$1 = /\bWindows(?:.+)ARM\b/i;
var otherBlackBerry$1 = /BlackBerry/i;
var otherBlackBerry10$1 = /BB10/i;
var otherOpera$1 = /Opera Mini/i;
var otherChrome$1 = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox$1 = /Mobile(?:.+)Firefox\b/i;
var isAppleTabletOnIos13$1 = function(navigator2) {
  return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
};
function createMatch$1(userAgent2) {
  return function(regex) {
    return regex.test(userAgent2);
  };
}
function isMobile$3(param) {
  var nav = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  if (!param && typeof navigator !== "undefined") {
    nav = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      maxTouchPoints: navigator.maxTouchPoints || 0
    };
  } else if (typeof param === "string") {
    nav.userAgent = param;
  } else if (param && param.userAgent) {
    nav = {
      userAgent: param.userAgent,
      platform: param.platform,
      maxTouchPoints: param.maxTouchPoints || 0
    };
  }
  var userAgent2 = nav.userAgent;
  var tmp = userAgent2.split("[FBAN");
  if (typeof tmp[1] !== "undefined") {
    userAgent2 = tmp[0];
  }
  tmp = userAgent2.split("Twitter");
  if (typeof tmp[1] !== "undefined") {
    userAgent2 = tmp[0];
  }
  var match2 = createMatch$1(userAgent2);
  var result = {
    apple: {
      phone: match2(appleIphone$1) && !match2(windowsPhone$1),
      ipod: match2(appleIpod$1),
      tablet: !match2(appleIphone$1) && (match2(appleTablet$1) || isAppleTabletOnIos13$1(nav)) && !match2(windowsPhone$1),
      universal: match2(appleUniversal$1),
      device: (match2(appleIphone$1) || match2(appleIpod$1) || match2(appleTablet$1) || match2(appleUniversal$1) || isAppleTabletOnIos13$1(nav)) && !match2(windowsPhone$1)
    },
    amazon: {
      phone: match2(amazonPhone$1),
      tablet: !match2(amazonPhone$1) && match2(amazonTablet$1),
      device: match2(amazonPhone$1) || match2(amazonTablet$1)
    },
    android: {
      phone: !match2(windowsPhone$1) && match2(amazonPhone$1) || !match2(windowsPhone$1) && match2(androidPhone$1),
      tablet: !match2(windowsPhone$1) && !match2(amazonPhone$1) && !match2(androidPhone$1) && (match2(amazonTablet$1) || match2(androidTablet$1)),
      device: !match2(windowsPhone$1) && (match2(amazonPhone$1) || match2(amazonTablet$1) || match2(androidPhone$1) || match2(androidTablet$1)) || match2(/\bokhttp\b/i)
    },
    windows: {
      phone: match2(windowsPhone$1),
      tablet: match2(windowsTablet$1),
      device: match2(windowsPhone$1) || match2(windowsTablet$1)
    },
    other: {
      blackberry: match2(otherBlackBerry$1),
      blackberry10: match2(otherBlackBerry10$1),
      opera: match2(otherOpera$1),
      firefox: match2(otherFirefox$1),
      chrome: match2(otherChrome$1),
      device: match2(otherBlackBerry$1) || match2(otherBlackBerry10$1) || match2(otherOpera$1) || match2(otherFirefox$1) || match2(otherChrome$1)
    },
    any: false,
    phone: false,
    tablet: false
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}
/*!
 * @pixi/settings - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/settings is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var isMobile$2 = isMobile$3(globalThis.navigator);
function maxRecommendedTextures$1(max2) {
  var allowMax = true;
  if (isMobile$2.tablet || isMobile$2.phone) {
    if (isMobile$2.apple.device) {
      var match2 = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (match2) {
        var majorVersion = parseInt(match2[1], 10);
        if (majorVersion < 11) {
          allowMax = false;
        }
      }
    }
    if (isMobile$2.android.device) {
      var match2 = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (match2) {
        var majorVersion = parseInt(match2[1], 10);
        if (majorVersion < 7) {
          allowMax = false;
        }
      }
    }
  }
  return allowMax ? max2 : 4;
}
function canUploadSameBuffer$1() {
  return !isMobile$2.apple.device;
}
/*!
 * @pixi/constants - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$5;
(function(ENV2) {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
})(ENV$5 || (ENV$5 = {}));
var RENDERER_TYPE$5;
(function(RENDERER_TYPE2) {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE$5 || (RENDERER_TYPE$5 = {}));
var BUFFER_BITS$5;
(function(BUFFER_BITS2) {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS$5 || (BUFFER_BITS$5 = {}));
var BLEND_MODES$5;
(function(BLEND_MODES2) {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
})(BLEND_MODES$5 || (BLEND_MODES$5 = {}));
var DRAW_MODES$5;
(function(DRAW_MODES2) {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$5 || (DRAW_MODES$5 = {}));
var FORMATS$5;
(function(FORMATS2) {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS$5 || (FORMATS$5 = {}));
var TARGETS$5;
(function(TARGETS2) {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$5 || (TARGETS$5 = {}));
var TYPES$5;
(function(TYPES2) {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES$5 || (TYPES$5 = {}));
var SAMPLER_TYPES$5;
(function(SAMPLER_TYPES2) {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
})(SAMPLER_TYPES$5 || (SAMPLER_TYPES$5 = {}));
var SCALE_MODES$5;
(function(SCALE_MODES2) {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES$5 || (SCALE_MODES$5 = {}));
var WRAP_MODES$5;
(function(WRAP_MODES2) {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$5 || (WRAP_MODES$5 = {}));
var MIPMAP_MODES$5;
(function(MIPMAP_MODES2) {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
})(MIPMAP_MODES$5 || (MIPMAP_MODES$5 = {}));
var ALPHA_MODES$5;
(function(ALPHA_MODES2) {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$5 || (ALPHA_MODES$5 = {}));
var CLEAR_MODES$5;
(function(CLEAR_MODES2) {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES$5 || (CLEAR_MODES$5 = {}));
var GC_MODES$5;
(function(GC_MODES2) {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
})(GC_MODES$5 || (GC_MODES$5 = {}));
var PRECISION$5;
(function(PRECISION2) {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
})(PRECISION$5 || (PRECISION$5 = {}));
var MASK_TYPES$5;
(function(MASK_TYPES2) {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
})(MASK_TYPES$5 || (MASK_TYPES$5 = {}));
var MSAA_QUALITY$5;
(function(MSAA_QUALITY2) {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY$5 || (MSAA_QUALITY$5 = {}));
var BUFFER_TYPE$5;
(function(BUFFER_TYPE2) {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$5 || (BUFFER_TYPE$5 = {}));
var settings$2 = {
  /**
   * If set to true WebGL will attempt make textures mimpaped by default.
   * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
   * @static
   * @name MIPMAP_TEXTURES
   * @memberof PIXI.settings
   * @type {PIXI.MIPMAP_MODES}
   * @default PIXI.MIPMAP_MODES.POW2
   */
  MIPMAP_TEXTURES: MIPMAP_MODES$5.POW2,
  /**
   * Default anisotropic filtering level of textures.
   * Usually from 0 to 16
   * @static
   * @name ANISOTROPIC_LEVEL
   * @memberof PIXI.settings
   * @type {number}
   * @default 0
   */
  ANISOTROPIC_LEVEL: 0,
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @static
   * @name RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  RESOLUTION: 1,
  /**
   * Default filter resolution.
   * @static
   * @name FILTER_RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  FILTER_RESOLUTION: 1,
  /**
   * Default filter samples.
   * @static
   * @name FILTER_MULTISAMPLE
   * @memberof PIXI.settings
   * @type {PIXI.MSAA_QUALITY}
   * @default PIXI.MSAA_QUALITY.NONE
   */
  FILTER_MULTISAMPLE: MSAA_QUALITY$5.NONE,
  /**
   * The maximum textures that this device supports.
   * @static
   * @name SPRITE_MAX_TEXTURES
   * @memberof PIXI.settings
   * @type {number}
   * @default 32
   */
  SPRITE_MAX_TEXTURES: maxRecommendedTextures$1(32),
  // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
  // TODO: maybe add PARTICLE.BATCH_SIZE: 15000
  /**
   * The default sprite batch size.
   *
   * The default aims to balance desktop and mobile devices.
   * @static
   * @name SPRITE_BATCH_SIZE
   * @memberof PIXI.settings
   * @type {number}
   * @default 4096
   */
  SPRITE_BATCH_SIZE: 4096,
  /**
   * The default render options if none are supplied to {@link PIXI.Renderer}
   * or {@link PIXI.CanvasRenderer}.
   * @static
   * @name RENDER_OPTIONS
   * @memberof PIXI.settings
   * @type {object}
   * @property {HTMLCanvasElement} [view=null] -
   * @property {boolean} [antialias=false] -
   * @property {boolean} [autoDensity=false] -
   * @property {boolean} [useContextAlpha=true]  -
   * @property {number} [backgroundColor=0x000000] -
   * @property {number} [backgroundAlpha=1] -
   * @property {boolean} [clearBeforeRender=true] -
   * @property {boolean} [preserveDrawingBuffer=false] -
   * @property {number} [width=800] -
   * @property {number} [height=600] -
   * @property {boolean} [legacy=false] -
   */
  RENDER_OPTIONS: {
    view: null,
    antialias: false,
    autoDensity: false,
    backgroundColor: 0,
    backgroundAlpha: 1,
    useContextAlpha: true,
    clearBeforeRender: true,
    preserveDrawingBuffer: false,
    width: 800,
    height: 600,
    legacy: false
  },
  /**
   * Default Garbage Collection mode.
   * @static
   * @name GC_MODE
   * @memberof PIXI.settings
   * @type {PIXI.GC_MODES}
   * @default PIXI.GC_MODES.AUTO
   */
  GC_MODE: GC_MODES$5.AUTO,
  /**
   * Default Garbage Collection max idle.
   * @static
   * @name GC_MAX_IDLE
   * @memberof PIXI.settings
   * @type {number}
   * @default 3600
   */
  GC_MAX_IDLE: 60 * 60,
  /**
   * Default Garbage Collection maximum check count.
   * @static
   * @name GC_MAX_CHECK_COUNT
   * @memberof PIXI.settings
   * @type {number}
   * @default 600
   */
  GC_MAX_CHECK_COUNT: 60 * 10,
  /**
   * Default wrap modes that are supported by pixi.
   * @static
   * @name WRAP_MODE
   * @memberof PIXI.settings
   * @type {PIXI.WRAP_MODES}
   * @default PIXI.WRAP_MODES.CLAMP
   */
  WRAP_MODE: WRAP_MODES$5.CLAMP,
  /**
   * Default scale mode for textures.
   * @static
   * @name SCALE_MODE
   * @memberof PIXI.settings
   * @type {PIXI.SCALE_MODES}
   * @default PIXI.SCALE_MODES.LINEAR
   */
  SCALE_MODE: SCALE_MODES$5.LINEAR,
  /**
   * Default specify float precision in vertex shader.
   * @static
   * @name PRECISION_VERTEX
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.HIGH
   */
  PRECISION_VERTEX: PRECISION$5.HIGH,
  /**
   * Default specify float precision in fragment shader.
   * iOS is best set at highp due to https://github.com/pixijs/pixi.js/issues/3742
   * @static
   * @name PRECISION_FRAGMENT
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.MEDIUM
   */
  PRECISION_FRAGMENT: isMobile$2.apple.device ? PRECISION$5.HIGH : PRECISION$5.MEDIUM,
  /**
   * Can we upload the same buffer in a single frame?
   * @static
   * @name CAN_UPLOAD_SAME_BUFFER
   * @memberof PIXI.settings
   * @type {boolean}
   */
  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer$1(),
  /**
   * Enables bitmap creation before image load. This feature is experimental.
   * @static
   * @name CREATE_IMAGE_BITMAP
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  CREATE_IMAGE_BITMAP: false,
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   * @static
   * @constant
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  ROUND_PIXELS: false
};
var eventemitter3 = { exports: {} };
(function(module) {
  var has2 = Object.prototype.hasOwnProperty, prefix2 = "~";
  function Events2() {
  }
  if (Object.create) {
    Events2.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events2().__proto__)
      prefix2 = false;
  }
  function EE(fn2, context2, once) {
    this.fn = fn2;
    this.context = context2;
    this.once = once || false;
  }
  function addListener(emitter, event, fn2, context2, once) {
    if (typeof fn2 !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn2, context2 || emitter, once), evt = prefix2 ? prefix2 + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events2();
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events2();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has2.call(events, name))
        names.push(prefix2 ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners(event) {
    var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i2 = 0, l2 = handlers.length, ee2 = new Array(l2); i2 < l2; i2++) {
      ee2[i2] = handlers[i2].fn;
    }
    return ee2;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i2;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
        args[i2 - 1] = arguments[i2];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length2 = listeners.length, j2;
      for (i2 = 0; i2 < length2; i2++) {
        if (listeners[i2].once)
          this.removeListener(event, listeners[i2].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i2].fn.call(listeners[i2].context);
            break;
          case 2:
            listeners[i2].fn.call(listeners[i2].context, a1);
            break;
          case 3:
            listeners[i2].fn.call(listeners[i2].context, a1, a2);
            break;
          case 4:
            listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
            listeners[i2].fn.apply(listeners[i2].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on2(event, fn2, context2) {
    return addListener(this, event, fn2, context2, false);
  };
  EventEmitter2.prototype.once = function once(event, fn2, context2) {
    return addListener(this, event, fn2, context2, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn2, context2, once) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt])
      return this;
    if (!fn2) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn2 && (!once || listeners.once) && (!context2 || listeners.context === context2)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i2 = 0, events = [], length2 = listeners.length; i2 < length2; i2++) {
        if (listeners[i2].fn !== fn2 || once && !listeners[i2].once || context2 && listeners[i2].context !== context2) {
          events.push(listeners[i2]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix2 ? prefix2 + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events2();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix2;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module.exports = EventEmitter2;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter$1 = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
var earcut$2 = { exports: {} };
earcut$2.exports = earcut;
earcut$2.exports.default = earcut;
function earcut(data2, holeIndices, dim) {
  dim = dim || 2;
  var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data2.length, outerNode = linkedList(data2, 0, outerLen, dim, true), triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev)
    return triangles;
  var minX, minY, maxX, maxY, x, y2, invSize;
  if (hasHoles)
    outerNode = eliminateHoles(data2, holeIndices, outerNode, dim);
  if (data2.length > 80 * dim) {
    minX = maxX = data2[0];
    minY = maxY = data2[1];
    for (var i2 = dim; i2 < outerLen; i2 += dim) {
      x = data2[i2];
      y2 = data2[i2 + 1];
      if (x < minX)
        minX = x;
      if (y2 < minY)
        minY = y2;
      if (x > maxX)
        maxX = x;
      if (y2 > maxY)
        maxY = y2;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 32767 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
  return triangles;
}
function linkedList(data2, start, end2, dim, clockwise) {
  var i2, last;
  if (clockwise === signedArea(data2, start, end2, dim) > 0) {
    for (i2 = start; i2 < end2; i2 += dim)
      last = insertNode(i2, data2[i2], data2[i2 + 1], last);
  } else {
    for (i2 = end2 - dim; i2 >= start; i2 -= dim)
      last = insertNode(i2, data2[i2], data2[i2 + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end2) {
  if (!start)
    return start;
  if (!end2)
    end2 = start;
  var p = start, again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end2 = p.prev;
      if (p === p.next)
        break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end2);
  return end2;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  var stop = ear, prev2, next2;
  while (ear.prev !== ear.next) {
    prev2 = ear.prev;
    next2 = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev2.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next2.i / dim | 0);
      removeNode(ear);
      ear = next2.next;
      stop = next2.next;
      continue;
    }
    ear = next2;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  var a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0)
    return false;
  var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
  var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var p = c2.next;
  while (p !== a2) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  var a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0)
    return false;
  var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
  var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
  var p = ear.prevZ, n2 = ear.nextZ;
  while (p && p.z >= minZ && n2 && n2.z <= maxZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a2 && p !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a2 && p !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
  }
  while (n2 && n2.z <= maxZ) {
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  var p = start;
  do {
    var a2 = p.prev, b2 = p.next.next;
    if (!equals(a2, b2) && intersects(a2, p, p.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
      triangles.push(a2.i / dim | 0);
      triangles.push(p.i / dim | 0);
      triangles.push(b2.i / dim | 0);
      removeNode(p);
      removeNode(p.next);
      p = start = b2;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  var a2 = start;
  do {
    var b2 = a2.next.next;
    while (b2 !== a2.prev) {
      if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
        var c2 = splitPolygon(a2, b2);
        a2 = filterPoints(a2, a2.next);
        c2 = filterPoints(c2, c2.next);
        earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b2 = b2.next;
    }
    a2 = a2.next;
  } while (a2 !== start);
}
function eliminateHoles(data2, holeIndices, outerNode, dim) {
  var queue = [], i2, len, start, end2, list;
  for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
    start = holeIndices[i2] * dim;
    end2 = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data2.length;
    list = linkedList(data2, start, end2, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i2 = 0; i2 < queue.length; i2++) {
    outerNode = eliminateHole(queue[i2], outerNode);
  }
  return outerNode;
}
function compareX(a2, b2) {
  return a2.x - b2.x;
}
function eliminateHole(hole, outerNode) {
  var bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  var bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        m2 = p.x < p.next.x ? p : p.next;
        if (x === hx)
          return m2;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m2)
    return null;
  var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan2;
  p = m2;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan2 = Math.abs(hy - p.y) / (hx - p.x);
      if (locallyInside(p, hole) && (tan2 < tanMin || tan2 === tanMin && (p.x > m2.x || p.x === m2.x && sectorContainsSector(m2, p)))) {
        m2 = p;
        tanMin = tan2;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m2;
}
function sectorContainsSector(m2, p) {
  return area(m2.prev, m2, p.prev) < 0 && area(p.next, m2, m2.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  var p = start;
  do {
    if (p.z === 0)
      p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  var i2, p, q2, e2, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q2 = p;
      pSize = 0;
      for (i2 = 0; i2 < inSize; i2++) {
        pSize++;
        q2 = q2.nextZ;
        if (!q2)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q2) {
        if (pSize !== 0 && (qSize === 0 || !q2 || p.z <= q2.z)) {
          e2 = p;
          p = p.nextZ;
          pSize--;
        } else {
          e2 = q2;
          q2 = q2.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e2;
        else
          list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p = q2;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y2, minX, minY, invSize) {
  x = (x - minX) * invSize | 0;
  y2 = (y2 - minY) * invSize | 0;
  x = (x | x << 8) & 16711935;
  x = (x | x << 4) & 252645135;
  x = (x | x << 2) & 858993459;
  x = (x | x << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x | y2 << 1;
}
function getLeftmost(start) {
  var p = start, leftmost = start;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
      leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
function isValidDiagonal(a2, b2) {
  return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && // dones't intersect other edges
  (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && // locally visible
  (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || // does not create opposite-facing sectors
  equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
}
function area(p, q2, r2) {
  return (q2.y - p.y) * (r2.x - q2.x) - (q2.x - p.x) * (r2.y - q2.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  var o1 = sign$1(area(p1, q1, p2));
  var o2 = sign$1(area(p1, q1, q2));
  var o3 = sign$1(area(p2, q2, p1));
  var o4 = sign$1(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p, q2, r2) {
  return q2.x <= Math.max(p.x, r2.x) && q2.x >= Math.min(p.x, r2.x) && q2.y <= Math.max(p.y, r2.y) && q2.y >= Math.min(p.y, r2.y);
}
function sign$1(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a2, b2) {
  var p = a2;
  do {
    if (p.i !== a2.i && p.next.i !== a2.i && p.i !== b2.i && p.next.i !== b2.i && intersects(p, p.next, a2, b2))
      return true;
    p = p.next;
  } while (p !== a2);
  return false;
}
function locallyInside(a2, b2) {
  return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
}
function middleInside(a2, b2) {
  var p = a2, inside = false, px = (a2.x + b2.x) / 2, py = (a2.y + b2.y) / 2;
  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
      inside = !inside;
    p = p.next;
  } while (p !== a2);
  return inside;
}
function splitPolygon(a2, b2) {
  var a22 = new Node(a2.i, a2.x, a2.y), b22 = new Node(b2.i, b2.x, b2.y), an2 = a2.next, bp = b2.prev;
  a2.next = b2;
  b2.prev = a2;
  a22.next = an2;
  an2.prev = a22;
  b22.next = a22;
  a22.prev = b22;
  bp.next = b22;
  b22.prev = bp;
  return b22;
}
function insertNode(i2, x, y2, last) {
  var p = new Node(i2, x, y2);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ)
    p.prevZ.nextZ = p.nextZ;
  if (p.nextZ)
    p.nextZ.prevZ = p.prevZ;
}
function Node(i2, x, y2) {
  this.i = i2;
  this.x = x;
  this.y = y2;
  this.prev = null;
  this.next = null;
  this.z = 0;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
earcut.deviation = function(data2, holeIndices, dim, triangles) {
  var hasHoles = holeIndices && holeIndices.length;
  var outerLen = hasHoles ? holeIndices[0] * dim : data2.length;
  var polygonArea = Math.abs(signedArea(data2, 0, outerLen, dim));
  if (hasHoles) {
    for (var i2 = 0, len = holeIndices.length; i2 < len; i2++) {
      var start = holeIndices[i2] * dim;
      var end2 = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data2.length;
      polygonArea -= Math.abs(signedArea(data2, start, end2, dim));
    }
  }
  var trianglesArea = 0;
  for (i2 = 0; i2 < triangles.length; i2 += 3) {
    var a2 = triangles[i2] * dim;
    var b2 = triangles[i2 + 1] * dim;
    var c2 = triangles[i2 + 2] * dim;
    trianglesArea += Math.abs(
      (data2[a2] - data2[c2]) * (data2[b2 + 1] - data2[a2 + 1]) - (data2[a2] - data2[b2]) * (data2[c2 + 1] - data2[a2 + 1])
    );
  }
  return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};
function signedArea(data2, start, end2, dim) {
  var sum = 0;
  for (var i2 = start, j2 = end2 - dim; i2 < end2; i2 += dim) {
    sum += (data2[j2] - data2[i2]) * (data2[i2 + 1] + data2[j2 + 1]);
    j2 = i2;
  }
  return sum;
}
earcut.flatten = function(data2) {
  var dim = data2[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
  for (var i2 = 0; i2 < data2.length; i2++) {
    for (var j2 = 0; j2 < data2[i2].length; j2++) {
      for (var d2 = 0; d2 < dim; d2++)
        result.vertices.push(data2[i2][j2][d2]);
    }
    if (i2 > 0) {
      holeIndex += data2[i2 - 1].length;
      result.holes.push(holeIndex);
    }
  }
  return result;
};
var earcutExports = earcut$2.exports;
const earcut$1 = /* @__PURE__ */ getDefaultExportFromCjs(earcutExports);
var punycode$1 = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
punycode$1.exports;
(function(module, exports) {
  (function(root2) {
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = module && !module.nodeType && module;
    var freeGlobal2 = typeof commonjsGlobal$1 == "object" && commonjsGlobal$1;
    if (freeGlobal2.global === freeGlobal2 || freeGlobal2.window === freeGlobal2 || freeGlobal2.self === freeGlobal2) {
      root2 = freeGlobal2;
    }
    var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter2 = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
    function error2(type2) {
      throw new RangeError(errors[type2]);
    }
    function map2(array, fn2) {
      var length2 = array.length;
      var result = [];
      while (length2--) {
        result[length2] = fn2(array[length2]);
      }
      return result;
    }
    function mapDomain(string, fn2) {
      var parts = string.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map2(labels, fn2).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output2 = [], counter = 0, length2 = string.length, value, extra2;
      while (counter < length2) {
        value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length2) {
          extra2 = string.charCodeAt(counter++);
          if ((extra2 & 64512) == 56320) {
            output2.push(((value & 1023) << 10) + (extra2 & 1023) + 65536);
          } else {
            output2.push(value);
            counter--;
          }
        } else {
          output2.push(value);
        }
      }
      return output2;
    }
    function ucs2encode(array) {
      return map2(array, function(value) {
        var output2 = "";
        if (value > 65535) {
          value -= 65536;
          output2 += stringFromCharCode(value >>> 10 & 1023 | 55296);
          value = 56320 | value & 1023;
        }
        output2 += stringFromCharCode(value);
        return output2;
      }).join("");
    }
    function basicToDigit(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    }
    function digitToBasic(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }
    function adapt(delta, numPoints, firstTime) {
      var k2 = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k2 += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
    }
    function decode2(input) {
      var output2 = [], inputLength = input.length, out, i2 = 0, n2 = initialN, bias = initialBias, basic, j2, index2, oldi, w2, k2, digit, t2, baseMinusT;
      basic = input.lastIndexOf(delimiter2);
      if (basic < 0) {
        basic = 0;
      }
      for (j2 = 0; j2 < basic; ++j2) {
        if (input.charCodeAt(j2) >= 128) {
          error2("not-basic");
        }
        output2.push(input.charCodeAt(j2));
      }
      for (index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
        for (oldi = i2, w2 = 1, k2 = base; ; k2 += base) {
          if (index2 >= inputLength) {
            error2("invalid-input");
          }
          digit = basicToDigit(input.charCodeAt(index2++));
          if (digit >= base || digit > floor((maxInt - i2) / w2)) {
            error2("overflow");
          }
          i2 += digit * w2;
          t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
          if (digit < t2) {
            break;
          }
          baseMinusT = base - t2;
          if (w2 > floor(maxInt / baseMinusT)) {
            error2("overflow");
          }
          w2 *= baseMinusT;
        }
        out = output2.length + 1;
        bias = adapt(i2 - oldi, out, oldi == 0);
        if (floor(i2 / out) > maxInt - n2) {
          error2("overflow");
        }
        n2 += floor(i2 / out);
        i2 %= out;
        output2.splice(i2++, 0, n2);
      }
      return ucs2encode(output2);
    }
    function encode3(input) {
      var n2, delta, handledCPCount, basicLength, bias, j2, m2, q2, k2, t2, currentValue, output2 = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
      input = ucs2decode(input);
      inputLength = input.length;
      n2 = initialN;
      delta = 0;
      bias = initialBias;
      for (j2 = 0; j2 < inputLength; ++j2) {
        currentValue = input[j2];
        if (currentValue < 128) {
          output2.push(stringFromCharCode(currentValue));
        }
      }
      handledCPCount = basicLength = output2.length;
      if (basicLength) {
        output2.push(delimiter2);
      }
      while (handledCPCount < inputLength) {
        for (m2 = maxInt, j2 = 0; j2 < inputLength; ++j2) {
          currentValue = input[j2];
          if (currentValue >= n2 && currentValue < m2) {
            m2 = currentValue;
          }
        }
        handledCPCountPlusOne = handledCPCount + 1;
        if (m2 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error2("overflow");
        }
        delta += (m2 - n2) * handledCPCountPlusOne;
        n2 = m2;
        for (j2 = 0; j2 < inputLength; ++j2) {
          currentValue = input[j2];
          if (currentValue < n2 && ++delta > maxInt) {
            error2("overflow");
          }
          if (currentValue == n2) {
            for (q2 = delta, k2 = base; ; k2 += base) {
              t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
              if (q2 < t2) {
                break;
              }
              qMinusT = q2 - t2;
              baseMinusT = base - t2;
              output2.push(
                stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
              );
              q2 = floor(qMinusT / baseMinusT);
            }
            output2.push(stringFromCharCode(digitToBasic(q2, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n2;
      }
      return output2.join("");
    }
    function toUnicode(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
      });
    }
    function toASCII(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode3(string) : string;
      });
    }
    punycode2 = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      "version": "1.4.1",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode2,
      "encode": encode3,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    if (freeExports && freeModule) {
      if (module.exports == freeExports) {
        freeModule.exports = punycode2;
      } else {
        for (key in punycode2) {
          punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
        }
      }
    } else {
      root2.punycode = punycode2;
    }
  })(commonjsGlobal$1);
})(punycode$1, punycode$1.exports);
var punycodeExports = punycode$1.exports;
var esErrors = Error;
var _eval = EvalError;
var range = RangeError;
var ref = ReferenceError;
var syntax = SyntaxError;
var type = TypeError;
var uri = URIError;
var shams = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams;
var hasSymbols$1 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var test = {
  __proto__: null,
  foo: {}
};
var $Object = Object;
var hasProto$1 = function hasProto() {
  return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var toStr$1 = Object.prototype.toString;
var max = Math.max;
var funcType = "[object Function]";
var concatty = function concatty2(a2, b2) {
  var arr = [];
  for (var i2 = 0; i2 < a2.length; i2 += 1) {
    arr[i2] = a2[i2];
  }
  for (var j2 = 0; j2 < b2.length; j2 += 1) {
    arr[j2 + a2.length] = b2[j2];
  }
  return arr;
};
var slicy = function slicy2(arrLike, offset) {
  var arr = [];
  for (var i2 = offset || 0, j2 = 0; i2 < arrLike.length; i2 += 1, j2 += 1) {
    arr[j2] = arrLike[i2];
  }
  return arr;
};
var joiny = function(arr, joiner) {
  var str = "";
  for (var i2 = 0; i2 < arr.length; i2 += 1) {
    str += arr[i2];
    if (i2 + 1 < arr.length) {
      str += joiner;
    }
  }
  return str;
};
var implementation$1 = function bind3(that) {
  var target = this;
  if (typeof target !== "function" || toStr$1.apply(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slicy(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target.apply(
        this,
        concatty(args, arguments)
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    }
    return target.apply(
      that,
      concatty(args, arguments)
    );
  };
  var boundLength = max(0, target.length - args.length);
  var boundArgs = [];
  for (var i2 = 0; i2 < boundLength; i2++) {
    boundArgs[i2] = "$" + i2;
  }
  bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};
var implementation = implementation$1;
var functionBind = Function.prototype.bind || implementation;
var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind$1 = functionBind;
var hasown = bind$1.call(call, $hasOwn);
var undefined$1;
var $Error = esErrors;
var $EvalError = _eval;
var $RangeError = range;
var $ReferenceError = ref;
var $SyntaxError$1 = syntax;
var $TypeError$3 = type;
var $URIError = uri;
var $Function = Function;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e2) {
  }
};
var $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1) {
  try {
    $gOPD$1({}, "");
  } catch (e2) {
    $gOPD$1 = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError$3();
};
var ThrowTypeError = $gOPD$1 ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols2 = hasSymbols$1();
var hasProto2 = hasProto$1();
var getProto = Object.getPrototypeOf || (hasProto2 ? function(x) {
  return x.__proto__;
} : null);
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols2 && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols2 && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols2 && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$3,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
if (getProto) {
  try {
    null.error;
  } catch (e2) {
    var errorProto = getProto(getProto(e2));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
}
var doEval = function doEval2(name) {
  var value;
  if (name === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name === "%AsyncGenerator%") {
    var fn2 = doEval2("%AsyncGeneratorFunction%");
    if (fn2) {
      value = fn2.prototype;
    }
  } else if (name === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen && getProto) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name] = value;
  return value;
};
var LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind4 = functionBind;
var hasOwn$1 = hasown;
var $concat$1 = bind4.call(Function.call, Array.prototype.concat);
var $spliceApply = bind4.call(Function.apply, Array.prototype.splice);
var $replace$1 = bind4.call(Function.call, String.prototype.replace);
var $strSlice = bind4.call(Function.call, String.prototype.slice);
var $exec = bind4.call(Function.call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);
  if (first === "%" && last !== "%") {
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  } else if (last === "%" && first !== "%") {
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace$1(string, rePropName, function(match2, number2, quote2, subString) {
    result[result.length] = quote2 ? $replace$1(subString, reEscapeChar, "$1") : number2 || match2;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$1(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$3("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError$1("intrinsic " + name + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== "string" || name.length === 0) {
    throw new $TypeError$3("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$3('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name) === null) {
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat$1([0, 1], alias));
  }
  for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
    var part = parts[i2];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$3("base intrinsic for " + name + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD$1 && i2 + 1 >= parts.length) {
        var desc = $gOPD$1(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$1(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var callBind$1 = { exports: {} };
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty)
    return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var GetIntrinsic3 = getIntrinsic;
  var $defineProperty2 = GetIntrinsic3("%Object.defineProperty%", true) || false;
  if ($defineProperty2) {
    try {
      $defineProperty2({}, "a", { value: 1 });
    } catch (e2) {
      $defineProperty2 = false;
    }
  }
  esDefineProperty = $defineProperty2;
  return esDefineProperty;
}
var GetIntrinsic$3 = getIntrinsic;
var $gOPD = GetIntrinsic$3("%Object.getOwnPropertyDescriptor%", true);
if ($gOPD) {
  try {
    $gOPD([], "length");
  } catch (e2) {
    $gOPD = null;
  }
}
var gopd$1 = $gOPD;
var $defineProperty$1 = requireEsDefineProperty();
var $SyntaxError = syntax;
var $TypeError$2 = type;
var gopd = gopd$1;
var defineDataProperty = function defineDataProperty2(obj, property2, value) {
  if (!obj || typeof obj !== "object" && typeof obj !== "function") {
    throw new $TypeError$2("`obj` must be an object or a function`");
  }
  if (typeof property2 !== "string" && typeof property2 !== "symbol") {
    throw new $TypeError$2("`property` must be a string or a symbol`");
  }
  if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
    throw new $TypeError$2("`nonEnumerable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
    throw new $TypeError$2("`nonWritable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
    throw new $TypeError$2("`nonConfigurable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
    throw new $TypeError$2("`loose`, if provided, must be a boolean");
  }
  var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
  var nonWritable = arguments.length > 4 ? arguments[4] : null;
  var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
  var loose = arguments.length > 6 ? arguments[6] : false;
  var desc = !!gopd && gopd(obj, property2);
  if ($defineProperty$1) {
    $defineProperty$1(obj, property2, {
      configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
      enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
      value,
      writable: nonWritable === null && desc ? desc.writable : !nonWritable
    });
  } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
    obj[property2] = value;
  } else {
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }
};
var $defineProperty = requireEsDefineProperty();
var hasPropertyDescriptors = function hasPropertyDescriptors2() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  if (!$defineProperty) {
    return null;
  }
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch (e2) {
    return true;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors;
var GetIntrinsic$2 = getIntrinsic;
var define = defineDataProperty;
var hasDescriptors = hasPropertyDescriptors_1();
var gOPD = gopd$1;
var $TypeError$1 = type;
var $floor$1 = GetIntrinsic$2("%Math.floor%");
var setFunctionLength = function setFunctionLength2(fn2, length2) {
  if (typeof fn2 !== "function") {
    throw new $TypeError$1("`fn` is not a function");
  }
  if (typeof length2 !== "number" || length2 < 0 || length2 > 4294967295 || $floor$1(length2) !== length2) {
    throw new $TypeError$1("`length` must be a positive 32-bit integer");
  }
  var loose = arguments.length > 2 && !!arguments[2];
  var functionLengthIsConfigurable = true;
  var functionLengthIsWritable = true;
  if ("length" in fn2 && gOPD) {
    var desc = gOPD(fn2, "length");
    if (desc && !desc.configurable) {
      functionLengthIsConfigurable = false;
    }
    if (desc && !desc.writable) {
      functionLengthIsWritable = false;
    }
  }
  if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
    if (hasDescriptors) {
      define(
        /** @type {Parameters<define>[0]} */
        fn2,
        "length",
        length2,
        true,
        true
      );
    } else {
      define(
        /** @type {Parameters<define>[0]} */
        fn2,
        "length",
        length2
      );
    }
  }
  return fn2;
};
(function(module) {
  var bind5 = functionBind;
  var GetIntrinsic3 = getIntrinsic;
  var setFunctionLength$1 = setFunctionLength;
  var $TypeError2 = type;
  var $apply = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind5.call($call, $apply);
  var $defineProperty2 = requireEsDefineProperty();
  var $max = GetIntrinsic3("%Math.max%");
  module.exports = function callBind2(originalFunction) {
    if (typeof originalFunction !== "function") {
      throw new $TypeError2("a function is required");
    }
    var func = $reflectApply(bind5, $call, arguments);
    return setFunctionLength$1(
      func,
      1 + $max(0, originalFunction.length - (arguments.length - 1)),
      true
    );
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind5, $apply, arguments);
  };
  if ($defineProperty2) {
    $defineProperty2(module.exports, "apply", { value: applyBind });
  } else {
    module.exports.apply = applyBind;
  }
})(callBind$1);
var callBindExports = callBind$1.exports;
var GetIntrinsic$1 = getIntrinsic;
var callBind = callBindExports;
var $indexOf = callBind(GetIntrinsic$1("String.prototype.indexOf"));
var callBound$1 = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic$1(name, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
    return callBind(intrinsic);
  }
  return intrinsic;
};
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasMap = typeof Map === "function" && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
var mapSize$1 = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === "function" && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
  return O2.__proto__;
} : null);
function addNumericSeparator(num, str) {
  if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
    return str;
  }
  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof num === "number") {
    var int = num < 0 ? -$floor(-num) : $floor(num);
    if (int !== num) {
      var intStr = String(int);
      var dec = $slice.call(str, intStr.length + 1);
      return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return $replace.call(str, sepRegex, "$&_");
}
var utilInspect = require$$0;
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
var objectInspect = function inspect_(obj, options, depth, seen2) {
  var opts = options || {};
  if (has$3(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has$3(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has$3(opts, "customInspect") ? opts.customInspect : true;
  if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  }
  if (has$3(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (has$3(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }
  var numericSeparator = opts.numericSeparator;
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  if (typeof obj === "boolean") {
    return obj ? "true" : "false";
  }
  if (typeof obj === "string") {
    return inspectString(obj, opts);
  }
  if (typeof obj === "number") {
    if (obj === 0) {
      return Infinity / obj > 0 ? "0" : "-0";
    }
    var str = String(obj);
    return numericSeparator ? addNumericSeparator(obj, str) : str;
  }
  if (typeof obj === "bigint") {
    var bigIntStr = String(obj) + "n";
    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
  }
  var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
  if (typeof depth === "undefined") {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
    return isArray$3(obj) ? "[Array]" : "[Object]";
  }
  var indent = getIndent(opts, depth);
  if (typeof seen2 === "undefined") {
    seen2 = [];
  } else if (indexOf(seen2, obj) >= 0) {
    return "[Circular]";
  }
  function inspect2(value, from2, noIndent) {
    if (from2) {
      seen2 = $arrSlice.call(seen2);
      seen2.push(from2);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };
      if (has$3(opts, "quoteStyle")) {
        newOpts.quoteStyle = opts.quoteStyle;
      }
      return inspect_(value, newOpts, depth + 1, seen2);
    }
    return inspect_(value, opts, depth + 1, seen2);
  }
  if (typeof obj === "function" && !isRegExp$1(obj)) {
    var name = nameOf(obj);
    var keys2 = arrObjKeys(obj, inspect2);
    return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
  }
  if (isSymbol(obj)) {
    var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
    return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
  }
  if (isElement(obj)) {
    var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
    var attrs = obj.attributes || [];
    for (var i2 = 0; i2 < attrs.length; i2++) {
      s2 += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
    }
    s2 += ">";
    if (obj.childNodes && obj.childNodes.length) {
      s2 += "...";
    }
    s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
    return s2;
  }
  if (isArray$3(obj)) {
    if (obj.length === 0) {
      return "[]";
    }
    var xs = arrObjKeys(obj, inspect2);
    if (indent && !singleLineValues(xs)) {
      return "[" + indentedJoin(xs, indent) + "]";
    }
    return "[ " + $join.call(xs, ", ") + " ]";
  }
  if (isError(obj)) {
    var parts = arrObjKeys(obj, inspect2);
    if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
      return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
    }
    if (parts.length === 0) {
      return "[" + String(obj) + "]";
    }
    return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
  }
  if (typeof obj === "object" && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
      return utilInspect(obj, { depth: maxDepth - depth });
    } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
      return obj.inspect();
    }
  }
  if (isMap(obj)) {
    var mapParts = [];
    if (mapForEach) {
      mapForEach.call(obj, function(value, key) {
        mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
      });
    }
    return collectionOf("Map", mapSize$1.call(obj), mapParts, indent);
  }
  if (isSet(obj)) {
    var setParts = [];
    if (setForEach) {
      setForEach.call(obj, function(value) {
        setParts.push(inspect2(value, obj));
      });
    }
    return collectionOf("Set", setSize.call(obj), setParts, indent);
  }
  if (isWeakMap(obj)) {
    return weakCollectionOf("WeakMap");
  }
  if (isWeakSet(obj)) {
    return weakCollectionOf("WeakSet");
  }
  if (isWeakRef(obj)) {
    return weakCollectionOf("WeakRef");
  }
  if (isNumber(obj)) {
    return markBoxed(inspect2(Number(obj)));
  }
  if (isBigInt(obj)) {
    return markBoxed(inspect2(bigIntValueOf.call(obj)));
  }
  if (isBoolean(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }
  if (isString(obj)) {
    return markBoxed(inspect2(String(obj)));
  }
  if (typeof window !== "undefined" && obj === window) {
    return "{ [object Window] }";
  }
  if (obj === commonjsGlobal$1) {
    return "{ [object globalThis] }";
  }
  if (!isDate(obj) && !isRegExp$1(obj)) {
    var ys = arrObjKeys(obj, inspect2);
    var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? "" : "null prototype";
    var stringTag2 = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
    var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
    var tag2 = constructorTag + (stringTag2 || protoTag ? "[" + $join.call($concat.call([], stringTag2 || [], protoTag || []), ": ") + "] " : "");
    if (ys.length === 0) {
      return tag2 + "{}";
    }
    if (indent) {
      return tag2 + "{" + indentedJoin(ys, indent) + "}";
    }
    return tag2 + "{ " + $join.call(ys, ", ") + " }";
  }
  return String(obj);
};
function wrapQuotes(s2, defaultStyle2, opts) {
  var quoteChar = (opts.quoteStyle || defaultStyle2) === "double" ? '"' : "'";
  return quoteChar + s2 + quoteChar;
}
function quote(s2) {
  return $replace.call(String(s2), /"/g, "&quot;");
}
function isArray$3(obj) {
  return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isDate(obj) {
  return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isRegExp$1(obj) {
  return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isError(obj) {
  return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isString(obj) {
  return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isNumber(obj) {
  return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isBoolean(obj) {
  return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isSymbol(obj) {
  if (hasShammedSymbols) {
    return obj && typeof obj === "object" && obj instanceof Symbol;
  }
  if (typeof obj === "symbol") {
    return true;
  }
  if (!obj || typeof obj !== "object" || !symToString) {
    return false;
  }
  try {
    symToString.call(obj);
    return true;
  } catch (e2) {
  }
  return false;
}
function isBigInt(obj) {
  if (!obj || typeof obj !== "object" || !bigIntValueOf) {
    return false;
  }
  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e2) {
  }
  return false;
}
var hasOwn = Object.prototype.hasOwnProperty || function(key) {
  return key in this;
};
function has$3(obj, key) {
  return hasOwn.call(obj, key);
}
function toStr(obj) {
  return objectToString.call(obj);
}
function nameOf(f2) {
  if (f2.name) {
    return f2.name;
  }
  var m2 = $match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
  if (m2) {
    return m2[1];
  }
  return null;
}
function indexOf(xs, x) {
  if (xs.indexOf) {
    return xs.indexOf(x);
  }
  for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
    if (xs[i2] === x) {
      return i2;
    }
  }
  return -1;
}
function isMap(x) {
  if (!mapSize$1 || !x || typeof x !== "object") {
    return false;
  }
  try {
    mapSize$1.call(x);
    try {
      setSize.call(x);
    } catch (s2) {
      return true;
    }
    return x instanceof Map;
  } catch (e2) {
  }
  return false;
}
function isWeakMap(x) {
  if (!weakMapHas || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakMapHas.call(x, weakMapHas);
    try {
      weakSetHas.call(x, weakSetHas);
    } catch (s2) {
      return true;
    }
    return x instanceof WeakMap;
  } catch (e2) {
  }
  return false;
}
function isWeakRef(x) {
  if (!weakRefDeref || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakRefDeref.call(x);
    return true;
  } catch (e2) {
  }
  return false;
}
function isSet(x) {
  if (!setSize || !x || typeof x !== "object") {
    return false;
  }
  try {
    setSize.call(x);
    try {
      mapSize$1.call(x);
    } catch (m2) {
      return true;
    }
    return x instanceof Set;
  } catch (e2) {
  }
  return false;
}
function isWeakSet(x) {
  if (!weakSetHas || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakSetHas.call(x, weakSetHas);
    try {
      weakMapHas.call(x, weakMapHas);
    } catch (s2) {
      return true;
    }
    return x instanceof WeakSet;
  } catch (e2) {
  }
  return false;
}
function isElement(x) {
  if (!x || typeof x !== "object") {
    return false;
  }
  if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
    return true;
  }
  return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
}
function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
    return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
  }
  var s2 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s2, "single", opts);
}
function lowbyte(c2) {
  var n2 = c2.charCodeAt(0);
  var x = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[n2];
  if (x) {
    return "\\" + x;
  }
  return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
}
function markBoxed(str) {
  return "Object(" + str + ")";
}
function weakCollectionOf(type2) {
  return type2 + " { ? }";
}
function collectionOf(type2, size, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
  return type2 + " (" + size + ") {" + joinedEntries + "}";
}
function singleLineValues(xs) {
  for (var i2 = 0; i2 < xs.length; i2++) {
    if (indexOf(xs[i2], "\n") >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts, depth) {
  var baseIndent;
  if (opts.indent === "	") {
    baseIndent = "	";
  } else if (typeof opts.indent === "number" && opts.indent > 0) {
    baseIndent = $join.call(Array(opts.indent + 1), " ");
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}
function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return "";
  }
  var lineJoiner = "\n" + indent.prev + indent.base;
  return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
}
function arrObjKeys(obj, inspect2) {
  var isArr = isArray$3(obj);
  var xs = [];
  if (isArr) {
    xs.length = obj.length;
    for (var i2 = 0; i2 < obj.length; i2++) {
      xs[i2] = has$3(obj, i2) ? inspect2(obj[i2], obj) : "";
    }
  }
  var syms = typeof gOPS === "function" ? gOPS(obj) : [];
  var symMap;
  if (hasShammedSymbols) {
    symMap = {};
    for (var k2 = 0; k2 < syms.length; k2++) {
      symMap["$" + syms[k2]] = syms[k2];
    }
  }
  for (var key in obj) {
    if (!has$3(obj, key)) {
      continue;
    }
    if (isArr && String(Number(key)) === key && key < obj.length) {
      continue;
    }
    if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
      continue;
    } else if ($test.call(/[^\w$]/, key)) {
      xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
    } else {
      xs.push(key + ": " + inspect2(obj[key], obj));
    }
  }
  if (typeof gOPS === "function") {
    for (var j2 = 0; j2 < syms.length; j2++) {
      if (isEnumerable.call(obj, syms[j2])) {
        xs.push("[" + inspect2(syms[j2]) + "]: " + inspect2(obj[syms[j2]], obj));
      }
    }
  }
  return xs;
}
var GetIntrinsic2 = getIntrinsic;
var callBound = callBound$1;
var inspect = objectInspect;
var $TypeError = type;
var $WeakMap = GetIntrinsic2("%WeakMap%", true);
var $Map = GetIntrinsic2("%Map%", true);
var $weakMapGet = callBound("WeakMap.prototype.get", true);
var $weakMapSet = callBound("WeakMap.prototype.set", true);
var $weakMapHas = callBound("WeakMap.prototype.has", true);
var $mapGet = callBound("Map.prototype.get", true);
var $mapSet = callBound("Map.prototype.set", true);
var $mapHas = callBound("Map.prototype.has", true);
var listGetNode = function(list, key) {
  var prev2 = list;
  var curr;
  for (; (curr = prev2.next) !== null; prev2 = curr) {
    if (curr.key === key) {
      prev2.next = curr.next;
      curr.next = /** @type {NonNullable<typeof list.next>} */
      list.next;
      list.next = curr;
      return curr;
    }
  }
};
var listGet = function(objects, key) {
  var node2 = listGetNode(objects, key);
  return node2 && node2.value;
};
var listSet = function(objects, key, value) {
  var node2 = listGetNode(objects, key);
  if (node2) {
    node2.value = value;
  } else {
    objects.next = /** @type {import('.').ListNode<typeof value>} */
    {
      // eslint-disable-line no-param-reassign, no-extra-parens
      key,
      next: objects.next,
      value
    };
  }
};
var listHas = function(objects, key) {
  return !!listGetNode(objects, key);
};
var sideChannel = function getSideChannel() {
  var $wm;
  var $m;
  var $o;
  var channel = {
    assert: function(key) {
      if (!channel.has(key)) {
        throw new $TypeError("Side channel does not contain " + inspect(key));
      }
    },
    get: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapGet($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapGet($m, key);
        }
      } else {
        if ($o) {
          return listGet($o, key);
        }
      }
    },
    has: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapHas($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapHas($m, key);
        }
      } else {
        if ($o) {
          return listHas($o, key);
        }
      }
      return false;
    },
    set: function(key, value) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if (!$wm) {
          $wm = new $WeakMap();
        }
        $weakMapSet($wm, key, value);
      } else if ($Map) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key, value);
      } else {
        if (!$o) {
          $o = { key: {}, next: null };
        }
        listSet($o, key, value);
      }
    }
  };
  return channel;
};
var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
};
var formats$4 = {
  "default": Format.RFC3986,
  formatters: {
    RFC1738: function(value) {
      return replace.call(value, percentTwenties, "+");
    },
    RFC3986: function(value) {
      return String(value);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
};
var formats$3 = formats$4;
var has$2 = Object.prototype.hasOwnProperty;
var isArray$2 = Array.isArray;
var hexTable = function() {
  var array = [];
  for (var i2 = 0; i2 < 256; ++i2) {
    array.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
  }
  return array;
}();
var compactQueue = function compactQueue2(queue) {
  while (queue.length > 1) {
    var item = queue.pop();
    var obj = item.obj[item.prop];
    if (isArray$2(obj)) {
      var compacted = [];
      for (var j2 = 0; j2 < obj.length; ++j2) {
        if (typeof obj[j2] !== "undefined") {
          compacted.push(obj[j2]);
        }
      }
      item.obj[item.prop] = compacted;
    }
  }
};
var arrayToObject = function arrayToObject2(source, options) {
  var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var i2 = 0; i2 < source.length; ++i2) {
    if (typeof source[i2] !== "undefined") {
      obj[i2] = source[i2];
    }
  }
  return obj;
};
var merge = function merge2(target, source, options) {
  if (!source) {
    return target;
  }
  if (typeof source !== "object") {
    if (isArray$2(target)) {
      target.push(source);
    } else if (target && typeof target === "object") {
      if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source)) {
        target[source] = true;
      }
    } else {
      return [target, source];
    }
    return target;
  }
  if (!target || typeof target !== "object") {
    return [target].concat(source);
  }
  var mergeTarget = target;
  if (isArray$2(target) && !isArray$2(source)) {
    mergeTarget = arrayToObject(target, options);
  }
  if (isArray$2(target) && isArray$2(source)) {
    source.forEach(function(item, i2) {
      if (has$2.call(target, i2)) {
        var targetItem = target[i2];
        if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
          target[i2] = merge2(targetItem, item, options);
        } else {
          target.push(item);
        }
      } else {
        target[i2] = item;
      }
    });
    return target;
  }
  return Object.keys(source).reduce(function(acc, key) {
    var value = source[key];
    if (has$2.call(acc, key)) {
      acc[key] = merge2(acc[key], value, options);
    } else {
      acc[key] = value;
    }
    return acc;
  }, mergeTarget);
};
var assign = function assignSingleSource(target, source) {
  return Object.keys(source).reduce(function(acc, key) {
    acc[key] = source[key];
    return acc;
  }, target);
};
var decode = function(str, decoder, charset) {
  var strWithoutPlus = str.replace(/\+/g, " ");
  if (charset === "iso-8859-1") {
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  }
  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e2) {
    return strWithoutPlus;
  }
};
var encode = function encode2(str, defaultEncoder, charset, kind, format2) {
  if (str.length === 0) {
    return str;
  }
  var string = str;
  if (typeof str === "symbol") {
    string = Symbol.prototype.toString.call(str);
  } else if (typeof str !== "string") {
    string = String(str);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  var out = "";
  for (var i2 = 0; i2 < string.length; ++i2) {
    var c2 = string.charCodeAt(i2);
    if (c2 === 45 || c2 === 46 || c2 === 95 || c2 === 126 || c2 >= 48 && c2 <= 57 || c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || format2 === formats$3.RFC1738 && (c2 === 40 || c2 === 41)) {
      out += string.charAt(i2);
      continue;
    }
    if (c2 < 128) {
      out = out + hexTable[c2];
      continue;
    }
    if (c2 < 2048) {
      out = out + (hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63]);
      continue;
    }
    if (c2 < 55296 || c2 >= 57344) {
      out = out + (hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63]);
      continue;
    }
    i2 += 1;
    c2 = 65536 + ((c2 & 1023) << 10 | string.charCodeAt(i2) & 1023);
    out += hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
  }
  return out;
};
var compact = function compact2(value) {
  var queue = [{ obj: { o: value }, prop: "o" }];
  var refs = [];
  for (var i2 = 0; i2 < queue.length; ++i2) {
    var item = queue[i2];
    var obj = item.obj[item.prop];
    var keys2 = Object.keys(obj);
    for (var j2 = 0; j2 < keys2.length; ++j2) {
      var key = keys2[j2];
      var val = obj[key];
      if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
        queue.push({ obj, prop: key });
        refs.push(val);
      }
    }
  }
  compactQueue(queue);
  return value;
};
var isRegExp = function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
};
var isBuffer$1 = function isBuffer(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine2(a2, b2) {
  return [].concat(a2, b2);
};
var maybeMap = function maybeMap2(val, fn2) {
  if (isArray$2(val)) {
    var mapped = [];
    for (var i2 = 0; i2 < val.length; i2 += 1) {
      mapped.push(fn2(val[i2]));
    }
    return mapped;
  }
  return fn2(val);
};
var utils$3 = {
  arrayToObject,
  assign,
  combine,
  compact,
  decode,
  encode,
  isBuffer: isBuffer$1,
  isRegExp,
  maybeMap,
  merge
};
var getSideChannel2 = sideChannel;
var utils$2 = utils$3;
var formats$2 = formats$4;
var has$1 = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix2) {
    return prefix2 + "[]";
  },
  comma: "comma",
  indices: function indices(prefix2, key) {
    return prefix2 + "[" + key + "]";
  },
  repeat: function repeat(prefix2) {
    return prefix2;
  }
};
var isArray$1 = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function(arr, valueOrArray) {
  push.apply(arr, isArray$1(valueOrArray) ? valueOrArray : [valueOrArray]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats$2["default"];
var defaults$1 = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encodeDotInKeys: false,
  encoder: utils$2.encode,
  encodeValuesOnly: false,
  format: defaultFormat,
  formatter: formats$2.formatters[defaultFormat],
  // deprecated
  indices: false,
  serializeDate: function serializeDate(date) {
    return toISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive2(v2) {
  return typeof v2 === "string" || typeof v2 === "number" || typeof v2 === "boolean" || typeof v2 === "symbol" || typeof v2 === "bigint";
};
var sentinel = {};
var stringify$1 = function stringify(object, prefix2, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter2, sort, allowDots, serializeDate2, format2, formatter, encodeValuesOnly, charset, sideChannel2) {
  var obj = object;
  var tmpSc = sideChannel2;
  var step = 0;
  var findFlag = false;
  while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
    var pos = tmpSc.get(object);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        findFlag = true;
      }
    }
    if (typeof tmpSc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter2 === "function") {
    obj = filter2(prefix2, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate2(obj);
  } else if (generateArrayPrefix === "comma" && isArray$1(obj)) {
    obj = utils$2.maybeMap(obj, function(value2) {
      if (value2 instanceof Date) {
        return serializeDate2(value2);
      }
      return value2;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix2, defaults$1.encoder, charset, "key", format2) : prefix2;
    }
    obj = "";
  }
  if (isNonNullishPrimitive(obj) || utils$2.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix2 : encoder(prefix2, defaults$1.encoder, charset, "key", format2);
      return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$1.encoder, charset, "value", format2))];
    }
    return [formatter(prefix2) + "=" + formatter(String(obj))];
  }
  var values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  var objKeys;
  if (generateArrayPrefix === "comma" && isArray$1(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = utils$2.maybeMap(obj, encoder);
    }
    objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray$1(filter2)) {
    objKeys = filter2;
  } else {
    var keys2 = Object.keys(obj);
    objKeys = sort ? keys2.sort(sort) : keys2;
  }
  var encodedPrefix = encodeDotInKeys ? prefix2.replace(/\./g, "%2E") : prefix2;
  var adjustedPrefix = commaRoundTrip && isArray$1(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
  if (allowEmptyArrays && isArray$1(obj) && obj.length === 0) {
    return adjustedPrefix + "[]";
  }
  for (var j2 = 0; j2 < objKeys.length; ++j2) {
    var key = objKeys[j2];
    var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
    if (skipNulls && value === null) {
      continue;
    }
    var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
    var keyPrefix = isArray$1(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
    sideChannel2.set(object, step);
    var valueSideChannel = getSideChannel2();
    valueSideChannel.set(sentinel, sideChannel2);
    pushToArray(values, stringify(
      value,
      keyPrefix,
      generateArrayPrefix,
      commaRoundTrip,
      allowEmptyArrays,
      strictNullHandling,
      skipNulls,
      encodeDotInKeys,
      generateArrayPrefix === "comma" && encodeValuesOnly && isArray$1(obj) ? null : encoder,
      filter2,
      sort,
      allowDots,
      serializeDate2,
      format2,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
  if (!opts) {
    return defaults$1;
  }
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  var charset = opts.charset || defaults$1.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var format2 = formats$2["default"];
  if (typeof opts.format !== "undefined") {
    if (!has$1.call(formats$2.formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format2 = opts.format;
  }
  var formatter = formats$2.formatters[format2];
  var filter2 = defaults$1.filter;
  if (typeof opts.filter === "function" || isArray$1(opts.filter)) {
    filter2 = opts.filter;
  }
  var arrayFormat;
  if (opts.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts.arrayFormat;
  } else if ("indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = defaults$1.arrayFormat;
  }
  if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults$1.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults$1.allowEmptyArrays,
    arrayFormat,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
    commaRoundTrip: opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === "undefined" ? defaults$1.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults$1.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults$1.encodeDotInKeys,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$1.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
    filter: filter2,
    format: format2,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$1.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$1.skipNulls,
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
  };
};
var stringify_1 = function(object, opts) {
  var obj = object;
  var options = normalizeStringifyOptions(opts);
  var objKeys;
  var filter2;
  if (typeof options.filter === "function") {
    filter2 = options.filter;
    obj = filter2("", obj);
  } else if (isArray$1(options.filter)) {
    filter2 = options.filter;
    objKeys = filter2;
  }
  var keys2 = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
  var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
  if (!objKeys) {
    objKeys = Object.keys(obj);
  }
  if (options.sort) {
    objKeys.sort(options.sort);
  }
  var sideChannel2 = getSideChannel2();
  for (var i2 = 0; i2 < objKeys.length; ++i2) {
    var key = objKeys[i2];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    pushToArray(keys2, stringify$1(
      obj[key],
      key,
      generateArrayPrefix,
      commaRoundTrip,
      options.allowEmptyArrays,
      options.strictNullHandling,
      options.skipNulls,
      options.encodeDotInKeys,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel2
    ));
  }
  var joined = keys2.join(options.delimiter);
  var prefix2 = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix2 += "utf8=%26%2310003%3B&";
    } else {
      prefix2 += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix2 + joined : "";
};
var utils$1 = utils$3;
var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;
var defaults = {
  allowDots: false,
  allowEmptyArrays: false,
  allowPrototypes: false,
  allowSparse: false,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: false,
  comma: false,
  decodeDotInKeys: true,
  decoder: utils$1.decode,
  delimiter: "&",
  depth: 5,
  duplicates: "combine",
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1e3,
  parseArrays: true,
  plainObjects: false,
  strictNullHandling: false
};
var interpretNumericEntities = function(str) {
  return str.replace(/&#(\d+);/g, function($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};
var parseArrayValue = function(val, options) {
  if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
    return val.split(",");
  }
  return val;
};
var isoSentinel = "utf8=%26%2310003%3B";
var charsetSentinel = "utf8=%E2%9C%93";
var parseValues = function parseQueryStringValues(str, options) {
  var obj = { __proto__: null };
  var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
  var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
  var parts = cleanStr.split(options.delimiter, limit);
  var skipIndex = -1;
  var i2;
  var charset = options.charset;
  if (options.charsetSentinel) {
    for (i2 = 0; i2 < parts.length; ++i2) {
      if (parts[i2].indexOf("utf8=") === 0) {
        if (parts[i2] === charsetSentinel) {
          charset = "utf-8";
        } else if (parts[i2] === isoSentinel) {
          charset = "iso-8859-1";
        }
        skipIndex = i2;
        i2 = parts.length;
      }
    }
  }
  for (i2 = 0; i2 < parts.length; ++i2) {
    if (i2 === skipIndex) {
      continue;
    }
    var part = parts[i2];
    var bracketEqualsPos = part.indexOf("]=");
    var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
    var key, val;
    if (pos === -1) {
      key = options.decoder(part, defaults.decoder, charset, "key");
      val = options.strictNullHandling ? null : "";
    } else {
      key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
      val = utils$1.maybeMap(
        parseArrayValue(part.slice(pos + 1), options),
        function(encodedVal) {
          return options.decoder(encodedVal, defaults.decoder, charset, "value");
        }
      );
    }
    if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
      val = interpretNumericEntities(val);
    }
    if (part.indexOf("[]=") > -1) {
      val = isArray(val) ? [val] : val;
    }
    var existing = has.call(obj, key);
    if (existing && options.duplicates === "combine") {
      obj[key] = utils$1.combine(obj[key], val);
    } else if (!existing || options.duplicates === "last") {
      obj[key] = val;
    }
  }
  return obj;
};
var parseObject = function(chain, val, options, valuesParsed) {
  var leaf = valuesParsed ? val : parseArrayValue(val, options);
  for (var i2 = chain.length - 1; i2 >= 0; --i2) {
    var obj;
    var root2 = chain[i2];
    if (root2 === "[]" && options.parseArrays) {
      obj = options.allowEmptyArrays && leaf === "" ? [] : [].concat(leaf);
    } else {
      obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
      var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
      var index2 = parseInt(decodedRoot, 10);
      if (!options.parseArrays && decodedRoot === "") {
        obj = { 0: leaf };
      } else if (!isNaN(index2) && root2 !== decodedRoot && String(index2) === decodedRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
        obj = [];
        obj[index2] = leaf;
      } else if (decodedRoot !== "__proto__") {
        obj[decodedRoot] = leaf;
      }
    }
    leaf = obj;
  }
  return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
  if (!givenKey) {
    return;
  }
  var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
  var brackets2 = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g;
  var segment = options.depth > 0 && brackets2.exec(key);
  var parent = segment ? key.slice(0, segment.index) : key;
  var keys2 = [];
  if (parent) {
    if (!options.plainObjects && has.call(Object.prototype, parent)) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys2.push(parent);
  }
  var i2 = 0;
  while (options.depth > 0 && (segment = child.exec(key)) !== null && i2 < options.depth) {
    i2 += 1;
    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys2.push(segment[1]);
  }
  if (segment) {
    keys2.push("[" + key.slice(segment.index) + "]");
  }
  return parseObject(keys2, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions2(opts) {
  if (!opts) {
    return defaults;
  }
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
    throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
    throw new TypeError("Decoder has to be a function.");
  }
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
  var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
  if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
    throw new TypeError("The duplicates option must be either combine, first, or last");
  }
  var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
    allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
    arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
    decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
    decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
    delimiter: typeof opts.delimiter === "string" || utils$1.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
    duplicates,
    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
    parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
    parseArrays: opts.parseArrays !== false,
    plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
};
var parse$2 = function(str, opts) {
  var options = normalizeParseOptions(opts);
  if (str === "" || str === null || typeof str === "undefined") {
    return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  }
  var tempObj = typeof str === "string" ? parseValues(str, options) : str;
  var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  var keys2 = Object.keys(tempObj);
  for (var i2 = 0; i2 < keys2.length; ++i2) {
    var key = keys2[i2];
    var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
    obj = utils$1.merge(obj, newObj, options);
  }
  if (options.allowSparse === true) {
    return obj;
  }
  return utils$1.compact(obj);
};
var stringify2 = stringify_1;
var parse$1 = parse$2;
var formats$1 = formats$4;
var lib = {
  formats: formats$1,
  parse: parse$1,
  stringify: stringify2
};
var punycode = punycodeExports;
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, delims = [
  "<",
  ">",
  '"',
  "`",
  " ",
  "\r",
  "\n",
  "	"
], unwise = [
  "{",
  "}",
  "|",
  "\\",
  "^",
  "`"
].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = [
  "%",
  "/",
  "?",
  ";",
  "#"
].concat(autoEscape), hostEndingChars = [
  "/",
  "?",
  "#"
], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
  javascript: true,
  "javascript:": true
}, hostlessProtocol = {
  javascript: true,
  "javascript:": true
}, slashedProtocol = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
}, querystring = lib;
function urlParse(url2, parseQueryString, slashesDenoteHost) {
  if (url2 && typeof url2 === "object" && url2 instanceof Url) {
    return url2;
  }
  var u2 = new Url();
  u2.parse(url2, parseQueryString, slashesDenoteHost);
  return u2;
}
Url.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
  if (typeof url2 !== "string") {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
  }
  var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, "/");
  url2 = uSplit.join(splitter);
  var rest = url2;
  rest = rest.trim();
  if (!slashesDenoteHost && url2.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      return this;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
    var slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1;
    for (var i2 = 0; i2 < hostEndingChars.length; i2++) {
      var hec = rest.indexOf(hostEndingChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }
    hostEnd = -1;
    for (var i2 = 0; i2 < nonHostChars.length; i2++) {
      var hec = rest.indexOf(nonHostChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost();
    this.hostname = this.hostname || "";
    var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i2 = 0, l2 = hostparts.length; i2 < l2; i2++) {
        var part = hostparts[i2];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j2 = 0, k2 = part.length; j2 < k2; j2++) {
            if (part.charCodeAt(j2) > 127) {
              newpart += "x";
            } else {
              newpart += part[j2];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i2);
            var notHost = hostparts.slice(i2 + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = "/" + notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    } else {
      this.hostname = this.hostname.toLowerCase();
    }
    if (!ipv6Hostname) {
      this.hostname = punycode.toASCII(this.hostname);
    }
    var p = this.port ? ":" + this.port : "";
    var h2 = this.hostname || "";
    this.host = h2 + p;
    this.href += this.host;
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== "/") {
        rest = "/" + rest;
      }
    }
  }
  if (!unsafeProtocol[lowerProto]) {
    for (var i2 = 0, l2 = autoEscape.length; i2 < l2; i2++) {
      var ae2 = autoEscape[i2];
      if (rest.indexOf(ae2) === -1) {
        continue;
      }
      var esc = encodeURIComponent(ae2);
      if (esc === ae2) {
        esc = escape(ae2);
      }
      rest = rest.split(ae2).join(esc);
    }
  }
  var hash2 = rest.indexOf("#");
  if (hash2 !== -1) {
    this.hash = rest.substr(hash2);
    rest = rest.slice(0, hash2);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    this.search = "";
    this.query = {};
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "/";
  }
  if (this.pathname || this.search) {
    var p = this.pathname || "";
    var s2 = this.search || "";
    this.path = p + s2;
  }
  this.href = this.format();
  return this;
};
function urlFormat(obj) {
  if (typeof obj === "string") {
    obj = urlParse(obj);
  }
  if (!(obj instanceof Url)) {
    return Url.prototype.format.call(obj);
  }
  return obj.format();
}
Url.prototype.format = function() {
  var auth = this.auth || "";
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ":");
    auth += "@";
  }
  var protocol = this.protocol || "", pathname = this.pathname || "", hash2 = this.hash || "", host = false, query = "";
  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
    if (this.port) {
      host += ":" + this.port;
    }
  }
  if (this.query && typeof this.query === "object" && Object.keys(this.query).length) {
    query = querystring.stringify(this.query, {
      arrayFormat: "repeat",
      addQueryPrefix: false
    });
  }
  var search = this.search || query && "?" + query || "";
  if (protocol && protocol.substr(-1) !== ":") {
    protocol += ":";
  }
  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = "//" + (host || "");
    if (pathname && pathname.charAt(0) !== "/") {
      pathname = "/" + pathname;
    }
  } else if (!host) {
    host = "";
  }
  if (hash2 && hash2.charAt(0) !== "#") {
    hash2 = "#" + hash2;
  }
  if (search && search.charAt(0) !== "?") {
    search = "?" + search;
  }
  pathname = pathname.replace(/[?#]/g, function(match2) {
    return encodeURIComponent(match2);
  });
  search = search.replace("#", "%23");
  return protocol + host + pathname + search + hash2;
};
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};
Url.prototype.resolveObject = function(relative) {
  if (typeof relative === "string") {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }
  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk2 = 0; tk2 < tkeys.length; tk2++) {
    var tkey = tkeys[tk2];
    result[tkey] = this[tkey];
  }
  result.hash = relative.hash;
  if (relative.href === "") {
    result.href = result.format();
    return result;
  }
  if (relative.slashes && !relative.protocol) {
    var rkeys = Object.keys(relative);
    for (var rk2 = 0; rk2 < rkeys.length; rk2++) {
      var rkey = rkeys[rk2];
      if (rkey !== "protocol") {
        result[rkey] = relative[rkey];
      }
    }
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.pathname = "/";
      result.path = result.pathname;
    }
    result.href = result.format();
    return result;
  }
  if (relative.protocol && relative.protocol !== result.protocol) {
    if (!slashedProtocol[relative.protocol]) {
      var keys2 = Object.keys(relative);
      for (var v2 = 0; v2 < keys2.length; v2++) {
        var k2 = keys2[v2];
        result[k2] = relative[k2];
      }
      result.href = result.format();
      return result;
    }
    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || "").split("/");
      while (relPath.length && !(relative.host = relPath.shift())) {
      }
      if (!relative.host) {
        relative.host = "";
      }
      if (!relative.hostname) {
        relative.hostname = "";
      }
      if (relPath[0] !== "") {
        relPath.unshift("");
      }
      if (relPath.length < 2) {
        relPath.unshift("");
      }
      result.pathname = relPath.join("/");
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || "";
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    if (result.pathname || result.search) {
      var p = result.pathname || "";
      var s2 = result.search || "";
      result.path = p + s2;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }
  var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
  if (psychotic) {
    result.hostname = "";
    result.port = null;
    if (result.host) {
      if (srcPath[0] === "") {
        srcPath[0] = result.host;
      } else {
        srcPath.unshift(result.host);
      }
    }
    result.host = "";
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === "") {
          relPath[0] = relative.host;
        } else {
          relPath.unshift(relative.host);
        }
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
  }
  if (isRelAbs) {
    result.host = relative.host || relative.host === "" ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
  } else if (relPath.length) {
    if (!srcPath) {
      srcPath = [];
    }
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (relative.search != null) {
    if (psychotic) {
      result.host = srcPath.shift();
      result.hostname = result.host;
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.hostname = authInHost.shift();
        result.host = result.hostname;
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    }
    result.href = result.format();
    return result;
  }
  if (!srcPath.length) {
    result.pathname = null;
    if (result.search) {
      result.path = "/" + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
  var up = 0;
  for (var i2 = srcPath.length; i2 >= 0; i2--) {
    last = srcPath[i2];
    if (last === ".") {
      srcPath.splice(i2, 1);
    } else if (last === "..") {
      srcPath.splice(i2, 1);
      up++;
    } else if (up) {
      srcPath.splice(i2, 1);
      up--;
    }
  }
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift("..");
    }
  }
  if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
    srcPath.unshift("");
  }
  if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
    srcPath.push("");
  }
  var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
  if (psychotic) {
    result.hostname = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
    result.host = result.hostname;
    var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.hostname = authInHost.shift();
      result.host = result.hostname;
    }
  }
  mustEndAbs = mustEndAbs || result.host && srcPath.length;
  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift("");
  }
  if (srcPath.length > 0) {
    result.pathname = srcPath.join("/");
  } else {
    result.pathname = null;
    result.path = null;
  }
  if (result.pathname !== null || result.search !== null) {
    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};
Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};
var parse = urlParse;
var resolve = urlResolve;
var format = urlFormat;
/*!
 * @pixi/constants - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$4;
(function(ENV2) {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
})(ENV$4 || (ENV$4 = {}));
var RENDERER_TYPE$4;
(function(RENDERER_TYPE2) {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE$4 || (RENDERER_TYPE$4 = {}));
var BUFFER_BITS$4;
(function(BUFFER_BITS2) {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS$4 || (BUFFER_BITS$4 = {}));
var BLEND_MODES$4;
(function(BLEND_MODES2) {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
})(BLEND_MODES$4 || (BLEND_MODES$4 = {}));
var DRAW_MODES$4;
(function(DRAW_MODES2) {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$4 || (DRAW_MODES$4 = {}));
var FORMATS$4;
(function(FORMATS2) {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS$4 || (FORMATS$4 = {}));
var TARGETS$4;
(function(TARGETS2) {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$4 || (TARGETS$4 = {}));
var TYPES$4;
(function(TYPES2) {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES$4 || (TYPES$4 = {}));
var SAMPLER_TYPES$4;
(function(SAMPLER_TYPES2) {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
})(SAMPLER_TYPES$4 || (SAMPLER_TYPES$4 = {}));
var SCALE_MODES$4;
(function(SCALE_MODES2) {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES$4 || (SCALE_MODES$4 = {}));
var WRAP_MODES$4;
(function(WRAP_MODES2) {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$4 || (WRAP_MODES$4 = {}));
var MIPMAP_MODES$4;
(function(MIPMAP_MODES2) {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
})(MIPMAP_MODES$4 || (MIPMAP_MODES$4 = {}));
var ALPHA_MODES$4;
(function(ALPHA_MODES2) {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$4 || (ALPHA_MODES$4 = {}));
var CLEAR_MODES$4;
(function(CLEAR_MODES2) {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES$4 || (CLEAR_MODES$4 = {}));
var GC_MODES$4;
(function(GC_MODES2) {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
})(GC_MODES$4 || (GC_MODES$4 = {}));
var PRECISION$4;
(function(PRECISION2) {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
})(PRECISION$4 || (PRECISION$4 = {}));
var MASK_TYPES$4;
(function(MASK_TYPES2) {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
})(MASK_TYPES$4 || (MASK_TYPES$4 = {}));
var MSAA_QUALITY$4;
(function(MSAA_QUALITY2) {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY$4 || (MSAA_QUALITY$4 = {}));
var BUFFER_TYPE$4;
(function(BUFFER_TYPE2) {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$4 || (BUFFER_TYPE$4 = {}));
/*!
 * @pixi/utils - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/utils is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var url = {
  parse,
  format,
  resolve
};
settings$2.RETINA_PREFIX = /@([0-9\.]+)x/;
settings$2.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
var saidHello = false;
var VERSION$1 = "6.4.2";
function skipHello() {
  saidHello = true;
}
function sayHello(type2) {
  var _a2;
  if (saidHello) {
    return;
  }
  if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
    var args = [
      "\n %c %c %c PixiJS " + VERSION$1 + " -  " + type2 + "   %c  %c  http://www.pixijs.com/  %c %c %c%c \n\n",
      "background: #ff66a5; padding:5px 0;",
      "background: #ff66a5; padding:5px 0;",
      "color: #ff66a5; background: #030307; padding:5px 0;",
      "background: #ff66a5; padding:5px 0;",
      "background: #ffc3dc; padding:5px 0;",
      "background: #ff66a5; padding:5px 0;",
      "color: #ff2424; background: #fff; padding:5px 0;",
      "color: #ff2424; background: #fff; padding:5px 0;",
      "color: #ff2424; background: #fff; padding:5px 0;"
    ];
    (_a2 = globalThis.console).log.apply(_a2, args);
  } else if (globalThis.console) {
    globalThis.console.log("PixiJS " + VERSION$1 + " - " + type2 + " - http://www.pixijs.com/");
  }
  saidHello = true;
}
var supported;
function isWebGLSupported() {
  if (typeof supported === "undefined") {
    supported = function supported2() {
      var contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: settings$2.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
      };
      try {
        if (!globalThis.WebGLRenderingContext) {
          return false;
        }
        var canvas = document.createElement("canvas");
        var gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);
        var success = !!(gl && gl.getContextAttributes().stencil);
        if (gl) {
          var loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (e2) {
        return false;
      }
    }();
  }
  return supported;
}
var aliceblue = "#f0f8ff";
var antiquewhite = "#faebd7";
var aqua = "#00ffff";
var aquamarine = "#7fffd4";
var azure = "#f0ffff";
var beige = "#f5f5dc";
var bisque = "#ffe4c4";
var black = "#000000";
var blanchedalmond = "#ffebcd";
var blue = "#0000ff";
var blueviolet = "#8a2be2";
var brown = "#a52a2a";
var burlywood = "#deb887";
var cadetblue = "#5f9ea0";
var chartreuse = "#7fff00";
var chocolate = "#d2691e";
var coral = "#ff7f50";
var cornflowerblue = "#6495ed";
var cornsilk = "#fff8dc";
var crimson = "#dc143c";
var cyan = "#00ffff";
var darkblue = "#00008b";
var darkcyan = "#008b8b";
var darkgoldenrod = "#b8860b";
var darkgray = "#a9a9a9";
var darkgreen = "#006400";
var darkgrey = "#a9a9a9";
var darkkhaki = "#bdb76b";
var darkmagenta = "#8b008b";
var darkolivegreen = "#556b2f";
var darkorange = "#ff8c00";
var darkorchid = "#9932cc";
var darkred = "#8b0000";
var darksalmon = "#e9967a";
var darkseagreen = "#8fbc8f";
var darkslateblue = "#483d8b";
var darkslategray = "#2f4f4f";
var darkslategrey = "#2f4f4f";
var darkturquoise = "#00ced1";
var darkviolet = "#9400d3";
var deeppink = "#ff1493";
var deepskyblue = "#00bfff";
var dimgray = "#696969";
var dimgrey = "#696969";
var dodgerblue = "#1e90ff";
var firebrick = "#b22222";
var floralwhite = "#fffaf0";
var forestgreen = "#228b22";
var fuchsia = "#ff00ff";
var gainsboro = "#dcdcdc";
var ghostwhite = "#f8f8ff";
var goldenrod = "#daa520";
var gold = "#ffd700";
var gray = "#808080";
var green = "#008000";
var greenyellow = "#adff2f";
var grey = "#808080";
var honeydew = "#f0fff0";
var hotpink = "#ff69b4";
var indianred = "#cd5c5c";
var indigo = "#4b0082";
var ivory = "#fffff0";
var khaki = "#f0e68c";
var lavenderblush = "#fff0f5";
var lavender = "#e6e6fa";
var lawngreen = "#7cfc00";
var lemonchiffon = "#fffacd";
var lightblue = "#add8e6";
var lightcoral = "#f08080";
var lightcyan = "#e0ffff";
var lightgoldenrodyellow = "#fafad2";
var lightgray = "#d3d3d3";
var lightgreen = "#90ee90";
var lightgrey = "#d3d3d3";
var lightpink = "#ffb6c1";
var lightsalmon = "#ffa07a";
var lightseagreen = "#20b2aa";
var lightskyblue = "#87cefa";
var lightslategray = "#778899";
var lightslategrey = "#778899";
var lightsteelblue = "#b0c4de";
var lightyellow = "#ffffe0";
var lime = "#00ff00";
var limegreen = "#32cd32";
var linen = "#faf0e6";
var magenta = "#ff00ff";
var maroon = "#800000";
var mediumaquamarine = "#66cdaa";
var mediumblue = "#0000cd";
var mediumorchid = "#ba55d3";
var mediumpurple = "#9370db";
var mediumseagreen = "#3cb371";
var mediumslateblue = "#7b68ee";
var mediumspringgreen = "#00fa9a";
var mediumturquoise = "#48d1cc";
var mediumvioletred = "#c71585";
var midnightblue = "#191970";
var mintcream = "#f5fffa";
var mistyrose = "#ffe4e1";
var moccasin = "#ffe4b5";
var navajowhite = "#ffdead";
var navy = "#000080";
var oldlace = "#fdf5e6";
var olive = "#808000";
var olivedrab = "#6b8e23";
var orange = "#ffa500";
var orangered = "#ff4500";
var orchid = "#da70d6";
var palegoldenrod = "#eee8aa";
var palegreen = "#98fb98";
var paleturquoise = "#afeeee";
var palevioletred = "#db7093";
var papayawhip = "#ffefd5";
var peachpuff = "#ffdab9";
var peru = "#cd853f";
var pink = "#ffc0cb";
var plum = "#dda0dd";
var powderblue = "#b0e0e6";
var purple = "#800080";
var rebeccapurple = "#663399";
var red = "#ff0000";
var rosybrown = "#bc8f8f";
var royalblue = "#4169e1";
var saddlebrown = "#8b4513";
var salmon = "#fa8072";
var sandybrown = "#f4a460";
var seagreen = "#2e8b57";
var seashell = "#fff5ee";
var sienna = "#a0522d";
var silver = "#c0c0c0";
var skyblue = "#87ceeb";
var slateblue = "#6a5acd";
var slategray = "#708090";
var slategrey = "#708090";
var snow = "#fffafa";
var springgreen = "#00ff7f";
var steelblue = "#4682b4";
var tan = "#d2b48c";
var teal = "#008080";
var thistle = "#d8bfd8";
var tomato = "#ff6347";
var turquoise = "#40e0d0";
var violet = "#ee82ee";
var wheat = "#f5deb3";
var white = "#ffffff";
var whitesmoke = "#f5f5f5";
var yellow = "#ffff00";
var yellowgreen = "#9acd32";
var cssColorNames = {
  aliceblue,
  antiquewhite,
  aqua,
  aquamarine,
  azure,
  beige,
  bisque,
  black,
  blanchedalmond,
  blue,
  blueviolet,
  brown,
  burlywood,
  cadetblue,
  chartreuse,
  chocolate,
  coral,
  cornflowerblue,
  cornsilk,
  crimson,
  cyan,
  darkblue,
  darkcyan,
  darkgoldenrod,
  darkgray,
  darkgreen,
  darkgrey,
  darkkhaki,
  darkmagenta,
  darkolivegreen,
  darkorange,
  darkorchid,
  darkred,
  darksalmon,
  darkseagreen,
  darkslateblue,
  darkslategray,
  darkslategrey,
  darkturquoise,
  darkviolet,
  deeppink,
  deepskyblue,
  dimgray,
  dimgrey,
  dodgerblue,
  firebrick,
  floralwhite,
  forestgreen,
  fuchsia,
  gainsboro,
  ghostwhite,
  goldenrod,
  gold,
  gray,
  green,
  greenyellow,
  grey,
  honeydew,
  hotpink,
  indianred,
  indigo,
  ivory,
  khaki,
  lavenderblush,
  lavender,
  lawngreen,
  lemonchiffon,
  lightblue,
  lightcoral,
  lightcyan,
  lightgoldenrodyellow,
  lightgray,
  lightgreen,
  lightgrey,
  lightpink,
  lightsalmon,
  lightseagreen,
  lightskyblue,
  lightslategray,
  lightslategrey,
  lightsteelblue,
  lightyellow,
  lime,
  limegreen,
  linen,
  magenta,
  maroon,
  mediumaquamarine,
  mediumblue,
  mediumorchid,
  mediumpurple,
  mediumseagreen,
  mediumslateblue,
  mediumspringgreen,
  mediumturquoise,
  mediumvioletred,
  midnightblue,
  mintcream,
  mistyrose,
  moccasin,
  navajowhite,
  navy,
  oldlace,
  olive,
  olivedrab,
  orange,
  orangered,
  orchid,
  palegoldenrod,
  palegreen,
  paleturquoise,
  palevioletred,
  papayawhip,
  peachpuff,
  peru,
  pink,
  plum,
  powderblue,
  purple,
  rebeccapurple,
  red,
  rosybrown,
  royalblue,
  saddlebrown,
  salmon,
  sandybrown,
  seagreen,
  seashell,
  sienna,
  silver,
  skyblue,
  slateblue,
  slategray,
  slategrey,
  snow,
  springgreen,
  steelblue,
  tan,
  teal,
  thistle,
  tomato,
  turquoise,
  violet,
  wheat,
  white,
  whitesmoke,
  yellow,
  yellowgreen
};
function hex2rgb(hex2, out) {
  if (out === void 0) {
    out = [];
  }
  out[0] = (hex2 >> 16 & 255) / 255;
  out[1] = (hex2 >> 8 & 255) / 255;
  out[2] = (hex2 & 255) / 255;
  return out;
}
function hex2string(hex2) {
  var hexString = hex2.toString(16);
  hexString = "000000".substring(0, 6 - hexString.length) + hexString;
  return "#" + hexString;
}
function string2hex(string) {
  if (typeof string === "string") {
    string = cssColorNames[string.toLowerCase()] || string;
    if (string[0] === "#") {
      string = string.slice(1);
    }
  }
  return parseInt(string, 16);
}
function rgb2hex(rgb) {
  return (rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + (rgb[2] * 255 | 0);
}
function mapPremultipliedBlendModes() {
  var pm = [];
  var npm = [];
  for (var i2 = 0; i2 < 32; i2++) {
    pm[i2] = i2;
    npm[i2] = i2;
  }
  pm[BLEND_MODES$4.NORMAL_NPM] = BLEND_MODES$4.NORMAL;
  pm[BLEND_MODES$4.ADD_NPM] = BLEND_MODES$4.ADD;
  pm[BLEND_MODES$4.SCREEN_NPM] = BLEND_MODES$4.SCREEN;
  npm[BLEND_MODES$4.NORMAL] = BLEND_MODES$4.NORMAL_NPM;
  npm[BLEND_MODES$4.ADD] = BLEND_MODES$4.ADD_NPM;
  npm[BLEND_MODES$4.SCREEN] = BLEND_MODES$4.SCREEN_NPM;
  var array = [];
  array.push(npm);
  array.push(pm);
  return array;
}
var premultiplyBlendMode = mapPremultipliedBlendModes();
function correctBlendMode(blendMode, premultiplied) {
  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
}
function premultiplyRgba(rgb, alpha2, out, premultiply) {
  out = out || new Float32Array(4);
  if (premultiply || premultiply === void 0) {
    out[0] = rgb[0] * alpha2;
    out[1] = rgb[1] * alpha2;
    out[2] = rgb[2] * alpha2;
  } else {
    out[0] = rgb[0];
    out[1] = rgb[1];
    out[2] = rgb[2];
  }
  out[3] = alpha2;
  return out;
}
function premultiplyTint(tint, alpha2) {
  if (alpha2 === 1) {
    return (alpha2 * 255 << 24) + tint;
  }
  if (alpha2 === 0) {
    return 0;
  }
  var R2 = tint >> 16 & 255;
  var G2 = tint >> 8 & 255;
  var B2 = tint & 255;
  R2 = R2 * alpha2 + 0.5 | 0;
  G2 = G2 * alpha2 + 0.5 | 0;
  B2 = B2 * alpha2 + 0.5 | 0;
  return (alpha2 * 255 << 24) + (R2 << 16) + (G2 << 8) + B2;
}
function premultiplyTintToRgba(tint, alpha2, out, premultiply) {
  out = out || new Float32Array(4);
  out[0] = (tint >> 16 & 255) / 255;
  out[1] = (tint >> 8 & 255) / 255;
  out[2] = (tint & 255) / 255;
  if (premultiply || premultiply === void 0) {
    out[0] *= alpha2;
    out[1] *= alpha2;
    out[2] *= alpha2;
  }
  out[3] = alpha2;
  return out;
}
function createIndicesForQuads(size, outBuffer) {
  if (outBuffer === void 0) {
    outBuffer = null;
  }
  var totalIndices = size * 6;
  outBuffer = outBuffer || new Uint16Array(totalIndices);
  if (outBuffer.length !== totalIndices) {
    throw new Error("Out buffer length is incorrect, got " + outBuffer.length + " and expected " + totalIndices);
  }
  for (var i2 = 0, j2 = 0; i2 < totalIndices; i2 += 6, j2 += 4) {
    outBuffer[i2 + 0] = j2 + 0;
    outBuffer[i2 + 1] = j2 + 1;
    outBuffer[i2 + 2] = j2 + 2;
    outBuffer[i2 + 3] = j2 + 0;
    outBuffer[i2 + 4] = j2 + 2;
    outBuffer[i2 + 5] = j2 + 3;
  }
  return outBuffer;
}
function getBufferType(array) {
  if (array.BYTES_PER_ELEMENT === 4) {
    if (array instanceof Float32Array) {
      return "Float32Array";
    } else if (array instanceof Uint32Array) {
      return "Uint32Array";
    }
    return "Int32Array";
  } else if (array.BYTES_PER_ELEMENT === 2) {
    if (array instanceof Uint16Array) {
      return "Uint16Array";
    }
  } else if (array.BYTES_PER_ELEMENT === 1) {
    if (array instanceof Uint8Array) {
      return "Uint8Array";
    }
  }
  return null;
}
var map$2 = { Float32Array, Uint32Array, Int32Array, Uint8Array };
function interleaveTypedArrays$1(arrays, sizes) {
  var outSize = 0;
  var stride = 0;
  var views = {};
  for (var i2 = 0; i2 < arrays.length; i2++) {
    stride += sizes[i2];
    outSize += arrays[i2].length;
  }
  var buffer = new ArrayBuffer(outSize * 4);
  var out = null;
  var littleOffset = 0;
  for (var i2 = 0; i2 < arrays.length; i2++) {
    var size = sizes[i2];
    var array = arrays[i2];
    var type2 = getBufferType(array);
    if (!views[type2]) {
      views[type2] = new map$2[type2](buffer);
    }
    out = views[type2];
    for (var j2 = 0; j2 < array.length; j2++) {
      var indexStart = (j2 / size | 0) * stride + littleOffset;
      var index2 = j2 % size;
      out[indexStart + index2] = array[j2];
    }
    littleOffset += size;
  }
  return new Float32Array(buffer);
}
function nextPow2(v2) {
  v2 += v2 === 0 ? 1 : 0;
  --v2;
  v2 |= v2 >>> 1;
  v2 |= v2 >>> 2;
  v2 |= v2 >>> 4;
  v2 |= v2 >>> 8;
  v2 |= v2 >>> 16;
  return v2 + 1;
}
function isPow2(v2) {
  return !(v2 & v2 - 1) && !!v2;
}
function log2(v2) {
  var r2 = (v2 > 65535 ? 1 : 0) << 4;
  v2 >>>= r2;
  var shift = (v2 > 255 ? 1 : 0) << 3;
  v2 >>>= shift;
  r2 |= shift;
  shift = (v2 > 15 ? 1 : 0) << 2;
  v2 >>>= shift;
  r2 |= shift;
  shift = (v2 > 3 ? 1 : 0) << 1;
  v2 >>>= shift;
  r2 |= shift;
  return r2 | v2 >> 1;
}
function removeItems(arr, startIdx, removeCount) {
  var length2 = arr.length;
  var i2;
  if (startIdx >= length2 || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length2 ? length2 - startIdx : removeCount;
  var len = length2 - removeCount;
  for (i2 = startIdx; i2 < len; ++i2) {
    arr[i2] = arr[i2 + removeCount];
  }
  arr.length = len;
}
function sign(n2) {
  if (n2 === 0) {
    return 0;
  }
  return n2 < 0 ? -1 : 1;
}
var nextUid = 0;
function uid() {
  return ++nextUid;
}
var warnings = {};
function deprecation(version, message, ignoreDepth) {
  if (ignoreDepth === void 0) {
    ignoreDepth = 3;
  }
  if (warnings[message]) {
    return;
  }
  var stack = new Error().stack;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (console.groupCollapsed) {
      console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", message + "\nDeprecated since v" + version);
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version);
      console.warn(stack);
    }
  }
  warnings[message] = true;
}
var ProgramCache = {};
var TextureCache = /* @__PURE__ */ Object.create(null);
var BaseTextureCache = /* @__PURE__ */ Object.create(null);
function destroyTextureCache() {
  var key;
  for (key in TextureCache) {
    TextureCache[key].destroy();
  }
  for (key in BaseTextureCache) {
    BaseTextureCache[key].destroy();
  }
}
function clearTextureCache() {
  var key;
  for (key in TextureCache) {
    delete TextureCache[key];
  }
  for (key in BaseTextureCache) {
    delete BaseTextureCache[key];
  }
}
var CanvasRenderTarget = (
  /** @class */
  function() {
    function CanvasRenderTarget2(width, height, resolution) {
      this.canvas = document.createElement("canvas");
      this.context = this.canvas.getContext("2d");
      this.resolution = resolution || settings$2.RESOLUTION;
      this.resize(width, height);
    }
    CanvasRenderTarget2.prototype.clear = function() {
      this.context.setTransform(1, 0, 0, 1, 0, 0);
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };
    CanvasRenderTarget2.prototype.resize = function(desiredWidth, desiredHeight) {
      this.canvas.width = Math.round(desiredWidth * this.resolution);
      this.canvas.height = Math.round(desiredHeight * this.resolution);
    };
    CanvasRenderTarget2.prototype.destroy = function() {
      this.context = null;
      this.canvas = null;
    };
    Object.defineProperty(CanvasRenderTarget2.prototype, "width", {
      /**
       * The width of the canvas buffer in pixels.
       * @member {number}
       */
      get: function() {
        return this.canvas.width;
      },
      set: function(val) {
        this.canvas.width = Math.round(val);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CanvasRenderTarget2.prototype, "height", {
      /**
       * The height of the canvas buffer in pixels.
       * @member {number}
       */
      get: function() {
        return this.canvas.height;
      },
      set: function(val) {
        this.canvas.height = Math.round(val);
      },
      enumerable: false,
      configurable: true
    });
    return CanvasRenderTarget2;
  }()
);
function trimCanvas(canvas) {
  var width = canvas.width;
  var height = canvas.height;
  var context2 = canvas.getContext("2d");
  var imageData = context2.getImageData(0, 0, width, height);
  var pixels = imageData.data;
  var len = pixels.length;
  var bound = {
    top: null,
    left: null,
    right: null,
    bottom: null
  };
  var data2 = null;
  var i2;
  var x;
  var y2;
  for (i2 = 0; i2 < len; i2 += 4) {
    if (pixels[i2 + 3] !== 0) {
      x = i2 / 4 % width;
      y2 = ~~(i2 / 4 / width);
      if (bound.top === null) {
        bound.top = y2;
      }
      if (bound.left === null) {
        bound.left = x;
      } else if (x < bound.left) {
        bound.left = x;
      }
      if (bound.right === null) {
        bound.right = x + 1;
      } else if (bound.right < x) {
        bound.right = x + 1;
      }
      if (bound.bottom === null) {
        bound.bottom = y2;
      } else if (bound.bottom < y2) {
        bound.bottom = y2;
      }
    }
  }
  if (bound.top !== null) {
    width = bound.right - bound.left;
    height = bound.bottom - bound.top + 1;
    data2 = context2.getImageData(bound.left, bound.top, width, height);
  }
  return {
    height,
    width,
    data: data2
  };
}
var DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
function decomposeDataUri(dataUri) {
  var dataUriMatch = DATA_URI.exec(dataUri);
  if (dataUriMatch) {
    return {
      mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : void 0,
      subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : void 0,
      charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : void 0,
      encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : void 0,
      data: dataUriMatch[5]
    };
  }
  return void 0;
}
var tempAnchor$1;
function determineCrossOrigin(url$1, loc) {
  if (loc === void 0) {
    loc = globalThis.location;
  }
  if (url$1.indexOf("data:") === 0) {
    return "";
  }
  loc = loc || globalThis.location;
  if (!tempAnchor$1) {
    tempAnchor$1 = document.createElement("a");
  }
  tempAnchor$1.href = url$1;
  var parsedUrl = url.parse(tempAnchor$1.href);
  var samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
  if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {
    return "anonymous";
  }
  return "";
}
function getResolutionOfUrl(url2, defaultValue2) {
  var resolution = settings$2.RETINA_PREFIX.exec(url2);
  if (resolution) {
    return parseFloat(resolution[1]);
  }
  return defaultValue2 !== void 0 ? defaultValue2 : 1;
}
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTextureCache,
  CanvasRenderTarget,
  DATA_URI,
  EventEmitter: EventEmitter$1,
  ProgramCache,
  TextureCache,
  clearTextureCache,
  correctBlendMode,
  createIndicesForQuads,
  decomposeDataUri,
  deprecation,
  destroyTextureCache,
  determineCrossOrigin,
  earcut: earcut$1,
  getBufferType,
  getResolutionOfUrl,
  hex2rgb,
  hex2string,
  interleaveTypedArrays: interleaveTypedArrays$1,
  isMobile: isMobile$2,
  isPow2,
  isWebGLSupported,
  log2,
  nextPow2,
  premultiplyBlendMode,
  premultiplyRgba,
  premultiplyTint,
  premultiplyTintToRgba,
  removeItems,
  rgb2hex,
  sayHello,
  sign,
  skipHello,
  string2hex,
  trimCanvas,
  uid,
  url
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * @pixi/math - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/math is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var PI_2 = Math.PI * 2;
var RAD_TO_DEG = 180 / Math.PI;
var DEG_TO_RAD = Math.PI / 180;
var SHAPES;
(function(SHAPES2) {
  SHAPES2[SHAPES2["POLY"] = 0] = "POLY";
  SHAPES2[SHAPES2["RECT"] = 1] = "RECT";
  SHAPES2[SHAPES2["CIRC"] = 2] = "CIRC";
  SHAPES2[SHAPES2["ELIP"] = 3] = "ELIP";
  SHAPES2[SHAPES2["RREC"] = 4] = "RREC";
})(SHAPES || (SHAPES = {}));
var Point = (
  /** @class */
  function() {
    function Point2(x, y2) {
      if (x === void 0) {
        x = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      this.x = 0;
      this.y = 0;
      this.x = x;
      this.y = y2;
    }
    Point2.prototype.clone = function() {
      return new Point2(this.x, this.y);
    };
    Point2.prototype.copyFrom = function(p) {
      this.set(p.x, p.y);
      return this;
    };
    Point2.prototype.copyTo = function(p) {
      p.set(this.x, this.y);
      return p;
    };
    Point2.prototype.equals = function(p) {
      return p.x === this.x && p.y === this.y;
    };
    Point2.prototype.set = function(x, y2) {
      if (x === void 0) {
        x = 0;
      }
      if (y2 === void 0) {
        y2 = x;
      }
      this.x = x;
      this.y = y2;
      return this;
    };
    Point2.prototype.toString = function() {
      return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
    };
    return Point2;
  }()
);
var tempPoints$1 = [new Point(), new Point(), new Point(), new Point()];
var Rectangle = (
  /** @class */
  function() {
    function Rectangle2(x, y2, width, height) {
      if (x === void 0) {
        x = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      this.x = Number(x);
      this.y = Number(y2);
      this.width = Number(width);
      this.height = Number(height);
      this.type = SHAPES.RECT;
    }
    Object.defineProperty(Rectangle2.prototype, "left", {
      /** Returns the left edge of the rectangle. */
      get: function() {
        return this.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Rectangle2.prototype, "right", {
      /** Returns the right edge of the rectangle. */
      get: function() {
        return this.x + this.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Rectangle2.prototype, "top", {
      /** Returns the top edge of the rectangle. */
      get: function() {
        return this.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Rectangle2.prototype, "bottom", {
      /** Returns the bottom edge of the rectangle. */
      get: function() {
        return this.y + this.height;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Rectangle2, "EMPTY", {
      /** A constant empty rectangle. */
      get: function() {
        return new Rectangle2(0, 0, 0, 0);
      },
      enumerable: false,
      configurable: true
    });
    Rectangle2.prototype.clone = function() {
      return new Rectangle2(this.x, this.y, this.width, this.height);
    };
    Rectangle2.prototype.copyFrom = function(rectangle) {
      this.x = rectangle.x;
      this.y = rectangle.y;
      this.width = rectangle.width;
      this.height = rectangle.height;
      return this;
    };
    Rectangle2.prototype.copyTo = function(rectangle) {
      rectangle.x = this.x;
      rectangle.y = this.y;
      rectangle.width = this.width;
      rectangle.height = this.height;
      return rectangle;
    };
    Rectangle2.prototype.contains = function(x, y2) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      if (x >= this.x && x < this.x + this.width) {
        if (y2 >= this.y && y2 < this.y + this.height) {
          return true;
        }
      }
      return false;
    };
    Rectangle2.prototype.intersects = function(other, transform) {
      if (!transform) {
        var x0_1 = this.x < other.x ? other.x : this.x;
        var x1_1 = this.right > other.right ? other.right : this.right;
        if (x1_1 <= x0_1) {
          return false;
        }
        var y0_1 = this.y < other.y ? other.y : this.y;
        var y1_1 = this.bottom > other.bottom ? other.bottom : this.bottom;
        return y1_1 > y0_1;
      }
      var x0 = this.left;
      var x1 = this.right;
      var y0 = this.top;
      var y1 = this.bottom;
      if (x1 <= x0 || y1 <= y0) {
        return false;
      }
      var lt = tempPoints$1[0].set(other.left, other.top);
      var lb2 = tempPoints$1[1].set(other.left, other.bottom);
      var rt = tempPoints$1[2].set(other.right, other.top);
      var rb2 = tempPoints$1[3].set(other.right, other.bottom);
      if (rt.x <= lt.x || lb2.y <= lt.y) {
        return false;
      }
      var s2 = Math.sign(transform.a * transform.d - transform.b * transform.c);
      if (s2 === 0) {
        return false;
      }
      transform.apply(lt, lt);
      transform.apply(lb2, lb2);
      transform.apply(rt, rt);
      transform.apply(rb2, rb2);
      if (Math.max(lt.x, lb2.x, rt.x, rb2.x) <= x0 || Math.min(lt.x, lb2.x, rt.x, rb2.x) >= x1 || Math.max(lt.y, lb2.y, rt.y, rb2.y) <= y0 || Math.min(lt.y, lb2.y, rt.y, rb2.y) >= y1) {
        return false;
      }
      var nx = s2 * (lb2.y - lt.y);
      var ny = s2 * (lt.x - lb2.x);
      var n00 = nx * x0 + ny * y0;
      var n10 = nx * x1 + ny * y0;
      var n01 = nx * x0 + ny * y1;
      var n11 = nx * x1 + ny * y1;
      if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb2.x + ny * rb2.y) {
        return false;
      }
      var mx = s2 * (lt.y - rt.y);
      var my = s2 * (rt.x - lt.x);
      var m00 = mx * x0 + my * y0;
      var m10 = mx * x1 + my * y0;
      var m01 = mx * x0 + my * y1;
      var m11 = mx * x1 + my * y1;
      if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb2.x + my * rb2.y) {
        return false;
      }
      return true;
    };
    Rectangle2.prototype.pad = function(paddingX, paddingY) {
      if (paddingX === void 0) {
        paddingX = 0;
      }
      if (paddingY === void 0) {
        paddingY = paddingX;
      }
      this.x -= paddingX;
      this.y -= paddingY;
      this.width += paddingX * 2;
      this.height += paddingY * 2;
      return this;
    };
    Rectangle2.prototype.fit = function(rectangle) {
      var x1 = Math.max(this.x, rectangle.x);
      var x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
      var y1 = Math.max(this.y, rectangle.y);
      var y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
      this.x = x1;
      this.width = Math.max(x2 - x1, 0);
      this.y = y1;
      this.height = Math.max(y2 - y1, 0);
      return this;
    };
    Rectangle2.prototype.ceil = function(resolution, eps) {
      if (resolution === void 0) {
        resolution = 1;
      }
      if (eps === void 0) {
        eps = 1e-3;
      }
      var x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
      var y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
      this.x = Math.floor((this.x + eps) * resolution) / resolution;
      this.y = Math.floor((this.y + eps) * resolution) / resolution;
      this.width = x2 - this.x;
      this.height = y2 - this.y;
      return this;
    };
    Rectangle2.prototype.enlarge = function(rectangle) {
      var x1 = Math.min(this.x, rectangle.x);
      var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
      var y1 = Math.min(this.y, rectangle.y);
      var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
      this.x = x1;
      this.width = x2 - x1;
      this.y = y1;
      this.height = y2 - y1;
      return this;
    };
    Rectangle2.prototype.toString = function() {
      return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
    };
    return Rectangle2;
  }()
);
var Circle = (
  /** @class */
  function() {
    function Circle2(x, y2, radius) {
      if (x === void 0) {
        x = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      if (radius === void 0) {
        radius = 0;
      }
      this.x = x;
      this.y = y2;
      this.radius = radius;
      this.type = SHAPES.CIRC;
    }
    Circle2.prototype.clone = function() {
      return new Circle2(this.x, this.y, this.radius);
    };
    Circle2.prototype.contains = function(x, y2) {
      if (this.radius <= 0) {
        return false;
      }
      var r2 = this.radius * this.radius;
      var dx = this.x - x;
      var dy = this.y - y2;
      dx *= dx;
      dy *= dy;
      return dx + dy <= r2;
    };
    Circle2.prototype.getBounds = function() {
      return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    };
    Circle2.prototype.toString = function() {
      return "[@pixi/math:Circle x=" + this.x + " y=" + this.y + " radius=" + this.radius + "]";
    };
    return Circle2;
  }()
);
var Ellipse = (
  /** @class */
  function() {
    function Ellipse2(x, y2, halfWidth, halfHeight) {
      if (x === void 0) {
        x = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      if (halfWidth === void 0) {
        halfWidth = 0;
      }
      if (halfHeight === void 0) {
        halfHeight = 0;
      }
      this.x = x;
      this.y = y2;
      this.width = halfWidth;
      this.height = halfHeight;
      this.type = SHAPES.ELIP;
    }
    Ellipse2.prototype.clone = function() {
      return new Ellipse2(this.x, this.y, this.width, this.height);
    };
    Ellipse2.prototype.contains = function(x, y2) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      var normx = (x - this.x) / this.width;
      var normy = (y2 - this.y) / this.height;
      normx *= normx;
      normy *= normy;
      return normx + normy <= 1;
    };
    Ellipse2.prototype.getBounds = function() {
      return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
    };
    Ellipse2.prototype.toString = function() {
      return "[@pixi/math:Ellipse x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
    };
    return Ellipse2;
  }()
);
var Polygon = (
  /** @class */
  function() {
    function Polygon2() {
      var arguments$1 = arguments;
      var points = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        points[_i] = arguments$1[_i];
      }
      var flat = Array.isArray(points[0]) ? points[0] : points;
      if (typeof flat[0] !== "number") {
        var p = [];
        for (var i2 = 0, il = flat.length; i2 < il; i2++) {
          p.push(flat[i2].x, flat[i2].y);
        }
        flat = p;
      }
      this.points = flat;
      this.type = SHAPES.POLY;
      this.closeStroke = true;
    }
    Polygon2.prototype.clone = function() {
      var points = this.points.slice();
      var polygon = new Polygon2(points);
      polygon.closeStroke = this.closeStroke;
      return polygon;
    };
    Polygon2.prototype.contains = function(x, y2) {
      var inside = false;
      var length2 = this.points.length / 2;
      for (var i2 = 0, j2 = length2 - 1; i2 < length2; j2 = i2++) {
        var xi2 = this.points[i2 * 2];
        var yi2 = this.points[i2 * 2 + 1];
        var xj2 = this.points[j2 * 2];
        var yj2 = this.points[j2 * 2 + 1];
        var intersect = yi2 > y2 !== yj2 > y2 && x < (xj2 - xi2) * ((y2 - yi2) / (yj2 - yi2)) + xi2;
        if (intersect) {
          inside = !inside;
        }
      }
      return inside;
    };
    Polygon2.prototype.toString = function() {
      return "[@pixi/math:Polygon" + ("closeStroke=" + this.closeStroke) + ("points=" + this.points.reduce(function(pointsDesc, currentPoint) {
        return pointsDesc + ", " + currentPoint;
      }, "") + "]");
    };
    return Polygon2;
  }()
);
var RoundedRectangle = (
  /** @class */
  function() {
    function RoundedRectangle2(x, y2, width, height, radius) {
      if (x === void 0) {
        x = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      if (radius === void 0) {
        radius = 20;
      }
      this.x = x;
      this.y = y2;
      this.width = width;
      this.height = height;
      this.radius = radius;
      this.type = SHAPES.RREC;
    }
    RoundedRectangle2.prototype.clone = function() {
      return new RoundedRectangle2(this.x, this.y, this.width, this.height, this.radius);
    };
    RoundedRectangle2.prototype.contains = function(x, y2) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      if (x >= this.x && x <= this.x + this.width) {
        if (y2 >= this.y && y2 <= this.y + this.height) {
          var radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
          if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {
            return true;
          }
          var dx = x - (this.x + radius);
          var dy = y2 - (this.y + radius);
          var radius2 = radius * radius;
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
          dx = x - (this.x + this.width - radius);
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
          dy = y2 - (this.y + this.height - radius);
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
          dx = x - (this.x + radius);
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
        }
      }
      return false;
    };
    RoundedRectangle2.prototype.toString = function() {
      return "[@pixi/math:RoundedRectangle x=" + this.x + " y=" + this.y + ("width=" + this.width + " height=" + this.height + " radius=" + this.radius + "]");
    };
    return RoundedRectangle2;
  }()
);
var ObservablePoint = (
  /** @class */
  function() {
    function ObservablePoint2(cb2, scope, x, y2) {
      if (x === void 0) {
        x = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      this._x = x;
      this._y = y2;
      this.cb = cb2;
      this.scope = scope;
    }
    ObservablePoint2.prototype.clone = function(cb2, scope) {
      if (cb2 === void 0) {
        cb2 = this.cb;
      }
      if (scope === void 0) {
        scope = this.scope;
      }
      return new ObservablePoint2(cb2, scope, this._x, this._y);
    };
    ObservablePoint2.prototype.set = function(x, y2) {
      if (x === void 0) {
        x = 0;
      }
      if (y2 === void 0) {
        y2 = x;
      }
      if (this._x !== x || this._y !== y2) {
        this._x = x;
        this._y = y2;
        this.cb.call(this.scope);
      }
      return this;
    };
    ObservablePoint2.prototype.copyFrom = function(p) {
      if (this._x !== p.x || this._y !== p.y) {
        this._x = p.x;
        this._y = p.y;
        this.cb.call(this.scope);
      }
      return this;
    };
    ObservablePoint2.prototype.copyTo = function(p) {
      p.set(this._x, this._y);
      return p;
    };
    ObservablePoint2.prototype.equals = function(p) {
      return p.x === this._x && p.y === this._y;
    };
    ObservablePoint2.prototype.toString = function() {
      return "[@pixi/math:ObservablePoint x=0 y=0 scope=" + this.scope + "]";
    };
    Object.defineProperty(ObservablePoint2.prototype, "x", {
      /** Position of the observable point on the x axis. */
      get: function() {
        return this._x;
      },
      set: function(value) {
        if (this._x !== value) {
          this._x = value;
          this.cb.call(this.scope);
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ObservablePoint2.prototype, "y", {
      /** Position of the observable point on the y axis. */
      get: function() {
        return this._y;
      },
      set: function(value) {
        if (this._y !== value) {
          this._y = value;
          this.cb.call(this.scope);
        }
      },
      enumerable: false,
      configurable: true
    });
    return ObservablePoint2;
  }()
);
var Matrix = (
  /** @class */
  function() {
    function Matrix2(a2, b2, c2, d2, tx, ty) {
      if (a2 === void 0) {
        a2 = 1;
      }
      if (b2 === void 0) {
        b2 = 0;
      }
      if (c2 === void 0) {
        c2 = 0;
      }
      if (d2 === void 0) {
        d2 = 1;
      }
      if (tx === void 0) {
        tx = 0;
      }
      if (ty === void 0) {
        ty = 0;
      }
      this.array = null;
      this.a = a2;
      this.b = b2;
      this.c = c2;
      this.d = d2;
      this.tx = tx;
      this.ty = ty;
    }
    Matrix2.prototype.fromArray = function(array) {
      this.a = array[0];
      this.b = array[1];
      this.c = array[3];
      this.d = array[4];
      this.tx = array[2];
      this.ty = array[5];
    };
    Matrix2.prototype.set = function(a2, b2, c2, d2, tx, ty) {
      this.a = a2;
      this.b = b2;
      this.c = c2;
      this.d = d2;
      this.tx = tx;
      this.ty = ty;
      return this;
    };
    Matrix2.prototype.toArray = function(transpose, out) {
      if (!this.array) {
        this.array = new Float32Array(9);
      }
      var array = out || this.array;
      if (transpose) {
        array[0] = this.a;
        array[1] = this.b;
        array[2] = 0;
        array[3] = this.c;
        array[4] = this.d;
        array[5] = 0;
        array[6] = this.tx;
        array[7] = this.ty;
        array[8] = 1;
      } else {
        array[0] = this.a;
        array[1] = this.c;
        array[2] = this.tx;
        array[3] = this.b;
        array[4] = this.d;
        array[5] = this.ty;
        array[6] = 0;
        array[7] = 0;
        array[8] = 1;
      }
      return array;
    };
    Matrix2.prototype.apply = function(pos, newPos) {
      newPos = newPos || new Point();
      var x = pos.x;
      var y2 = pos.y;
      newPos.x = this.a * x + this.c * y2 + this.tx;
      newPos.y = this.b * x + this.d * y2 + this.ty;
      return newPos;
    };
    Matrix2.prototype.applyInverse = function(pos, newPos) {
      newPos = newPos || new Point();
      var id2 = 1 / (this.a * this.d + this.c * -this.b);
      var x = pos.x;
      var y2 = pos.y;
      newPos.x = this.d * id2 * x + -this.c * id2 * y2 + (this.ty * this.c - this.tx * this.d) * id2;
      newPos.y = this.a * id2 * y2 + -this.b * id2 * x + (-this.ty * this.a + this.tx * this.b) * id2;
      return newPos;
    };
    Matrix2.prototype.translate = function(x, y2) {
      this.tx += x;
      this.ty += y2;
      return this;
    };
    Matrix2.prototype.scale = function(x, y2) {
      this.a *= x;
      this.d *= y2;
      this.c *= x;
      this.b *= y2;
      this.tx *= x;
      this.ty *= y2;
      return this;
    };
    Matrix2.prototype.rotate = function(angle) {
      var cos = Math.cos(angle);
      var sin = Math.sin(angle);
      var a1 = this.a;
      var c1 = this.c;
      var tx1 = this.tx;
      this.a = a1 * cos - this.b * sin;
      this.b = a1 * sin + this.b * cos;
      this.c = c1 * cos - this.d * sin;
      this.d = c1 * sin + this.d * cos;
      this.tx = tx1 * cos - this.ty * sin;
      this.ty = tx1 * sin + this.ty * cos;
      return this;
    };
    Matrix2.prototype.append = function(matrix) {
      var a1 = this.a;
      var b1 = this.b;
      var c1 = this.c;
      var d1 = this.d;
      this.a = matrix.a * a1 + matrix.b * c1;
      this.b = matrix.a * b1 + matrix.b * d1;
      this.c = matrix.c * a1 + matrix.d * c1;
      this.d = matrix.c * b1 + matrix.d * d1;
      this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
      this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
      return this;
    };
    Matrix2.prototype.setTransform = function(x, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
      this.a = Math.cos(rotation + skewY) * scaleX;
      this.b = Math.sin(rotation + skewY) * scaleX;
      this.c = -Math.sin(rotation - skewX) * scaleY;
      this.d = Math.cos(rotation - skewX) * scaleY;
      this.tx = x - (pivotX * this.a + pivotY * this.c);
      this.ty = y2 - (pivotX * this.b + pivotY * this.d);
      return this;
    };
    Matrix2.prototype.prepend = function(matrix) {
      var tx1 = this.tx;
      if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
        var a1 = this.a;
        var c1 = this.c;
        this.a = a1 * matrix.a + this.b * matrix.c;
        this.b = a1 * matrix.b + this.b * matrix.d;
        this.c = c1 * matrix.a + this.d * matrix.c;
        this.d = c1 * matrix.b + this.d * matrix.d;
      }
      this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
      this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
      return this;
    };
    Matrix2.prototype.decompose = function(transform) {
      var a2 = this.a;
      var b2 = this.b;
      var c2 = this.c;
      var d2 = this.d;
      var pivot = transform.pivot;
      var skewX = -Math.atan2(-c2, d2);
      var skewY = Math.atan2(b2, a2);
      var delta = Math.abs(skewX + skewY);
      if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
        transform.rotation = skewY;
        transform.skew.x = transform.skew.y = 0;
      } else {
        transform.rotation = 0;
        transform.skew.x = skewX;
        transform.skew.y = skewY;
      }
      transform.scale.x = Math.sqrt(a2 * a2 + b2 * b2);
      transform.scale.y = Math.sqrt(c2 * c2 + d2 * d2);
      transform.position.x = this.tx + (pivot.x * a2 + pivot.y * c2);
      transform.position.y = this.ty + (pivot.x * b2 + pivot.y * d2);
      return transform;
    };
    Matrix2.prototype.invert = function() {
      var a1 = this.a;
      var b1 = this.b;
      var c1 = this.c;
      var d1 = this.d;
      var tx1 = this.tx;
      var n2 = a1 * d1 - b1 * c1;
      this.a = d1 / n2;
      this.b = -b1 / n2;
      this.c = -c1 / n2;
      this.d = a1 / n2;
      this.tx = (c1 * this.ty - d1 * tx1) / n2;
      this.ty = -(a1 * this.ty - b1 * tx1) / n2;
      return this;
    };
    Matrix2.prototype.identity = function() {
      this.a = 1;
      this.b = 0;
      this.c = 0;
      this.d = 1;
      this.tx = 0;
      this.ty = 0;
      return this;
    };
    Matrix2.prototype.clone = function() {
      var matrix = new Matrix2();
      matrix.a = this.a;
      matrix.b = this.b;
      matrix.c = this.c;
      matrix.d = this.d;
      matrix.tx = this.tx;
      matrix.ty = this.ty;
      return matrix;
    };
    Matrix2.prototype.copyTo = function(matrix) {
      matrix.a = this.a;
      matrix.b = this.b;
      matrix.c = this.c;
      matrix.d = this.d;
      matrix.tx = this.tx;
      matrix.ty = this.ty;
      return matrix;
    };
    Matrix2.prototype.copyFrom = function(matrix) {
      this.a = matrix.a;
      this.b = matrix.b;
      this.c = matrix.c;
      this.d = matrix.d;
      this.tx = matrix.tx;
      this.ty = matrix.ty;
      return this;
    };
    Matrix2.prototype.toString = function() {
      return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
    };
    Object.defineProperty(Matrix2, "IDENTITY", {
      /**
       * A default (identity) matrix
       * @readonly
       */
      get: function() {
        return new Matrix2();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Matrix2, "TEMP_MATRIX", {
      /**
       * A temp matrix
       * @readonly
       */
      get: function() {
        return new Matrix2();
      },
      enumerable: false,
      configurable: true
    });
    return Matrix2;
  }()
);
var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
var rotationCayley = [];
var rotationMatrices = [];
var signum = Math.sign;
function init2() {
  for (var i2 = 0; i2 < 16; i2++) {
    var row = [];
    rotationCayley.push(row);
    for (var j2 = 0; j2 < 16; j2++) {
      var _ux = signum(ux[i2] * ux[j2] + vx[i2] * uy[j2]);
      var _uy = signum(uy[i2] * ux[j2] + vy[i2] * uy[j2]);
      var _vx = signum(ux[i2] * vx[j2] + vx[i2] * vy[j2]);
      var _vy = signum(uy[i2] * vx[j2] + vy[i2] * vy[j2]);
      for (var k2 = 0; k2 < 16; k2++) {
        if (ux[k2] === _ux && uy[k2] === _uy && vx[k2] === _vx && vy[k2] === _vy) {
          row.push(k2);
          break;
        }
      }
    }
  }
  for (var i2 = 0; i2 < 16; i2++) {
    var mat = new Matrix();
    mat.set(ux[i2], uy[i2], vx[i2], vy[i2], 0, 0);
    rotationMatrices.push(mat);
  }
}
init2();
var groupD8 = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0       | East      |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45     | Southeast |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90     | South     |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135    | Southwest |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180     | West      |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135/225 | Northwest    |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90/270  | North        |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45/315  | Northeast    |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: function(ind) {
    return ux[ind];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: function(ind) {
    return uy[ind];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: function(ind) {
    return vx[ind];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: function(ind) {
    return vy[ind];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: function(rotation) {
    if (rotation & 8) {
      return rotation & 15;
    }
    return -rotation & 7;
  },
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {PIXI.GD8Symmetry} Composed operation
   */
  add: function(rotationSecond, rotationFirst) {
    return rotationCayley[rotationSecond][rotationFirst];
  },
  /**
   * Reverse of `add`.
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation
   * @returns {PIXI.GD8Symmetry} Result
   */
  sub: function(rotationSecond, rotationFirst) {
    return rotationCayley[rotationSecond][groupD8.inv(rotationFirst)];
  },
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @memberof PIXI.groupD8
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: function(rotation) {
    return rotation ^ 4;
  },
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: function(rotation) {
    return (rotation & 3) === 2;
  },
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @memberof PIXI.groupD8
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {PIXI.GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: function(dx, dy) {
    if (Math.abs(dx) * 2 <= Math.abs(dy)) {
      if (dy >= 0) {
        return groupD8.S;
      }
      return groupD8.N;
    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
      if (dx > 0) {
        return groupD8.E;
      }
      return groupD8.W;
    } else if (dy > 0) {
      if (dx > 0) {
        return groupD8.SE;
      }
      return groupD8.SW;
    } else if (dx > 0) {
      return groupD8.NE;
    }
    return groupD8.NW;
  },
  /**
   * Helps sprite to compensate texture packer rotation.
   * @memberof PIXI.groupD8
   * @param {PIXI.Matrix} matrix - sprite world matrix
   * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: function(matrix, rotation, tx, ty) {
    if (tx === void 0) {
      tx = 0;
    }
    if (ty === void 0) {
      ty = 0;
    }
    var mat = rotationMatrices[groupD8.inv(rotation)];
    mat.tx = tx;
    mat.ty = ty;
    matrix.append(mat);
  }
};
var Transform = (
  /** @class */
  function() {
    function Transform2() {
      this.worldTransform = new Matrix();
      this.localTransform = new Matrix();
      this.position = new ObservablePoint(this.onChange, this, 0, 0);
      this.scale = new ObservablePoint(this.onChange, this, 1, 1);
      this.pivot = new ObservablePoint(this.onChange, this, 0, 0);
      this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);
      this._rotation = 0;
      this._cx = 1;
      this._sx = 0;
      this._cy = 0;
      this._sy = 1;
      this._localID = 0;
      this._currentLocalID = 0;
      this._worldID = 0;
      this._parentID = 0;
    }
    Transform2.prototype.onChange = function() {
      this._localID++;
    };
    Transform2.prototype.updateSkew = function() {
      this._cx = Math.cos(this._rotation + this.skew.y);
      this._sx = Math.sin(this._rotation + this.skew.y);
      this._cy = -Math.sin(this._rotation - this.skew.x);
      this._sy = Math.cos(this._rotation - this.skew.x);
      this._localID++;
    };
    Transform2.prototype.toString = function() {
      return "[@pixi/math:Transform " + ("position=(" + this.position.x + ", " + this.position.y + ") ") + ("rotation=" + this.rotation + " ") + ("scale=(" + this.scale.x + ", " + this.scale.y + ") ") + ("skew=(" + this.skew.x + ", " + this.skew.y + ") ") + "]";
    };
    Transform2.prototype.updateLocalTransform = function() {
      var lt = this.localTransform;
      if (this._localID !== this._currentLocalID) {
        lt.a = this._cx * this.scale.x;
        lt.b = this._sx * this.scale.x;
        lt.c = this._cy * this.scale.y;
        lt.d = this._sy * this.scale.y;
        lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
        lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
        this._currentLocalID = this._localID;
        this._parentID = -1;
      }
    };
    Transform2.prototype.updateTransform = function(parentTransform) {
      var lt = this.localTransform;
      if (this._localID !== this._currentLocalID) {
        lt.a = this._cx * this.scale.x;
        lt.b = this._sx * this.scale.x;
        lt.c = this._cy * this.scale.y;
        lt.d = this._sy * this.scale.y;
        lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
        lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
        this._currentLocalID = this._localID;
        this._parentID = -1;
      }
      if (this._parentID !== parentTransform._worldID) {
        var pt = parentTransform.worldTransform;
        var wt = this.worldTransform;
        wt.a = lt.a * pt.a + lt.b * pt.c;
        wt.b = lt.a * pt.b + lt.b * pt.d;
        wt.c = lt.c * pt.a + lt.d * pt.c;
        wt.d = lt.c * pt.b + lt.d * pt.d;
        wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
        wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
        this._parentID = parentTransform._worldID;
        this._worldID++;
      }
    };
    Transform2.prototype.setFromMatrix = function(matrix) {
      matrix.decompose(this);
      this._localID++;
    };
    Object.defineProperty(Transform2.prototype, "rotation", {
      /** The rotation of the object in radians. */
      get: function() {
        return this._rotation;
      },
      set: function(value) {
        if (this._rotation !== value) {
          this._rotation = value;
          this.updateSkew();
        }
      },
      enumerable: false,
      configurable: true
    });
    Transform2.IDENTITY = new Transform2();
    return Transform2;
  }()
);
/*!
 * @pixi/display - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/display is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings$2.SORTABLE_CHILDREN = false;
var Bounds$1 = (
  /** @class */
  function() {
    function Bounds2() {
      this.minX = Infinity;
      this.minY = Infinity;
      this.maxX = -Infinity;
      this.maxY = -Infinity;
      this.rect = null;
      this.updateID = -1;
    }
    Bounds2.prototype.isEmpty = function() {
      return this.minX > this.maxX || this.minY > this.maxY;
    };
    Bounds2.prototype.clear = function() {
      this.minX = Infinity;
      this.minY = Infinity;
      this.maxX = -Infinity;
      this.maxY = -Infinity;
    };
    Bounds2.prototype.getRectangle = function(rect) {
      if (this.minX > this.maxX || this.minY > this.maxY) {
        return Rectangle.EMPTY;
      }
      rect = rect || new Rectangle(0, 0, 1, 1);
      rect.x = this.minX;
      rect.y = this.minY;
      rect.width = this.maxX - this.minX;
      rect.height = this.maxY - this.minY;
      return rect;
    };
    Bounds2.prototype.addPoint = function(point) {
      this.minX = Math.min(this.minX, point.x);
      this.maxX = Math.max(this.maxX, point.x);
      this.minY = Math.min(this.minY, point.y);
      this.maxY = Math.max(this.maxY, point.y);
    };
    Bounds2.prototype.addPointMatrix = function(matrix, point) {
      var a2 = matrix.a, b2 = matrix.b, c2 = matrix.c, d2 = matrix.d, tx = matrix.tx, ty = matrix.ty;
      var x = a2 * point.x + c2 * point.y + tx;
      var y2 = b2 * point.x + d2 * point.y + ty;
      this.minX = Math.min(this.minX, x);
      this.maxX = Math.max(this.maxX, x);
      this.minY = Math.min(this.minY, y2);
      this.maxY = Math.max(this.maxY, y2);
    };
    Bounds2.prototype.addQuad = function(vertices) {
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      var x = vertices[0];
      var y2 = vertices[1];
      minX = x < minX ? x : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y2 > maxY ? y2 : maxY;
      x = vertices[2];
      y2 = vertices[3];
      minX = x < minX ? x : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y2 > maxY ? y2 : maxY;
      x = vertices[4];
      y2 = vertices[5];
      minX = x < minX ? x : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y2 > maxY ? y2 : maxY;
      x = vertices[6];
      y2 = vertices[7];
      minX = x < minX ? x : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y2 > maxY ? y2 : maxY;
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    };
    Bounds2.prototype.addFrame = function(transform, x0, y0, x1, y1) {
      this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);
    };
    Bounds2.prototype.addFrameMatrix = function(matrix, x0, y0, x1, y1) {
      var a2 = matrix.a;
      var b2 = matrix.b;
      var c2 = matrix.c;
      var d2 = matrix.d;
      var tx = matrix.tx;
      var ty = matrix.ty;
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      var x = a2 * x0 + c2 * y0 + tx;
      var y2 = b2 * x0 + d2 * y0 + ty;
      minX = x < minX ? x : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y2 > maxY ? y2 : maxY;
      x = a2 * x1 + c2 * y0 + tx;
      y2 = b2 * x1 + d2 * y0 + ty;
      minX = x < minX ? x : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y2 > maxY ? y2 : maxY;
      x = a2 * x0 + c2 * y1 + tx;
      y2 = b2 * x0 + d2 * y1 + ty;
      minX = x < minX ? x : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y2 > maxY ? y2 : maxY;
      x = a2 * x1 + c2 * y1 + tx;
      y2 = b2 * x1 + d2 * y1 + ty;
      minX = x < minX ? x : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y2 > maxY ? y2 : maxY;
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    };
    Bounds2.prototype.addVertexData = function(vertexData, beginOffset, endOffset) {
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      for (var i2 = beginOffset; i2 < endOffset; i2 += 2) {
        var x = vertexData[i2];
        var y2 = vertexData[i2 + 1];
        minX = x < minX ? x : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y2 > maxY ? y2 : maxY;
      }
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    };
    Bounds2.prototype.addVertices = function(transform, vertices, beginOffset, endOffset) {
      this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);
    };
    Bounds2.prototype.addVerticesMatrix = function(matrix, vertices, beginOffset, endOffset, padX, padY) {
      if (padX === void 0) {
        padX = 0;
      }
      if (padY === void 0) {
        padY = padX;
      }
      var a2 = matrix.a;
      var b2 = matrix.b;
      var c2 = matrix.c;
      var d2 = matrix.d;
      var tx = matrix.tx;
      var ty = matrix.ty;
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      for (var i2 = beginOffset; i2 < endOffset; i2 += 2) {
        var rawX = vertices[i2];
        var rawY = vertices[i2 + 1];
        var x = a2 * rawX + c2 * rawY + tx;
        var y2 = d2 * rawY + b2 * rawX + ty;
        minX = Math.min(minX, x - padX);
        maxX = Math.max(maxX, x + padX);
        minY = Math.min(minY, y2 - padY);
        maxY = Math.max(maxY, y2 + padY);
      }
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    };
    Bounds2.prototype.addBounds = function(bounds) {
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      this.minX = bounds.minX < minX ? bounds.minX : minX;
      this.minY = bounds.minY < minY ? bounds.minY : minY;
      this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
      this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
    };
    Bounds2.prototype.addBoundsMask = function(bounds, mask2) {
      var _minX = bounds.minX > mask2.minX ? bounds.minX : mask2.minX;
      var _minY = bounds.minY > mask2.minY ? bounds.minY : mask2.minY;
      var _maxX = bounds.maxX < mask2.maxX ? bounds.maxX : mask2.maxX;
      var _maxY = bounds.maxY < mask2.maxY ? bounds.maxY : mask2.maxY;
      if (_minX <= _maxX && _minY <= _maxY) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        this.minX = _minX < minX ? _minX : minX;
        this.minY = _minY < minY ? _minY : minY;
        this.maxX = _maxX > maxX ? _maxX : maxX;
        this.maxY = _maxY > maxY ? _maxY : maxY;
      }
    };
    Bounds2.prototype.addBoundsMatrix = function(bounds, matrix) {
      this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
    };
    Bounds2.prototype.addBoundsArea = function(bounds, area2) {
      var _minX = bounds.minX > area2.x ? bounds.minX : area2.x;
      var _minY = bounds.minY > area2.y ? bounds.minY : area2.y;
      var _maxX = bounds.maxX < area2.x + area2.width ? bounds.maxX : area2.x + area2.width;
      var _maxY = bounds.maxY < area2.y + area2.height ? bounds.maxY : area2.y + area2.height;
      if (_minX <= _maxX && _minY <= _maxY) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        this.minX = _minX < minX ? _minX : minX;
        this.minY = _minY < minY ? _minY : minY;
        this.maxX = _maxX > maxX ? _maxX : maxX;
        this.maxY = _maxY > maxY ? _maxY : maxY;
      }
    };
    Bounds2.prototype.pad = function(paddingX, paddingY) {
      if (paddingX === void 0) {
        paddingX = 0;
      }
      if (paddingY === void 0) {
        paddingY = paddingX;
      }
      if (!this.isEmpty()) {
        this.minX -= paddingX;
        this.maxX += paddingX;
        this.minY -= paddingY;
        this.maxY += paddingY;
      }
    };
    Bounds2.prototype.addFramePad = function(x0, y0, x1, y1, padX, padY) {
      x0 -= padX;
      y0 -= padY;
      x1 += padX;
      y1 += padY;
      this.minX = this.minX < x0 ? this.minX : x0;
      this.maxX = this.maxX > x1 ? this.maxX : x1;
      this.minY = this.minY < y0 ? this.minY : y0;
      this.maxY = this.maxY > y1 ? this.maxY : y1;
    };
    return Bounds2;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$W = function(d2, b2) {
  extendStatics$W = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (b3.hasOwnProperty(p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$W(d2, b2);
};
function __extends$W(d2, b2) {
  extendStatics$W(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var DisplayObject$1 = (
  /** @class */
  function(_super) {
    __extends$W(DisplayObject2, _super);
    function DisplayObject2() {
      var _this = _super.call(this) || this;
      _this.tempDisplayObjectParent = null;
      _this.transform = new Transform();
      _this.alpha = 1;
      _this.visible = true;
      _this.renderable = true;
      _this.cullable = false;
      _this.cullArea = null;
      _this.parent = null;
      _this.worldAlpha = 1;
      _this._lastSortedIndex = 0;
      _this._zIndex = 0;
      _this.filterArea = null;
      _this.filters = null;
      _this._enabledFilters = null;
      _this._bounds = new Bounds$1();
      _this._localBounds = null;
      _this._boundsID = 0;
      _this._boundsRect = null;
      _this._localBoundsRect = null;
      _this._mask = null;
      _this._maskRefCount = 0;
      _this._destroyed = false;
      _this.isSprite = false;
      _this.isMask = false;
      return _this;
    }
    DisplayObject2.mixin = function(source) {
      var keys2 = Object.keys(source);
      for (var i2 = 0; i2 < keys2.length; ++i2) {
        var propertyName = keys2[i2];
        Object.defineProperty(DisplayObject2.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
      }
    };
    Object.defineProperty(DisplayObject2.prototype, "destroyed", {
      /**
       * Fired when this DisplayObject is added to a Container.
       * @instance
       * @event added
       * @param {PIXI.Container} container - The container added to.
       */
      /**
       * Fired when this DisplayObject is removed from a Container.
       * @instance
       * @event removed
       * @param {PIXI.Container} container - The container removed from.
       */
      /**
       * Fired when this DisplayObject is destroyed. This event is emitted once
       * destroy is finished.
       * @instance
       * @event destroyed
       */
      /** Readonly flag for destroyed display objects. */
      get: function() {
        return this._destroyed;
      },
      enumerable: false,
      configurable: true
    });
    DisplayObject2.prototype._recursivePostUpdateTransform = function() {
      if (this.parent) {
        this.parent._recursivePostUpdateTransform();
        this.transform.updateTransform(this.parent.transform);
      } else {
        this.transform.updateTransform(this._tempDisplayObjectParent.transform);
      }
    };
    DisplayObject2.prototype.updateTransform = function() {
      this._boundsID++;
      this.transform.updateTransform(this.parent.transform);
      this.worldAlpha = this.alpha * this.parent.worldAlpha;
    };
    DisplayObject2.prototype.getBounds = function(skipUpdate, rect) {
      if (!skipUpdate) {
        if (!this.parent) {
          this.parent = this._tempDisplayObjectParent;
          this.updateTransform();
          this.parent = null;
        } else {
          this._recursivePostUpdateTransform();
          this.updateTransform();
        }
      }
      if (this._bounds.updateID !== this._boundsID) {
        this.calculateBounds();
        this._bounds.updateID = this._boundsID;
      }
      if (!rect) {
        if (!this._boundsRect) {
          this._boundsRect = new Rectangle();
        }
        rect = this._boundsRect;
      }
      return this._bounds.getRectangle(rect);
    };
    DisplayObject2.prototype.getLocalBounds = function(rect) {
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new Rectangle();
        }
        rect = this._localBoundsRect;
      }
      if (!this._localBounds) {
        this._localBounds = new Bounds$1();
      }
      var transformRef = this.transform;
      var parentRef = this.parent;
      this.parent = null;
      this.transform = this._tempDisplayObjectParent.transform;
      var worldBounds = this._bounds;
      var worldBoundsID = this._boundsID;
      this._bounds = this._localBounds;
      var bounds = this.getBounds(false, rect);
      this.parent = parentRef;
      this.transform = transformRef;
      this._bounds = worldBounds;
      this._bounds.updateID += this._boundsID - worldBoundsID;
      return bounds;
    };
    DisplayObject2.prototype.toGlobal = function(position2, point, skipUpdate) {
      if (skipUpdate === void 0) {
        skipUpdate = false;
      }
      if (!skipUpdate) {
        this._recursivePostUpdateTransform();
        if (!this.parent) {
          this.parent = this._tempDisplayObjectParent;
          this.displayObjectUpdateTransform();
          this.parent = null;
        } else {
          this.displayObjectUpdateTransform();
        }
      }
      return this.worldTransform.apply(position2, point);
    };
    DisplayObject2.prototype.toLocal = function(position2, from2, point, skipUpdate) {
      if (from2) {
        position2 = from2.toGlobal(position2, point, skipUpdate);
      }
      if (!skipUpdate) {
        this._recursivePostUpdateTransform();
        if (!this.parent) {
          this.parent = this._tempDisplayObjectParent;
          this.displayObjectUpdateTransform();
          this.parent = null;
        } else {
          this.displayObjectUpdateTransform();
        }
      }
      return this.worldTransform.applyInverse(position2, point);
    };
    DisplayObject2.prototype.setParent = function(container2) {
      if (!container2 || !container2.addChild) {
        throw new Error("setParent: Argument must be a Container");
      }
      container2.addChild(this);
      return container2;
    };
    DisplayObject2.prototype.setTransform = function(x, y2, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {
      if (x === void 0) {
        x = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      if (scaleX === void 0) {
        scaleX = 1;
      }
      if (scaleY === void 0) {
        scaleY = 1;
      }
      if (rotation === void 0) {
        rotation = 0;
      }
      if (skewX === void 0) {
        skewX = 0;
      }
      if (skewY === void 0) {
        skewY = 0;
      }
      if (pivotX === void 0) {
        pivotX = 0;
      }
      if (pivotY === void 0) {
        pivotY = 0;
      }
      this.position.x = x;
      this.position.y = y2;
      this.scale.x = !scaleX ? 1 : scaleX;
      this.scale.y = !scaleY ? 1 : scaleY;
      this.rotation = rotation;
      this.skew.x = skewX;
      this.skew.y = skewY;
      this.pivot.x = pivotX;
      this.pivot.y = pivotY;
      return this;
    };
    DisplayObject2.prototype.destroy = function(_options) {
      if (this.parent) {
        this.parent.removeChild(this);
      }
      this._destroyed = true;
      this.transform = null;
      this.parent = null;
      this._bounds = null;
      this.mask = null;
      this.cullArea = null;
      this.filters = null;
      this.filterArea = null;
      this.hitArea = null;
      this.interactive = false;
      this.interactiveChildren = false;
      this.emit("destroyed");
      this.removeAllListeners();
    };
    Object.defineProperty(DisplayObject2.prototype, "_tempDisplayObjectParent", {
      /**
       * @protected
       * @member {PIXI.Container}
       */
      get: function() {
        if (this.tempDisplayObjectParent === null) {
          this.tempDisplayObjectParent = new TemporaryDisplayObject$1();
        }
        return this.tempDisplayObjectParent;
      },
      enumerable: false,
      configurable: true
    });
    DisplayObject2.prototype.enableTempParent = function() {
      var myParent = this.parent;
      this.parent = this._tempDisplayObjectParent;
      return myParent;
    };
    DisplayObject2.prototype.disableTempParent = function(cacheParent) {
      this.parent = cacheParent;
    };
    Object.defineProperty(DisplayObject2.prototype, "x", {
      /**
       * The position of the displayObject on the x axis relative to the local coordinates of the parent.
       * An alias to position.x
       */
      get: function() {
        return this.position.x;
      },
      set: function(value) {
        this.transform.position.x = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "y", {
      /**
       * The position of the displayObject on the y axis relative to the local coordinates of the parent.
       * An alias to position.y
       */
      get: function() {
        return this.position.y;
      },
      set: function(value) {
        this.transform.position.y = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "worldTransform", {
      /**
       * Current transform of the object based on world (parent) factors.
       * @readonly
       */
      get: function() {
        return this.transform.worldTransform;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "localTransform", {
      /**
       * Current transform of the object based on local factors: position, scale, other stuff.
       * @readonly
       */
      get: function() {
        return this.transform.localTransform;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "position", {
      /**
       * The coordinate of the object relative to the local coordinates of the parent.
       * @since 4.0.0
       */
      get: function() {
        return this.transform.position;
      },
      set: function(value) {
        this.transform.position.copyFrom(value);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "scale", {
      /**
       * The scale factors of this object along the local coordinate axes.
       *
       * The default scale is (1, 1).
       * @since 4.0.0
       */
      get: function() {
        return this.transform.scale;
      },
      set: function(value) {
        this.transform.scale.copyFrom(value);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "pivot", {
      /**
       * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
       * is the projection of `pivot` in the parent's local space.
       *
       * By default, the pivot is the origin (0, 0).
       * @since 4.0.0
       */
      get: function() {
        return this.transform.pivot;
      },
      set: function(value) {
        this.transform.pivot.copyFrom(value);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "skew", {
      /**
       * The skew factor for the object in radians.
       * @since 4.0.0
       */
      get: function() {
        return this.transform.skew;
      },
      set: function(value) {
        this.transform.skew.copyFrom(value);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "rotation", {
      /**
       * The rotation of the object in radians.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get: function() {
        return this.transform.rotation;
      },
      set: function(value) {
        this.transform.rotation = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "angle", {
      /**
       * The angle of the object in degrees.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get: function() {
        return this.transform.rotation * RAD_TO_DEG;
      },
      set: function(value) {
        this.transform.rotation = value * DEG_TO_RAD;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "zIndex", {
      /**
       * The zIndex of the displayObject.
       *
       * If a container has the sortableChildren property set to true, children will be automatically
       * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
       * and thus rendered on top of other display objects within the same container.
       * @see PIXI.Container#sortableChildren
       */
      get: function() {
        return this._zIndex;
      },
      set: function(value) {
        this._zIndex = value;
        if (this.parent) {
          this.parent.sortDirty = true;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "worldVisible", {
      /**
       * Indicates if the object is globally visible.
       * @readonly
       */
      get: function() {
        var item = this;
        do {
          if (!item.visible) {
            return false;
          }
          item = item.parent;
        } while (item);
        return true;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "mask", {
      /**
       * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
       * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
       * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it
       * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
       * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
       * To remove a mask, set this property to `null`.
       *
       * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
       * @example
       * const graphics = new PIXI.Graphics();
       * graphics.beginFill(0xFF3300);
       * graphics.drawRect(50, 250, 100, 100);
       * graphics.endFill();
       *
       * const sprite = new PIXI.Sprite(texture);
       * sprite.mask = graphics;
       * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
       */
      get: function() {
        return this._mask;
      },
      set: function(value) {
        if (this._mask === value) {
          return;
        }
        if (this._mask) {
          var maskObject = this._mask.maskObject || this._mask;
          maskObject._maskRefCount--;
          if (maskObject._maskRefCount === 0) {
            maskObject.renderable = true;
            maskObject.isMask = false;
          }
        }
        this._mask = value;
        if (this._mask) {
          var maskObject = this._mask.maskObject || this._mask;
          if (maskObject._maskRefCount === 0) {
            maskObject.renderable = false;
            maskObject.isMask = true;
          }
          maskObject._maskRefCount++;
        }
      },
      enumerable: false,
      configurable: true
    });
    return DisplayObject2;
  }(EventEmitter$1)
);
var TemporaryDisplayObject$1 = (
  /** @class */
  function(_super) {
    __extends$W(TemporaryDisplayObject2, _super);
    function TemporaryDisplayObject2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.sortDirty = null;
      return _this;
    }
    return TemporaryDisplayObject2;
  }(DisplayObject$1)
);
DisplayObject$1.prototype.displayObjectUpdateTransform = DisplayObject$1.prototype.updateTransform;
/*!
 * @pixi/constants - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$3;
(function(ENV2) {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
})(ENV$3 || (ENV$3 = {}));
var RENDERER_TYPE$3;
(function(RENDERER_TYPE2) {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE$3 || (RENDERER_TYPE$3 = {}));
var BUFFER_BITS$3;
(function(BUFFER_BITS2) {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS$3 || (BUFFER_BITS$3 = {}));
var BLEND_MODES$3;
(function(BLEND_MODES2) {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
})(BLEND_MODES$3 || (BLEND_MODES$3 = {}));
var DRAW_MODES$3;
(function(DRAW_MODES2) {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$3 || (DRAW_MODES$3 = {}));
var FORMATS$3;
(function(FORMATS2) {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS$3 || (FORMATS$3 = {}));
var TARGETS$3;
(function(TARGETS2) {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$3 || (TARGETS$3 = {}));
var TYPES$3;
(function(TYPES2) {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES$3 || (TYPES$3 = {}));
var SAMPLER_TYPES$3;
(function(SAMPLER_TYPES2) {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
})(SAMPLER_TYPES$3 || (SAMPLER_TYPES$3 = {}));
var SCALE_MODES$3;
(function(SCALE_MODES2) {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES$3 || (SCALE_MODES$3 = {}));
var WRAP_MODES$3;
(function(WRAP_MODES2) {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$3 || (WRAP_MODES$3 = {}));
var MIPMAP_MODES$3;
(function(MIPMAP_MODES2) {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
})(MIPMAP_MODES$3 || (MIPMAP_MODES$3 = {}));
var ALPHA_MODES$3;
(function(ALPHA_MODES2) {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$3 || (ALPHA_MODES$3 = {}));
var CLEAR_MODES$3;
(function(CLEAR_MODES2) {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES$3 || (CLEAR_MODES$3 = {}));
var GC_MODES$3;
(function(GC_MODES2) {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
})(GC_MODES$3 || (GC_MODES$3 = {}));
var PRECISION$3;
(function(PRECISION2) {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
})(PRECISION$3 || (PRECISION$3 = {}));
var MASK_TYPES$3;
(function(MASK_TYPES2) {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
})(MASK_TYPES$3 || (MASK_TYPES$3 = {}));
var MSAA_QUALITY$3;
(function(MSAA_QUALITY2) {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY$3 || (MSAA_QUALITY$3 = {}));
var BUFFER_TYPE$3;
(function(BUFFER_TYPE2) {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$3 || (BUFFER_TYPE$3 = {}));
function sortChildren$1(a2, b2) {
  if (a2.zIndex === b2.zIndex) {
    return a2._lastSortedIndex - b2._lastSortedIndex;
  }
  return a2.zIndex - b2.zIndex;
}
var Container$1 = (
  /** @class */
  function(_super) {
    __extends$W(Container2, _super);
    function Container2() {
      var _this = _super.call(this) || this;
      _this.children = [];
      _this.sortableChildren = settings$2.SORTABLE_CHILDREN;
      _this.sortDirty = false;
      return _this;
    }
    Container2.prototype.onChildrenChange = function(_length) {
    };
    Container2.prototype.addChild = function() {
      var arguments$1 = arguments;
      var children = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        children[_i] = arguments$1[_i];
      }
      if (children.length > 1) {
        for (var i2 = 0; i2 < children.length; i2++) {
          this.addChild(children[i2]);
        }
      } else {
        var child = children[0];
        if (child.parent) {
          child.parent.removeChild(child);
        }
        child.parent = this;
        this.sortDirty = true;
        child.transform._parentID = -1;
        this.children.push(child);
        this._boundsID++;
        this.onChildrenChange(this.children.length - 1);
        this.emit("childAdded", child, this, this.children.length - 1);
        child.emit("added", this);
      }
      return children[0];
    };
    Container2.prototype.addChildAt = function(child, index2) {
      if (index2 < 0 || index2 > this.children.length) {
        throw new Error(child + "addChildAt: The index " + index2 + " supplied is out of bounds " + this.children.length);
      }
      if (child.parent) {
        child.parent.removeChild(child);
      }
      child.parent = this;
      this.sortDirty = true;
      child.transform._parentID = -1;
      this.children.splice(index2, 0, child);
      this._boundsID++;
      this.onChildrenChange(index2);
      child.emit("added", this);
      this.emit("childAdded", child, this, index2);
      return child;
    };
    Container2.prototype.swapChildren = function(child, child2) {
      if (child === child2) {
        return;
      }
      var index1 = this.getChildIndex(child);
      var index2 = this.getChildIndex(child2);
      this.children[index1] = child2;
      this.children[index2] = child;
      this.onChildrenChange(index1 < index2 ? index1 : index2);
    };
    Container2.prototype.getChildIndex = function(child) {
      var index2 = this.children.indexOf(child);
      if (index2 === -1) {
        throw new Error("The supplied DisplayObject must be a child of the caller");
      }
      return index2;
    };
    Container2.prototype.setChildIndex = function(child, index2) {
      if (index2 < 0 || index2 >= this.children.length) {
        throw new Error("The index " + index2 + " supplied is out of bounds " + this.children.length);
      }
      var currentIndex = this.getChildIndex(child);
      removeItems(this.children, currentIndex, 1);
      this.children.splice(index2, 0, child);
      this.onChildrenChange(index2);
    };
    Container2.prototype.getChildAt = function(index2) {
      if (index2 < 0 || index2 >= this.children.length) {
        throw new Error("getChildAt: Index (" + index2 + ") does not exist.");
      }
      return this.children[index2];
    };
    Container2.prototype.removeChild = function() {
      var arguments$1 = arguments;
      var children = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        children[_i] = arguments$1[_i];
      }
      if (children.length > 1) {
        for (var i2 = 0; i2 < children.length; i2++) {
          this.removeChild(children[i2]);
        }
      } else {
        var child = children[0];
        var index2 = this.children.indexOf(child);
        if (index2 === -1) {
          return null;
        }
        child.parent = null;
        child.transform._parentID = -1;
        removeItems(this.children, index2, 1);
        this._boundsID++;
        this.onChildrenChange(index2);
        child.emit("removed", this);
        this.emit("childRemoved", child, this, index2);
      }
      return children[0];
    };
    Container2.prototype.removeChildAt = function(index2) {
      var child = this.getChildAt(index2);
      child.parent = null;
      child.transform._parentID = -1;
      removeItems(this.children, index2, 1);
      this._boundsID++;
      this.onChildrenChange(index2);
      child.emit("removed", this);
      this.emit("childRemoved", child, this, index2);
      return child;
    };
    Container2.prototype.removeChildren = function(beginIndex, endIndex) {
      if (beginIndex === void 0) {
        beginIndex = 0;
      }
      if (endIndex === void 0) {
        endIndex = this.children.length;
      }
      var begin = beginIndex;
      var end2 = endIndex;
      var range2 = end2 - begin;
      var removed;
      if (range2 > 0 && range2 <= end2) {
        removed = this.children.splice(begin, range2);
        for (var i2 = 0; i2 < removed.length; ++i2) {
          removed[i2].parent = null;
          if (removed[i2].transform) {
            removed[i2].transform._parentID = -1;
          }
        }
        this._boundsID++;
        this.onChildrenChange(beginIndex);
        for (var i2 = 0; i2 < removed.length; ++i2) {
          removed[i2].emit("removed", this);
          this.emit("childRemoved", removed[i2], this, i2);
        }
        return removed;
      } else if (range2 === 0 && this.children.length === 0) {
        return [];
      }
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    };
    Container2.prototype.sortChildren = function() {
      var sortRequired = false;
      for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
        var child = this.children[i2];
        child._lastSortedIndex = i2;
        if (!sortRequired && child.zIndex !== 0) {
          sortRequired = true;
        }
      }
      if (sortRequired && this.children.length > 1) {
        this.children.sort(sortChildren$1);
      }
      this.sortDirty = false;
    };
    Container2.prototype.updateTransform = function() {
      if (this.sortableChildren && this.sortDirty) {
        this.sortChildren();
      }
      this._boundsID++;
      this.transform.updateTransform(this.parent.transform);
      this.worldAlpha = this.alpha * this.parent.worldAlpha;
      for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
        var child = this.children[i2];
        if (child.visible) {
          child.updateTransform();
        }
      }
    };
    Container2.prototype.calculateBounds = function() {
      this._bounds.clear();
      this._calculateBounds();
      for (var i2 = 0; i2 < this.children.length; i2++) {
        var child = this.children[i2];
        if (!child.visible || !child.renderable) {
          continue;
        }
        child.calculateBounds();
        if (child._mask) {
          var maskObject = child._mask.maskObject || child._mask;
          maskObject.calculateBounds();
          this._bounds.addBoundsMask(child._bounds, maskObject._bounds);
        } else if (child.filterArea) {
          this._bounds.addBoundsArea(child._bounds, child.filterArea);
        } else {
          this._bounds.addBounds(child._bounds);
        }
      }
      this._bounds.updateID = this._boundsID;
    };
    Container2.prototype.getLocalBounds = function(rect, skipChildrenUpdate) {
      if (skipChildrenUpdate === void 0) {
        skipChildrenUpdate = false;
      }
      var result = _super.prototype.getLocalBounds.call(this, rect);
      if (!skipChildrenUpdate) {
        for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
          var child = this.children[i2];
          if (child.visible) {
            child.updateTransform();
          }
        }
      }
      return result;
    };
    Container2.prototype._calculateBounds = function() {
    };
    Container2.prototype._renderWithCulling = function(renderer) {
      var sourceFrame = renderer.renderTexture.sourceFrame;
      if (!(sourceFrame.width > 0 && sourceFrame.height > 0)) {
        return;
      }
      var bounds;
      var transform;
      if (this.cullArea) {
        bounds = this.cullArea;
        transform = this.worldTransform;
      } else if (this._render !== Container2.prototype._render) {
        bounds = this.getBounds(true);
      }
      if (bounds && sourceFrame.intersects(bounds, transform)) {
        this._render(renderer);
      } else if (this.cullArea) {
        return;
      }
      for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
        var child = this.children[i2];
        var childCullable = child.cullable;
        child.cullable = childCullable || !this.cullArea;
        child.render(renderer);
        child.cullable = childCullable;
      }
    };
    Container2.prototype.render = function(renderer) {
      if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
        return;
      }
      if (this._mask || this.filters && this.filters.length) {
        this.renderAdvanced(renderer);
      } else if (this.cullable) {
        this._renderWithCulling(renderer);
      } else {
        this._render(renderer);
        for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
          this.children[i2].render(renderer);
        }
      }
    };
    Container2.prototype.renderAdvanced = function(renderer) {
      var filters2 = this.filters;
      var mask2 = this._mask;
      if (filters2) {
        if (!this._enabledFilters) {
          this._enabledFilters = [];
        }
        this._enabledFilters.length = 0;
        for (var i2 = 0; i2 < filters2.length; i2++) {
          if (filters2[i2].enabled) {
            this._enabledFilters.push(filters2[i2]);
          }
        }
      }
      var flush = filters2 && this._enabledFilters && this._enabledFilters.length || mask2 && (!mask2.isMaskData || mask2.enabled && (mask2.autoDetect || mask2.type !== MASK_TYPES$3.NONE));
      if (flush) {
        renderer.batch.flush();
      }
      if (filters2 && this._enabledFilters && this._enabledFilters.length) {
        renderer.filter.push(this, this._enabledFilters);
      }
      if (mask2) {
        renderer.mask.push(this, this._mask);
      }
      if (this.cullable) {
        this._renderWithCulling(renderer);
      } else {
        this._render(renderer);
        for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
          this.children[i2].render(renderer);
        }
      }
      if (flush) {
        renderer.batch.flush();
      }
      if (mask2) {
        renderer.mask.pop(this);
      }
      if (filters2 && this._enabledFilters && this._enabledFilters.length) {
        renderer.filter.pop();
      }
    };
    Container2.prototype._render = function(_renderer) {
    };
    Container2.prototype.destroy = function(options) {
      _super.prototype.destroy.call(this);
      this.sortDirty = false;
      var destroyChildren = typeof options === "boolean" ? options : options && options.children;
      var oldChildren = this.removeChildren(0, this.children.length);
      if (destroyChildren) {
        for (var i2 = 0; i2 < oldChildren.length; ++i2) {
          oldChildren[i2].destroy(options);
        }
      }
    };
    Object.defineProperty(Container2.prototype, "width", {
      /** The width of the Container, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.scale.x * this.getLocalBounds().width;
      },
      set: function(value) {
        var width = this.getLocalBounds().width;
        if (width !== 0) {
          this.scale.x = value / width;
        } else {
          this.scale.x = 1;
        }
        this._width = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Container2.prototype, "height", {
      /** The height of the Container, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.scale.y * this.getLocalBounds().height;
      },
      set: function(value) {
        var height = this.getLocalBounds().height;
        if (height !== 0) {
          this.scale.y = value / height;
        } else {
          this.scale.y = 1;
        }
        this._height = value;
      },
      enumerable: false,
      configurable: true
    });
    return Container2;
  }(DisplayObject$1)
);
Container$1.prototype.containerUpdateTransform = Container$1.prototype.updateTransform;
/*!
 * @pixi/accessibility - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/accessibility is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var accessibleTarget = {
  /**
   *  Flag for if the object is accessible. If true AccessibilityManager will overlay a
   *   shadow div with attributes set
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  accessible: false,
  /**
   * Sets the title attribute of the shadow div
   * If accessibleTitle AND accessibleHint has not been this will default to 'displayObject [tabIndex]'
   * @member {?string}
   * @memberof PIXI.DisplayObject#
   */
  accessibleTitle: null,
  /**
   * Sets the aria-label attribute of the shadow div
   * @member {string}
   * @memberof PIXI.DisplayObject#
   */
  accessibleHint: null,
  /**
   * @member {number}
   * @memberof PIXI.DisplayObject#
   * @private
   * @todo Needs docs.
   */
  tabIndex: 0,
  /**
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @todo Needs docs.
   */
  _accessibleActive: false,
  /**
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @todo Needs docs.
   */
  _accessibleDiv: null,
  /**
   * Specify the type of div the accessible layer is. Screen readers treat the element differently
   * depending on this type. Defaults to button.
   * @member {string}
   * @memberof PIXI.DisplayObject#
   * @default 'button'
   */
  accessibleType: "button",
  /**
   * Specify the pointer-events the accessible div will use
   * Defaults to auto.
   * @member {string}
   * @memberof PIXI.DisplayObject#
   * @default 'auto'
   */
  accessiblePointerEvents: "auto",
  /**
   * Setting to false will prevent any children inside this container to
   * be accessible. Defaults to true.
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @default true
   */
  accessibleChildren: true,
  renderId: -1
};
DisplayObject$1.mixin(accessibleTarget);
var KEY_CODE_TAB = 9;
var DIV_TOUCH_SIZE = 100;
var DIV_TOUCH_POS_X = 0;
var DIV_TOUCH_POS_Y = 0;
var DIV_TOUCH_ZINDEX = 2;
var DIV_HOOK_SIZE = 1;
var DIV_HOOK_POS_X = -1e3;
var DIV_HOOK_POS_Y = -1e3;
var DIV_HOOK_ZINDEX = 2;
var AccessibilityManager = (
  /** @class */
  function() {
    function AccessibilityManager2(renderer) {
      this.debug = false;
      this._isActive = false;
      this._isMobileAccessibility = false;
      this.pool = [];
      this.renderId = 0;
      this.children = [];
      this.androidUpdateCount = 0;
      this.androidUpdateFrequency = 500;
      this._hookDiv = null;
      if (isMobile$2.tablet || isMobile$2.phone) {
        this.createTouchHook();
      }
      var div = document.createElement("div");
      div.style.width = DIV_TOUCH_SIZE + "px";
      div.style.height = DIV_TOUCH_SIZE + "px";
      div.style.position = "absolute";
      div.style.top = DIV_TOUCH_POS_X + "px";
      div.style.left = DIV_TOUCH_POS_Y + "px";
      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
      this.div = div;
      this.renderer = renderer;
      this._onKeyDown = this._onKeyDown.bind(this);
      this._onMouseMove = this._onMouseMove.bind(this);
      globalThis.addEventListener("keydown", this._onKeyDown, false);
    }
    Object.defineProperty(AccessibilityManager2.prototype, "isActive", {
      /**
       * Value of `true` if accessibility is currently active and accessibility layers are showing.
       * @member {boolean}
       * @readonly
       */
      get: function() {
        return this._isActive;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(AccessibilityManager2.prototype, "isMobileAccessibility", {
      /**
       * Value of `true` if accessibility is enabled for touch devices.
       * @member {boolean}
       * @readonly
       */
      get: function() {
        return this._isMobileAccessibility;
      },
      enumerable: false,
      configurable: true
    });
    AccessibilityManager2.prototype.createTouchHook = function() {
      var _this = this;
      var hookDiv = document.createElement("button");
      hookDiv.style.width = DIV_HOOK_SIZE + "px";
      hookDiv.style.height = DIV_HOOK_SIZE + "px";
      hookDiv.style.position = "absolute";
      hookDiv.style.top = DIV_HOOK_POS_X + "px";
      hookDiv.style.left = DIV_HOOK_POS_Y + "px";
      hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
      hookDiv.style.backgroundColor = "#FF0000";
      hookDiv.title = "select to enable accessibility for this content";
      hookDiv.addEventListener("focus", function() {
        _this._isMobileAccessibility = true;
        _this.activate();
        _this.destroyTouchHook();
      });
      document.body.appendChild(hookDiv);
      this._hookDiv = hookDiv;
    };
    AccessibilityManager2.prototype.destroyTouchHook = function() {
      if (!this._hookDiv) {
        return;
      }
      document.body.removeChild(this._hookDiv);
      this._hookDiv = null;
    };
    AccessibilityManager2.prototype.activate = function() {
      var _a2;
      if (this._isActive) {
        return;
      }
      this._isActive = true;
      globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
      globalThis.removeEventListener("keydown", this._onKeyDown, false);
      this.renderer.on("postrender", this.update, this);
      (_a2 = this.renderer.view.parentNode) === null || _a2 === void 0 ? void 0 : _a2.appendChild(this.div);
    };
    AccessibilityManager2.prototype.deactivate = function() {
      var _a2;
      if (!this._isActive || this._isMobileAccessibility) {
        return;
      }
      this._isActive = false;
      globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
      globalThis.addEventListener("keydown", this._onKeyDown, false);
      this.renderer.off("postrender", this.update);
      (_a2 = this.div.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(this.div);
    };
    AccessibilityManager2.prototype.updateAccessibleObjects = function(displayObject) {
      if (!displayObject.visible || !displayObject.accessibleChildren) {
        return;
      }
      if (displayObject.accessible && displayObject.interactive) {
        if (!displayObject._accessibleActive) {
          this.addChild(displayObject);
        }
        displayObject.renderId = this.renderId;
      }
      var children = displayObject.children;
      if (children) {
        for (var i2 = 0; i2 < children.length; i2++) {
          this.updateAccessibleObjects(children[i2]);
        }
      }
    };
    AccessibilityManager2.prototype.update = function() {
      var now2 = performance.now();
      if (isMobile$2.android.device && now2 < this.androidUpdateCount) {
        return;
      }
      this.androidUpdateCount = now2 + this.androidUpdateFrequency;
      if (!this.renderer.renderingToScreen) {
        return;
      }
      if (this.renderer._lastObjectRendered) {
        this.updateAccessibleObjects(this.renderer._lastObjectRendered);
      }
      var _a2 = this.renderer.view.getBoundingClientRect(), left = _a2.left, top = _a2.top, width = _a2.width, height = _a2.height;
      var _b2 = this.renderer, viewWidth = _b2.width, viewHeight = _b2.height, resolution = _b2.resolution;
      var sx = width / viewWidth * resolution;
      var sy = height / viewHeight * resolution;
      var div = this.div;
      div.style.left = left + "px";
      div.style.top = top + "px";
      div.style.width = viewWidth + "px";
      div.style.height = viewHeight + "px";
      for (var i2 = 0; i2 < this.children.length; i2++) {
        var child = this.children[i2];
        if (child.renderId !== this.renderId) {
          child._accessibleActive = false;
          removeItems(this.children, i2, 1);
          this.div.removeChild(child._accessibleDiv);
          this.pool.push(child._accessibleDiv);
          child._accessibleDiv = null;
          i2--;
        } else {
          div = child._accessibleDiv;
          var hitArea = child.hitArea;
          var wt = child.worldTransform;
          if (child.hitArea) {
            div.style.left = (wt.tx + hitArea.x * wt.a) * sx + "px";
            div.style.top = (wt.ty + hitArea.y * wt.d) * sy + "px";
            div.style.width = hitArea.width * wt.a * sx + "px";
            div.style.height = hitArea.height * wt.d * sy + "px";
          } else {
            hitArea = child.getBounds();
            this.capHitArea(hitArea);
            div.style.left = hitArea.x * sx + "px";
            div.style.top = hitArea.y * sy + "px";
            div.style.width = hitArea.width * sx + "px";
            div.style.height = hitArea.height * sy + "px";
            if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
              div.title = child.accessibleTitle;
            }
            if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
              div.setAttribute("aria-label", child.accessibleHint);
            }
          }
          if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
            div.title = child.accessibleTitle;
            div.tabIndex = child.tabIndex;
            if (this.debug) {
              this.updateDebugHTML(div);
            }
          }
        }
      }
      this.renderId++;
    };
    AccessibilityManager2.prototype.updateDebugHTML = function(div) {
      div.innerHTML = "type: " + div.type + "</br> title : " + div.title + "</br> tabIndex: " + div.tabIndex;
    };
    AccessibilityManager2.prototype.capHitArea = function(hitArea) {
      if (hitArea.x < 0) {
        hitArea.width += hitArea.x;
        hitArea.x = 0;
      }
      if (hitArea.y < 0) {
        hitArea.height += hitArea.y;
        hitArea.y = 0;
      }
      var _a2 = this.renderer, viewWidth = _a2.width, viewHeight = _a2.height;
      if (hitArea.x + hitArea.width > viewWidth) {
        hitArea.width = viewWidth - hitArea.x;
      }
      if (hitArea.y + hitArea.height > viewHeight) {
        hitArea.height = viewHeight - hitArea.y;
      }
    };
    AccessibilityManager2.prototype.addChild = function(displayObject) {
      var div = this.pool.pop();
      if (!div) {
        div = document.createElement("button");
        div.style.width = DIV_TOUCH_SIZE + "px";
        div.style.height = DIV_TOUCH_SIZE + "px";
        div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
        div.style.position = "absolute";
        div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
        div.style.borderStyle = "none";
        if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
          div.setAttribute("aria-live", "off");
        } else {
          div.setAttribute("aria-live", "polite");
        }
        if (navigator.userAgent.match(/rv:.*Gecko\//)) {
          div.setAttribute("aria-relevant", "additions");
        } else {
          div.setAttribute("aria-relevant", "text");
        }
        div.addEventListener("click", this._onClick.bind(this));
        div.addEventListener("focus", this._onFocus.bind(this));
        div.addEventListener("focusout", this._onFocusOut.bind(this));
      }
      div.style.pointerEvents = displayObject.accessiblePointerEvents;
      div.type = displayObject.accessibleType;
      if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
        div.title = displayObject.accessibleTitle;
      } else if (!displayObject.accessibleHint || displayObject.accessibleHint === null) {
        div.title = "displayObject " + displayObject.tabIndex;
      }
      if (displayObject.accessibleHint && displayObject.accessibleHint !== null) {
        div.setAttribute("aria-label", displayObject.accessibleHint);
      }
      if (this.debug) {
        this.updateDebugHTML(div);
      }
      displayObject._accessibleActive = true;
      displayObject._accessibleDiv = div;
      div.displayObject = displayObject;
      this.children.push(displayObject);
      this.div.appendChild(displayObject._accessibleDiv);
      displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
    };
    AccessibilityManager2.prototype._onClick = function(e2) {
      var interactionManager = this.renderer.plugins.interaction;
      var displayObject = e2.target.displayObject;
      var eventData = interactionManager.eventData;
      interactionManager.dispatchEvent(displayObject, "click", eventData);
      interactionManager.dispatchEvent(displayObject, "pointertap", eventData);
      interactionManager.dispatchEvent(displayObject, "tap", eventData);
    };
    AccessibilityManager2.prototype._onFocus = function(e2) {
      if (!e2.target.getAttribute("aria-live")) {
        e2.target.setAttribute("aria-live", "assertive");
      }
      var interactionManager = this.renderer.plugins.interaction;
      var displayObject = e2.target.displayObject;
      var eventData = interactionManager.eventData;
      interactionManager.dispatchEvent(displayObject, "mouseover", eventData);
    };
    AccessibilityManager2.prototype._onFocusOut = function(e2) {
      if (!e2.target.getAttribute("aria-live")) {
        e2.target.setAttribute("aria-live", "polite");
      }
      var interactionManager = this.renderer.plugins.interaction;
      var displayObject = e2.target.displayObject;
      var eventData = interactionManager.eventData;
      interactionManager.dispatchEvent(displayObject, "mouseout", eventData);
    };
    AccessibilityManager2.prototype._onKeyDown = function(e2) {
      if (e2.keyCode !== KEY_CODE_TAB) {
        return;
      }
      this.activate();
    };
    AccessibilityManager2.prototype._onMouseMove = function(e2) {
      if (e2.movementX === 0 && e2.movementY === 0) {
        return;
      }
      this.deactivate();
    };
    AccessibilityManager2.prototype.destroy = function() {
      this.destroyTouchHook();
      this.div = null;
      globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
      globalThis.removeEventListener("keydown", this._onKeyDown);
      this.pool = null;
      this.children = null;
      this.renderer = null;
    };
    return AccessibilityManager2;
  }()
);
/*!
 * @pixi/ticker - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/ticker is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings$2.TARGET_FPMS = 0.06;
var UPDATE_PRIORITY;
(function(UPDATE_PRIORITY2) {
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
})(UPDATE_PRIORITY || (UPDATE_PRIORITY = {}));
var TickerListener = (
  /** @class */
  function() {
    function TickerListener2(fn2, context2, priority, once) {
      if (context2 === void 0) {
        context2 = null;
      }
      if (priority === void 0) {
        priority = 0;
      }
      if (once === void 0) {
        once = false;
      }
      this.next = null;
      this.previous = null;
      this._destroyed = false;
      this.fn = fn2;
      this.context = context2;
      this.priority = priority;
      this.once = once;
    }
    TickerListener2.prototype.match = function(fn2, context2) {
      if (context2 === void 0) {
        context2 = null;
      }
      return this.fn === fn2 && this.context === context2;
    };
    TickerListener2.prototype.emit = function(deltaTime) {
      if (this.fn) {
        if (this.context) {
          this.fn.call(this.context, deltaTime);
        } else {
          this.fn(deltaTime);
        }
      }
      var redirect = this.next;
      if (this.once) {
        this.destroy(true);
      }
      if (this._destroyed) {
        this.next = null;
      }
      return redirect;
    };
    TickerListener2.prototype.connect = function(previous) {
      this.previous = previous;
      if (previous.next) {
        previous.next.previous = this;
      }
      this.next = previous.next;
      previous.next = this;
    };
    TickerListener2.prototype.destroy = function(hard) {
      if (hard === void 0) {
        hard = false;
      }
      this._destroyed = true;
      this.fn = null;
      this.context = null;
      if (this.previous) {
        this.previous.next = this.next;
      }
      if (this.next) {
        this.next.previous = this.previous;
      }
      var redirect = this.next;
      this.next = hard ? null : redirect;
      this.previous = null;
      return redirect;
    };
    return TickerListener2;
  }()
);
var Ticker = (
  /** @class */
  function() {
    function Ticker2() {
      var _this = this;
      this.autoStart = false;
      this.deltaTime = 1;
      this.lastTime = -1;
      this.speed = 1;
      this.started = false;
      this._requestId = null;
      this._maxElapsedMS = 100;
      this._minElapsedMS = 0;
      this._protected = false;
      this._lastFrame = -1;
      this._head = new TickerListener(null, null, Infinity);
      this.deltaMS = 1 / settings$2.TARGET_FPMS;
      this.elapsedMS = 1 / settings$2.TARGET_FPMS;
      this._tick = function(time) {
        _this._requestId = null;
        if (_this.started) {
          _this.update(time);
          if (_this.started && _this._requestId === null && _this._head.next) {
            _this._requestId = requestAnimationFrame(_this._tick);
          }
        }
      };
    }
    Ticker2.prototype._requestIfNeeded = function() {
      if (this._requestId === null && this._head.next) {
        this.lastTime = performance.now();
        this._lastFrame = this.lastTime;
        this._requestId = requestAnimationFrame(this._tick);
      }
    };
    Ticker2.prototype._cancelIfNeeded = function() {
      if (this._requestId !== null) {
        cancelAnimationFrame(this._requestId);
        this._requestId = null;
      }
    };
    Ticker2.prototype._startIfPossible = function() {
      if (this.started) {
        this._requestIfNeeded();
      } else if (this.autoStart) {
        this.start();
      }
    };
    Ticker2.prototype.add = function(fn2, context2, priority) {
      if (priority === void 0) {
        priority = UPDATE_PRIORITY.NORMAL;
      }
      return this._addListener(new TickerListener(fn2, context2, priority));
    };
    Ticker2.prototype.addOnce = function(fn2, context2, priority) {
      if (priority === void 0) {
        priority = UPDATE_PRIORITY.NORMAL;
      }
      return this._addListener(new TickerListener(fn2, context2, priority, true));
    };
    Ticker2.prototype._addListener = function(listener) {
      var current = this._head.next;
      var previous = this._head;
      if (!current) {
        listener.connect(previous);
      } else {
        while (current) {
          if (listener.priority > current.priority) {
            listener.connect(previous);
            break;
          }
          previous = current;
          current = current.next;
        }
        if (!listener.previous) {
          listener.connect(previous);
        }
      }
      this._startIfPossible();
      return this;
    };
    Ticker2.prototype.remove = function(fn2, context2) {
      var listener = this._head.next;
      while (listener) {
        if (listener.match(fn2, context2)) {
          listener = listener.destroy();
        } else {
          listener = listener.next;
        }
      }
      if (!this._head.next) {
        this._cancelIfNeeded();
      }
      return this;
    };
    Object.defineProperty(Ticker2.prototype, "count", {
      /**
       * The number of listeners on this ticker, calculated by walking through linked list
       * @readonly
       * @member {number}
       */
      get: function() {
        if (!this._head) {
          return 0;
        }
        var count = 0;
        var current = this._head;
        while (current = current.next) {
          count++;
        }
        return count;
      },
      enumerable: false,
      configurable: true
    });
    Ticker2.prototype.start = function() {
      if (!this.started) {
        this.started = true;
        this._requestIfNeeded();
      }
    };
    Ticker2.prototype.stop = function() {
      if (this.started) {
        this.started = false;
        this._cancelIfNeeded();
      }
    };
    Ticker2.prototype.destroy = function() {
      if (!this._protected) {
        this.stop();
        var listener = this._head.next;
        while (listener) {
          listener = listener.destroy(true);
        }
        this._head.destroy();
        this._head = null;
      }
    };
    Ticker2.prototype.update = function(currentTime) {
      if (currentTime === void 0) {
        currentTime = performance.now();
      }
      var elapsedMS;
      if (currentTime > this.lastTime) {
        elapsedMS = this.elapsedMS = currentTime - this.lastTime;
        if (elapsedMS > this._maxElapsedMS) {
          elapsedMS = this._maxElapsedMS;
        }
        elapsedMS *= this.speed;
        if (this._minElapsedMS) {
          var delta = currentTime - this._lastFrame | 0;
          if (delta < this._minElapsedMS) {
            return;
          }
          this._lastFrame = currentTime - delta % this._minElapsedMS;
        }
        this.deltaMS = elapsedMS;
        this.deltaTime = this.deltaMS * settings$2.TARGET_FPMS;
        var head = this._head;
        var listener = head.next;
        while (listener) {
          listener = listener.emit(this.deltaTime);
        }
        if (!head.next) {
          this._cancelIfNeeded();
        }
      } else {
        this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      }
      this.lastTime = currentTime;
    };
    Object.defineProperty(Ticker2.prototype, "FPS", {
      /**
       * The frames per second at which this ticker is running.
       * The default is approximately 60 in most modern browsers.
       * **Note:** This does not factor in the value of
       * {@link PIXI.Ticker#speed}, which is specific
       * to scaling {@link PIXI.Ticker#deltaTime}.
       * @member {number}
       * @readonly
       */
      get: function() {
        return 1e3 / this.elapsedMS;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Ticker2.prototype, "minFPS", {
      /**
       * Manages the maximum amount of milliseconds allowed to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This value is used to cap {@link PIXI.Ticker#deltaTime},
       * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
       * When setting this property it is clamped to a value between
       * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
       * @member {number}
       * @default 10
       */
      get: function() {
        return 1e3 / this._maxElapsedMS;
      },
      set: function(fps) {
        var minFPS = Math.min(this.maxFPS, fps);
        var minFPMS = Math.min(Math.max(0, minFPS) / 1e3, settings$2.TARGET_FPMS);
        this._maxElapsedMS = 1 / minFPMS;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Ticker2.prototype, "maxFPS", {
      /**
       * Manages the minimum amount of milliseconds required to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This will effect the measured value of {@link PIXI.Ticker#FPS}.
       * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
       * Otherwise it will be at least `minFPS`
       * @member {number}
       * @default 0
       */
      get: function() {
        if (this._minElapsedMS) {
          return Math.round(1e3 / this._minElapsedMS);
        }
        return 0;
      },
      set: function(fps) {
        if (fps === 0) {
          this._minElapsedMS = 0;
        } else {
          var maxFPS = Math.max(this.minFPS, fps);
          this._minElapsedMS = 1 / (maxFPS / 1e3);
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Ticker2, "shared", {
      /**
       * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
       * {@link PIXI.VideoResource} to update animation frames / video textures.
       *
       * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
       * @example
       * let ticker = PIXI.Ticker.shared;
       * // Set this to prevent starting this ticker when listeners are added.
       * // By default this is true only for the PIXI.Ticker.shared instance.
       * ticker.autoStart = false;
       * // FYI, call this to ensure the ticker is stopped. It should be stopped
       * // if you have not attempted to render anything yet.
       * ticker.stop();
       * // Call this when you are ready for a running shared ticker.
       * ticker.start();
       * @example
       * // You may use the shared ticker to render...
       * let renderer = PIXI.autoDetectRenderer();
       * let stage = new PIXI.Container();
       * document.body.appendChild(renderer.view);
       * ticker.add(function (time) {
       *     renderer.render(stage);
       * });
       * @example
       * // Or you can just update it manually.
       * ticker.autoStart = false;
       * ticker.stop();
       * function animate(time) {
       *     ticker.update(time);
       *     renderer.render(stage);
       *     requestAnimationFrame(animate);
       * }
       * animate(performance.now());
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!Ticker2._shared) {
          var shared = Ticker2._shared = new Ticker2();
          shared.autoStart = true;
          shared._protected = true;
        }
        return Ticker2._shared;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Ticker2, "system", {
      /**
       * The system ticker instance used by {@link PIXI.InteractionManager} and by
       * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,
       * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!Ticker2._system) {
          var system = Ticker2._system = new Ticker2();
          system.autoStart = true;
          system._protected = true;
        }
        return Ticker2._system;
      },
      enumerable: false,
      configurable: true
    });
    return Ticker2;
  }()
);
var TickerPlugin = (
  /** @class */
  function() {
    function TickerPlugin2() {
    }
    TickerPlugin2.init = function(options) {
      var _this = this;
      options = Object.assign({
        autoStart: true,
        sharedTicker: false
      }, options);
      Object.defineProperty(this, "ticker", {
        set: function(ticker) {
          if (this._ticker) {
            this._ticker.remove(this.render, this);
          }
          this._ticker = ticker;
          if (ticker) {
            ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
          }
        },
        get: function() {
          return this._ticker;
        }
      });
      this.stop = function() {
        _this._ticker.stop();
      };
      this.start = function() {
        _this._ticker.start();
      };
      this._ticker = null;
      this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
      if (options.autoStart) {
        this.start();
      }
    };
    TickerPlugin2.destroy = function() {
      if (this._ticker) {
        var oldTicker = this._ticker;
        this.ticker = null;
        oldTicker.destroy();
      }
    };
    return TickerPlugin2;
  }()
);
/*!
 * @pixi/interaction - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/interaction is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var InteractionData = (
  /** @class */
  function() {
    function InteractionData2() {
      this.pressure = 0;
      this.rotationAngle = 0;
      this.twist = 0;
      this.tangentialPressure = 0;
      this.global = new Point();
      this.target = null;
      this.originalEvent = null;
      this.identifier = null;
      this.isPrimary = false;
      this.button = 0;
      this.buttons = 0;
      this.width = 0;
      this.height = 0;
      this.tiltX = 0;
      this.tiltY = 0;
      this.pointerType = null;
      this.pressure = 0;
      this.rotationAngle = 0;
      this.twist = 0;
      this.tangentialPressure = 0;
    }
    Object.defineProperty(InteractionData2.prototype, "pointerId", {
      /**
       * The unique identifier of the pointer. It will be the same as `identifier`.
       * @readonly
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId
       */
      get: function() {
        return this.identifier;
      },
      enumerable: false,
      configurable: true
    });
    InteractionData2.prototype.getLocalPosition = function(displayObject, point, globalPos) {
      return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
    };
    InteractionData2.prototype.copyEvent = function(event) {
      if ("isPrimary" in event && event.isPrimary) {
        this.isPrimary = true;
      }
      this.button = "button" in event && event.button;
      var buttons = "buttons" in event && event.buttons;
      this.buttons = Number.isInteger(buttons) ? buttons : "which" in event && event.which;
      this.width = "width" in event && event.width;
      this.height = "height" in event && event.height;
      this.tiltX = "tiltX" in event && event.tiltX;
      this.tiltY = "tiltY" in event && event.tiltY;
      this.pointerType = "pointerType" in event && event.pointerType;
      this.pressure = "pressure" in event && event.pressure;
      this.rotationAngle = "rotationAngle" in event && event.rotationAngle;
      this.twist = "twist" in event && event.twist || 0;
      this.tangentialPressure = "tangentialPressure" in event && event.tangentialPressure || 0;
    };
    InteractionData2.prototype.reset = function() {
      this.isPrimary = false;
    };
    return InteractionData2;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$V = function(d2, b2) {
  extendStatics$V = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (b3.hasOwnProperty(p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$V(d2, b2);
};
function __extends$V(d2, b2) {
  extendStatics$V(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var InteractionEvent = (
  /** @class */
  function() {
    function InteractionEvent2() {
      this.stopped = false;
      this.stopsPropagatingAt = null;
      this.stopPropagationHint = false;
      this.target = null;
      this.currentTarget = null;
      this.type = null;
      this.data = null;
    }
    InteractionEvent2.prototype.stopPropagation = function() {
      this.stopped = true;
      this.stopPropagationHint = true;
      this.stopsPropagatingAt = this.currentTarget;
    };
    InteractionEvent2.prototype.reset = function() {
      this.stopped = false;
      this.stopsPropagatingAt = null;
      this.stopPropagationHint = false;
      this.currentTarget = null;
      this.target = null;
    };
    return InteractionEvent2;
  }()
);
var InteractionTrackingData = (
  /** @class */
  function() {
    function InteractionTrackingData2(pointerId) {
      this._pointerId = pointerId;
      this._flags = InteractionTrackingData2.FLAGS.NONE;
    }
    InteractionTrackingData2.prototype._doSet = function(flag, yn) {
      if (yn) {
        this._flags = this._flags | flag;
      } else {
        this._flags = this._flags & ~flag;
      }
    };
    Object.defineProperty(InteractionTrackingData2.prototype, "pointerId", {
      /**
       * Unique pointer id of the event
       * @readonly
       * @private
       * @member {number}
       */
      get: function() {
        return this._pointerId;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(InteractionTrackingData2.prototype, "flags", {
      /**
       * State of the tracking data, expressed as bit flags
       * @private
       * @member {number}
       */
      get: function() {
        return this._flags;
      },
      set: function(flags) {
        this._flags = flags;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(InteractionTrackingData2.prototype, "none", {
      /**
       * Is the tracked event inactive (not over or down)?
       * @private
       * @member {number}
       */
      get: function() {
        return this._flags === InteractionTrackingData2.FLAGS.NONE;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(InteractionTrackingData2.prototype, "over", {
      /**
       * Is the tracked event over the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & InteractionTrackingData2.FLAGS.OVER) !== 0;
      },
      set: function(yn) {
        this._doSet(InteractionTrackingData2.FLAGS.OVER, yn);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(InteractionTrackingData2.prototype, "rightDown", {
      /**
       * Did the right mouse button come down in the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & InteractionTrackingData2.FLAGS.RIGHT_DOWN) !== 0;
      },
      set: function(yn) {
        this._doSet(InteractionTrackingData2.FLAGS.RIGHT_DOWN, yn);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(InteractionTrackingData2.prototype, "leftDown", {
      /**
       * Did the left mouse button come down in the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & InteractionTrackingData2.FLAGS.LEFT_DOWN) !== 0;
      },
      set: function(yn) {
        this._doSet(InteractionTrackingData2.FLAGS.LEFT_DOWN, yn);
      },
      enumerable: false,
      configurable: true
    });
    InteractionTrackingData2.FLAGS = Object.freeze({
      NONE: 0,
      OVER: 1 << 0,
      LEFT_DOWN: 1 << 1,
      RIGHT_DOWN: 1 << 2
    });
    return InteractionTrackingData2;
  }()
);
var TreeSearch = (
  /** @class */
  function() {
    function TreeSearch2() {
      this._tempPoint = new Point();
    }
    TreeSearch2.prototype.recursiveFindHit = function(interactionEvent, displayObject, func, hitTest, interactive) {
      if (!displayObject || !displayObject.visible) {
        return false;
      }
      var point = interactionEvent.data.global;
      interactive = displayObject.interactive || interactive;
      var hit = false;
      var interactiveParent = interactive;
      var hitTestChildren = true;
      if (displayObject.hitArea) {
        if (hitTest) {
          displayObject.worldTransform.applyInverse(point, this._tempPoint);
          if (!displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) {
            hitTest = false;
            hitTestChildren = false;
          } else {
            hit = true;
          }
        }
        interactiveParent = false;
      } else if (displayObject._mask) {
        if (hitTest) {
          if (!(displayObject._mask.containsPoint && displayObject._mask.containsPoint(point))) {
            hitTest = false;
          }
        }
      }
      if (hitTestChildren && displayObject.interactiveChildren && displayObject.children) {
        var children = displayObject.children;
        for (var i2 = children.length - 1; i2 >= 0; i2--) {
          var child = children[i2];
          var childHit = this.recursiveFindHit(interactionEvent, child, func, hitTest, interactiveParent);
          if (childHit) {
            if (!child.parent) {
              continue;
            }
            interactiveParent = false;
            if (childHit) {
              if (interactionEvent.target) {
                hitTest = false;
              }
              hit = true;
            }
          }
        }
      }
      if (interactive) {
        if (hitTest && !interactionEvent.target) {
          if (!displayObject.hitArea && displayObject.containsPoint) {
            if (displayObject.containsPoint(point)) {
              hit = true;
            }
          }
        }
        if (displayObject.interactive) {
          if (hit && !interactionEvent.target) {
            interactionEvent.target = displayObject;
          }
          if (func) {
            func(interactionEvent, displayObject, !!hit);
          }
        }
      }
      return hit;
    };
    TreeSearch2.prototype.findHit = function(interactionEvent, displayObject, func, hitTest) {
      this.recursiveFindHit(interactionEvent, displayObject, func, hitTest, false);
    };
    return TreeSearch2;
  }()
);
var interactiveTarget = {
  interactive: false,
  interactiveChildren: true,
  hitArea: null,
  /**
   * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive
   * Setting this changes the 'cursor' property to `'pointer'`.
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.buttonMode = true;
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  get buttonMode() {
    return this.cursor === "pointer";
  },
  set buttonMode(value) {
    if (value) {
      this.cursor = "pointer";
    } else if (this.cursor === "pointer") {
      this.cursor = null;
    }
  },
  /**
   * This defines what cursor mode is used when the mouse cursor
   * is hovered over the displayObject.
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.cursor = 'wait';
   * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor
   * @member {string}
   * @memberof PIXI.DisplayObject#
   */
  cursor: null,
  /**
   * Internal set of all active pointers, by identifier
   * @member {Map<number, InteractionTrackingData>}
   * @memberof PIXI.DisplayObject#
   * @private
   */
  get trackedPointers() {
    if (this._trackedPointers === void 0) {
      this._trackedPointers = {};
    }
    return this._trackedPointers;
  },
  /**
   * Map of all tracked pointers, by identifier. Use trackedPointers to access.
   * @private
   * @type {Map<number, InteractionTrackingData>}
   */
  _trackedPointers: void 0
};
DisplayObject$1.mixin(interactiveTarget);
var MOUSE_POINTER_ID = 1;
var hitTestEvent = {
  target: null,
  data: {
    global: null
  }
};
var InteractionManager = (
  /** @class */
  function(_super) {
    __extends$V(InteractionManager2, _super);
    function InteractionManager2(renderer, options) {
      var _this = _super.call(this) || this;
      options = options || {};
      _this.renderer = renderer;
      _this.autoPreventDefault = options.autoPreventDefault !== void 0 ? options.autoPreventDefault : true;
      _this.interactionFrequency = options.interactionFrequency || 10;
      _this.mouse = new InteractionData();
      _this.mouse.identifier = MOUSE_POINTER_ID;
      _this.mouse.global.set(-999999);
      _this.activeInteractionData = {};
      _this.activeInteractionData[MOUSE_POINTER_ID] = _this.mouse;
      _this.interactionDataPool = [];
      _this.eventData = new InteractionEvent();
      _this.interactionDOMElement = null;
      _this.moveWhenInside = false;
      _this.eventsAdded = false;
      _this.tickerAdded = false;
      _this.mouseOverRenderer = !("PointerEvent" in globalThis);
      _this.supportsTouchEvents = "ontouchstart" in globalThis;
      _this.supportsPointerEvents = !!globalThis.PointerEvent;
      _this.onPointerUp = _this.onPointerUp.bind(_this);
      _this.processPointerUp = _this.processPointerUp.bind(_this);
      _this.onPointerCancel = _this.onPointerCancel.bind(_this);
      _this.processPointerCancel = _this.processPointerCancel.bind(_this);
      _this.onPointerDown = _this.onPointerDown.bind(_this);
      _this.processPointerDown = _this.processPointerDown.bind(_this);
      _this.onPointerMove = _this.onPointerMove.bind(_this);
      _this.processPointerMove = _this.processPointerMove.bind(_this);
      _this.onPointerOut = _this.onPointerOut.bind(_this);
      _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);
      _this.onPointerOver = _this.onPointerOver.bind(_this);
      _this.cursorStyles = {
        default: "inherit",
        pointer: "pointer"
      };
      _this.currentCursorMode = null;
      _this.cursor = null;
      _this.resolution = 1;
      _this.delayedEvents = [];
      _this.search = new TreeSearch();
      _this._tempDisplayObject = new TemporaryDisplayObject$1();
      _this._eventListenerOptions = { capture: true, passive: false };
      _this._useSystemTicker = options.useSystemTicker !== void 0 ? options.useSystemTicker : true;
      _this.setTargetElement(_this.renderer.view, _this.renderer.resolution);
      return _this;
    }
    Object.defineProperty(InteractionManager2.prototype, "useSystemTicker", {
      /**
       * Should the InteractionManager automatically add {@link tickerUpdate} to {@link PIXI.Ticker.system}.
       * @default true
       */
      get: function() {
        return this._useSystemTicker;
      },
      set: function(useSystemTicker) {
        this._useSystemTicker = useSystemTicker;
        if (useSystemTicker) {
          this.addTickerListener();
        } else {
          this.removeTickerListener();
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(InteractionManager2.prototype, "lastObjectRendered", {
      /**
       * Last rendered object or temp object.
       * @readonly
       * @protected
       */
      get: function() {
        return this.renderer._lastObjectRendered || this._tempDisplayObject;
      },
      enumerable: false,
      configurable: true
    });
    InteractionManager2.prototype.hitTest = function(globalPoint, root2) {
      hitTestEvent.target = null;
      hitTestEvent.data.global = globalPoint;
      if (!root2) {
        root2 = this.lastObjectRendered;
      }
      this.processInteractive(hitTestEvent, root2, null, true);
      return hitTestEvent.target;
    };
    InteractionManager2.prototype.setTargetElement = function(element, resolution) {
      if (resolution === void 0) {
        resolution = 1;
      }
      this.removeTickerListener();
      this.removeEvents();
      this.interactionDOMElement = element;
      this.resolution = resolution;
      this.addEvents();
      this.addTickerListener();
    };
    InteractionManager2.prototype.addTickerListener = function() {
      if (this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker) {
        return;
      }
      Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
      this.tickerAdded = true;
    };
    InteractionManager2.prototype.removeTickerListener = function() {
      if (!this.tickerAdded) {
        return;
      }
      Ticker.system.remove(this.tickerUpdate, this);
      this.tickerAdded = false;
    };
    InteractionManager2.prototype.addEvents = function() {
      if (this.eventsAdded || !this.interactionDOMElement) {
        return;
      }
      var style = this.interactionDOMElement.style;
      if (globalThis.navigator.msPointerEnabled) {
        style.msContentZooming = "none";
        style.msTouchAction = "none";
      } else if (this.supportsPointerEvents) {
        style.touchAction = "none";
      }
      if (this.supportsPointerEvents) {
        globalThis.document.addEventListener("pointermove", this.onPointerMove, this._eventListenerOptions);
        this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions);
        this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions);
        this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, this._eventListenerOptions);
        globalThis.addEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions);
        globalThis.addEventListener("pointerup", this.onPointerUp, this._eventListenerOptions);
      } else {
        globalThis.document.addEventListener("mousemove", this.onPointerMove, this._eventListenerOptions);
        this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, this._eventListenerOptions);
        this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, this._eventListenerOptions);
        this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, this._eventListenerOptions);
        globalThis.addEventListener("mouseup", this.onPointerUp, this._eventListenerOptions);
      }
      if (this.supportsTouchEvents) {
        this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, this._eventListenerOptions);
        this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions);
        this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, this._eventListenerOptions);
        this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, this._eventListenerOptions);
      }
      this.eventsAdded = true;
    };
    InteractionManager2.prototype.removeEvents = function() {
      if (!this.eventsAdded || !this.interactionDOMElement) {
        return;
      }
      var style = this.interactionDOMElement.style;
      if (globalThis.navigator.msPointerEnabled) {
        style.msContentZooming = "";
        style.msTouchAction = "";
      } else if (this.supportsPointerEvents) {
        style.touchAction = "";
      }
      if (this.supportsPointerEvents) {
        globalThis.document.removeEventListener("pointermove", this.onPointerMove, this._eventListenerOptions);
        this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions);
        this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions);
        this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, this._eventListenerOptions);
        globalThis.removeEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions);
        globalThis.removeEventListener("pointerup", this.onPointerUp, this._eventListenerOptions);
      } else {
        globalThis.document.removeEventListener("mousemove", this.onPointerMove, this._eventListenerOptions);
        this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, this._eventListenerOptions);
        this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, this._eventListenerOptions);
        this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, this._eventListenerOptions);
        globalThis.removeEventListener("mouseup", this.onPointerUp, this._eventListenerOptions);
      }
      if (this.supportsTouchEvents) {
        this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, this._eventListenerOptions);
        this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions);
        this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, this._eventListenerOptions);
        this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, this._eventListenerOptions);
      }
      this.interactionDOMElement = null;
      this.eventsAdded = false;
    };
    InteractionManager2.prototype.tickerUpdate = function(deltaTime) {
      this._deltaTime += deltaTime;
      if (this._deltaTime < this.interactionFrequency) {
        return;
      }
      this._deltaTime = 0;
      this.update();
    };
    InteractionManager2.prototype.update = function() {
      if (!this.interactionDOMElement) {
        return;
      }
      if (this._didMove) {
        this._didMove = false;
        return;
      }
      this.cursor = null;
      for (var k2 in this.activeInteractionData) {
        if (this.activeInteractionData.hasOwnProperty(k2)) {
          var interactionData = this.activeInteractionData[k2];
          if (interactionData.originalEvent && interactionData.pointerType !== "touch") {
            var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);
            this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, true);
          }
        }
      }
      this.setCursorMode(this.cursor);
    };
    InteractionManager2.prototype.setCursorMode = function(mode) {
      mode = mode || "default";
      var applyStyles = true;
      if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas) {
        applyStyles = false;
      }
      if (this.currentCursorMode === mode) {
        return;
      }
      this.currentCursorMode = mode;
      var style = this.cursorStyles[mode];
      if (style) {
        switch (typeof style) {
          case "string":
            if (applyStyles) {
              this.interactionDOMElement.style.cursor = style;
            }
            break;
          case "function":
            style(mode);
            break;
          case "object":
            if (applyStyles) {
              Object.assign(this.interactionDOMElement.style, style);
            }
            break;
        }
      } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
        this.interactionDOMElement.style.cursor = mode;
      }
    };
    InteractionManager2.prototype.dispatchEvent = function(displayObject, eventString, eventData) {
      if (!eventData.stopPropagationHint || displayObject === eventData.stopsPropagatingAt) {
        eventData.currentTarget = displayObject;
        eventData.type = eventString;
        displayObject.emit(eventString, eventData);
        if (displayObject[eventString]) {
          displayObject[eventString](eventData);
        }
      }
    };
    InteractionManager2.prototype.delayDispatchEvent = function(displayObject, eventString, eventData) {
      this.delayedEvents.push({ displayObject, eventString, eventData });
    };
    InteractionManager2.prototype.mapPositionToPoint = function(point, x, y2) {
      var rect;
      if (!this.interactionDOMElement.parentElement) {
        rect = {
          x: 0,
          y: 0,
          width: this.interactionDOMElement.width,
          height: this.interactionDOMElement.height,
          left: 0,
          top: 0
        };
      } else {
        rect = this.interactionDOMElement.getBoundingClientRect();
      }
      var resolutionMultiplier = 1 / this.resolution;
      point.x = (x - rect.left) * (this.interactionDOMElement.width / rect.width) * resolutionMultiplier;
      point.y = (y2 - rect.top) * (this.interactionDOMElement.height / rect.height) * resolutionMultiplier;
    };
    InteractionManager2.prototype.processInteractive = function(interactionEvent, displayObject, func, hitTest) {
      var hit = this.search.findHit(interactionEvent, displayObject, func, hitTest);
      var delayedEvents = this.delayedEvents;
      if (!delayedEvents.length) {
        return hit;
      }
      interactionEvent.stopPropagationHint = false;
      var delayedLen = delayedEvents.length;
      this.delayedEvents = [];
      for (var i2 = 0; i2 < delayedLen; i2++) {
        var _a2 = delayedEvents[i2], displayObject_1 = _a2.displayObject, eventString = _a2.eventString, eventData = _a2.eventData;
        if (eventData.stopsPropagatingAt === displayObject_1) {
          eventData.stopPropagationHint = true;
        }
        this.dispatchEvent(displayObject_1, eventString, eventData);
      }
      return hit;
    };
    InteractionManager2.prototype.onPointerDown = function(originalEvent) {
      if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
        return;
      }
      var events = this.normalizeToPointerData(originalEvent);
      if (this.autoPreventDefault && events[0].isNormalized) {
        var cancelable = originalEvent.cancelable || !("cancelable" in originalEvent);
        if (cancelable) {
          originalEvent.preventDefault();
        }
      }
      var eventLen = events.length;
      for (var i2 = 0; i2 < eventLen; i2++) {
        var event = events[i2];
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = originalEvent;
        this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerDown, true);
        this.emit("pointerdown", interactionEvent);
        if (event.pointerType === "touch") {
          this.emit("touchstart", interactionEvent);
        } else if (event.pointerType === "mouse" || event.pointerType === "pen") {
          var isRightButton = event.button === 2;
          this.emit(isRightButton ? "rightdown" : "mousedown", this.eventData);
        }
      }
    };
    InteractionManager2.prototype.processPointerDown = function(interactionEvent, displayObject, hit) {
      var data2 = interactionEvent.data;
      var id2 = interactionEvent.data.identifier;
      if (hit) {
        if (!displayObject.trackedPointers[id2]) {
          displayObject.trackedPointers[id2] = new InteractionTrackingData(id2);
        }
        this.dispatchEvent(displayObject, "pointerdown", interactionEvent);
        if (data2.pointerType === "touch") {
          this.dispatchEvent(displayObject, "touchstart", interactionEvent);
        } else if (data2.pointerType === "mouse" || data2.pointerType === "pen") {
          var isRightButton = data2.button === 2;
          if (isRightButton) {
            displayObject.trackedPointers[id2].rightDown = true;
          } else {
            displayObject.trackedPointers[id2].leftDown = true;
          }
          this.dispatchEvent(displayObject, isRightButton ? "rightdown" : "mousedown", interactionEvent);
        }
      }
    };
    InteractionManager2.prototype.onPointerComplete = function(originalEvent, cancelled, func) {
      var events = this.normalizeToPointerData(originalEvent);
      var eventLen = events.length;
      var eventAppend = originalEvent.target !== this.interactionDOMElement ? "outside" : "";
      for (var i2 = 0; i2 < eventLen; i2++) {
        var event = events[i2];
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = originalEvent;
        this.processInteractive(interactionEvent, this.lastObjectRendered, func, cancelled || !eventAppend);
        this.emit(cancelled ? "pointercancel" : "pointerup" + eventAppend, interactionEvent);
        if (event.pointerType === "mouse" || event.pointerType === "pen") {
          var isRightButton = event.button === 2;
          this.emit(isRightButton ? "rightup" + eventAppend : "mouseup" + eventAppend, interactionEvent);
        } else if (event.pointerType === "touch") {
          this.emit(cancelled ? "touchcancel" : "touchend" + eventAppend, interactionEvent);
          this.releaseInteractionDataForPointerId(event.pointerId);
        }
      }
    };
    InteractionManager2.prototype.onPointerCancel = function(event) {
      if (this.supportsTouchEvents && event.pointerType === "touch") {
        return;
      }
      this.onPointerComplete(event, true, this.processPointerCancel);
    };
    InteractionManager2.prototype.processPointerCancel = function(interactionEvent, displayObject) {
      var data2 = interactionEvent.data;
      var id2 = interactionEvent.data.identifier;
      if (displayObject.trackedPointers[id2] !== void 0) {
        delete displayObject.trackedPointers[id2];
        this.dispatchEvent(displayObject, "pointercancel", interactionEvent);
        if (data2.pointerType === "touch") {
          this.dispatchEvent(displayObject, "touchcancel", interactionEvent);
        }
      }
    };
    InteractionManager2.prototype.onPointerUp = function(event) {
      if (this.supportsTouchEvents && event.pointerType === "touch") {
        return;
      }
      this.onPointerComplete(event, false, this.processPointerUp);
    };
    InteractionManager2.prototype.processPointerUp = function(interactionEvent, displayObject, hit) {
      var data2 = interactionEvent.data;
      var id2 = interactionEvent.data.identifier;
      var trackingData = displayObject.trackedPointers[id2];
      var isTouch = data2.pointerType === "touch";
      var isMouse = data2.pointerType === "mouse" || data2.pointerType === "pen";
      var isMouseTap = false;
      if (isMouse) {
        var isRightButton = data2.button === 2;
        var flags = InteractionTrackingData.FLAGS;
        var test2 = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;
        var isDown = trackingData !== void 0 && trackingData.flags & test2;
        if (hit) {
          this.dispatchEvent(displayObject, isRightButton ? "rightup" : "mouseup", interactionEvent);
          if (isDown) {
            this.dispatchEvent(displayObject, isRightButton ? "rightclick" : "click", interactionEvent);
            isMouseTap = true;
          }
        } else if (isDown) {
          this.dispatchEvent(displayObject, isRightButton ? "rightupoutside" : "mouseupoutside", interactionEvent);
        }
        if (trackingData) {
          if (isRightButton) {
            trackingData.rightDown = false;
          } else {
            trackingData.leftDown = false;
          }
        }
      }
      if (hit) {
        this.dispatchEvent(displayObject, "pointerup", interactionEvent);
        if (isTouch) {
          this.dispatchEvent(displayObject, "touchend", interactionEvent);
        }
        if (trackingData) {
          if (!isMouse || isMouseTap) {
            this.dispatchEvent(displayObject, "pointertap", interactionEvent);
          }
          if (isTouch) {
            this.dispatchEvent(displayObject, "tap", interactionEvent);
            trackingData.over = false;
          }
        }
      } else if (trackingData) {
        this.dispatchEvent(displayObject, "pointerupoutside", interactionEvent);
        if (isTouch) {
          this.dispatchEvent(displayObject, "touchendoutside", interactionEvent);
        }
      }
      if (trackingData && trackingData.none) {
        delete displayObject.trackedPointers[id2];
      }
    };
    InteractionManager2.prototype.onPointerMove = function(originalEvent) {
      if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
        return;
      }
      var events = this.normalizeToPointerData(originalEvent);
      if (events[0].pointerType === "mouse" || events[0].pointerType === "pen") {
        this._didMove = true;
        this.cursor = null;
      }
      var eventLen = events.length;
      for (var i2 = 0; i2 < eventLen; i2++) {
        var event = events[i2];
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = originalEvent;
        this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerMove, true);
        this.emit("pointermove", interactionEvent);
        if (event.pointerType === "touch") {
          this.emit("touchmove", interactionEvent);
        }
        if (event.pointerType === "mouse" || event.pointerType === "pen") {
          this.emit("mousemove", interactionEvent);
        }
      }
      if (events[0].pointerType === "mouse") {
        this.setCursorMode(this.cursor);
      }
    };
    InteractionManager2.prototype.processPointerMove = function(interactionEvent, displayObject, hit) {
      var data2 = interactionEvent.data;
      var isTouch = data2.pointerType === "touch";
      var isMouse = data2.pointerType === "mouse" || data2.pointerType === "pen";
      if (isMouse) {
        this.processPointerOverOut(interactionEvent, displayObject, hit);
      }
      if (!this.moveWhenInside || hit) {
        this.dispatchEvent(displayObject, "pointermove", interactionEvent);
        if (isTouch) {
          this.dispatchEvent(displayObject, "touchmove", interactionEvent);
        }
        if (isMouse) {
          this.dispatchEvent(displayObject, "mousemove", interactionEvent);
        }
      }
    };
    InteractionManager2.prototype.onPointerOut = function(originalEvent) {
      if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
        return;
      }
      var events = this.normalizeToPointerData(originalEvent);
      var event = events[0];
      if (event.pointerType === "mouse") {
        this.mouseOverRenderer = false;
        this.setCursorMode(null);
      }
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = event;
      this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, false);
      this.emit("pointerout", interactionEvent);
      if (event.pointerType === "mouse" || event.pointerType === "pen") {
        this.emit("mouseout", interactionEvent);
      } else {
        this.releaseInteractionDataForPointerId(interactionData.identifier);
      }
    };
    InteractionManager2.prototype.processPointerOverOut = function(interactionEvent, displayObject, hit) {
      var data2 = interactionEvent.data;
      var id2 = interactionEvent.data.identifier;
      var isMouse = data2.pointerType === "mouse" || data2.pointerType === "pen";
      var trackingData = displayObject.trackedPointers[id2];
      if (hit && !trackingData) {
        trackingData = displayObject.trackedPointers[id2] = new InteractionTrackingData(id2);
      }
      if (trackingData === void 0) {
        return;
      }
      if (hit && this.mouseOverRenderer) {
        if (!trackingData.over) {
          trackingData.over = true;
          this.delayDispatchEvent(displayObject, "pointerover", interactionEvent);
          if (isMouse) {
            this.delayDispatchEvent(displayObject, "mouseover", interactionEvent);
          }
        }
        if (isMouse && this.cursor === null) {
          this.cursor = displayObject.cursor;
        }
      } else if (trackingData.over) {
        trackingData.over = false;
        this.dispatchEvent(displayObject, "pointerout", this.eventData);
        if (isMouse) {
          this.dispatchEvent(displayObject, "mouseout", interactionEvent);
        }
        if (trackingData.none) {
          delete displayObject.trackedPointers[id2];
        }
      }
    };
    InteractionManager2.prototype.onPointerOver = function(originalEvent) {
      var events = this.normalizeToPointerData(originalEvent);
      var event = events[0];
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = event;
      if (event.pointerType === "mouse") {
        this.mouseOverRenderer = true;
      }
      this.emit("pointerover", interactionEvent);
      if (event.pointerType === "mouse" || event.pointerType === "pen") {
        this.emit("mouseover", interactionEvent);
      }
    };
    InteractionManager2.prototype.getInteractionDataForPointerId = function(event) {
      var pointerId = event.pointerId;
      var interactionData;
      if (pointerId === MOUSE_POINTER_ID || event.pointerType === "mouse") {
        interactionData = this.mouse;
      } else if (this.activeInteractionData[pointerId]) {
        interactionData = this.activeInteractionData[pointerId];
      } else {
        interactionData = this.interactionDataPool.pop() || new InteractionData();
        interactionData.identifier = pointerId;
        this.activeInteractionData[pointerId] = interactionData;
      }
      interactionData.copyEvent(event);
      return interactionData;
    };
    InteractionManager2.prototype.releaseInteractionDataForPointerId = function(pointerId) {
      var interactionData = this.activeInteractionData[pointerId];
      if (interactionData) {
        delete this.activeInteractionData[pointerId];
        interactionData.reset();
        this.interactionDataPool.push(interactionData);
      }
    };
    InteractionManager2.prototype.configureInteractionEventForDOMEvent = function(interactionEvent, pointerEvent, interactionData) {
      interactionEvent.data = interactionData;
      this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);
      if (pointerEvent.pointerType === "touch") {
        pointerEvent.globalX = interactionData.global.x;
        pointerEvent.globalY = interactionData.global.y;
      }
      interactionData.originalEvent = pointerEvent;
      interactionEvent.reset();
      return interactionEvent;
    };
    InteractionManager2.prototype.normalizeToPointerData = function(event) {
      var normalizedEvents = [];
      if (this.supportsTouchEvents && event instanceof TouchEvent) {
        for (var i2 = 0, li2 = event.changedTouches.length; i2 < li2; i2++) {
          var touch = event.changedTouches[i2];
          if (typeof touch.button === "undefined") {
            touch.button = event.touches.length ? 1 : 0;
          }
          if (typeof touch.buttons === "undefined") {
            touch.buttons = event.touches.length ? 1 : 0;
          }
          if (typeof touch.isPrimary === "undefined") {
            touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
          }
          if (typeof touch.width === "undefined") {
            touch.width = touch.radiusX || 1;
          }
          if (typeof touch.height === "undefined") {
            touch.height = touch.radiusY || 1;
          }
          if (typeof touch.tiltX === "undefined") {
            touch.tiltX = 0;
          }
          if (typeof touch.tiltY === "undefined") {
            touch.tiltY = 0;
          }
          if (typeof touch.pointerType === "undefined") {
            touch.pointerType = "touch";
          }
          if (typeof touch.pointerId === "undefined") {
            touch.pointerId = touch.identifier || 0;
          }
          if (typeof touch.pressure === "undefined") {
            touch.pressure = touch.force || 0.5;
          }
          if (typeof touch.twist === "undefined") {
            touch.twist = 0;
          }
          if (typeof touch.tangentialPressure === "undefined") {
            touch.tangentialPressure = 0;
          }
          if (typeof touch.layerX === "undefined") {
            touch.layerX = touch.offsetX = touch.clientX;
          }
          if (typeof touch.layerY === "undefined") {
            touch.layerY = touch.offsetY = touch.clientY;
          }
          touch.isNormalized = true;
          normalizedEvents.push(touch);
        }
      } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
        var tempEvent = event;
        if (typeof tempEvent.isPrimary === "undefined") {
          tempEvent.isPrimary = true;
        }
        if (typeof tempEvent.width === "undefined") {
          tempEvent.width = 1;
        }
        if (typeof tempEvent.height === "undefined") {
          tempEvent.height = 1;
        }
        if (typeof tempEvent.tiltX === "undefined") {
          tempEvent.tiltX = 0;
        }
        if (typeof tempEvent.tiltY === "undefined") {
          tempEvent.tiltY = 0;
        }
        if (typeof tempEvent.pointerType === "undefined") {
          tempEvent.pointerType = "mouse";
        }
        if (typeof tempEvent.pointerId === "undefined") {
          tempEvent.pointerId = MOUSE_POINTER_ID;
        }
        if (typeof tempEvent.pressure === "undefined") {
          tempEvent.pressure = 0.5;
        }
        if (typeof tempEvent.twist === "undefined") {
          tempEvent.twist = 0;
        }
        if (typeof tempEvent.tangentialPressure === "undefined") {
          tempEvent.tangentialPressure = 0;
        }
        tempEvent.isNormalized = true;
        normalizedEvents.push(tempEvent);
      } else {
        normalizedEvents.push(event);
      }
      return normalizedEvents;
    };
    InteractionManager2.prototype.destroy = function() {
      this.removeEvents();
      this.removeTickerListener();
      this.removeAllListeners();
      this.renderer = null;
      this.mouse = null;
      this.eventData = null;
      this.interactionDOMElement = null;
      this.onPointerDown = null;
      this.processPointerDown = null;
      this.onPointerUp = null;
      this.processPointerUp = null;
      this.onPointerCancel = null;
      this.processPointerCancel = null;
      this.onPointerMove = null;
      this.processPointerMove = null;
      this.onPointerOut = null;
      this.processPointerOverOut = null;
      this.onPointerOver = null;
      this.search = null;
    };
    return InteractionManager2;
  }(EventEmitter$1)
);
/*!
 * @pixi/runner - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/runner is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Runner = (
  /** @class */
  function() {
    function Runner2(name) {
      this.items = [];
      this._name = name;
      this._aliasCount = 0;
    }
    Runner2.prototype.emit = function(a0, a1, a2, a3, a4, a5, a6, a7) {
      if (arguments.length > 8) {
        throw new Error("max arguments reached");
      }
      var _a2 = this, name = _a2.name, items = _a2.items;
      this._aliasCount++;
      for (var i2 = 0, len = items.length; i2 < len; i2++) {
        items[i2][name](a0, a1, a2, a3, a4, a5, a6, a7);
      }
      if (items === this.items) {
        this._aliasCount--;
      }
      return this;
    };
    Runner2.prototype.ensureNonAliasedItems = function() {
      if (this._aliasCount > 0 && this.items.length > 1) {
        this._aliasCount = 0;
        this.items = this.items.slice(0);
      }
    };
    Runner2.prototype.add = function(item) {
      if (item[this._name]) {
        this.ensureNonAliasedItems();
        this.remove(item);
        this.items.push(item);
      }
      return this;
    };
    Runner2.prototype.remove = function(item) {
      var index2 = this.items.indexOf(item);
      if (index2 !== -1) {
        this.ensureNonAliasedItems();
        this.items.splice(index2, 1);
      }
      return this;
    };
    Runner2.prototype.contains = function(item) {
      return this.items.indexOf(item) !== -1;
    };
    Runner2.prototype.removeAll = function() {
      this.ensureNonAliasedItems();
      this.items.length = 0;
      return this;
    };
    Runner2.prototype.destroy = function() {
      this.removeAll();
      this.items = null;
      this._name = null;
    };
    Object.defineProperty(Runner2.prototype, "empty", {
      /**
       * `true` if there are no this Runner contains no listeners
       * @readonly
       */
      get: function() {
        return this.items.length === 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Runner2.prototype, "name", {
      /**
       * The name of the runner.
       * @readonly
       */
      get: function() {
        return this._name;
      },
      enumerable: false,
      configurable: true
    });
    return Runner2;
  }()
);
Object.defineProperties(Runner.prototype, {
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method dispatch
   * @see PIXI.Runner#emit
   */
  dispatch: { value: Runner.prototype.emit },
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method run
   * @see PIXI.Runner#emit
   */
  run: { value: Runner.prototype.emit }
});
/*!
 * @pixi/core - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/core is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings$2.PREFER_ENV = isMobile$2.any ? ENV$4.WEBGL : ENV$4.WEBGL2;
settings$2.STRICT_TEXTURE_CACHE = false;
var INSTALLED = [];
function autoDetectResource(source, options) {
  if (!source) {
    return null;
  }
  var extension = "";
  if (typeof source === "string") {
    var result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
    if (result) {
      extension = result[1].toLowerCase();
    }
  }
  for (var i2 = INSTALLED.length - 1; i2 >= 0; --i2) {
    var ResourcePlugin = INSTALLED[i2];
    if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
      return new ResourcePlugin(source, options);
    }
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$U = function(d2, b2) {
  extendStatics$U = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (b3.hasOwnProperty(p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$U(d2, b2);
};
function __extends$U(d2, b2) {
  extendStatics$U(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t2) {
    var arguments$1 = arguments;
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments$1[i2];
      for (var p in s2) {
        if (Object.prototype.hasOwnProperty.call(s2, p)) {
          t2[p] = s2[p];
        }
      }
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
function __rest$1(s2, e2) {
  var t2 = {};
  for (var p in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) {
      t2[p] = s2[p];
    }
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") {
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
      if (e2.indexOf(p[i2]) < 0) {
        t2[p[i2]] = s2[p[i2]];
      }
    }
  }
  return t2;
}
var Resource = (
  /** @class */
  function() {
    function Resource2(width, height) {
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      this._width = width;
      this._height = height;
      this.destroyed = false;
      this.internal = false;
      this.onResize = new Runner("setRealSize");
      this.onUpdate = new Runner("update");
      this.onError = new Runner("onError");
    }
    Resource2.prototype.bind = function(baseTexture) {
      this.onResize.add(baseTexture);
      this.onUpdate.add(baseTexture);
      this.onError.add(baseTexture);
      if (this._width || this._height) {
        this.onResize.emit(this._width, this._height);
      }
    };
    Resource2.prototype.unbind = function(baseTexture) {
      this.onResize.remove(baseTexture);
      this.onUpdate.remove(baseTexture);
      this.onError.remove(baseTexture);
    };
    Resource2.prototype.resize = function(width, height) {
      if (width !== this._width || height !== this._height) {
        this._width = width;
        this._height = height;
        this.onResize.emit(width, height);
      }
    };
    Object.defineProperty(Resource2.prototype, "valid", {
      /**
       * Has been validated
       * @readonly
       */
      get: function() {
        return !!this._width && !!this._height;
      },
      enumerable: false,
      configurable: true
    });
    Resource2.prototype.update = function() {
      if (!this.destroyed) {
        this.onUpdate.emit();
      }
    };
    Resource2.prototype.load = function() {
      return Promise.resolve(this);
    };
    Object.defineProperty(Resource2.prototype, "width", {
      /**
       * The width of the resource.
       * @readonly
       */
      get: function() {
        return this._width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Resource2.prototype, "height", {
      /**
       * The height of the resource.
       * @readonly
       */
      get: function() {
        return this._height;
      },
      enumerable: false,
      configurable: true
    });
    Resource2.prototype.style = function(_renderer, _baseTexture, _glTexture) {
      return false;
    };
    Resource2.prototype.dispose = function() {
    };
    Resource2.prototype.destroy = function() {
      if (!this.destroyed) {
        this.destroyed = true;
        this.dispose();
        this.onError.removeAll();
        this.onError = null;
        this.onResize.removeAll();
        this.onResize = null;
        this.onUpdate.removeAll();
        this.onUpdate = null;
      }
    };
    Resource2.test = function(_source, _extension) {
      return false;
    };
    return Resource2;
  }()
);
var BufferResource = (
  /** @class */
  function(_super) {
    __extends$U(BufferResource2, _super);
    function BufferResource2(source, options) {
      var _this = this;
      var _a2 = options || {}, width = _a2.width, height = _a2.height;
      if (!width || !height) {
        throw new Error("BufferResource width or height invalid");
      }
      _this = _super.call(this, width, height) || this;
      _this.data = source;
      return _this;
    }
    BufferResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
      var gl = renderer.gl;
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES$4.UNPACK);
      var width = baseTexture.realWidth;
      var height = baseTexture.realHeight;
      if (glTexture.width === width && glTexture.height === height) {
        gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
      } else {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
      }
      return true;
    };
    BufferResource2.prototype.dispose = function() {
      this.data = null;
    };
    BufferResource2.test = function(source) {
      return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
    };
    return BufferResource2;
  }(Resource)
);
var defaultBufferOptions = {
  scaleMode: SCALE_MODES$4.NEAREST,
  format: FORMATS$4.RGBA,
  alphaMode: ALPHA_MODES$4.NPM
};
var BaseTexture = (
  /** @class */
  function(_super) {
    __extends$U(BaseTexture2, _super);
    function BaseTexture2(resource, options) {
      if (resource === void 0) {
        resource = null;
      }
      if (options === void 0) {
        options = null;
      }
      var _this = _super.call(this) || this;
      options = options || {};
      var alphaMode = options.alphaMode, mipmap = options.mipmap, anisotropicLevel = options.anisotropicLevel, scaleMode = options.scaleMode, width = options.width, height = options.height, wrapMode = options.wrapMode, format2 = options.format, type2 = options.type, target = options.target, resolution = options.resolution, resourceOptions = options.resourceOptions;
      if (resource && !(resource instanceof Resource)) {
        resource = autoDetectResource(resource, resourceOptions);
        resource.internal = true;
      }
      _this.resolution = resolution || settings$2.RESOLUTION;
      _this.width = Math.round((width || 0) * _this.resolution) / _this.resolution;
      _this.height = Math.round((height || 0) * _this.resolution) / _this.resolution;
      _this._mipmap = mipmap !== void 0 ? mipmap : settings$2.MIPMAP_TEXTURES;
      _this.anisotropicLevel = anisotropicLevel !== void 0 ? anisotropicLevel : settings$2.ANISOTROPIC_LEVEL;
      _this._wrapMode = wrapMode || settings$2.WRAP_MODE;
      _this._scaleMode = scaleMode !== void 0 ? scaleMode : settings$2.SCALE_MODE;
      _this.format = format2 || FORMATS$4.RGBA;
      _this.type = type2 || TYPES$4.UNSIGNED_BYTE;
      _this.target = target || TARGETS$4.TEXTURE_2D;
      _this.alphaMode = alphaMode !== void 0 ? alphaMode : ALPHA_MODES$4.UNPACK;
      _this.uid = uid();
      _this.touched = 0;
      _this.isPowerOfTwo = false;
      _this._refreshPOT();
      _this._glTextures = {};
      _this.dirtyId = 0;
      _this.dirtyStyleId = 0;
      _this.cacheId = null;
      _this.valid = width > 0 && height > 0;
      _this.textureCacheIds = [];
      _this.destroyed = false;
      _this.resource = null;
      _this._batchEnabled = 0;
      _this._batchLocation = 0;
      _this.parentTextureArray = null;
      _this.setResource(resource);
      return _this;
    }
    Object.defineProperty(BaseTexture2.prototype, "realWidth", {
      /**
       * Pixel width of the source of this texture
       * @readonly
       */
      get: function() {
        return Math.round(this.width * this.resolution);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BaseTexture2.prototype, "realHeight", {
      /**
       * Pixel height of the source of this texture
       * @readonly
       */
      get: function() {
        return Math.round(this.height * this.resolution);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BaseTexture2.prototype, "mipmap", {
      /**
       * Mipmap mode of the texture, affects downscaled images
       * @default PIXI.settings.MIPMAP_TEXTURES
       */
      get: function() {
        return this._mipmap;
      },
      set: function(value) {
        if (this._mipmap !== value) {
          this._mipmap = value;
          this.dirtyStyleId++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BaseTexture2.prototype, "scaleMode", {
      /**
       * The scale mode to apply when scaling this texture
       * @default PIXI.settings.SCALE_MODE
       */
      get: function() {
        return this._scaleMode;
      },
      set: function(value) {
        if (this._scaleMode !== value) {
          this._scaleMode = value;
          this.dirtyStyleId++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BaseTexture2.prototype, "wrapMode", {
      /**
       * How the texture wraps
       * @default PIXI.settings.WRAP_MODE
       */
      get: function() {
        return this._wrapMode;
      },
      set: function(value) {
        if (this._wrapMode !== value) {
          this._wrapMode = value;
          this.dirtyStyleId++;
        }
      },
      enumerable: false,
      configurable: true
    });
    BaseTexture2.prototype.setStyle = function(scaleMode, mipmap) {
      var dirty;
      if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {
        this.scaleMode = scaleMode;
        dirty = true;
      }
      if (mipmap !== void 0 && mipmap !== this.mipmap) {
        this.mipmap = mipmap;
        dirty = true;
      }
      if (dirty) {
        this.dirtyStyleId++;
      }
      return this;
    };
    BaseTexture2.prototype.setSize = function(desiredWidth, desiredHeight, resolution) {
      resolution = resolution || this.resolution;
      return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
    };
    BaseTexture2.prototype.setRealSize = function(realWidth, realHeight, resolution) {
      this.resolution = resolution || this.resolution;
      this.width = Math.round(realWidth) / this.resolution;
      this.height = Math.round(realHeight) / this.resolution;
      this._refreshPOT();
      this.update();
      return this;
    };
    BaseTexture2.prototype._refreshPOT = function() {
      this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
    };
    BaseTexture2.prototype.setResolution = function(resolution) {
      var oldResolution = this.resolution;
      if (oldResolution === resolution) {
        return this;
      }
      this.resolution = resolution;
      if (this.valid) {
        this.width = Math.round(this.width * oldResolution) / resolution;
        this.height = Math.round(this.height * oldResolution) / resolution;
        this.emit("update", this);
      }
      this._refreshPOT();
      return this;
    };
    BaseTexture2.prototype.setResource = function(resource) {
      if (this.resource === resource) {
        return this;
      }
      if (this.resource) {
        throw new Error("Resource can be set only once");
      }
      resource.bind(this);
      this.resource = resource;
      return this;
    };
    BaseTexture2.prototype.update = function() {
      if (!this.valid) {
        if (this.width > 0 && this.height > 0) {
          this.valid = true;
          this.emit("loaded", this);
          this.emit("update", this);
        }
      } else {
        this.dirtyId++;
        this.dirtyStyleId++;
        this.emit("update", this);
      }
    };
    BaseTexture2.prototype.onError = function(event) {
      this.emit("error", this, event);
    };
    BaseTexture2.prototype.destroy = function() {
      if (this.resource) {
        this.resource.unbind(this);
        if (this.resource.internal) {
          this.resource.destroy();
        }
        this.resource = null;
      }
      if (this.cacheId) {
        delete BaseTextureCache[this.cacheId];
        delete TextureCache[this.cacheId];
        this.cacheId = null;
      }
      this.dispose();
      BaseTexture2.removeFromCache(this);
      this.textureCacheIds = null;
      this.destroyed = true;
    };
    BaseTexture2.prototype.dispose = function() {
      this.emit("dispose", this);
    };
    BaseTexture2.prototype.castToBaseTexture = function() {
      return this;
    };
    BaseTexture2.from = function(source, options, strict) {
      if (strict === void 0) {
        strict = settings$2.STRICT_TEXTURE_CACHE;
      }
      var isFrame = typeof source === "string";
      var cacheId = null;
      if (isFrame) {
        cacheId = source;
      } else {
        if (!source._pixiId) {
          var prefix2 = options && options.pixiIdPrefix || "pixiid";
          source._pixiId = prefix2 + "_" + uid();
        }
        cacheId = source._pixiId;
      }
      var baseTexture = BaseTextureCache[cacheId];
      if (isFrame && strict && !baseTexture) {
        throw new Error('The cacheId "' + cacheId + '" does not exist in BaseTextureCache.');
      }
      if (!baseTexture) {
        baseTexture = new BaseTexture2(source, options);
        baseTexture.cacheId = cacheId;
        BaseTexture2.addToCache(baseTexture, cacheId);
      }
      return baseTexture;
    };
    BaseTexture2.fromBuffer = function(buffer, width, height, options) {
      buffer = buffer || new Float32Array(width * height * 4);
      var resource = new BufferResource(buffer, { width, height });
      var type2 = buffer instanceof Float32Array ? TYPES$4.FLOAT : TYPES$4.UNSIGNED_BYTE;
      return new BaseTexture2(resource, Object.assign(defaultBufferOptions, options || { width, height, type: type2 }));
    };
    BaseTexture2.addToCache = function(baseTexture, id2) {
      if (id2) {
        if (baseTexture.textureCacheIds.indexOf(id2) === -1) {
          baseTexture.textureCacheIds.push(id2);
        }
        if (BaseTextureCache[id2]) {
          console.warn("BaseTexture added to the cache with an id [" + id2 + "] that already had an entry");
        }
        BaseTextureCache[id2] = baseTexture;
      }
    };
    BaseTexture2.removeFromCache = function(baseTexture) {
      if (typeof baseTexture === "string") {
        var baseTextureFromCache = BaseTextureCache[baseTexture];
        if (baseTextureFromCache) {
          var index2 = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
          if (index2 > -1) {
            baseTextureFromCache.textureCacheIds.splice(index2, 1);
          }
          delete BaseTextureCache[baseTexture];
          return baseTextureFromCache;
        }
      } else if (baseTexture && baseTexture.textureCacheIds) {
        for (var i2 = 0; i2 < baseTexture.textureCacheIds.length; ++i2) {
          delete BaseTextureCache[baseTexture.textureCacheIds[i2]];
        }
        baseTexture.textureCacheIds.length = 0;
        return baseTexture;
      }
      return null;
    };
    BaseTexture2._globalBatch = 0;
    return BaseTexture2;
  }(EventEmitter$1)
);
var AbstractMultiResource = (
  /** @class */
  function(_super) {
    __extends$U(AbstractMultiResource2, _super);
    function AbstractMultiResource2(length2, options) {
      var _this = this;
      var _a2 = options || {}, width = _a2.width, height = _a2.height;
      _this = _super.call(this, width, height) || this;
      _this.items = [];
      _this.itemDirtyIds = [];
      for (var i2 = 0; i2 < length2; i2++) {
        var partTexture = new BaseTexture();
        _this.items.push(partTexture);
        _this.itemDirtyIds.push(-2);
      }
      _this.length = length2;
      _this._load = null;
      _this.baseTexture = null;
      return _this;
    }
    AbstractMultiResource2.prototype.initFromArray = function(resources2, options) {
      for (var i2 = 0; i2 < this.length; i2++) {
        if (!resources2[i2]) {
          continue;
        }
        if (resources2[i2].castToBaseTexture) {
          this.addBaseTextureAt(resources2[i2].castToBaseTexture(), i2);
        } else if (resources2[i2] instanceof Resource) {
          this.addResourceAt(resources2[i2], i2);
        } else {
          this.addResourceAt(autoDetectResource(resources2[i2], options), i2);
        }
      }
    };
    AbstractMultiResource2.prototype.dispose = function() {
      for (var i2 = 0, len = this.length; i2 < len; i2++) {
        this.items[i2].destroy();
      }
      this.items = null;
      this.itemDirtyIds = null;
      this._load = null;
    };
    AbstractMultiResource2.prototype.addResourceAt = function(resource, index2) {
      if (!this.items[index2]) {
        throw new Error("Index " + index2 + " is out of bounds");
      }
      if (resource.valid && !this.valid) {
        this.resize(resource.width, resource.height);
      }
      this.items[index2].setResource(resource);
      return this;
    };
    AbstractMultiResource2.prototype.bind = function(baseTexture) {
      if (this.baseTexture !== null) {
        throw new Error("Only one base texture per TextureArray is allowed");
      }
      _super.prototype.bind.call(this, baseTexture);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.items[i2].parentTextureArray = baseTexture;
        this.items[i2].on("update", baseTexture.update, baseTexture);
      }
    };
    AbstractMultiResource2.prototype.unbind = function(baseTexture) {
      _super.prototype.unbind.call(this, baseTexture);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.items[i2].parentTextureArray = null;
        this.items[i2].off("update", baseTexture.update, baseTexture);
      }
    };
    AbstractMultiResource2.prototype.load = function() {
      var _this = this;
      if (this._load) {
        return this._load;
      }
      var resources2 = this.items.map(function(item) {
        return item.resource;
      }).filter(function(item) {
        return item;
      });
      var promises = resources2.map(function(item) {
        return item.load();
      });
      this._load = Promise.all(promises).then(function() {
        var _a2 = _this.items[0], realWidth = _a2.realWidth, realHeight = _a2.realHeight;
        _this.resize(realWidth, realHeight);
        return Promise.resolve(_this);
      });
      return this._load;
    };
    return AbstractMultiResource2;
  }(Resource)
);
var ArrayResource = (
  /** @class */
  function(_super) {
    __extends$U(ArrayResource2, _super);
    function ArrayResource2(source, options) {
      var _this = this;
      var _a2 = options || {}, width = _a2.width, height = _a2.height;
      var urls;
      var length2;
      if (Array.isArray(source)) {
        urls = source;
        length2 = source.length;
      } else {
        length2 = source;
      }
      _this = _super.call(this, length2, { width, height }) || this;
      if (urls) {
        _this.initFromArray(urls, options);
      }
      return _this;
    }
    ArrayResource2.prototype.addBaseTextureAt = function(baseTexture, index2) {
      if (baseTexture.resource) {
        this.addResourceAt(baseTexture.resource, index2);
      } else {
        throw new Error("ArrayResource does not support RenderTexture");
      }
      return this;
    };
    ArrayResource2.prototype.bind = function(baseTexture) {
      _super.prototype.bind.call(this, baseTexture);
      baseTexture.target = TARGETS$4.TEXTURE_2D_ARRAY;
    };
    ArrayResource2.prototype.upload = function(renderer, texture, glTexture) {
      var _a2 = this, length2 = _a2.length, itemDirtyIds = _a2.itemDirtyIds, items = _a2.items;
      var gl = renderer.gl;
      if (glTexture.dirtyId < 0) {
        gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length2, 0, texture.format, glTexture.type, null);
      }
      for (var i2 = 0; i2 < length2; i2++) {
        var item = items[i2];
        if (itemDirtyIds[i2] < item.dirtyId) {
          itemDirtyIds[i2] = item.dirtyId;
          if (item.valid) {
            gl.texSubImage3D(
              gl.TEXTURE_2D_ARRAY,
              0,
              0,
              // xoffset
              0,
              // yoffset
              i2,
              // zoffset
              item.resource.width,
              item.resource.height,
              1,
              texture.format,
              glTexture.type,
              item.resource.source
            );
          }
        }
      }
      return true;
    };
    return ArrayResource2;
  }(AbstractMultiResource)
);
var BaseImageResource = (
  /** @class */
  function(_super) {
    __extends$U(BaseImageResource2, _super);
    function BaseImageResource2(source) {
      var _this = this;
      var sourceAny = source;
      var width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
      var height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
      _this = _super.call(this, width, height) || this;
      _this.source = source;
      _this.noSubImage = false;
      return _this;
    }
    BaseImageResource2.crossOrigin = function(element, url2, crossorigin) {
      if (crossorigin === void 0 && url2.indexOf("data:") !== 0) {
        element.crossOrigin = determineCrossOrigin(url2);
      } else if (crossorigin !== false) {
        element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
      }
    };
    BaseImageResource2.prototype.upload = function(renderer, baseTexture, glTexture, source) {
      var gl = renderer.gl;
      var width = baseTexture.realWidth;
      var height = baseTexture.realHeight;
      source = source || this.source;
      if (source instanceof HTMLImageElement) {
        if (!source.complete || source.naturalWidth === 0) {
          return false;
        }
      } else if (source instanceof HTMLVideoElement) {
        if (source.readyState <= 1) {
          return false;
        }
      }
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES$4.UNPACK);
      if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);
      } else {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);
      }
      return true;
    };
    BaseImageResource2.prototype.update = function() {
      if (this.destroyed) {
        return;
      }
      var source = this.source;
      var width = source.naturalWidth || source.videoWidth || source.width;
      var height = source.naturalHeight || source.videoHeight || source.height;
      this.resize(width, height);
      _super.prototype.update.call(this);
    };
    BaseImageResource2.prototype.dispose = function() {
      this.source = null;
    };
    return BaseImageResource2;
  }(Resource)
);
var CanvasResource = (
  /** @class */
  function(_super) {
    __extends$U(CanvasResource2, _super);
    function CanvasResource2(source) {
      return _super.call(this, source) || this;
    }
    CanvasResource2.test = function(source) {
      var OffscreenCanvas2 = globalThis.OffscreenCanvas;
      if (OffscreenCanvas2 && source instanceof OffscreenCanvas2) {
        return true;
      }
      return globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;
    };
    return CanvasResource2;
  }(BaseImageResource)
);
var CubeResource = (
  /** @class */
  function(_super) {
    __extends$U(CubeResource2, _super);
    function CubeResource2(source, options) {
      var _this = this;
      var _a2 = options || {}, width = _a2.width, height = _a2.height, autoLoad = _a2.autoLoad, linkBaseTexture = _a2.linkBaseTexture;
      if (source && source.length !== CubeResource2.SIDES) {
        throw new Error("Invalid length. Got " + source.length + ", expected 6");
      }
      _this = _super.call(this, 6, { width, height }) || this;
      for (var i2 = 0; i2 < CubeResource2.SIDES; i2++) {
        _this.items[i2].target = TARGETS$4.TEXTURE_CUBE_MAP_POSITIVE_X + i2;
      }
      _this.linkBaseTexture = linkBaseTexture !== false;
      if (source) {
        _this.initFromArray(source, options);
      }
      if (autoLoad !== false) {
        _this.load();
      }
      return _this;
    }
    CubeResource2.prototype.bind = function(baseTexture) {
      _super.prototype.bind.call(this, baseTexture);
      baseTexture.target = TARGETS$4.TEXTURE_CUBE_MAP;
    };
    CubeResource2.prototype.addBaseTextureAt = function(baseTexture, index2, linkBaseTexture) {
      if (!this.items[index2]) {
        throw new Error("Index " + index2 + " is out of bounds");
      }
      if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
        if (baseTexture.resource) {
          this.addResourceAt(baseTexture.resource, index2);
        } else {
          throw new Error("CubeResource does not support copying of renderTexture.");
        }
      } else {
        baseTexture.target = TARGETS$4.TEXTURE_CUBE_MAP_POSITIVE_X + index2;
        baseTexture.parentTextureArray = this.baseTexture;
        this.items[index2] = baseTexture;
      }
      if (baseTexture.valid && !this.valid) {
        this.resize(baseTexture.realWidth, baseTexture.realHeight);
      }
      this.items[index2] = baseTexture;
      return this;
    };
    CubeResource2.prototype.upload = function(renderer, _baseTexture, glTexture) {
      var dirty = this.itemDirtyIds;
      for (var i2 = 0; i2 < CubeResource2.SIDES; i2++) {
        var side = this.items[i2];
        if (dirty[i2] < side.dirtyId) {
          if (side.valid && side.resource) {
            side.resource.upload(renderer, side, glTexture);
            dirty[i2] = side.dirtyId;
          } else if (dirty[i2] < -1) {
            renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
            dirty[i2] = -1;
          }
        }
      }
      return true;
    };
    CubeResource2.test = function(source) {
      return Array.isArray(source) && source.length === CubeResource2.SIDES;
    };
    CubeResource2.SIDES = 6;
    return CubeResource2;
  }(AbstractMultiResource)
);
var ImageResource = (
  /** @class */
  function(_super) {
    __extends$U(ImageResource2, _super);
    function ImageResource2(source, options) {
      var _this = this;
      options = options || {};
      if (!(source instanceof HTMLImageElement)) {
        var imageElement = new Image();
        BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
        imageElement.src = source;
        source = imageElement;
      }
      _this = _super.call(this, source) || this;
      if (!source.complete && !!_this._width && !!_this._height) {
        _this._width = 0;
        _this._height = 0;
      }
      _this.url = source.src;
      _this._process = null;
      _this.preserveBitmap = false;
      _this.createBitmap = (options.createBitmap !== void 0 ? options.createBitmap : settings$2.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;
      _this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
      _this.bitmap = null;
      _this._load = null;
      if (options.autoLoad !== false) {
        _this.load();
      }
      return _this;
    }
    ImageResource2.prototype.load = function(createBitmap) {
      var _this = this;
      if (this._load) {
        return this._load;
      }
      if (createBitmap !== void 0) {
        this.createBitmap = createBitmap;
      }
      this._load = new Promise(function(resolve2, reject2) {
        var source = _this.source;
        _this.url = source.src;
        var completed = function() {
          if (_this.destroyed) {
            return;
          }
          source.onload = null;
          source.onerror = null;
          _this.resize(source.width, source.height);
          _this._load = null;
          if (_this.createBitmap) {
            resolve2(_this.process());
          } else {
            resolve2(_this);
          }
        };
        if (source.complete && source.src) {
          completed();
        } else {
          source.onload = completed;
          source.onerror = function(event) {
            reject2(event);
            _this.onError.emit(event);
          };
        }
      });
      return this._load;
    };
    ImageResource2.prototype.process = function() {
      var _this = this;
      var source = this.source;
      if (this._process !== null) {
        return this._process;
      }
      if (this.bitmap !== null || !globalThis.createImageBitmap) {
        return Promise.resolve(this);
      }
      var createImageBitmap = globalThis.createImageBitmap;
      var cors = !source.crossOrigin || source.crossOrigin === "anonymous";
      this._process = fetch(source.src, {
        mode: cors ? "cors" : "no-cors"
      }).then(function(r2) {
        return r2.blob();
      }).then(function(blob) {
        return createImageBitmap(blob, 0, 0, source.width, source.height, {
          premultiplyAlpha: _this.alphaMode === ALPHA_MODES$4.UNPACK ? "premultiply" : "none"
        });
      }).then(function(bitmap) {
        if (_this.destroyed) {
          return Promise.reject();
        }
        _this.bitmap = bitmap;
        _this.update();
        _this._process = null;
        return Promise.resolve(_this);
      });
      return this._process;
    };
    ImageResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
      if (typeof this.alphaMode === "number") {
        baseTexture.alphaMode = this.alphaMode;
      }
      if (!this.createBitmap) {
        return _super.prototype.upload.call(this, renderer, baseTexture, glTexture);
      }
      if (!this.bitmap) {
        this.process();
        if (!this.bitmap) {
          return false;
        }
      }
      _super.prototype.upload.call(this, renderer, baseTexture, glTexture, this.bitmap);
      if (!this.preserveBitmap) {
        var flag = true;
        var glTextures = baseTexture._glTextures;
        for (var key in glTextures) {
          var otherTex = glTextures[key];
          if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
            flag = false;
            break;
          }
        }
        if (flag) {
          if (this.bitmap.close) {
            this.bitmap.close();
          }
          this.bitmap = null;
        }
      }
      return true;
    };
    ImageResource2.prototype.dispose = function() {
      this.source.onload = null;
      this.source.onerror = null;
      _super.prototype.dispose.call(this);
      if (this.bitmap) {
        this.bitmap.close();
        this.bitmap = null;
      }
      this._process = null;
      this._load = null;
    };
    ImageResource2.test = function(source) {
      return typeof source === "string" || source instanceof HTMLImageElement;
    };
    return ImageResource2;
  }(BaseImageResource)
);
var SVGResource = (
  /** @class */
  function(_super) {
    __extends$U(SVGResource2, _super);
    function SVGResource2(sourceBase64, options) {
      var _this = this;
      options = options || {};
      _this = _super.call(this, document.createElement("canvas")) || this;
      _this._width = 0;
      _this._height = 0;
      _this.svg = sourceBase64;
      _this.scale = options.scale || 1;
      _this._overrideWidth = options.width;
      _this._overrideHeight = options.height;
      _this._resolve = null;
      _this._crossorigin = options.crossorigin;
      _this._load = null;
      if (options.autoLoad !== false) {
        _this.load();
      }
      return _this;
    }
    SVGResource2.prototype.load = function() {
      var _this = this;
      if (this._load) {
        return this._load;
      }
      this._load = new Promise(function(resolve2) {
        _this._resolve = function() {
          _this.resize(_this.source.width, _this.source.height);
          resolve2(_this);
        };
        if (SVGResource2.SVG_XML.test(_this.svg.trim())) {
          if (!btoa) {
            throw new Error("Your browser doesn't support base64 conversions.");
          }
          _this.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(_this.svg)));
        }
        _this._loadSvg();
      });
      return this._load;
    };
    SVGResource2.prototype._loadSvg = function() {
      var _this = this;
      var tempImage = new Image();
      BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
      tempImage.src = this.svg;
      tempImage.onerror = function(event) {
        if (!_this._resolve) {
          return;
        }
        tempImage.onerror = null;
        _this.onError.emit(event);
      };
      tempImage.onload = function() {
        if (!_this._resolve) {
          return;
        }
        var svgWidth = tempImage.width;
        var svgHeight = tempImage.height;
        if (!svgWidth || !svgHeight) {
          throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
        }
        var width = svgWidth * _this.scale;
        var height = svgHeight * _this.scale;
        if (_this._overrideWidth || _this._overrideHeight) {
          width = _this._overrideWidth || _this._overrideHeight / svgHeight * svgWidth;
          height = _this._overrideHeight || _this._overrideWidth / svgWidth * svgHeight;
        }
        width = Math.round(width);
        height = Math.round(height);
        var canvas = _this.source;
        canvas.width = width;
        canvas.height = height;
        canvas._pixiId = "canvas_" + uid();
        canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
        _this._resolve();
        _this._resolve = null;
      };
    };
    SVGResource2.getSize = function(svgString) {
      var sizeMatch = SVGResource2.SVG_SIZE.exec(svgString);
      var size = {};
      if (sizeMatch) {
        size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
        size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
      }
      return size;
    };
    SVGResource2.prototype.dispose = function() {
      _super.prototype.dispose.call(this);
      this._resolve = null;
      this._crossorigin = null;
    };
    SVGResource2.test = function(source, extension) {
      return extension === "svg" || typeof source === "string" && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(source) || typeof source === "string" && SVGResource2.SVG_XML.test(source);
    };
    SVGResource2.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
    SVGResource2.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
    return SVGResource2;
  }(BaseImageResource)
);
var VideoResource = (
  /** @class */
  function(_super) {
    __extends$U(VideoResource2, _super);
    function VideoResource2(source, options) {
      var _this = this;
      options = options || {};
      if (!(source instanceof HTMLVideoElement)) {
        var videoElement = document.createElement("video");
        videoElement.setAttribute("preload", "auto");
        videoElement.setAttribute("webkit-playsinline", "");
        videoElement.setAttribute("playsinline", "");
        if (typeof source === "string") {
          source = [source];
        }
        var firstSrc = source[0].src || source[0];
        BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
        for (var i2 = 0; i2 < source.length; ++i2) {
          var sourceElement = document.createElement("source");
          var _a2 = source[i2], src = _a2.src, mime = _a2.mime;
          src = src || source[i2];
          var baseSrc = src.split("?").shift().toLowerCase();
          var ext = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);
          mime = mime || VideoResource2.MIME_TYPES[ext] || "video/" + ext;
          sourceElement.src = src;
          sourceElement.type = mime;
          videoElement.appendChild(sourceElement);
        }
        source = videoElement;
      }
      _this = _super.call(this, source) || this;
      _this.noSubImage = true;
      _this._autoUpdate = true;
      _this._isConnectedToTicker = false;
      _this._updateFPS = options.updateFPS || 0;
      _this._msToNextUpdate = 0;
      _this.autoPlay = options.autoPlay !== false;
      _this._load = null;
      _this._resolve = null;
      _this._onCanPlay = _this._onCanPlay.bind(_this);
      _this._onError = _this._onError.bind(_this);
      if (options.autoLoad !== false) {
        _this.load();
      }
      return _this;
    }
    VideoResource2.prototype.update = function(_deltaTime) {
      if (!this.destroyed) {
        var elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
        if (!this._updateFPS || this._msToNextUpdate <= 0) {
          _super.prototype.update.call(this);
          this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
        }
      }
    };
    VideoResource2.prototype.load = function() {
      var _this = this;
      if (this._load) {
        return this._load;
      }
      var source = this.source;
      if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
        source.complete = true;
      }
      source.addEventListener("play", this._onPlayStart.bind(this));
      source.addEventListener("pause", this._onPlayStop.bind(this));
      if (!this._isSourceReady()) {
        source.addEventListener("canplay", this._onCanPlay);
        source.addEventListener("canplaythrough", this._onCanPlay);
        source.addEventListener("error", this._onError, true);
      } else {
        this._onCanPlay();
      }
      this._load = new Promise(function(resolve2) {
        if (_this.valid) {
          resolve2(_this);
        } else {
          _this._resolve = resolve2;
          source.load();
        }
      });
      return this._load;
    };
    VideoResource2.prototype._onError = function(event) {
      this.source.removeEventListener("error", this._onError, true);
      this.onError.emit(event);
    };
    VideoResource2.prototype._isSourcePlaying = function() {
      var source = this.source;
      return source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2;
    };
    VideoResource2.prototype._isSourceReady = function() {
      var source = this.source;
      return source.readyState === 3 || source.readyState === 4;
    };
    VideoResource2.prototype._onPlayStart = function() {
      if (!this.valid) {
        this._onCanPlay();
      }
      if (this.autoUpdate && !this._isConnectedToTicker) {
        Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    };
    VideoResource2.prototype._onPlayStop = function() {
      if (this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      }
    };
    VideoResource2.prototype._onCanPlay = function() {
      var source = this.source;
      source.removeEventListener("canplay", this._onCanPlay);
      source.removeEventListener("canplaythrough", this._onCanPlay);
      var valid = this.valid;
      this.resize(source.videoWidth, source.videoHeight);
      if (!valid && this._resolve) {
        this._resolve(this);
        this._resolve = null;
      }
      if (this._isSourcePlaying()) {
        this._onPlayStart();
      } else if (this.autoPlay) {
        source.play();
      }
    };
    VideoResource2.prototype.dispose = function() {
      if (this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      }
      var source = this.source;
      if (source) {
        source.removeEventListener("error", this._onError, true);
        source.pause();
        source.src = "";
        source.load();
      }
      _super.prototype.dispose.call(this);
    };
    Object.defineProperty(VideoResource2.prototype, "autoUpdate", {
      /** Should the base texture automatically update itself, set to true by default. */
      get: function() {
        return this._autoUpdate;
      },
      set: function(value) {
        if (value !== this._autoUpdate) {
          this._autoUpdate = value;
          if (!this._autoUpdate && this._isConnectedToTicker) {
            Ticker.shared.remove(this.update, this);
            this._isConnectedToTicker = false;
          } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
            Ticker.shared.add(this.update, this);
            this._isConnectedToTicker = true;
          }
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(VideoResource2.prototype, "updateFPS", {
      /**
       * How many times a second to update the texture from the video. Leave at 0 to update at every render.
       * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
       */
      get: function() {
        return this._updateFPS;
      },
      set: function(value) {
        if (value !== this._updateFPS) {
          this._updateFPS = value;
        }
      },
      enumerable: false,
      configurable: true
    });
    VideoResource2.test = function(source, extension) {
      return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || VideoResource2.TYPES.indexOf(extension) > -1;
    };
    VideoResource2.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
    VideoResource2.MIME_TYPES = {
      ogv: "video/ogg",
      mov: "video/quicktime",
      m4v: "video/mp4"
    };
    return VideoResource2;
  }(BaseImageResource)
);
var ImageBitmapResource = (
  /** @class */
  function(_super) {
    __extends$U(ImageBitmapResource2, _super);
    function ImageBitmapResource2(source) {
      return _super.call(this, source) || this;
    }
    ImageBitmapResource2.test = function(source) {
      return !!globalThis.createImageBitmap && source instanceof ImageBitmap;
    };
    return ImageBitmapResource2;
  }(BaseImageResource)
);
INSTALLED.push(ImageResource, ImageBitmapResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);
var _resources = {
  __proto__: null,
  Resource,
  BaseImageResource,
  INSTALLED,
  autoDetectResource,
  AbstractMultiResource,
  ArrayResource,
  BufferResource,
  CanvasResource,
  CubeResource,
  ImageResource,
  SVGResource,
  VideoResource,
  ImageBitmapResource
};
var DepthResource = (
  /** @class */
  function(_super) {
    __extends$U(DepthResource2, _super);
    function DepthResource2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DepthResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
      var gl = renderer.gl;
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES$4.UNPACK);
      var width = baseTexture.realWidth;
      var height = baseTexture.realHeight;
      if (glTexture.width === width && glTexture.height === height) {
        gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
      } else {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
      }
      return true;
    };
    return DepthResource2;
  }(BufferResource)
);
var Framebuffer = (
  /** @class */
  function() {
    function Framebuffer2(width, height) {
      this.width = Math.round(width || 100);
      this.height = Math.round(height || 100);
      this.stencil = false;
      this.depth = false;
      this.dirtyId = 0;
      this.dirtyFormat = 0;
      this.dirtySize = 0;
      this.depthTexture = null;
      this.colorTextures = [];
      this.glFramebuffers = {};
      this.disposeRunner = new Runner("disposeFramebuffer");
      this.multisample = MSAA_QUALITY$4.NONE;
    }
    Object.defineProperty(Framebuffer2.prototype, "colorTexture", {
      /**
       * Reference to the colorTexture.
       * @readonly
       */
      get: function() {
        return this.colorTextures[0];
      },
      enumerable: false,
      configurable: true
    });
    Framebuffer2.prototype.addColorTexture = function(index2, texture) {
      if (index2 === void 0) {
        index2 = 0;
      }
      this.colorTextures[index2] = texture || new BaseTexture(null, {
        scaleMode: SCALE_MODES$4.NEAREST,
        resolution: 1,
        mipmap: MIPMAP_MODES$4.OFF,
        width: this.width,
        height: this.height
      });
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    };
    Framebuffer2.prototype.addDepthTexture = function(texture) {
      this.depthTexture = texture || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {
        scaleMode: SCALE_MODES$4.NEAREST,
        resolution: 1,
        width: this.width,
        height: this.height,
        mipmap: MIPMAP_MODES$4.OFF,
        format: FORMATS$4.DEPTH_COMPONENT,
        type: TYPES$4.UNSIGNED_SHORT
      });
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    };
    Framebuffer2.prototype.enableDepth = function() {
      this.depth = true;
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    };
    Framebuffer2.prototype.enableStencil = function() {
      this.stencil = true;
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    };
    Framebuffer2.prototype.resize = function(width, height) {
      width = Math.round(width);
      height = Math.round(height);
      if (width === this.width && height === this.height) {
        return;
      }
      this.width = width;
      this.height = height;
      this.dirtyId++;
      this.dirtySize++;
      for (var i2 = 0; i2 < this.colorTextures.length; i2++) {
        var texture = this.colorTextures[i2];
        var resolution = texture.resolution;
        texture.setSize(width / resolution, height / resolution);
      }
      if (this.depthTexture) {
        var resolution = this.depthTexture.resolution;
        this.depthTexture.setSize(width / resolution, height / resolution);
      }
    };
    Framebuffer2.prototype.dispose = function() {
      this.disposeRunner.emit(this, false);
    };
    Framebuffer2.prototype.destroyDepthTexture = function() {
      if (this.depthTexture) {
        this.depthTexture.destroy();
        this.depthTexture = null;
        ++this.dirtyId;
        ++this.dirtyFormat;
      }
    };
    return Framebuffer2;
  }()
);
var BaseRenderTexture = (
  /** @class */
  function(_super) {
    __extends$U(BaseRenderTexture2, _super);
    function BaseRenderTexture2(options) {
      if (options === void 0) {
        options = {};
      }
      var _this = this;
      if (typeof options === "number") {
        var width = arguments[0];
        var height = arguments[1];
        var scaleMode = arguments[2];
        var resolution = arguments[3];
        options = { width, height, scaleMode, resolution };
      }
      options.width = options.width || 100;
      options.height = options.height || 100;
      options.multisample = options.multisample !== void 0 ? options.multisample : MSAA_QUALITY$4.NONE;
      _this = _super.call(this, null, options) || this;
      _this.mipmap = MIPMAP_MODES$4.OFF;
      _this.valid = true;
      _this.clearColor = [0, 0, 0, 0];
      _this.framebuffer = new Framebuffer(_this.realWidth, _this.realHeight).addColorTexture(0, _this);
      _this.framebuffer.multisample = options.multisample;
      _this.maskStack = [];
      _this.filterStack = [{}];
      return _this;
    }
    BaseRenderTexture2.prototype.resize = function(desiredWidth, desiredHeight) {
      this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution);
      this.setRealSize(this.framebuffer.width, this.framebuffer.height);
    };
    BaseRenderTexture2.prototype.dispose = function() {
      this.framebuffer.dispose();
      _super.prototype.dispose.call(this);
    };
    BaseRenderTexture2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.framebuffer.destroyDepthTexture();
      this.framebuffer = null;
    };
    return BaseRenderTexture2;
  }(BaseTexture)
);
var TextureUvs = (
  /** @class */
  function() {
    function TextureUvs2() {
      this.x0 = 0;
      this.y0 = 0;
      this.x1 = 1;
      this.y1 = 0;
      this.x2 = 1;
      this.y2 = 1;
      this.x3 = 0;
      this.y3 = 1;
      this.uvsFloat32 = new Float32Array(8);
    }
    TextureUvs2.prototype.set = function(frame2, baseFrame, rotate) {
      var tw = baseFrame.width;
      var th2 = baseFrame.height;
      if (rotate) {
        var w2 = frame2.width / 2 / tw;
        var h2 = frame2.height / 2 / th2;
        var cX = frame2.x / tw + w2;
        var cY = frame2.y / th2 + h2;
        rotate = groupD8.add(rotate, groupD8.NW);
        this.x0 = cX + w2 * groupD8.uX(rotate);
        this.y0 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        this.x1 = cX + w2 * groupD8.uX(rotate);
        this.y1 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        this.x2 = cX + w2 * groupD8.uX(rotate);
        this.y2 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        this.x3 = cX + w2 * groupD8.uX(rotate);
        this.y3 = cY + h2 * groupD8.uY(rotate);
      } else {
        this.x0 = frame2.x / tw;
        this.y0 = frame2.y / th2;
        this.x1 = (frame2.x + frame2.width) / tw;
        this.y1 = frame2.y / th2;
        this.x2 = (frame2.x + frame2.width) / tw;
        this.y2 = (frame2.y + frame2.height) / th2;
        this.x3 = frame2.x / tw;
        this.y3 = (frame2.y + frame2.height) / th2;
      }
      this.uvsFloat32[0] = this.x0;
      this.uvsFloat32[1] = this.y0;
      this.uvsFloat32[2] = this.x1;
      this.uvsFloat32[3] = this.y1;
      this.uvsFloat32[4] = this.x2;
      this.uvsFloat32[5] = this.y2;
      this.uvsFloat32[6] = this.x3;
      this.uvsFloat32[7] = this.y3;
    };
    TextureUvs2.prototype.toString = function() {
      return "[@pixi/core:TextureUvs " + ("x0=" + this.x0 + " y0=" + this.y0 + " ") + ("x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " ") + ("y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3) + "]";
    };
    return TextureUvs2;
  }()
);
var DEFAULT_UVS = new TextureUvs();
function removeAllHandlers(tex) {
  tex.destroy = function _emptyDestroy() {
  };
  tex.on = function _emptyOn() {
  };
  tex.once = function _emptyOnce() {
  };
  tex.emit = function _emptyEmit() {
  };
}
var Texture = (
  /** @class */
  function(_super) {
    __extends$U(Texture2, _super);
    function Texture2(baseTexture, frame2, orig, trim2, rotate, anchor) {
      var _this = _super.call(this) || this;
      _this.noFrame = false;
      if (!frame2) {
        _this.noFrame = true;
        frame2 = new Rectangle(0, 0, 1, 1);
      }
      if (baseTexture instanceof Texture2) {
        baseTexture = baseTexture.baseTexture;
      }
      _this.baseTexture = baseTexture;
      _this._frame = frame2;
      _this.trim = trim2;
      _this.valid = false;
      _this._uvs = DEFAULT_UVS;
      _this.uvMatrix = null;
      _this.orig = orig || frame2;
      _this._rotate = Number(rotate || 0);
      if (rotate === true) {
        _this._rotate = 2;
      } else if (_this._rotate % 2 !== 0) {
        throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
      }
      _this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0);
      _this._updateID = 0;
      _this.textureCacheIds = [];
      if (!baseTexture.valid) {
        baseTexture.once("loaded", _this.onBaseTextureUpdated, _this);
      } else if (_this.noFrame) {
        if (baseTexture.valid) {
          _this.onBaseTextureUpdated(baseTexture);
        }
      } else {
        _this.frame = frame2;
      }
      if (_this.noFrame) {
        baseTexture.on("update", _this.onBaseTextureUpdated, _this);
      }
      return _this;
    }
    Texture2.prototype.update = function() {
      if (this.baseTexture.resource) {
        this.baseTexture.resource.update();
      }
    };
    Texture2.prototype.onBaseTextureUpdated = function(baseTexture) {
      if (this.noFrame) {
        if (!this.baseTexture.valid) {
          return;
        }
        this._frame.width = baseTexture.width;
        this._frame.height = baseTexture.height;
        this.valid = true;
        this.updateUvs();
      } else {
        this.frame = this._frame;
      }
      this.emit("update", this);
    };
    Texture2.prototype.destroy = function(destroyBase) {
      if (this.baseTexture) {
        if (destroyBase) {
          var resource = this.baseTexture.resource;
          if (resource && resource.url && TextureCache[resource.url]) {
            Texture2.removeFromCache(resource.url);
          }
          this.baseTexture.destroy();
        }
        this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
        this.baseTexture.off("update", this.onBaseTextureUpdated, this);
        this.baseTexture = null;
      }
      this._frame = null;
      this._uvs = null;
      this.trim = null;
      this.orig = null;
      this.valid = false;
      Texture2.removeFromCache(this);
      this.textureCacheIds = null;
    };
    Texture2.prototype.clone = function() {
      var clonedFrame = this._frame.clone();
      var clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();
      var clonedTexture = new Texture2(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
      if (this.noFrame) {
        clonedTexture._frame = clonedFrame;
      }
      return clonedTexture;
    };
    Texture2.prototype.updateUvs = function() {
      if (this._uvs === DEFAULT_UVS) {
        this._uvs = new TextureUvs();
      }
      this._uvs.set(this._frame, this.baseTexture, this.rotate);
      this._updateID++;
    };
    Texture2.from = function(source, options, strict) {
      if (options === void 0) {
        options = {};
      }
      if (strict === void 0) {
        strict = settings$2.STRICT_TEXTURE_CACHE;
      }
      var isFrame = typeof source === "string";
      var cacheId = null;
      if (isFrame) {
        cacheId = source;
      } else if (source instanceof BaseTexture) {
        if (!source.cacheId) {
          var prefix2 = options && options.pixiIdPrefix || "pixiid";
          source.cacheId = prefix2 + "-" + uid();
          BaseTexture.addToCache(source, source.cacheId);
        }
        cacheId = source.cacheId;
      } else {
        if (!source._pixiId) {
          var prefix2 = options && options.pixiIdPrefix || "pixiid";
          source._pixiId = prefix2 + "_" + uid();
        }
        cacheId = source._pixiId;
      }
      var texture = TextureCache[cacheId];
      if (isFrame && strict && !texture) {
        throw new Error('The cacheId "' + cacheId + '" does not exist in TextureCache.');
      }
      if (!texture && !(source instanceof BaseTexture)) {
        if (!options.resolution) {
          options.resolution = getResolutionOfUrl(source);
        }
        texture = new Texture2(new BaseTexture(source, options));
        texture.baseTexture.cacheId = cacheId;
        BaseTexture.addToCache(texture.baseTexture, cacheId);
        Texture2.addToCache(texture, cacheId);
      } else if (!texture && source instanceof BaseTexture) {
        texture = new Texture2(source);
        Texture2.addToCache(texture, cacheId);
      }
      return texture;
    };
    Texture2.fromURL = function(url2, options) {
      var resourceOptions = Object.assign({ autoLoad: false }, options === null || options === void 0 ? void 0 : options.resourceOptions);
      var texture = Texture2.from(url2, Object.assign({ resourceOptions }, options), false);
      var resource = texture.baseTexture.resource;
      if (texture.baseTexture.valid) {
        return Promise.resolve(texture);
      }
      return resource.load().then(function() {
        return Promise.resolve(texture);
      });
    };
    Texture2.fromBuffer = function(buffer, width, height, options) {
      return new Texture2(BaseTexture.fromBuffer(buffer, width, height, options));
    };
    Texture2.fromLoader = function(source, imageUrl, name, options) {
      var baseTexture = new BaseTexture(source, Object.assign({
        scaleMode: settings$2.SCALE_MODE,
        resolution: getResolutionOfUrl(imageUrl)
      }, options));
      var resource = baseTexture.resource;
      if (resource instanceof ImageResource) {
        resource.url = imageUrl;
      }
      var texture = new Texture2(baseTexture);
      if (!name) {
        name = imageUrl;
      }
      BaseTexture.addToCache(texture.baseTexture, name);
      Texture2.addToCache(texture, name);
      if (name !== imageUrl) {
        BaseTexture.addToCache(texture.baseTexture, imageUrl);
        Texture2.addToCache(texture, imageUrl);
      }
      if (texture.baseTexture.valid) {
        return Promise.resolve(texture);
      }
      return new Promise(function(resolve2) {
        texture.baseTexture.once("loaded", function() {
          return resolve2(texture);
        });
      });
    };
    Texture2.addToCache = function(texture, id2) {
      if (id2) {
        if (texture.textureCacheIds.indexOf(id2) === -1) {
          texture.textureCacheIds.push(id2);
        }
        if (TextureCache[id2]) {
          console.warn("Texture added to the cache with an id [" + id2 + "] that already had an entry");
        }
        TextureCache[id2] = texture;
      }
    };
    Texture2.removeFromCache = function(texture) {
      if (typeof texture === "string") {
        var textureFromCache = TextureCache[texture];
        if (textureFromCache) {
          var index2 = textureFromCache.textureCacheIds.indexOf(texture);
          if (index2 > -1) {
            textureFromCache.textureCacheIds.splice(index2, 1);
          }
          delete TextureCache[texture];
          return textureFromCache;
        }
      } else if (texture && texture.textureCacheIds) {
        for (var i2 = 0; i2 < texture.textureCacheIds.length; ++i2) {
          if (TextureCache[texture.textureCacheIds[i2]] === texture) {
            delete TextureCache[texture.textureCacheIds[i2]];
          }
        }
        texture.textureCacheIds.length = 0;
        return texture;
      }
      return null;
    };
    Object.defineProperty(Texture2.prototype, "resolution", {
      /**
       * Returns resolution of baseTexture
       * @readonly
       */
      get: function() {
        return this.baseTexture.resolution;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Texture2.prototype, "frame", {
      /**
       * The frame specifies the region of the base texture that this texture uses.
       * Please call `updateUvs()` after you change coordinates of `frame` manually.
       */
      get: function() {
        return this._frame;
      },
      set: function(frame2) {
        this._frame = frame2;
        this.noFrame = false;
        var x = frame2.x, y2 = frame2.y, width = frame2.width, height = frame2.height;
        var xNotFit = x + width > this.baseTexture.width;
        var yNotFit = y2 + height > this.baseTexture.height;
        if (xNotFit || yNotFit) {
          var relationship = xNotFit && yNotFit ? "and" : "or";
          var errorX = "X: " + x + " + " + width + " = " + (x + width) + " > " + this.baseTexture.width;
          var errorY = "Y: " + y2 + " + " + height + " = " + (y2 + height) + " > " + this.baseTexture.height;
          throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (errorX + " " + relationship + " " + errorY));
        }
        this.valid = width && height && this.baseTexture.valid;
        if (!this.trim && !this.rotate) {
          this.orig = frame2;
        }
        if (this.valid) {
          this.updateUvs();
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Texture2.prototype, "rotate", {
      /**
       * Indicates whether the texture is rotated inside the atlas
       * set to 2 to compensate for texture packer rotation
       * set to 6 to compensate for spine packer rotation
       * can be used to rotate or mirror sprites
       * See {@link PIXI.groupD8} for explanation
       */
      get: function() {
        return this._rotate;
      },
      set: function(rotate) {
        this._rotate = rotate;
        if (this.valid) {
          this.updateUvs();
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Texture2.prototype, "width", {
      /** The width of the Texture in pixels. */
      get: function() {
        return this.orig.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Texture2.prototype, "height", {
      /** The height of the Texture in pixels. */
      get: function() {
        return this.orig.height;
      },
      enumerable: false,
      configurable: true
    });
    Texture2.prototype.castToBaseTexture = function() {
      return this.baseTexture;
    };
    Object.defineProperty(Texture2, "EMPTY", {
      /** An empty texture, used often to not have to create multiple empty textures. Can not be destroyed. */
      get: function() {
        if (!Texture2._EMPTY) {
          Texture2._EMPTY = new Texture2(new BaseTexture());
          removeAllHandlers(Texture2._EMPTY);
          removeAllHandlers(Texture2._EMPTY.baseTexture);
        }
        return Texture2._EMPTY;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Texture2, "WHITE", {
      /** A white texture of 16x16 size, used for graphics and other things Can not be destroyed. */
      get: function() {
        if (!Texture2._WHITE) {
          var canvas = document.createElement("canvas");
          var context2 = canvas.getContext("2d");
          canvas.width = 16;
          canvas.height = 16;
          context2.fillStyle = "white";
          context2.fillRect(0, 0, 16, 16);
          Texture2._WHITE = new Texture2(new BaseTexture(new CanvasResource(canvas)));
          removeAllHandlers(Texture2._WHITE);
          removeAllHandlers(Texture2._WHITE.baseTexture);
        }
        return Texture2._WHITE;
      },
      enumerable: false,
      configurable: true
    });
    return Texture2;
  }(EventEmitter$1)
);
var RenderTexture = (
  /** @class */
  function(_super) {
    __extends$U(RenderTexture2, _super);
    function RenderTexture2(baseRenderTexture, frame2) {
      var _this = _super.call(this, baseRenderTexture, frame2) || this;
      _this.valid = true;
      _this.filterFrame = null;
      _this.filterPoolKey = null;
      _this.updateUvs();
      return _this;
    }
    Object.defineProperty(RenderTexture2.prototype, "framebuffer", {
      /**
       * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.
       * @readonly
       */
      get: function() {
        return this.baseTexture.framebuffer;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(RenderTexture2.prototype, "multisample", {
      /**
       * Shortcut to `this.framebuffer.multisample`.
       * @default PIXI.MSAA_QUALITY.NONE
       */
      get: function() {
        return this.framebuffer.multisample;
      },
      set: function(value) {
        this.framebuffer.multisample = value;
      },
      enumerable: false,
      configurable: true
    });
    RenderTexture2.prototype.resize = function(desiredWidth, desiredHeight, resizeBaseTexture) {
      if (resizeBaseTexture === void 0) {
        resizeBaseTexture = true;
      }
      var resolution = this.baseTexture.resolution;
      var width = Math.round(desiredWidth * resolution) / resolution;
      var height = Math.round(desiredHeight * resolution) / resolution;
      this.valid = width > 0 && height > 0;
      this._frame.width = this.orig.width = width;
      this._frame.height = this.orig.height = height;
      if (resizeBaseTexture) {
        this.baseTexture.resize(width, height);
      }
      this.updateUvs();
    };
    RenderTexture2.prototype.setResolution = function(resolution) {
      var baseTexture = this.baseTexture;
      if (baseTexture.resolution === resolution) {
        return;
      }
      baseTexture.setResolution(resolution);
      this.resize(baseTexture.width, baseTexture.height, false);
    };
    RenderTexture2.create = function(options) {
      var arguments$1 = arguments;
      var rest = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        rest[_i - 1] = arguments$1[_i];
      }
      if (typeof options === "number") {
        deprecation("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated.");
        options = {
          width: options,
          height: rest[0],
          scaleMode: rest[1],
          resolution: rest[2]
        };
      }
      return new RenderTexture2(new BaseRenderTexture(options));
    };
    return RenderTexture2;
  }(Texture)
);
var RenderTexturePool = (
  /** @class */
  function() {
    function RenderTexturePool2(textureOptions) {
      this.texturePool = {};
      this.textureOptions = textureOptions || {};
      this.enableFullScreen = false;
      this._pixelsWidth = 0;
      this._pixelsHeight = 0;
    }
    RenderTexturePool2.prototype.createTexture = function(realWidth, realHeight, multisample) {
      if (multisample === void 0) {
        multisample = MSAA_QUALITY$4.NONE;
      }
      var baseRenderTexture = new BaseRenderTexture(Object.assign({
        width: realWidth,
        height: realHeight,
        resolution: 1,
        multisample
      }, this.textureOptions));
      return new RenderTexture(baseRenderTexture);
    };
    RenderTexturePool2.prototype.getOptimalTexture = function(minWidth, minHeight, resolution, multisample) {
      if (resolution === void 0) {
        resolution = 1;
      }
      if (multisample === void 0) {
        multisample = MSAA_QUALITY$4.NONE;
      }
      var key;
      minWidth = Math.ceil(minWidth * resolution - 1e-6);
      minHeight = Math.ceil(minHeight * resolution - 1e-6);
      if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
        minWidth = nextPow2(minWidth);
        minHeight = nextPow2(minHeight);
        key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0;
        if (multisample > 1) {
          key += multisample * 4294967296;
        }
      } else {
        key = multisample > 1 ? -multisample : -1;
      }
      if (!this.texturePool[key]) {
        this.texturePool[key] = [];
      }
      var renderTexture = this.texturePool[key].pop();
      if (!renderTexture) {
        renderTexture = this.createTexture(minWidth, minHeight, multisample);
      }
      renderTexture.filterPoolKey = key;
      renderTexture.setResolution(resolution);
      return renderTexture;
    };
    RenderTexturePool2.prototype.getFilterTexture = function(input, resolution, multisample) {
      var filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY$4.NONE);
      filterTexture.filterFrame = input.filterFrame;
      return filterTexture;
    };
    RenderTexturePool2.prototype.returnTexture = function(renderTexture) {
      var key = renderTexture.filterPoolKey;
      renderTexture.filterFrame = null;
      this.texturePool[key].push(renderTexture);
    };
    RenderTexturePool2.prototype.returnFilterTexture = function(renderTexture) {
      this.returnTexture(renderTexture);
    };
    RenderTexturePool2.prototype.clear = function(destroyTextures) {
      destroyTextures = destroyTextures !== false;
      if (destroyTextures) {
        for (var i2 in this.texturePool) {
          var textures = this.texturePool[i2];
          if (textures) {
            for (var j2 = 0; j2 < textures.length; j2++) {
              textures[j2].destroy(true);
            }
          }
        }
      }
      this.texturePool = {};
    };
    RenderTexturePool2.prototype.setScreenSize = function(size) {
      if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {
        return;
      }
      this.enableFullScreen = size.width > 0 && size.height > 0;
      for (var i2 in this.texturePool) {
        if (!(Number(i2) < 0)) {
          continue;
        }
        var textures = this.texturePool[i2];
        if (textures) {
          for (var j2 = 0; j2 < textures.length; j2++) {
            textures[j2].destroy(true);
          }
        }
        this.texturePool[i2] = [];
      }
      this._pixelsWidth = size.width;
      this._pixelsHeight = size.height;
    };
    RenderTexturePool2.SCREEN_KEY = -1;
    return RenderTexturePool2;
  }()
);
var Attribute = (
  /** @class */
  function() {
    function Attribute2(buffer, size, normalized, type2, stride, start, instance2) {
      if (size === void 0) {
        size = 0;
      }
      if (normalized === void 0) {
        normalized = false;
      }
      if (type2 === void 0) {
        type2 = TYPES$4.FLOAT;
      }
      this.buffer = buffer;
      this.size = size;
      this.normalized = normalized;
      this.type = type2;
      this.stride = stride;
      this.start = start;
      this.instance = instance2;
    }
    Attribute2.prototype.destroy = function() {
      this.buffer = null;
    };
    Attribute2.from = function(buffer, size, normalized, type2, stride) {
      return new Attribute2(buffer, size, normalized, type2, stride);
    };
    return Attribute2;
  }()
);
var UID$4 = 0;
var Buffer$1 = (
  /** @class */
  function() {
    function Buffer2(data2, _static, index2) {
      if (_static === void 0) {
        _static = true;
      }
      if (index2 === void 0) {
        index2 = false;
      }
      this.data = data2 || new Float32Array(1);
      this._glBuffers = {};
      this._updateID = 0;
      this.index = index2;
      this.static = _static;
      this.id = UID$4++;
      this.disposeRunner = new Runner("disposeBuffer");
    }
    Buffer2.prototype.update = function(data2) {
      if (data2 instanceof Array) {
        data2 = new Float32Array(data2);
      }
      this.data = data2 || this.data;
      this._updateID++;
    };
    Buffer2.prototype.dispose = function() {
      this.disposeRunner.emit(this, false);
    };
    Buffer2.prototype.destroy = function() {
      this.dispose();
      this.data = null;
    };
    Object.defineProperty(Buffer2.prototype, "index", {
      get: function() {
        return this.type === BUFFER_TYPE$4.ELEMENT_ARRAY_BUFFER;
      },
      /**
       * Flags whether this is an index buffer.
       *
       * Index buffers are of type `ELEMENT_ARRAY_BUFFER`. Note that setting this property to false will make
       * the buffer of type `ARRAY_BUFFER`.
       *
       * For backwards compatibility.
       */
      set: function(value) {
        this.type = value ? BUFFER_TYPE$4.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE$4.ARRAY_BUFFER;
      },
      enumerable: false,
      configurable: true
    });
    Buffer2.from = function(data2) {
      if (data2 instanceof Array) {
        data2 = new Float32Array(data2);
      }
      return new Buffer2(data2);
    };
    return Buffer2;
  }()
);
var map$1 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays(arrays, sizes) {
  var outSize = 0;
  var stride = 0;
  var views = {};
  for (var i2 = 0; i2 < arrays.length; i2++) {
    stride += sizes[i2];
    outSize += arrays[i2].length;
  }
  var buffer = new ArrayBuffer(outSize * 4);
  var out = null;
  var littleOffset = 0;
  for (var i2 = 0; i2 < arrays.length; i2++) {
    var size = sizes[i2];
    var array = arrays[i2];
    var type2 = getBufferType(array);
    if (!views[type2]) {
      views[type2] = new map$1[type2](buffer);
    }
    out = views[type2];
    for (var j2 = 0; j2 < array.length; j2++) {
      var indexStart = (j2 / size | 0) * stride + littleOffset;
      var index2 = j2 % size;
      out[indexStart + index2] = array[j2];
    }
    littleOffset += size;
  }
  return new Float32Array(buffer);
}
var byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 };
var UID$3 = 0;
var map = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
};
var Geometry = (
  /** @class */
  function() {
    function Geometry2(buffers, attributes) {
      if (buffers === void 0) {
        buffers = [];
      }
      if (attributes === void 0) {
        attributes = {};
      }
      this.buffers = buffers;
      this.indexBuffer = null;
      this.attributes = attributes;
      this.glVertexArrayObjects = {};
      this.id = UID$3++;
      this.instanced = false;
      this.instanceCount = 1;
      this.disposeRunner = new Runner("disposeGeometry");
      this.refCount = 0;
    }
    Geometry2.prototype.addAttribute = function(id2, buffer, size, normalized, type2, stride, start, instance2) {
      if (size === void 0) {
        size = 0;
      }
      if (normalized === void 0) {
        normalized = false;
      }
      if (instance2 === void 0) {
        instance2 = false;
      }
      if (!buffer) {
        throw new Error("You must pass a buffer when creating an attribute");
      }
      if (!(buffer instanceof Buffer$1)) {
        if (buffer instanceof Array) {
          buffer = new Float32Array(buffer);
        }
        buffer = new Buffer$1(buffer);
      }
      var ids = id2.split("|");
      if (ids.length > 1) {
        for (var i2 = 0; i2 < ids.length; i2++) {
          this.addAttribute(ids[i2], buffer, size, normalized, type2);
        }
        return this;
      }
      var bufferIndex = this.buffers.indexOf(buffer);
      if (bufferIndex === -1) {
        this.buffers.push(buffer);
        bufferIndex = this.buffers.length - 1;
      }
      this.attributes[id2] = new Attribute(bufferIndex, size, normalized, type2, stride, start, instance2);
      this.instanced = this.instanced || instance2;
      return this;
    };
    Geometry2.prototype.getAttribute = function(id2) {
      return this.attributes[id2];
    };
    Geometry2.prototype.getBuffer = function(id2) {
      return this.buffers[this.getAttribute(id2).buffer];
    };
    Geometry2.prototype.addIndex = function(buffer) {
      if (!(buffer instanceof Buffer$1)) {
        if (buffer instanceof Array) {
          buffer = new Uint16Array(buffer);
        }
        buffer = new Buffer$1(buffer);
      }
      buffer.type = BUFFER_TYPE$4.ELEMENT_ARRAY_BUFFER;
      this.indexBuffer = buffer;
      if (this.buffers.indexOf(buffer) === -1) {
        this.buffers.push(buffer);
      }
      return this;
    };
    Geometry2.prototype.getIndex = function() {
      return this.indexBuffer;
    };
    Geometry2.prototype.interleave = function() {
      if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) {
        return this;
      }
      var arrays = [];
      var sizes = [];
      var interleavedBuffer = new Buffer$1();
      var i2;
      for (i2 in this.attributes) {
        var attribute = this.attributes[i2];
        var buffer = this.buffers[attribute.buffer];
        arrays.push(buffer.data);
        sizes.push(attribute.size * byteSizeMap$1[attribute.type] / 4);
        attribute.buffer = 0;
      }
      interleavedBuffer.data = interleaveTypedArrays(arrays, sizes);
      for (i2 = 0; i2 < this.buffers.length; i2++) {
        if (this.buffers[i2] !== this.indexBuffer) {
          this.buffers[i2].destroy();
        }
      }
      this.buffers = [interleavedBuffer];
      if (this.indexBuffer) {
        this.buffers.push(this.indexBuffer);
      }
      return this;
    };
    Geometry2.prototype.getSize = function() {
      for (var i2 in this.attributes) {
        var attribute = this.attributes[i2];
        var buffer = this.buffers[attribute.buffer];
        return buffer.data.length / (attribute.stride / 4 || attribute.size);
      }
      return 0;
    };
    Geometry2.prototype.dispose = function() {
      this.disposeRunner.emit(this, false);
    };
    Geometry2.prototype.destroy = function() {
      this.dispose();
      this.buffers = null;
      this.indexBuffer = null;
      this.attributes = null;
    };
    Geometry2.prototype.clone = function() {
      var geometry = new Geometry2();
      for (var i2 = 0; i2 < this.buffers.length; i2++) {
        geometry.buffers[i2] = new Buffer$1(this.buffers[i2].data.slice(0));
      }
      for (var i2 in this.attributes) {
        var attrib = this.attributes[i2];
        geometry.attributes[i2] = new Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
      }
      if (this.indexBuffer) {
        geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
        geometry.indexBuffer.type = BUFFER_TYPE$4.ELEMENT_ARRAY_BUFFER;
      }
      return geometry;
    };
    Geometry2.merge = function(geometries) {
      var geometryOut = new Geometry2();
      var arrays = [];
      var sizes = [];
      var offsets = [];
      var geometry;
      for (var i2 = 0; i2 < geometries.length; i2++) {
        geometry = geometries[i2];
        for (var j2 = 0; j2 < geometry.buffers.length; j2++) {
          sizes[j2] = sizes[j2] || 0;
          sizes[j2] += geometry.buffers[j2].data.length;
          offsets[j2] = 0;
        }
      }
      for (var i2 = 0; i2 < geometry.buffers.length; i2++) {
        arrays[i2] = new map[getBufferType(geometry.buffers[i2].data)](sizes[i2]);
        geometryOut.buffers[i2] = new Buffer$1(arrays[i2]);
      }
      for (var i2 = 0; i2 < geometries.length; i2++) {
        geometry = geometries[i2];
        for (var j2 = 0; j2 < geometry.buffers.length; j2++) {
          arrays[j2].set(geometry.buffers[j2].data, offsets[j2]);
          offsets[j2] += geometry.buffers[j2].data.length;
        }
      }
      geometryOut.attributes = geometry.attributes;
      if (geometry.indexBuffer) {
        geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
        geometryOut.indexBuffer.type = BUFFER_TYPE$4.ELEMENT_ARRAY_BUFFER;
        var offset = 0;
        var stride = 0;
        var offset2 = 0;
        var bufferIndexToCount = 0;
        for (var i2 = 0; i2 < geometry.buffers.length; i2++) {
          if (geometry.buffers[i2] !== geometry.indexBuffer) {
            bufferIndexToCount = i2;
            break;
          }
        }
        for (var i2 in geometry.attributes) {
          var attribute = geometry.attributes[i2];
          if ((attribute.buffer | 0) === bufferIndexToCount) {
            stride += attribute.size * byteSizeMap$1[attribute.type] / 4;
          }
        }
        for (var i2 = 0; i2 < geometries.length; i2++) {
          var indexBufferData = geometries[i2].indexBuffer.data;
          for (var j2 = 0; j2 < indexBufferData.length; j2++) {
            geometryOut.indexBuffer.data[j2 + offset2] += offset;
          }
          offset += geometries[i2].buffers[bufferIndexToCount].data.length / stride;
          offset2 += indexBufferData.length;
        }
      }
      return geometryOut;
    };
    return Geometry2;
  }()
);
var Quad = (
  /** @class */
  function(_super) {
    __extends$U(Quad2, _super);
    function Quad2() {
      var _this = _super.call(this) || this;
      _this.addAttribute("aVertexPosition", new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ])).addIndex([0, 1, 3, 2]);
      return _this;
    }
    return Quad2;
  }(Geometry)
);
var QuadUv = (
  /** @class */
  function(_super) {
    __extends$U(QuadUv2, _super);
    function QuadUv2() {
      var _this = _super.call(this) || this;
      _this.vertices = new Float32Array([
        -1,
        -1,
        1,
        -1,
        1,
        1,
        -1,
        1
      ]);
      _this.uvs = new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ]);
      _this.vertexBuffer = new Buffer$1(_this.vertices);
      _this.uvBuffer = new Buffer$1(_this.uvs);
      _this.addAttribute("aVertexPosition", _this.vertexBuffer).addAttribute("aTextureCoord", _this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
      return _this;
    }
    QuadUv2.prototype.map = function(targetTextureFrame, destinationFrame) {
      var x = 0;
      var y2 = 0;
      this.uvs[0] = x;
      this.uvs[1] = y2;
      this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width;
      this.uvs[3] = y2;
      this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width;
      this.uvs[5] = y2 + destinationFrame.height / targetTextureFrame.height;
      this.uvs[6] = x;
      this.uvs[7] = y2 + destinationFrame.height / targetTextureFrame.height;
      x = destinationFrame.x;
      y2 = destinationFrame.y;
      this.vertices[0] = x;
      this.vertices[1] = y2;
      this.vertices[2] = x + destinationFrame.width;
      this.vertices[3] = y2;
      this.vertices[4] = x + destinationFrame.width;
      this.vertices[5] = y2 + destinationFrame.height;
      this.vertices[6] = x;
      this.vertices[7] = y2 + destinationFrame.height;
      this.invalidate();
      return this;
    };
    QuadUv2.prototype.invalidate = function() {
      this.vertexBuffer._updateID++;
      this.uvBuffer._updateID++;
      return this;
    };
    return QuadUv2;
  }(Geometry)
);
var UID$2 = 0;
var UniformGroup = (
  /** @class */
  function() {
    function UniformGroup2(uniforms, isStatic, isUbo) {
      this.group = true;
      this.syncUniforms = {};
      this.dirtyId = 0;
      this.id = UID$2++;
      this.static = !!isStatic;
      this.ubo = !!isUbo;
      if (uniforms instanceof Buffer$1) {
        this.buffer = uniforms;
        this.buffer.type = BUFFER_TYPE$4.UNIFORM_BUFFER;
        this.autoManage = false;
        this.ubo = true;
      } else {
        this.uniforms = uniforms;
        if (this.ubo) {
          this.buffer = new Buffer$1(new Float32Array(1));
          this.buffer.type = BUFFER_TYPE$4.UNIFORM_BUFFER;
          this.autoManage = true;
        }
      }
    }
    UniformGroup2.prototype.update = function() {
      this.dirtyId++;
      if (!this.autoManage && this.buffer) {
        this.buffer.update();
      }
    };
    UniformGroup2.prototype.add = function(name, uniforms, _static) {
      if (!this.ubo) {
        this.uniforms[name] = new UniformGroup2(uniforms, _static);
      } else {
        throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
      }
    };
    UniformGroup2.from = function(uniforms, _static, _ubo) {
      return new UniformGroup2(uniforms, _static, _ubo);
    };
    UniformGroup2.uboFrom = function(uniforms, _static) {
      return new UniformGroup2(uniforms, _static !== null && _static !== void 0 ? _static : true, true);
    };
    return UniformGroup2;
  }()
);
var FilterState = (
  /** @class */
  function() {
    function FilterState2() {
      this.renderTexture = null;
      this.target = null;
      this.legacy = false;
      this.resolution = 1;
      this.multisample = MSAA_QUALITY$4.NONE;
      this.sourceFrame = new Rectangle();
      this.destinationFrame = new Rectangle();
      this.bindingSourceFrame = new Rectangle();
      this.bindingDestinationFrame = new Rectangle();
      this.filters = [];
      this.transform = null;
    }
    FilterState2.prototype.clear = function() {
      this.target = null;
      this.filters = null;
      this.renderTexture = null;
    };
    return FilterState2;
  }()
);
var tempPoints = [new Point(), new Point(), new Point(), new Point()];
var tempMatrix$2 = new Matrix();
var FilterSystem = (
  /** @class */
  function() {
    function FilterSystem2(renderer) {
      this.renderer = renderer;
      this.defaultFilterStack = [{}];
      this.texturePool = new RenderTexturePool();
      this.texturePool.setScreenSize(renderer.view);
      this.statePool = [];
      this.quad = new Quad();
      this.quadUv = new QuadUv();
      this.tempRect = new Rectangle();
      this.activeState = {};
      this.globalUniforms = new UniformGroup({
        outputFrame: new Rectangle(),
        inputSize: new Float32Array(4),
        inputPixel: new Float32Array(4),
        inputClamp: new Float32Array(4),
        resolution: 1,
        // legacy variables
        filterArea: new Float32Array(4),
        filterClamp: new Float32Array(4)
      }, true);
      this.forceClear = false;
      this.useMaxPadding = false;
    }
    FilterSystem2.prototype.push = function(target, filters2) {
      var _a2, _b2;
      var renderer = this.renderer;
      var filterStack = this.defaultFilterStack;
      var state = this.statePool.pop() || new FilterState();
      var renderTextureSystem = this.renderer.renderTexture;
      var resolution = filters2[0].resolution;
      var multisample = filters2[0].multisample;
      var padding = filters2[0].padding;
      var autoFit = filters2[0].autoFit;
      var legacy = (_a2 = filters2[0].legacy) !== null && _a2 !== void 0 ? _a2 : true;
      for (var i2 = 1; i2 < filters2.length; i2++) {
        var filter2 = filters2[i2];
        resolution = Math.min(resolution, filter2.resolution);
        multisample = Math.min(multisample, filter2.multisample);
        padding = this.useMaxPadding ? Math.max(padding, filter2.padding) : padding + filter2.padding;
        autoFit = autoFit && filter2.autoFit;
        legacy = legacy || ((_b2 = filter2.legacy) !== null && _b2 !== void 0 ? _b2 : true);
      }
      if (filterStack.length === 1) {
        this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;
      }
      filterStack.push(state);
      state.resolution = resolution;
      state.multisample = multisample;
      state.legacy = legacy;
      state.target = target;
      state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
      state.sourceFrame.pad(padding);
      var sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
      if (renderer.projection.transform) {
        this.transformAABB(tempMatrix$2.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected);
      }
      if (autoFit) {
        state.sourceFrame.fit(sourceFrameProjected);
        if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) {
          state.sourceFrame.width = 0;
          state.sourceFrame.height = 0;
        }
      } else if (!state.sourceFrame.intersects(sourceFrameProjected)) {
        state.sourceFrame.width = 0;
        state.sourceFrame.height = 0;
      }
      this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
      state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);
      state.filters = filters2;
      state.destinationFrame.width = state.renderTexture.width;
      state.destinationFrame.height = state.renderTexture.height;
      var destinationFrame = this.tempRect;
      destinationFrame.x = 0;
      destinationFrame.y = 0;
      destinationFrame.width = state.sourceFrame.width;
      destinationFrame.height = state.sourceFrame.height;
      state.renderTexture.filterFrame = state.sourceFrame;
      state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);
      state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);
      state.transform = renderer.projection.transform;
      renderer.projection.transform = null;
      renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);
      renderer.framebuffer.clear(0, 0, 0, 0);
    };
    FilterSystem2.prototype.pop = function() {
      var filterStack = this.defaultFilterStack;
      var state = filterStack.pop();
      var filters2 = state.filters;
      this.activeState = state;
      var globalUniforms = this.globalUniforms.uniforms;
      globalUniforms.outputFrame = state.sourceFrame;
      globalUniforms.resolution = state.resolution;
      var inputSize = globalUniforms.inputSize;
      var inputPixel = globalUniforms.inputPixel;
      var inputClamp = globalUniforms.inputClamp;
      inputSize[0] = state.destinationFrame.width;
      inputSize[1] = state.destinationFrame.height;
      inputSize[2] = 1 / inputSize[0];
      inputSize[3] = 1 / inputSize[1];
      inputPixel[0] = Math.round(inputSize[0] * state.resolution);
      inputPixel[1] = Math.round(inputSize[1] * state.resolution);
      inputPixel[2] = 1 / inputPixel[0];
      inputPixel[3] = 1 / inputPixel[1];
      inputClamp[0] = 0.5 * inputPixel[2];
      inputClamp[1] = 0.5 * inputPixel[3];
      inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
      inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
      if (state.legacy) {
        var filterArea = globalUniforms.filterArea;
        filterArea[0] = state.destinationFrame.width;
        filterArea[1] = state.destinationFrame.height;
        filterArea[2] = state.sourceFrame.x;
        filterArea[3] = state.sourceFrame.y;
        globalUniforms.filterClamp = globalUniforms.inputClamp;
      }
      this.globalUniforms.update();
      var lastState = filterStack[filterStack.length - 1];
      this.renderer.framebuffer.blit();
      if (filters2.length === 1) {
        filters2[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES$4.BLEND, state);
        this.returnFilterTexture(state.renderTexture);
      } else {
        var flip = state.renderTexture;
        var flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
        flop.filterFrame = flip.filterFrame;
        var i2 = 0;
        for (i2 = 0; i2 < filters2.length - 1; ++i2) {
          if (i2 === 1 && state.multisample > 1) {
            flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
            flop.filterFrame = flip.filterFrame;
          }
          filters2[i2].apply(this, flip, flop, CLEAR_MODES$4.CLEAR, state);
          var t2 = flip;
          flip = flop;
          flop = t2;
        }
        filters2[i2].apply(this, flip, lastState.renderTexture, CLEAR_MODES$4.BLEND, state);
        if (i2 > 1 && state.multisample > 1) {
          this.returnFilterTexture(state.renderTexture);
        }
        this.returnFilterTexture(flip);
        this.returnFilterTexture(flop);
      }
      state.clear();
      this.statePool.push(state);
    };
    FilterSystem2.prototype.bindAndClear = function(filterTexture, clearMode) {
      if (clearMode === void 0) {
        clearMode = CLEAR_MODES$4.CLEAR;
      }
      var _a2 = this.renderer, renderTextureSystem = _a2.renderTexture, stateSystem = _a2.state;
      if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
        this.renderer.projection.transform = this.activeState.transform;
      } else {
        this.renderer.projection.transform = null;
      }
      if (filterTexture && filterTexture.filterFrame) {
        var destinationFrame = this.tempRect;
        destinationFrame.x = 0;
        destinationFrame.y = 0;
        destinationFrame.width = filterTexture.filterFrame.width;
        destinationFrame.height = filterTexture.filterFrame.height;
        renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
      } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
        renderTextureSystem.bind(filterTexture);
      } else {
        this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
      }
      var autoClear = stateSystem.stateId & 1 || this.forceClear;
      if (clearMode === CLEAR_MODES$4.CLEAR || clearMode === CLEAR_MODES$4.BLIT && autoClear) {
        this.renderer.framebuffer.clear(0, 0, 0, 0);
      }
    };
    FilterSystem2.prototype.applyFilter = function(filter2, input, output2, clearMode) {
      var renderer = this.renderer;
      renderer.state.set(filter2.state);
      this.bindAndClear(output2, clearMode);
      filter2.uniforms.uSampler = input;
      filter2.uniforms.filterGlobals = this.globalUniforms;
      renderer.shader.bind(filter2);
      filter2.legacy = !!filter2.program.attributeData.aTextureCoord;
      if (filter2.legacy) {
        this.quadUv.map(input._frame, input.filterFrame);
        renderer.geometry.bind(this.quadUv);
        renderer.geometry.draw(DRAW_MODES$4.TRIANGLES);
      } else {
        renderer.geometry.bind(this.quad);
        renderer.geometry.draw(DRAW_MODES$4.TRIANGLE_STRIP);
      }
    };
    FilterSystem2.prototype.calculateSpriteMatrix = function(outputMatrix, sprite) {
      var _a2 = this.activeState, sourceFrame = _a2.sourceFrame, destinationFrame = _a2.destinationFrame;
      var orig = sprite._texture.orig;
      var mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
      var worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);
      worldTransform.invert();
      mappedMatrix.prepend(worldTransform);
      mappedMatrix.scale(1 / orig.width, 1 / orig.height);
      mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
      return mappedMatrix;
    };
    FilterSystem2.prototype.destroy = function() {
      this.renderer = null;
      this.texturePool.clear(false);
    };
    FilterSystem2.prototype.getOptimalFilterTexture = function(minWidth, minHeight, resolution, multisample) {
      if (resolution === void 0) {
        resolution = 1;
      }
      if (multisample === void 0) {
        multisample = MSAA_QUALITY$4.NONE;
      }
      return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
    };
    FilterSystem2.prototype.getFilterTexture = function(input, resolution, multisample) {
      if (typeof input === "number") {
        var swap = input;
        input = resolution;
        resolution = swap;
      }
      input = input || this.activeState.renderTexture;
      var filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY$4.NONE);
      filterTexture.filterFrame = input.filterFrame;
      return filterTexture;
    };
    FilterSystem2.prototype.returnFilterTexture = function(renderTexture) {
      this.texturePool.returnTexture(renderTexture);
    };
    FilterSystem2.prototype.emptyPool = function() {
      this.texturePool.clear(true);
    };
    FilterSystem2.prototype.resize = function() {
      this.texturePool.setScreenSize(this.renderer.view);
    };
    FilterSystem2.prototype.transformAABB = function(matrix, rect) {
      var lt = tempPoints[0];
      var lb2 = tempPoints[1];
      var rt = tempPoints[2];
      var rb2 = tempPoints[3];
      lt.set(rect.left, rect.top);
      lb2.set(rect.left, rect.bottom);
      rt.set(rect.right, rect.top);
      rb2.set(rect.right, rect.bottom);
      matrix.apply(lt, lt);
      matrix.apply(lb2, lb2);
      matrix.apply(rt, rt);
      matrix.apply(rb2, rb2);
      var x0 = Math.min(lt.x, lb2.x, rt.x, rb2.x);
      var y0 = Math.min(lt.y, lb2.y, rt.y, rb2.y);
      var x1 = Math.max(lt.x, lb2.x, rt.x, rb2.x);
      var y1 = Math.max(lt.y, lb2.y, rt.y, rb2.y);
      rect.x = x0;
      rect.y = y0;
      rect.width = x1 - x0;
      rect.height = y1 - y0;
    };
    FilterSystem2.prototype.roundFrame = function(frame2, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
      if (frame2.width <= 0 || frame2.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {
        return;
      }
      if (transform) {
        var a2 = transform.a, b2 = transform.b, c2 = transform.c, d2 = transform.d;
        if ((Math.abs(b2) > 1e-4 || Math.abs(c2) > 1e-4) && (Math.abs(a2) > 1e-4 || Math.abs(d2) > 1e-4)) {
          return;
        }
      }
      transform = transform ? tempMatrix$2.copyFrom(transform) : tempMatrix$2.identity();
      transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
      this.transformAABB(transform, frame2);
      frame2.ceil(resolution);
      this.transformAABB(transform.invert(), frame2);
    };
    return FilterSystem2;
  }()
);
var ObjectRenderer = (
  /** @class */
  function() {
    function ObjectRenderer2(renderer) {
      this.renderer = renderer;
    }
    ObjectRenderer2.prototype.flush = function() {
    };
    ObjectRenderer2.prototype.destroy = function() {
      this.renderer = null;
    };
    ObjectRenderer2.prototype.start = function() {
    };
    ObjectRenderer2.prototype.stop = function() {
      this.flush();
    };
    ObjectRenderer2.prototype.render = function(_object) {
    };
    return ObjectRenderer2;
  }()
);
var BatchSystem = (
  /** @class */
  function() {
    function BatchSystem2(renderer) {
      this.renderer = renderer;
      this.emptyRenderer = new ObjectRenderer(renderer);
      this.currentRenderer = this.emptyRenderer;
    }
    BatchSystem2.prototype.setObjectRenderer = function(objectRenderer) {
      if (this.currentRenderer === objectRenderer) {
        return;
      }
      this.currentRenderer.stop();
      this.currentRenderer = objectRenderer;
      this.currentRenderer.start();
    };
    BatchSystem2.prototype.flush = function() {
      this.setObjectRenderer(this.emptyRenderer);
    };
    BatchSystem2.prototype.reset = function() {
      this.setObjectRenderer(this.emptyRenderer);
    };
    BatchSystem2.prototype.copyBoundTextures = function(arr, maxTextures) {
      var boundTextures = this.renderer.texture.boundTextures;
      for (var i2 = maxTextures - 1; i2 >= 0; --i2) {
        arr[i2] = boundTextures[i2] || null;
        if (arr[i2]) {
          arr[i2]._batchLocation = i2;
        }
      }
    };
    BatchSystem2.prototype.boundArray = function(texArray, boundTextures, batchId, maxTextures) {
      var elements = texArray.elements, ids = texArray.ids, count = texArray.count;
      var j2 = 0;
      for (var i2 = 0; i2 < count; i2++) {
        var tex = elements[i2];
        var loc = tex._batchLocation;
        if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
          ids[i2] = loc;
          continue;
        }
        while (j2 < maxTextures) {
          var bound = boundTextures[j2];
          if (bound && bound._batchEnabled === batchId && bound._batchLocation === j2) {
            j2++;
            continue;
          }
          ids[i2] = j2;
          tex._batchLocation = j2;
          boundTextures[j2] = tex;
          break;
        }
      }
    };
    BatchSystem2.prototype.destroy = function() {
      this.renderer = null;
    };
    return BatchSystem2;
  }()
);
var CONTEXT_UID_COUNTER = 0;
var ContextSystem = (
  /** @class */
  function() {
    function ContextSystem2(renderer) {
      this.renderer = renderer;
      this.webGLVersion = 1;
      this.extensions = {};
      this.supports = {
        uint32Indices: false
      };
      this.handleContextLost = this.handleContextLost.bind(this);
      this.handleContextRestored = this.handleContextRestored.bind(this);
      renderer.view.addEventListener("webglcontextlost", this.handleContextLost, false);
      renderer.view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
    }
    Object.defineProperty(ContextSystem2.prototype, "isLost", {
      /**
       * `true` if the context is lost
       * @readonly
       */
      get: function() {
        return !this.gl || this.gl.isContextLost();
      },
      enumerable: false,
      configurable: true
    });
    ContextSystem2.prototype.contextChange = function(gl) {
      this.gl = gl;
      this.renderer.gl = gl;
      this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
      if (gl.isContextLost() && gl.getExtension("WEBGL_lose_context")) {
        gl.getExtension("WEBGL_lose_context").restoreContext();
      }
    };
    ContextSystem2.prototype.initFromContext = function(gl) {
      this.gl = gl;
      this.validateContext(gl);
      this.renderer.gl = gl;
      this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
      this.renderer.runners.contextChange.emit(gl);
    };
    ContextSystem2.prototype.initFromOptions = function(options) {
      var gl = this.createContext(this.renderer.view, options);
      this.initFromContext(gl);
    };
    ContextSystem2.prototype.createContext = function(canvas, options) {
      var gl;
      if (settings$2.PREFER_ENV >= ENV$4.WEBGL2) {
        gl = canvas.getContext("webgl2", options);
      }
      if (gl) {
        this.webGLVersion = 2;
      } else {
        this.webGLVersion = 1;
        gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
        if (!gl) {
          throw new Error("This browser does not support WebGL. Try using the canvas renderer");
        }
      }
      this.gl = gl;
      this.getExtensions();
      return this.gl;
    };
    ContextSystem2.prototype.getExtensions = function() {
      var gl = this.gl;
      var common2 = {
        anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
        s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        etc: gl.getExtension("WEBGL_compressed_texture_etc"),
        etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: gl.getExtension("WEBGL_compressed_texture_atc"),
        astc: gl.getExtension("WEBGL_compressed_texture_astc")
      };
      if (this.webGLVersion === 1) {
        Object.assign(this.extensions, common2, {
          drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
          depthTexture: gl.getExtension("WEBGL_depth_texture"),
          loseContext: gl.getExtension("WEBGL_lose_context"),
          vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
          uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
          // Floats and half-floats
          floatTexture: gl.getExtension("OES_texture_float"),
          floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
          textureHalfFloat: gl.getExtension("OES_texture_half_float"),
          textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
        });
      } else if (this.webGLVersion === 2) {
        Object.assign(this.extensions, common2, {
          // Floats and half-floats
          colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
        });
      }
    };
    ContextSystem2.prototype.handleContextLost = function(event) {
      event.preventDefault();
    };
    ContextSystem2.prototype.handleContextRestored = function() {
      this.renderer.runners.contextChange.emit(this.gl);
    };
    ContextSystem2.prototype.destroy = function() {
      var view = this.renderer.view;
      this.renderer = null;
      view.removeEventListener("webglcontextlost", this.handleContextLost);
      view.removeEventListener("webglcontextrestored", this.handleContextRestored);
      this.gl.useProgram(null);
      if (this.extensions.loseContext) {
        this.extensions.loseContext.loseContext();
      }
    };
    ContextSystem2.prototype.postrender = function() {
      if (this.renderer.renderingToScreen) {
        this.gl.flush();
      }
    };
    ContextSystem2.prototype.validateContext = function(gl) {
      var attributes = gl.getContextAttributes();
      var isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
      if (isWebGl2) {
        this.webGLVersion = 2;
      }
      if (attributes && !attributes.stencil) {
        console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
      }
      var hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
      this.supports.uint32Indices = hasuint32;
      if (!hasuint32) {
        console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
      }
    };
    return ContextSystem2;
  }()
);
var GLFramebuffer = (
  /** @class */
  function() {
    function GLFramebuffer2(framebuffer) {
      this.framebuffer = framebuffer;
      this.stencil = null;
      this.dirtyId = -1;
      this.dirtyFormat = -1;
      this.dirtySize = -1;
      this.multisample = MSAA_QUALITY$4.NONE;
      this.msaaBuffer = null;
      this.blitFramebuffer = null;
      this.mipLevel = 0;
    }
    return GLFramebuffer2;
  }()
);
var tempRectangle = new Rectangle();
var FramebufferSystem = (
  /** @class */
  function() {
    function FramebufferSystem2(renderer) {
      this.renderer = renderer;
      this.managedFramebuffers = [];
      this.unknownFramebuffer = new Framebuffer(10, 10);
      this.msaaSamples = null;
    }
    FramebufferSystem2.prototype.contextChange = function() {
      var gl = this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      this.current = this.unknownFramebuffer;
      this.viewport = new Rectangle();
      this.hasMRT = true;
      this.writeDepthTexture = true;
      this.disposeAll(true);
      if (this.renderer.context.webGLVersion === 1) {
        var nativeDrawBuffersExtension_1 = this.renderer.context.extensions.drawBuffers;
        var nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
        if (settings$2.PREFER_ENV === ENV$4.WEBGL_LEGACY) {
          nativeDrawBuffersExtension_1 = null;
          nativeDepthTextureExtension = null;
        }
        if (nativeDrawBuffersExtension_1) {
          gl.drawBuffers = function(activeTextures) {
            return nativeDrawBuffersExtension_1.drawBuffersWEBGL(activeTextures);
          };
        } else {
          this.hasMRT = false;
          gl.drawBuffers = function() {
          };
        }
        if (!nativeDepthTextureExtension) {
          this.writeDepthTexture = false;
        }
      } else {
        this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
      }
    };
    FramebufferSystem2.prototype.bind = function(framebuffer, frame2, mipLevel) {
      if (mipLevel === void 0) {
        mipLevel = 0;
      }
      var gl = this.gl;
      if (framebuffer) {
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
        if (this.current !== framebuffer) {
          this.current = framebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
        }
        if (fbo.mipLevel !== mipLevel) {
          framebuffer.dirtyId++;
          framebuffer.dirtyFormat++;
          fbo.mipLevel = mipLevel;
        }
        if (fbo.dirtyId !== framebuffer.dirtyId) {
          fbo.dirtyId = framebuffer.dirtyId;
          if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
            fbo.dirtyFormat = framebuffer.dirtyFormat;
            fbo.dirtySize = framebuffer.dirtySize;
            this.updateFramebuffer(framebuffer, mipLevel);
          } else if (fbo.dirtySize !== framebuffer.dirtySize) {
            fbo.dirtySize = framebuffer.dirtySize;
            this.resizeFramebuffer(framebuffer);
          }
        }
        for (var i2 = 0; i2 < framebuffer.colorTextures.length; i2++) {
          var tex = framebuffer.colorTextures[i2];
          this.renderer.texture.unbind(tex.parentTextureArray || tex);
        }
        if (framebuffer.depthTexture) {
          this.renderer.texture.unbind(framebuffer.depthTexture);
        }
        if (frame2) {
          var mipWidth = frame2.width >> mipLevel;
          var mipHeight = frame2.height >> mipLevel;
          var scale = mipWidth / frame2.width;
          this.setViewport(frame2.x * scale, frame2.y * scale, mipWidth, mipHeight);
        } else {
          var mipWidth = framebuffer.width >> mipLevel;
          var mipHeight = framebuffer.height >> mipLevel;
          this.setViewport(0, 0, mipWidth, mipHeight);
        }
      } else {
        if (this.current) {
          this.current = null;
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
        if (frame2) {
          this.setViewport(frame2.x, frame2.y, frame2.width, frame2.height);
        } else {
          this.setViewport(0, 0, this.renderer.width, this.renderer.height);
        }
      }
    };
    FramebufferSystem2.prototype.setViewport = function(x, y2, width, height) {
      var v2 = this.viewport;
      x = Math.round(x);
      y2 = Math.round(y2);
      width = Math.round(width);
      height = Math.round(height);
      if (v2.width !== width || v2.height !== height || v2.x !== x || v2.y !== y2) {
        v2.x = x;
        v2.y = y2;
        v2.width = width;
        v2.height = height;
        this.gl.viewport(x, y2, width, height);
      }
    };
    Object.defineProperty(FramebufferSystem2.prototype, "size", {
      /**
       * Get the size of the current width and height. Returns object with `width` and `height` values.
       * @readonly
       */
      get: function() {
        if (this.current) {
          return { x: 0, y: 0, width: this.current.width, height: this.current.height };
        }
        return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
      },
      enumerable: false,
      configurable: true
    });
    FramebufferSystem2.prototype.clear = function(r2, g2, b2, a2, mask2) {
      if (mask2 === void 0) {
        mask2 = BUFFER_BITS$4.COLOR | BUFFER_BITS$4.DEPTH;
      }
      var gl = this.gl;
      gl.clearColor(r2, g2, b2, a2);
      gl.clear(mask2);
    };
    FramebufferSystem2.prototype.initFramebuffer = function(framebuffer) {
      var gl = this.gl;
      var fbo = new GLFramebuffer(gl.createFramebuffer());
      fbo.multisample = this.detectSamples(framebuffer.multisample);
      framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
      this.managedFramebuffers.push(framebuffer);
      framebuffer.disposeRunner.add(this);
      return fbo;
    };
    FramebufferSystem2.prototype.resizeFramebuffer = function(framebuffer) {
      var gl = this.gl;
      var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      if (fbo.msaaBuffer) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);
      }
      if (fbo.stencil) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
        if (fbo.msaaBuffer) {
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
        } else {
          gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
        }
      }
      var colorTextures = framebuffer.colorTextures;
      var count = colorTextures.length;
      if (!gl.drawBuffers) {
        count = Math.min(count, 1);
      }
      for (var i2 = 0; i2 < count; i2++) {
        var texture = colorTextures[i2];
        var parentTexture = texture.parentTextureArray || texture;
        this.renderer.texture.bind(parentTexture, 0);
      }
      if (framebuffer.depthTexture && this.writeDepthTexture) {
        this.renderer.texture.bind(framebuffer.depthTexture, 0);
      }
    };
    FramebufferSystem2.prototype.updateFramebuffer = function(framebuffer, mipLevel) {
      var gl = this.gl;
      var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      var colorTextures = framebuffer.colorTextures;
      var count = colorTextures.length;
      if (!gl.drawBuffers) {
        count = Math.min(count, 1);
      }
      if (fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer)) {
        fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
      } else if (fbo.msaaBuffer) {
        gl.deleteRenderbuffer(fbo.msaaBuffer);
        fbo.msaaBuffer = null;
        if (fbo.blitFramebuffer) {
          fbo.blitFramebuffer.dispose();
          fbo.blitFramebuffer = null;
        }
      }
      var activeTextures = [];
      for (var i2 = 0; i2 < count; i2++) {
        var texture = colorTextures[i2];
        var parentTexture = texture.parentTextureArray || texture;
        this.renderer.texture.bind(parentTexture, 0);
        if (i2 === 0 && fbo.msaaBuffer) {
          continue;
        }
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i2, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
        activeTextures.push(gl.COLOR_ATTACHMENT0 + i2);
      }
      if (activeTextures.length > 1) {
        gl.drawBuffers(activeTextures);
      }
      if (framebuffer.depthTexture) {
        var writeDepthTexture = this.writeDepthTexture;
        if (writeDepthTexture) {
          var depthTexture = framebuffer.depthTexture;
          this.renderer.texture.bind(depthTexture, 0);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
        }
      }
      if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {
        fbo.stencil = fbo.stencil || gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
        if (fbo.msaaBuffer) {
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
        } else {
          gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
        }
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
      } else if (fbo.stencil) {
        gl.deleteRenderbuffer(fbo.stencil);
        fbo.stencil = null;
      }
    };
    FramebufferSystem2.prototype.canMultisampleFramebuffer = function(framebuffer) {
      return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;
    };
    FramebufferSystem2.prototype.detectSamples = function(samples) {
      var msaaSamples = this.msaaSamples;
      var res = MSAA_QUALITY$4.NONE;
      if (samples <= 1 || msaaSamples === null) {
        return res;
      }
      for (var i2 = 0; i2 < msaaSamples.length; i2++) {
        if (msaaSamples[i2] <= samples) {
          res = msaaSamples[i2];
          break;
        }
      }
      if (res === 1) {
        res = MSAA_QUALITY$4.NONE;
      }
      return res;
    };
    FramebufferSystem2.prototype.blit = function(framebuffer, sourcePixels, destPixels) {
      var _a2 = this, current = _a2.current, renderer = _a2.renderer, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
      if (renderer.context.webGLVersion !== 2) {
        return;
      }
      if (!current) {
        return;
      }
      var fbo = current.glFramebuffers[CONTEXT_UID];
      if (!fbo) {
        return;
      }
      if (!framebuffer) {
        if (!fbo.msaaBuffer) {
          return;
        }
        var colorTexture = current.colorTextures[0];
        if (!colorTexture) {
          return;
        }
        if (!fbo.blitFramebuffer) {
          fbo.blitFramebuffer = new Framebuffer(current.width, current.height);
          fbo.blitFramebuffer.addColorTexture(0, colorTexture);
        }
        framebuffer = fbo.blitFramebuffer;
        if (framebuffer.colorTextures[0] !== colorTexture) {
          framebuffer.colorTextures[0] = colorTexture;
          framebuffer.dirtyId++;
          framebuffer.dirtyFormat++;
        }
        if (framebuffer.width !== current.width || framebuffer.height !== current.height) {
          framebuffer.width = current.width;
          framebuffer.height = current.height;
          framebuffer.dirtyId++;
          framebuffer.dirtySize++;
        }
      }
      if (!sourcePixels) {
        sourcePixels = tempRectangle;
        sourcePixels.width = current.width;
        sourcePixels.height = current.height;
      }
      if (!destPixels) {
        destPixels = sourcePixels;
      }
      var sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
      this.bind(framebuffer);
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
      gl.blitFramebuffer(sourcePixels.left, sourcePixels.top, sourcePixels.right, sourcePixels.bottom, destPixels.left, destPixels.top, destPixels.right, destPixels.bottom, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
    };
    FramebufferSystem2.prototype.disposeFramebuffer = function(framebuffer, contextLost) {
      var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      var gl = this.gl;
      if (!fbo) {
        return;
      }
      delete framebuffer.glFramebuffers[this.CONTEXT_UID];
      var index2 = this.managedFramebuffers.indexOf(framebuffer);
      if (index2 >= 0) {
        this.managedFramebuffers.splice(index2, 1);
      }
      framebuffer.disposeRunner.remove(this);
      if (!contextLost) {
        gl.deleteFramebuffer(fbo.framebuffer);
        if (fbo.msaaBuffer) {
          gl.deleteRenderbuffer(fbo.msaaBuffer);
        }
        if (fbo.stencil) {
          gl.deleteRenderbuffer(fbo.stencil);
        }
      }
      if (fbo.blitFramebuffer) {
        fbo.blitFramebuffer.dispose();
      }
    };
    FramebufferSystem2.prototype.disposeAll = function(contextLost) {
      var list = this.managedFramebuffers;
      this.managedFramebuffers = [];
      for (var i2 = 0; i2 < list.length; i2++) {
        this.disposeFramebuffer(list[i2], contextLost);
      }
    };
    FramebufferSystem2.prototype.forceStencil = function() {
      var framebuffer = this.current;
      if (!framebuffer) {
        return;
      }
      var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      if (!fbo || fbo.stencil) {
        return;
      }
      framebuffer.stencil = true;
      var w2 = framebuffer.width;
      var h2 = framebuffer.height;
      var gl = this.gl;
      var stencil = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, w2, h2);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w2, h2);
      }
      fbo.stencil = stencil;
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
    };
    FramebufferSystem2.prototype.reset = function() {
      this.current = this.unknownFramebuffer;
      this.viewport = new Rectangle();
    };
    FramebufferSystem2.prototype.destroy = function() {
      this.renderer = null;
    };
    return FramebufferSystem2;
  }()
);
var byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
var GeometrySystem = (
  /** @class */
  function() {
    function GeometrySystem2(renderer) {
      this.renderer = renderer;
      this._activeGeometry = null;
      this._activeVao = null;
      this.hasVao = true;
      this.hasInstance = true;
      this.canUseUInt32ElementIndex = false;
      this.managedGeometries = {};
    }
    GeometrySystem2.prototype.contextChange = function() {
      this.disposeAll(true);
      var gl = this.gl = this.renderer.gl;
      var context2 = this.renderer.context;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      if (context2.webGLVersion !== 2) {
        var nativeVaoExtension_1 = this.renderer.context.extensions.vertexArrayObject;
        if (settings$2.PREFER_ENV === ENV$4.WEBGL_LEGACY) {
          nativeVaoExtension_1 = null;
        }
        if (nativeVaoExtension_1) {
          gl.createVertexArray = function() {
            return nativeVaoExtension_1.createVertexArrayOES();
          };
          gl.bindVertexArray = function(vao) {
            return nativeVaoExtension_1.bindVertexArrayOES(vao);
          };
          gl.deleteVertexArray = function(vao) {
            return nativeVaoExtension_1.deleteVertexArrayOES(vao);
          };
        } else {
          this.hasVao = false;
          gl.createVertexArray = function() {
            return null;
          };
          gl.bindVertexArray = function() {
            return null;
          };
          gl.deleteVertexArray = function() {
            return null;
          };
        }
      }
      if (context2.webGLVersion !== 2) {
        var instanceExt_1 = gl.getExtension("ANGLE_instanced_arrays");
        if (instanceExt_1) {
          gl.vertexAttribDivisor = function(a2, b2) {
            return instanceExt_1.vertexAttribDivisorANGLE(a2, b2);
          };
          gl.drawElementsInstanced = function(a2, b2, c2, d2, e2) {
            return instanceExt_1.drawElementsInstancedANGLE(a2, b2, c2, d2, e2);
          };
          gl.drawArraysInstanced = function(a2, b2, c2, d2) {
            return instanceExt_1.drawArraysInstancedANGLE(a2, b2, c2, d2);
          };
        } else {
          this.hasInstance = false;
        }
      }
      this.canUseUInt32ElementIndex = context2.webGLVersion === 2 || !!context2.extensions.uint32ElementIndex;
    };
    GeometrySystem2.prototype.bind = function(geometry, shader) {
      shader = shader || this.renderer.shader.shader;
      var gl = this.gl;
      var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
      var incRefCount = false;
      if (!vaos) {
        this.managedGeometries[geometry.id] = geometry;
        geometry.disposeRunner.add(this);
        geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
        incRefCount = true;
      }
      var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
      this._activeGeometry = geometry;
      if (this._activeVao !== vao) {
        this._activeVao = vao;
        if (this.hasVao) {
          gl.bindVertexArray(vao);
        } else {
          this.activateVao(geometry, shader.program);
        }
      }
      this.updateBuffers();
    };
    GeometrySystem2.prototype.reset = function() {
      this.unbind();
    };
    GeometrySystem2.prototype.updateBuffers = function() {
      var geometry = this._activeGeometry;
      var bufferSystem = this.renderer.buffer;
      for (var i2 = 0; i2 < geometry.buffers.length; i2++) {
        var buffer = geometry.buffers[i2];
        bufferSystem.update(buffer);
      }
    };
    GeometrySystem2.prototype.checkCompatibility = function(geometry, program) {
      var geometryAttributes = geometry.attributes;
      var shaderAttributes = program.attributeData;
      for (var j2 in shaderAttributes) {
        if (!geometryAttributes[j2]) {
          throw new Error('shader and geometry incompatible, geometry missing the "' + j2 + '" attribute');
        }
      }
    };
    GeometrySystem2.prototype.getSignature = function(geometry, program) {
      var attribs = geometry.attributes;
      var shaderAttributes = program.attributeData;
      var strings2 = ["g", geometry.id];
      for (var i2 in attribs) {
        if (shaderAttributes[i2]) {
          strings2.push(i2, shaderAttributes[i2].location);
        }
      }
      return strings2.join("-");
    };
    GeometrySystem2.prototype.initGeometryVao = function(geometry, shader, incRefCount) {
      if (incRefCount === void 0) {
        incRefCount = true;
      }
      var gl = this.gl;
      var CONTEXT_UID = this.CONTEXT_UID;
      var bufferSystem = this.renderer.buffer;
      var program = shader.program;
      if (!program.glPrograms[CONTEXT_UID]) {
        this.renderer.shader.generateProgram(shader);
      }
      this.checkCompatibility(geometry, program);
      var signature = this.getSignature(geometry, program);
      var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
      var vao = vaoObjectHash[signature];
      if (vao) {
        vaoObjectHash[program.id] = vao;
        return vao;
      }
      var buffers = geometry.buffers;
      var attributes = geometry.attributes;
      var tempStride = {};
      var tempStart = {};
      for (var j2 in buffers) {
        tempStride[j2] = 0;
        tempStart[j2] = 0;
      }
      for (var j2 in attributes) {
        if (!attributes[j2].size && program.attributeData[j2]) {
          attributes[j2].size = program.attributeData[j2].size;
        } else if (!attributes[j2].size) {
          console.warn("PIXI Geometry attribute '" + j2 + "' size cannot be determined (likely the bound shader does not have the attribute)");
        }
        tempStride[attributes[j2].buffer] += attributes[j2].size * byteSizeMap[attributes[j2].type];
      }
      for (var j2 in attributes) {
        var attribute = attributes[j2];
        var attribSize = attribute.size;
        if (attribute.stride === void 0) {
          if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type]) {
            attribute.stride = 0;
          } else {
            attribute.stride = tempStride[attribute.buffer];
          }
        }
        if (attribute.start === void 0) {
          attribute.start = tempStart[attribute.buffer];
          tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];
        }
      }
      vao = gl.createVertexArray();
      gl.bindVertexArray(vao);
      for (var i2 = 0; i2 < buffers.length; i2++) {
        var buffer = buffers[i2];
        bufferSystem.bind(buffer);
        if (incRefCount) {
          buffer._glBuffers[CONTEXT_UID].refCount++;
        }
      }
      this.activateVao(geometry, program);
      this._activeVao = vao;
      vaoObjectHash[program.id] = vao;
      vaoObjectHash[signature] = vao;
      return vao;
    };
    GeometrySystem2.prototype.disposeGeometry = function(geometry, contextLost) {
      var _a2;
      if (!this.managedGeometries[geometry.id]) {
        return;
      }
      delete this.managedGeometries[geometry.id];
      var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
      var gl = this.gl;
      var buffers = geometry.buffers;
      var bufferSystem = (_a2 = this.renderer) === null || _a2 === void 0 ? void 0 : _a2.buffer;
      geometry.disposeRunner.remove(this);
      if (!vaos) {
        return;
      }
      if (bufferSystem) {
        for (var i2 = 0; i2 < buffers.length; i2++) {
          var buf = buffers[i2]._glBuffers[this.CONTEXT_UID];
          if (buf) {
            buf.refCount--;
            if (buf.refCount === 0 && !contextLost) {
              bufferSystem.dispose(buffers[i2], contextLost);
            }
          }
        }
      }
      if (!contextLost) {
        for (var vaoId in vaos) {
          if (vaoId[0] === "g") {
            var vao = vaos[vaoId];
            if (this._activeVao === vao) {
              this.unbind();
            }
            gl.deleteVertexArray(vao);
          }
        }
      }
      delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
    };
    GeometrySystem2.prototype.disposeAll = function(contextLost) {
      var all3 = Object.keys(this.managedGeometries);
      for (var i2 = 0; i2 < all3.length; i2++) {
        this.disposeGeometry(this.managedGeometries[all3[i2]], contextLost);
      }
    };
    GeometrySystem2.prototype.activateVao = function(geometry, program) {
      var gl = this.gl;
      var CONTEXT_UID = this.CONTEXT_UID;
      var bufferSystem = this.renderer.buffer;
      var buffers = geometry.buffers;
      var attributes = geometry.attributes;
      if (geometry.indexBuffer) {
        bufferSystem.bind(geometry.indexBuffer);
      }
      var lastBuffer = null;
      for (var j2 in attributes) {
        var attribute = attributes[j2];
        var buffer = buffers[attribute.buffer];
        var glBuffer = buffer._glBuffers[CONTEXT_UID];
        if (program.attributeData[j2]) {
          if (lastBuffer !== glBuffer) {
            bufferSystem.bind(buffer);
            lastBuffer = glBuffer;
          }
          var location = program.attributeData[j2].location;
          gl.enableVertexAttribArray(location);
          gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
          if (attribute.instance) {
            if (this.hasInstance) {
              gl.vertexAttribDivisor(location, 1);
            } else {
              throw new Error("geometry error, GPU Instancing is not supported on this device");
            }
          }
        }
      }
    };
    GeometrySystem2.prototype.draw = function(type2, size, start, instanceCount) {
      var gl = this.gl;
      var geometry = this._activeGeometry;
      if (geometry.indexBuffer) {
        var byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
        var glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
        if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
          if (geometry.instanced) {
            gl.drawElementsInstanced(type2, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);
          } else {
            gl.drawElements(type2, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
          }
        } else {
          console.warn("unsupported index buffer type: uint32");
        }
      } else if (geometry.instanced) {
        gl.drawArraysInstanced(type2, start, size || geometry.getSize(), instanceCount || 1);
      } else {
        gl.drawArrays(type2, start, size || geometry.getSize());
      }
      return this;
    };
    GeometrySystem2.prototype.unbind = function() {
      this.gl.bindVertexArray(null);
      this._activeVao = null;
      this._activeGeometry = null;
    };
    GeometrySystem2.prototype.destroy = function() {
      this.renderer = null;
    };
    return GeometrySystem2;
  }()
);
var MaskData = (
  /** @class */
  function() {
    function MaskData2(maskObject) {
      if (maskObject === void 0) {
        maskObject = null;
      }
      this.type = MASK_TYPES$4.NONE;
      this.autoDetect = true;
      this.maskObject = maskObject || null;
      this.pooled = false;
      this.isMaskData = true;
      this.resolution = null;
      this.multisample = settings$2.FILTER_MULTISAMPLE;
      this.enabled = true;
      this._filters = null;
      this._stencilCounter = 0;
      this._scissorCounter = 0;
      this._scissorRect = null;
      this._scissorRectLocal = null;
      this._target = null;
    }
    Object.defineProperty(MaskData2.prototype, "filter", {
      /**
       * The sprite mask filter.
       * If set to `null`, the default sprite mask filter is used.
       * @default null
       */
      get: function() {
        return this._filters ? this._filters[0] : null;
      },
      set: function(value) {
        if (value) {
          if (this._filters) {
            this._filters[0] = value;
          } else {
            this._filters = [value];
          }
        } else {
          this._filters = null;
        }
      },
      enumerable: false,
      configurable: true
    });
    MaskData2.prototype.reset = function() {
      if (this.pooled) {
        this.maskObject = null;
        this.type = MASK_TYPES$4.NONE;
        this.autoDetect = true;
      }
      this._target = null;
      this._scissorRectLocal = null;
    };
    MaskData2.prototype.copyCountersOrReset = function(maskAbove) {
      if (maskAbove) {
        this._stencilCounter = maskAbove._stencilCounter;
        this._scissorCounter = maskAbove._scissorCounter;
        this._scissorRect = maskAbove._scissorRect;
      } else {
        this._stencilCounter = 0;
        this._scissorCounter = 0;
        this._scissorRect = null;
      }
    };
    return MaskData2;
  }()
);
function compileShader(gl, type2, src) {
  var shader = gl.createShader(type2);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}
function logPrettyShaderError(gl, shader) {
  var shaderSrc = gl.getShaderSource(shader).split("\n").map(function(line2, index2) {
    return index2 + ": " + line2;
  });
  var shaderLog = gl.getShaderInfoLog(shader);
  var splitShader = shaderLog.split("\n");
  var dedupe = {};
  var lineNumbers = splitShader.map(function(line2) {
    return parseFloat(line2.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
  }).filter(function(n2) {
    if (n2 && !dedupe[n2]) {
      dedupe[n2] = true;
      return true;
    }
    return false;
  });
  var logArgs = [""];
  lineNumbers.forEach(function(number2) {
    shaderSrc[number2 - 1] = "%c" + shaderSrc[number2 - 1] + "%c";
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  var fragmentSourceToLog = shaderSrc.join("\n");
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn.apply(console, logArgs);
  console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
}
function booleanArray(size) {
  var array = new Array(size);
  for (var i2 = 0; i2 < array.length; i2++) {
    array[i2] = false;
  }
  return array;
}
function defaultValue(type2, size) {
  switch (type2) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size);
    case "vec3":
      return new Float32Array(3 * size);
    case "vec4":
      return new Float32Array(4 * size);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size);
    case "ivec3":
      return new Int32Array(3 * size);
    case "ivec4":
      return new Int32Array(4 * size);
    case "uvec2":
      return new Uint32Array(2 * size);
    case "uvec3":
      return new Uint32Array(3 * size);
    case "uvec4":
      return new Uint32Array(4 * size);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size);
    case "bvec3":
      return booleanArray(3 * size);
    case "bvec4":
      return booleanArray(4 * size);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var unknownContext = {};
var context = unknownContext;
function getTestContext() {
  if (context === unknownContext || context && context.isContextLost()) {
    var canvas = document.createElement("canvas");
    var gl = void 0;
    if (settings$2.PREFER_ENV >= ENV$4.WEBGL2) {
      gl = canvas.getContext("webgl2", {});
    }
    if (!gl) {
      gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {});
      if (!gl) {
        gl = null;
      } else {
        gl.getExtension("WEBGL_draw_buffers");
      }
    }
    context = gl;
  }
  return context;
}
var maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = PRECISION$4.MEDIUM;
    var gl = getTestContext();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        var shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? PRECISION$4.HIGH : PRECISION$4.MEDIUM;
      }
    }
  }
  return maxFragmentPrecision;
}
function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
  if (src.substring(0, 9) !== "precision") {
    var precision = requestedPrecision;
    if (requestedPrecision === PRECISION$4.HIGH && maxSupportedPrecision !== PRECISION$4.HIGH) {
      precision = PRECISION$4.MEDIUM;
    }
    return "precision " + precision + " float;\n" + src;
  } else if (maxSupportedPrecision !== PRECISION$4.HIGH && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}
var GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize(type2) {
  return GLSL_TO_SIZE[type2];
}
var GL_TABLE = null;
var GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType(gl, type2) {
  if (!GL_TABLE) {
    var typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (var i2 = 0; i2 < typeNames.length; ++i2) {
      var tn2 = typeNames[i2];
      GL_TABLE[gl[tn2]] = GL_TO_GLSL_TYPES[tn2];
    }
  }
  return GL_TABLE[type2];
}
var uniformParsers = [
  // a float cache layer
  {
    test: function(data2) {
      return data2.type === "float" && data2.size === 1;
    },
    code: function(name) {
      return '\n            if(uv["' + name + '"] !== ud["' + name + '"].value)\n            {\n                ud["' + name + '"].value = uv["' + name + '"]\n                gl.uniform1f(ud["' + name + '"].location, uv["' + name + '"])\n            }\n            ';
    }
  },
  // handling samplers
  {
    test: function(data2) {
      return (data2.type === "sampler2D" || data2.type === "samplerCube" || data2.type === "sampler2DArray") && data2.size === 1 && !data2.isArray;
    },
    code: function(name) {
      return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + name + '"], t);\n\n            if(ud["' + name + '"].value !== t)\n            {\n                ud["' + name + '"].value = t;\n                gl.uniform1i(ud["' + name + '"].location, t);\n; // eslint-disable-line max-len\n            }';
    }
  },
  // uploading pixi matrix object to mat3
  {
    test: function(data2, uniform) {
      return data2.type === "mat3" && data2.size === 1 && uniform.a !== void 0;
    },
    code: function(name) {
      return '\n            gl.uniformMatrix3fv(ud["' + name + '"].location, false, uv["' + name + '"].toArray(true));\n            ';
    },
    codeUbo: function(name) {
      return "\n                var " + name + "_matrix = uv." + name + ".toArray(true);\n\n                data[offset] = " + name + "_matrix[0];\n                data[offset+1] = " + name + "_matrix[1];\n                data[offset+2] = " + name + "_matrix[2];\n        \n                data[offset + 4] = " + name + "_matrix[3];\n                data[offset + 5] = " + name + "_matrix[4];\n                data[offset + 6] = " + name + "_matrix[5];\n        \n                data[offset + 8] = " + name + "_matrix[6];\n                data[offset + 9] = " + name + "_matrix[7];\n                data[offset + 10] = " + name + "_matrix[8];\n            ";
    }
  },
  // uploading a pixi point as a vec2 with caching layer
  {
    test: function(data2, uniform) {
      return data2.type === "vec2" && data2.size === 1 && uniform.x !== void 0;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + name + '"].location, v.x, v.y);\n                }';
    },
    codeUbo: function(name) {
      return "\n                v = uv." + name + ";\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            ";
    }
  },
  // caching layer for a vec2
  {
    test: function(data2) {
      return data2.type === "vec2" && data2.size === 1;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + name + '"].location, v[0], v[1]);\n                }\n            ';
    }
  },
  // upload a pixi rectangle as a vec4 with caching layer
  {
    test: function(data2, uniform) {
      return data2.type === "vec4" && data2.size === 1 && uniform.width !== void 0;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + name + '"].location, v.x, v.y, v.width, v.height)\n                }';
    },
    codeUbo: function(name) {
      return "\n                    v = uv." + name + ";\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                ";
    }
  },
  // a caching layer for vec4 uploading
  {
    test: function(data2) {
      return data2.type === "vec4" && data2.size === 1;
    },
    code: function(name) {
      return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + name + '"].location, v[0], v[1], v[2], v[3])\n                }';
    }
  }
];
var GLSL_TO_SINGLE_SETTERS_CACHED = {
  float: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }",
  vec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }",
  vec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
  vec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }",
  int: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
  ivec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
  ivec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
  ivec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
  uint: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }",
  uvec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }",
  uvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }",
  uvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }",
  bool: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }",
  bvec2: "\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
  bvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
  bvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: "gl.uniform1i(location, v)",
  samplerCube: "gl.uniform1i(location, v)",
  sampler2DArray: "gl.uniform1i(location, v)"
};
var GLSL_TO_ARRAY_SETTERS = {
  float: "gl.uniform1fv(location, v)",
  vec2: "gl.uniform2fv(location, v)",
  vec3: "gl.uniform3fv(location, v)",
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync(group, uniformData) {
  var _a2;
  var funcFragments = ["\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    "];
  for (var i2 in group.uniforms) {
    var data2 = uniformData[i2];
    if (!data2) {
      if ((_a2 = group.uniforms[i2]) === null || _a2 === void 0 ? void 0 : _a2.group) {
        if (group.uniforms[i2].ubo) {
          funcFragments.push("\n                        renderer.shader.syncUniformBufferGroup(uv." + i2 + ", '" + i2 + "');\n                    ");
        } else {
          funcFragments.push("\n                        renderer.shader.syncUniformGroup(uv." + i2 + ", syncData);\n                    ");
        }
      }
      continue;
    }
    var uniform = group.uniforms[i2];
    var parsed = false;
    for (var j2 = 0; j2 < uniformParsers.length; j2++) {
      if (uniformParsers[j2].test(data2, uniform)) {
        funcFragments.push(uniformParsers[j2].code(i2, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      var templateType = data2.size === 1 ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
      var template = templateType[data2.type].replace("location", 'ud["' + i2 + '"].location');
      funcFragments.push('\n            cu = ud["' + i2 + '"];\n            cv = cu.value;\n            v = uv["' + i2 + '"];\n            ' + template + ";");
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}
var fragTemplate$1 = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join("\n");
function generateIfTestSrc(maxIfs) {
  var src = "";
  for (var i2 = 0; i2 < maxIfs; ++i2) {
    if (i2 > 0) {
      src += "\nelse ";
    }
    if (i2 < maxIfs - 1) {
      src += "if(test == " + i2 + ".0){}";
    }
  }
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  var shader = gl.createShader(gl.FRAGMENT_SHADER);
  while (true) {
    var fragmentSrc = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
    gl.shaderSource(shader, fragmentSrc);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      maxIfs = maxIfs / 2 | 0;
    } else {
      break;
    }
  }
  return maxIfs;
}
var unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    var func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({ a: "b" }, "a", "b") === true;
  } catch (e2) {
    unsafeEval = false;
  }
  return unsafeEval;
}
var defaultFragment$2 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
var defaultVertex$3 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
var UID$1 = 0;
var nameCache = {};
var Program = (
  /** @class */
  function() {
    function Program2(vertexSrc, fragmentSrc, name) {
      if (name === void 0) {
        name = "pixi-shader";
      }
      this.id = UID$1++;
      this.vertexSrc = vertexSrc || Program2.defaultVertexSrc;
      this.fragmentSrc = fragmentSrc || Program2.defaultFragmentSrc;
      this.vertexSrc = this.vertexSrc.trim();
      this.fragmentSrc = this.fragmentSrc.trim();
      if (this.vertexSrc.substring(0, 8) !== "#version") {
        name = name.replace(/\s+/g, "-");
        if (nameCache[name]) {
          nameCache[name]++;
          name += "-" + nameCache[name];
        } else {
          nameCache[name] = 1;
        }
        this.vertexSrc = "#define SHADER_NAME " + name + "\n" + this.vertexSrc;
        this.fragmentSrc = "#define SHADER_NAME " + name + "\n" + this.fragmentSrc;
        this.vertexSrc = setPrecision(this.vertexSrc, settings$2.PRECISION_VERTEX, PRECISION$4.HIGH);
        this.fragmentSrc = setPrecision(this.fragmentSrc, settings$2.PRECISION_FRAGMENT, getMaxFragmentPrecision());
      }
      this.glPrograms = {};
      this.syncUniforms = null;
    }
    Object.defineProperty(Program2, "defaultVertexSrc", {
      /**
       * The default vertex shader source.
       * @constant
       */
      get: function() {
        return defaultVertex$3;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Program2, "defaultFragmentSrc", {
      /**
       * The default fragment shader source.
       * @constant
       */
      get: function() {
        return defaultFragment$2;
      },
      enumerable: false,
      configurable: true
    });
    Program2.from = function(vertexSrc, fragmentSrc, name) {
      var key = vertexSrc + fragmentSrc;
      var program = ProgramCache[key];
      if (!program) {
        ProgramCache[key] = program = new Program2(vertexSrc, fragmentSrc, name);
      }
      return program;
    };
    return Program2;
  }()
);
var Shader = (
  /** @class */
  function() {
    function Shader2(program, uniforms) {
      this.uniformBindCount = 0;
      this.program = program;
      if (uniforms) {
        if (uniforms instanceof UniformGroup) {
          this.uniformGroup = uniforms;
        } else {
          this.uniformGroup = new UniformGroup(uniforms);
        }
      } else {
        this.uniformGroup = new UniformGroup({});
      }
    }
    Shader2.prototype.checkUniformExists = function(name, group) {
      if (group.uniforms[name]) {
        return true;
      }
      for (var i2 in group.uniforms) {
        var uniform = group.uniforms[i2];
        if (uniform.group) {
          if (this.checkUniformExists(name, uniform)) {
            return true;
          }
        }
      }
      return false;
    };
    Shader2.prototype.destroy = function() {
      this.uniformGroup = null;
    };
    Object.defineProperty(Shader2.prototype, "uniforms", {
      /**
       * Shader uniform values, shortcut for `uniformGroup.uniforms`.
       * @readonly
       */
      get: function() {
        return this.uniformGroup.uniforms;
      },
      enumerable: false,
      configurable: true
    });
    Shader2.from = function(vertexSrc, fragmentSrc, uniforms) {
      var program = Program.from(vertexSrc, fragmentSrc);
      return new Shader2(program, uniforms);
    };
    return Shader2;
  }()
);
var BLEND$1 = 0;
var OFFSET$1 = 1;
var CULLING$1 = 2;
var DEPTH_TEST$1 = 3;
var WINDING$1 = 4;
var DEPTH_MASK$1 = 5;
var State = (
  /** @class */
  function() {
    function State2() {
      this.data = 0;
      this.blendMode = BLEND_MODES$4.NORMAL;
      this.polygonOffset = 0;
      this.blend = true;
      this.depthMask = true;
    }
    Object.defineProperty(State2.prototype, "blend", {
      /**
       * Activates blending of the computed fragment color values.
       * @default true
       */
      get: function() {
        return !!(this.data & 1 << BLEND$1);
      },
      set: function(value) {
        if (!!(this.data & 1 << BLEND$1) !== value) {
          this.data ^= 1 << BLEND$1;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State2.prototype, "offsets", {
      /**
       * Activates adding an offset to depth values of polygon's fragments
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << OFFSET$1);
      },
      set: function(value) {
        if (!!(this.data & 1 << OFFSET$1) !== value) {
          this.data ^= 1 << OFFSET$1;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State2.prototype, "culling", {
      /**
       * Activates culling of polygons.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << CULLING$1);
      },
      set: function(value) {
        if (!!(this.data & 1 << CULLING$1) !== value) {
          this.data ^= 1 << CULLING$1;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State2.prototype, "depthTest", {
      /**
       * Activates depth comparisons and updates to the depth buffer.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << DEPTH_TEST$1);
      },
      set: function(value) {
        if (!!(this.data & 1 << DEPTH_TEST$1) !== value) {
          this.data ^= 1 << DEPTH_TEST$1;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State2.prototype, "depthMask", {
      /**
       * Enables or disables writing to the depth buffer.
       * @default true
       */
      get: function() {
        return !!(this.data & 1 << DEPTH_MASK$1);
      },
      set: function(value) {
        if (!!(this.data & 1 << DEPTH_MASK$1) !== value) {
          this.data ^= 1 << DEPTH_MASK$1;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State2.prototype, "clockwiseFrontFace", {
      /**
       * Specifies whether or not front or back-facing polygons can be culled.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << WINDING$1);
      },
      set: function(value) {
        if (!!(this.data & 1 << WINDING$1) !== value) {
          this.data ^= 1 << WINDING$1;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State2.prototype, "blendMode", {
      /**
       * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
       * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get: function() {
        return this._blendMode;
      },
      set: function(value) {
        this.blend = value !== BLEND_MODES$4.NONE;
        this._blendMode = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(State2.prototype, "polygonOffset", {
      /**
       * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
       * @default 0
       */
      get: function() {
        return this._polygonOffset;
      },
      set: function(value) {
        this.offsets = !!value;
        this._polygonOffset = value;
      },
      enumerable: false,
      configurable: true
    });
    State2.prototype.toString = function() {
      return "[@pixi/core:State " + ("blendMode=" + this.blendMode + " ") + ("clockwiseFrontFace=" + this.clockwiseFrontFace + " ") + ("culling=" + this.culling + " ") + ("depthMask=" + this.depthMask + " ") + ("polygonOffset=" + this.polygonOffset) + "]";
    };
    State2.for2d = function() {
      var state = new State2();
      state.depthTest = false;
      state.blend = true;
      return state;
    };
    return State2;
  }()
);
var defaultVertex$2 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
var defaultFragment$1 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
var Filter = (
  /** @class */
  function(_super) {
    __extends$U(Filter2, _super);
    function Filter2(vertexSrc, fragmentSrc, uniforms) {
      var _this = this;
      var program = Program.from(vertexSrc || Filter2.defaultVertexSrc, fragmentSrc || Filter2.defaultFragmentSrc);
      _this = _super.call(this, program, uniforms) || this;
      _this.padding = 0;
      _this.resolution = settings$2.FILTER_RESOLUTION;
      _this.multisample = settings$2.FILTER_MULTISAMPLE;
      _this.enabled = true;
      _this.autoFit = true;
      _this.state = new State();
      return _this;
    }
    Filter2.prototype.apply = function(filterManager, input, output2, clearMode, _currentState) {
      filterManager.applyFilter(this, input, output2, clearMode);
    };
    Object.defineProperty(Filter2.prototype, "blendMode", {
      /**
       * Sets the blend mode of the filter.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get: function() {
        return this.state.blendMode;
      },
      set: function(value) {
        this.state.blendMode = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Filter2.prototype, "resolution", {
      /**
       * The resolution of the filter. Setting this to be lower will lower the quality but
       * increase the performance of the filter.
       */
      get: function() {
        return this._resolution;
      },
      set: function(value) {
        this._resolution = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Filter2, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       * @constant
       */
      get: function() {
        return defaultVertex$2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Filter2, "defaultFragmentSrc", {
      /**
       * The default fragment shader source
       * @constant
       */
      get: function() {
        return defaultFragment$1;
      },
      enumerable: false,
      configurable: true
    });
    return Filter2;
  }(Shader)
);
var vertex$z = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";
var fragment$C = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";
var tempMat$1 = new Matrix();
var TextureMatrix = (
  /** @class */
  function() {
    function TextureMatrix2(texture, clampMargin) {
      this._texture = texture;
      this.mapCoord = new Matrix();
      this.uClampFrame = new Float32Array(4);
      this.uClampOffset = new Float32Array(2);
      this._textureID = -1;
      this._updateID = 0;
      this.clampOffset = 0;
      this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
      this.isSimple = false;
    }
    Object.defineProperty(TextureMatrix2.prototype, "texture", {
      /** Texture property. */
      get: function() {
        return this._texture;
      },
      set: function(value) {
        this._texture = value;
        this._textureID = -1;
      },
      enumerable: false,
      configurable: true
    });
    TextureMatrix2.prototype.multiplyUvs = function(uvs, out) {
      if (out === void 0) {
        out = uvs;
      }
      var mat = this.mapCoord;
      for (var i2 = 0; i2 < uvs.length; i2 += 2) {
        var x = uvs[i2];
        var y2 = uvs[i2 + 1];
        out[i2] = x * mat.a + y2 * mat.c + mat.tx;
        out[i2 + 1] = x * mat.b + y2 * mat.d + mat.ty;
      }
      return out;
    };
    TextureMatrix2.prototype.update = function(forceUpdate) {
      var tex = this._texture;
      if (!tex || !tex.valid) {
        return false;
      }
      if (!forceUpdate && this._textureID === tex._updateID) {
        return false;
      }
      this._textureID = tex._updateID;
      this._updateID++;
      var uvs = tex._uvs;
      this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
      var orig = tex.orig;
      var trim2 = tex.trim;
      if (trim2) {
        tempMat$1.set(orig.width / trim2.width, 0, 0, orig.height / trim2.height, -trim2.x / trim2.width, -trim2.y / trim2.height);
        this.mapCoord.append(tempMat$1);
      }
      var texBase = tex.baseTexture;
      var frame2 = this.uClampFrame;
      var margin = this.clampMargin / texBase.resolution;
      var offset = this.clampOffset;
      frame2[0] = (tex._frame.x + margin + offset) / texBase.width;
      frame2[1] = (tex._frame.y + margin + offset) / texBase.height;
      frame2[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
      frame2[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
      this.uClampOffset[0] = offset / texBase.realWidth;
      this.uClampOffset[1] = offset / texBase.realHeight;
      this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
      return true;
    };
    return TextureMatrix2;
  }()
);
var SpriteMaskFilter = (
  /** @class */
  function(_super) {
    __extends$U(SpriteMaskFilter2, _super);
    function SpriteMaskFilter2(vertexSrc, fragmentSrc, uniforms) {
      var _this = this;
      var sprite = null;
      if (typeof vertexSrc !== "string" && fragmentSrc === void 0 && uniforms === void 0) {
        sprite = vertexSrc;
        vertexSrc = void 0;
        fragmentSrc = void 0;
        uniforms = void 0;
      }
      _this = _super.call(this, vertexSrc || vertex$z, fragmentSrc || fragment$C, uniforms) || this;
      _this.maskSprite = sprite;
      _this.maskMatrix = new Matrix();
      return _this;
    }
    Object.defineProperty(SpriteMaskFilter2.prototype, "maskSprite", {
      /**
       * Sprite mask
       * @type {PIXI.DisplayObject}
       */
      get: function() {
        return this._maskSprite;
      },
      set: function(value) {
        this._maskSprite = value;
        if (this._maskSprite) {
          this._maskSprite.renderable = false;
        }
      },
      enumerable: false,
      configurable: true
    });
    SpriteMaskFilter2.prototype.apply = function(filterManager, input, output2, clearMode) {
      var maskSprite = this._maskSprite;
      var tex = maskSprite._texture;
      if (!tex.valid) {
        return;
      }
      if (!tex.uvMatrix) {
        tex.uvMatrix = new TextureMatrix(tex, 0);
      }
      tex.uvMatrix.update();
      this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
      this.uniforms.mask = tex;
      this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
      this.uniforms.alpha = maskSprite.worldAlpha;
      this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
      filterManager.applyFilter(this, input, output2, clearMode);
    };
    return SpriteMaskFilter2;
  }(Filter)
);
var MaskSystem = (
  /** @class */
  function() {
    function MaskSystem2(renderer) {
      this.renderer = renderer;
      this.enableScissor = true;
      this.alphaMaskPool = [];
      this.maskDataPool = [];
      this.maskStack = [];
      this.alphaMaskIndex = 0;
    }
    MaskSystem2.prototype.setMaskStack = function(maskStack) {
      this.maskStack = maskStack;
      this.renderer.scissor.setMaskStack(maskStack);
      this.renderer.stencil.setMaskStack(maskStack);
    };
    MaskSystem2.prototype.push = function(target, maskDataOrTarget) {
      var maskData = maskDataOrTarget;
      if (!maskData.isMaskData) {
        var d2 = this.maskDataPool.pop() || new MaskData();
        d2.pooled = true;
        d2.maskObject = maskDataOrTarget;
        maskData = d2;
      }
      var maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
      maskData.copyCountersOrReset(maskAbove);
      if (maskData.autoDetect) {
        this.detect(maskData);
      }
      maskData._target = target;
      if (maskData.type !== MASK_TYPES$4.SPRITE) {
        this.maskStack.push(maskData);
      }
      if (maskData.enabled) {
        switch (maskData.type) {
          case MASK_TYPES$4.SCISSOR:
            this.renderer.scissor.push(maskData);
            break;
          case MASK_TYPES$4.STENCIL:
            this.renderer.stencil.push(maskData);
            break;
          case MASK_TYPES$4.SPRITE:
            maskData.copyCountersOrReset(null);
            this.pushSpriteMask(maskData);
            break;
        }
      }
      if (maskData.type === MASK_TYPES$4.SPRITE) {
        this.maskStack.push(maskData);
      }
    };
    MaskSystem2.prototype.pop = function(target) {
      var maskData = this.maskStack.pop();
      if (!maskData || maskData._target !== target) {
        return;
      }
      if (maskData.enabled) {
        switch (maskData.type) {
          case MASK_TYPES$4.SCISSOR:
            this.renderer.scissor.pop();
            break;
          case MASK_TYPES$4.STENCIL:
            this.renderer.stencil.pop(maskData.maskObject);
            break;
          case MASK_TYPES$4.SPRITE:
            this.popSpriteMask(maskData);
            break;
        }
      }
      maskData.reset();
      if (maskData.pooled) {
        this.maskDataPool.push(maskData);
      }
      if (this.maskStack.length !== 0) {
        var maskCurrent = this.maskStack[this.maskStack.length - 1];
        if (maskCurrent.type === MASK_TYPES$4.SPRITE && maskCurrent._filters) {
          maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;
        }
      }
    };
    MaskSystem2.prototype.detect = function(maskData) {
      var maskObject = maskData.maskObject;
      if (maskObject.isSprite) {
        maskData.type = MASK_TYPES$4.SPRITE;
      } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {
        maskData.type = MASK_TYPES$4.SCISSOR;
      } else {
        maskData.type = MASK_TYPES$4.STENCIL;
      }
    };
    MaskSystem2.prototype.pushSpriteMask = function(maskData) {
      var _a2, _b2;
      var maskObject = maskData.maskObject;
      var target = maskData._target;
      var alphaMaskFilter = maskData._filters;
      if (!alphaMaskFilter) {
        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
        if (!alphaMaskFilter) {
          alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()];
        }
      }
      var renderer = this.renderer;
      var renderTextureSystem = renderer.renderTexture;
      var resolution;
      var multisample;
      if (renderTextureSystem.current) {
        var renderTexture = renderTextureSystem.current;
        resolution = maskData.resolution || renderTexture.resolution;
        multisample = (_a2 = maskData.multisample) !== null && _a2 !== void 0 ? _a2 : renderTexture.multisample;
      } else {
        resolution = maskData.resolution || renderer.resolution;
        multisample = (_b2 = maskData.multisample) !== null && _b2 !== void 0 ? _b2 : renderer.multisample;
      }
      alphaMaskFilter[0].resolution = resolution;
      alphaMaskFilter[0].multisample = multisample;
      alphaMaskFilter[0].maskSprite = maskObject;
      var stashFilterArea = target.filterArea;
      target.filterArea = maskObject.getBounds(true);
      renderer.filter.push(target, alphaMaskFilter);
      target.filterArea = stashFilterArea;
      if (!maskData._filters) {
        this.alphaMaskIndex++;
      }
    };
    MaskSystem2.prototype.popSpriteMask = function(maskData) {
      this.renderer.filter.pop();
      if (maskData._filters) {
        maskData._filters[0].maskSprite = null;
      } else {
        this.alphaMaskIndex--;
        this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;
      }
    };
    MaskSystem2.prototype.destroy = function() {
      this.renderer = null;
    };
    return MaskSystem2;
  }()
);
var AbstractMaskSystem = (
  /** @class */
  function() {
    function AbstractMaskSystem2(renderer) {
      this.renderer = renderer;
      this.maskStack = [];
      this.glConst = 0;
    }
    AbstractMaskSystem2.prototype.getStackLength = function() {
      return this.maskStack.length;
    };
    AbstractMaskSystem2.prototype.setMaskStack = function(maskStack) {
      var gl = this.renderer.gl;
      var curStackLen = this.getStackLength();
      this.maskStack = maskStack;
      var newStackLen = this.getStackLength();
      if (newStackLen !== curStackLen) {
        if (newStackLen === 0) {
          gl.disable(this.glConst);
        } else {
          gl.enable(this.glConst);
          this._useCurrent();
        }
      }
    };
    AbstractMaskSystem2.prototype._useCurrent = function() {
    };
    AbstractMaskSystem2.prototype.destroy = function() {
      this.renderer = null;
      this.maskStack = null;
    };
    return AbstractMaskSystem2;
  }()
);
var tempMatrix$1 = new Matrix();
var ScissorSystem = (
  /** @class */
  function(_super) {
    __extends$U(ScissorSystem2, _super);
    function ScissorSystem2(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.glConst = WebGLRenderingContext.SCISSOR_TEST;
      return _this;
    }
    ScissorSystem2.prototype.getStackLength = function() {
      var maskData = this.maskStack[this.maskStack.length - 1];
      if (maskData) {
        return maskData._scissorCounter;
      }
      return 0;
    };
    ScissorSystem2.prototype.calcScissorRect = function(maskData) {
      if (maskData._scissorRectLocal) {
        return;
      }
      var prevData = maskData._scissorRect;
      var maskObject = maskData.maskObject;
      var renderer = this.renderer;
      var renderTextureSystem = renderer.renderTexture;
      maskObject.renderable = true;
      var rect = maskObject.getBounds();
      this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
      maskObject.renderable = false;
      if (prevData) {
        rect.fit(prevData);
      }
      maskData._scissorRectLocal = rect;
    };
    ScissorSystem2.isMatrixRotated = function(matrix) {
      if (!matrix) {
        return false;
      }
      var a2 = matrix.a, b2 = matrix.b, c2 = matrix.c, d2 = matrix.d;
      return (Math.abs(b2) > 1e-4 || Math.abs(c2) > 1e-4) && (Math.abs(a2) > 1e-4 || Math.abs(d2) > 1e-4);
    };
    ScissorSystem2.prototype.testScissor = function(maskData) {
      var maskObject = maskData.maskObject;
      if (!maskObject.isFastRect || !maskObject.isFastRect()) {
        return false;
      }
      if (ScissorSystem2.isMatrixRotated(maskObject.worldTransform)) {
        return false;
      }
      if (ScissorSystem2.isMatrixRotated(this.renderer.projection.transform)) {
        return false;
      }
      this.calcScissorRect(maskData);
      var rect = maskData._scissorRectLocal;
      return rect.width > 0 && rect.height > 0;
    };
    ScissorSystem2.prototype.roundFrameToPixels = function(frame2, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
      if (ScissorSystem2.isMatrixRotated(transform)) {
        return;
      }
      transform = transform ? tempMatrix$1.copyFrom(transform) : tempMatrix$1.identity();
      transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
      this.renderer.filter.transformAABB(transform, frame2);
      frame2.fit(bindingDestinationFrame);
      frame2.x = Math.round(frame2.x * resolution);
      frame2.y = Math.round(frame2.y * resolution);
      frame2.width = Math.round(frame2.width * resolution);
      frame2.height = Math.round(frame2.height * resolution);
    };
    ScissorSystem2.prototype.push = function(maskData) {
      if (!maskData._scissorRectLocal) {
        this.calcScissorRect(maskData);
      }
      var gl = this.renderer.gl;
      if (!maskData._scissorRect) {
        gl.enable(gl.SCISSOR_TEST);
      }
      maskData._scissorCounter++;
      maskData._scissorRect = maskData._scissorRectLocal;
      this._useCurrent();
    };
    ScissorSystem2.prototype.pop = function() {
      var gl = this.renderer.gl;
      if (this.getStackLength() > 0) {
        this._useCurrent();
      } else {
        gl.disable(gl.SCISSOR_TEST);
      }
    };
    ScissorSystem2.prototype._useCurrent = function() {
      var rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
      var y2;
      if (this.renderer.renderTexture.current) {
        y2 = rect.y;
      } else {
        y2 = this.renderer.height - rect.height - rect.y;
      }
      this.renderer.gl.scissor(rect.x, y2, rect.width, rect.height);
    };
    return ScissorSystem2;
  }(AbstractMaskSystem)
);
var StencilSystem = (
  /** @class */
  function(_super) {
    __extends$U(StencilSystem2, _super);
    function StencilSystem2(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.glConst = WebGLRenderingContext.STENCIL_TEST;
      return _this;
    }
    StencilSystem2.prototype.getStackLength = function() {
      var maskData = this.maskStack[this.maskStack.length - 1];
      if (maskData) {
        return maskData._stencilCounter;
      }
      return 0;
    };
    StencilSystem2.prototype.push = function(maskData) {
      var maskObject = maskData.maskObject;
      var gl = this.renderer.gl;
      var prevMaskCount = maskData._stencilCounter;
      if (prevMaskCount === 0) {
        this.renderer.framebuffer.forceStencil();
        gl.clearStencil(0);
        gl.clear(gl.STENCIL_BUFFER_BIT);
        gl.enable(gl.STENCIL_TEST);
      }
      maskData._stencilCounter++;
      gl.colorMask(false, false, false, false);
      gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
      maskObject.renderable = true;
      maskObject.render(this.renderer);
      this.renderer.batch.flush();
      maskObject.renderable = false;
      this._useCurrent();
    };
    StencilSystem2.prototype.pop = function(maskObject) {
      var gl = this.renderer.gl;
      if (this.getStackLength() === 0) {
        gl.disable(gl.STENCIL_TEST);
      } else {
        gl.colorMask(false, false, false, false);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
        maskObject.renderable = true;
        maskObject.render(this.renderer);
        this.renderer.batch.flush();
        maskObject.renderable = false;
        this._useCurrent();
      }
    };
    StencilSystem2.prototype._useCurrent = function() {
      var gl = this.renderer.gl;
      gl.colorMask(true, true, true, true);
      gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    };
    return StencilSystem2;
  }(AbstractMaskSystem)
);
var ProjectionSystem = (
  /** @class */
  function() {
    function ProjectionSystem2(renderer) {
      this.renderer = renderer;
      this.destinationFrame = null;
      this.sourceFrame = null;
      this.defaultFrame = null;
      this.projectionMatrix = new Matrix();
      this.transform = null;
    }
    ProjectionSystem2.prototype.update = function(destinationFrame, sourceFrame, resolution, root2) {
      this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
      this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
      this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root2);
      if (this.transform) {
        this.projectionMatrix.append(this.transform);
      }
      var renderer = this.renderer;
      renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
      renderer.globalUniforms.update();
      if (renderer.shader.shader) {
        renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
      }
    };
    ProjectionSystem2.prototype.calculateProjection = function(_destinationFrame, sourceFrame, _resolution, root2) {
      var pm = this.projectionMatrix;
      var sign2 = !root2 ? 1 : -1;
      pm.identity();
      pm.a = 1 / sourceFrame.width * 2;
      pm.d = sign2 * (1 / sourceFrame.height * 2);
      pm.tx = -1 - sourceFrame.x * pm.a;
      pm.ty = -sign2 - sourceFrame.y * pm.d;
    };
    ProjectionSystem2.prototype.setTransform = function(_matrix) {
    };
    ProjectionSystem2.prototype.destroy = function() {
      this.renderer = null;
    };
    return ProjectionSystem2;
  }()
);
var tempRect = new Rectangle();
var tempRect2 = new Rectangle();
var RenderTextureSystem = (
  /** @class */
  function() {
    function RenderTextureSystem2(renderer) {
      this.renderer = renderer;
      this.clearColor = renderer._backgroundColorRgba;
      this.defaultMaskStack = [];
      this.current = null;
      this.sourceFrame = new Rectangle();
      this.destinationFrame = new Rectangle();
      this.viewportFrame = new Rectangle();
    }
    RenderTextureSystem2.prototype.bind = function(renderTexture, sourceFrame, destinationFrame) {
      if (renderTexture === void 0) {
        renderTexture = null;
      }
      var renderer = this.renderer;
      this.current = renderTexture;
      var baseTexture;
      var framebuffer;
      var resolution;
      if (renderTexture) {
        baseTexture = renderTexture.baseTexture;
        resolution = baseTexture.resolution;
        if (!sourceFrame) {
          tempRect.width = renderTexture.frame.width;
          tempRect.height = renderTexture.frame.height;
          sourceFrame = tempRect;
        }
        if (!destinationFrame) {
          tempRect2.x = renderTexture.frame.x;
          tempRect2.y = renderTexture.frame.y;
          tempRect2.width = sourceFrame.width;
          tempRect2.height = sourceFrame.height;
          destinationFrame = tempRect2;
        }
        framebuffer = baseTexture.framebuffer;
      } else {
        resolution = renderer.resolution;
        if (!sourceFrame) {
          tempRect.width = renderer.screen.width;
          tempRect.height = renderer.screen.height;
          sourceFrame = tempRect;
        }
        if (!destinationFrame) {
          destinationFrame = tempRect;
          destinationFrame.width = sourceFrame.width;
          destinationFrame.height = sourceFrame.height;
        }
      }
      var viewportFrame = this.viewportFrame;
      viewportFrame.x = destinationFrame.x * resolution;
      viewportFrame.y = destinationFrame.y * resolution;
      viewportFrame.width = destinationFrame.width * resolution;
      viewportFrame.height = destinationFrame.height * resolution;
      if (!renderTexture) {
        viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);
      }
      viewportFrame.ceil();
      this.renderer.framebuffer.bind(framebuffer, viewportFrame);
      this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
      if (renderTexture) {
        this.renderer.mask.setMaskStack(baseTexture.maskStack);
      } else {
        this.renderer.mask.setMaskStack(this.defaultMaskStack);
      }
      this.sourceFrame.copyFrom(sourceFrame);
      this.destinationFrame.copyFrom(destinationFrame);
    };
    RenderTextureSystem2.prototype.clear = function(clearColor, mask2) {
      if (this.current) {
        clearColor = clearColor || this.current.baseTexture.clearColor;
      } else {
        clearColor = clearColor || this.clearColor;
      }
      var destinationFrame = this.destinationFrame;
      var baseFrame = this.current ? this.current.baseTexture : this.renderer.screen;
      var clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
      if (clearMask) {
        var _a2 = this.viewportFrame, x = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height;
        x = Math.round(x);
        y2 = Math.round(y2);
        width = Math.round(width);
        height = Math.round(height);
        this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
        this.renderer.gl.scissor(x, y2, width, height);
      }
      this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3], mask2);
      if (clearMask) {
        this.renderer.scissor.pop();
      }
    };
    RenderTextureSystem2.prototype.resize = function() {
      this.bind(null);
    };
    RenderTextureSystem2.prototype.reset = function() {
      this.bind(null);
    };
    RenderTextureSystem2.prototype.destroy = function() {
      this.renderer = null;
    };
    return RenderTextureSystem2;
  }()
);
function uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {
  _renderer.buffer.update(buffer);
}
var UBO_TO_SINGLE_SETTERS = {
  float: "\n        data[offset] = v;\n    ",
  vec2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ",
  vec3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ",
  vec4: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ",
  mat2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ",
  mat3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ",
  mat4: "\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    "
};
var GLSL_TO_STD40_SIZE = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function createUBOElements(uniformData) {
  var uboElements = uniformData.map(function(data2) {
    return {
      data: data2,
      offset: 0,
      dataLen: 0,
      dirty: 0
    };
  });
  var size = 0;
  var chunkSize = 0;
  var offset = 0;
  for (var i2 = 0; i2 < uboElements.length; i2++) {
    var uboElement = uboElements[i2];
    size = GLSL_TO_STD40_SIZE[uboElement.data.type];
    if (uboElement.data.size > 1) {
      size = Math.max(size, 16) * uboElement.data.size;
    }
    uboElement.dataLen = size;
    if (chunkSize % size !== 0 && chunkSize < 16) {
      var lineUpValue = chunkSize % size % 16;
      chunkSize += lineUpValue;
      offset += lineUpValue;
    }
    if (chunkSize + size > 16) {
      offset = Math.ceil(offset / 16) * 16;
      uboElement.offset = offset;
      offset += size;
      chunkSize = size;
    } else {
      uboElement.offset = offset;
      chunkSize += size;
      offset += size;
    }
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
function getUBOData(uniforms, uniformData) {
  var usedUniformDatas = [];
  for (var i2 in uniforms) {
    if (uniformData[i2]) {
      usedUniformDatas.push(uniformData[i2]);
    }
  }
  usedUniformDatas.sort(function(a2, b2) {
    return a2.index - b2.index;
  });
  return usedUniformDatas;
}
function generateUniformBufferSync(group, uniformData) {
  if (!group.autoManage) {
    return { size: 0, syncFunc: uboUpdate };
  }
  var usedUniformDatas = getUBOData(group.uniforms, uniformData);
  var _a2 = createUBOElements(usedUniformDatas), uboElements = _a2.uboElements, size = _a2.size;
  var funcFragments = ["\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    "];
  for (var i2 = 0; i2 < uboElements.length; i2++) {
    var uboElement = uboElements[i2];
    var uniform = group.uniforms[uboElement.data.name];
    var name = uboElement.data.name;
    var parsed = false;
    for (var j2 = 0; j2 < uniformParsers.length; j2++) {
      var uniformParser = uniformParsers[j2];
      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
        funcFragments.push("offset = " + uboElement.offset / 4 + ";", uniformParsers[j2].codeUbo(uboElement.data.name, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        var size_1 = mapSize(uboElement.data.type);
        var rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
        var elementSize = size_1 / rowSize;
        var remainder = (4 - elementSize % 4) % 4;
        funcFragments.push("\n                cv = ud." + name + ".value;\n                v = uv." + name + ";\n                offset = " + uboElement.offset / 4 + ";\n\n                t = 0;\n\n                for(var i=0; i < " + uboElement.data.size * rowSize + "; i++)\n                {\n                    for(var j = 0; j < " + elementSize + "; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += " + remainder + ";\n                }\n\n                ");
      } else {
        var template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
        funcFragments.push("\n                cv = ud." + name + ".value;\n                v = uv." + name + ";\n                offset = " + uboElement.offset / 4 + ";\n                " + template + ";\n                ");
      }
    }
  }
  funcFragments.push("\n       renderer.buffer.update(buffer);\n    ");
  return {
    size,
    // eslint-disable-next-line no-new-func
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", funcFragments.join("\n"))
  };
}
var IGLUniformData = (
  /** @class */
  function() {
    function IGLUniformData2() {
    }
    return IGLUniformData2;
  }()
);
var GLProgram = (
  /** @class */
  function() {
    function GLProgram2(program, uniformData) {
      this.program = program;
      this.uniformData = uniformData;
      this.uniformGroups = {};
      this.uniformDirtyGroups = {};
      this.uniformBufferBindings = {};
    }
    GLProgram2.prototype.destroy = function() {
      this.uniformData = null;
      this.uniformGroups = null;
      this.uniformDirtyGroups = null;
      this.uniformBufferBindings = null;
      this.program = null;
    };
    return GLProgram2;
  }()
);
function getAttributeData(program, gl) {
  var attributes = {};
  var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (var i2 = 0; i2 < totalAttributes; i2++) {
    var attribData = gl.getActiveAttrib(program, i2);
    if (attribData.name.indexOf("gl_") === 0) {
      continue;
    }
    var type2 = mapType(gl, attribData.type);
    var data2 = {
      type: type2,
      name: attribData.name,
      size: mapSize(type2),
      location: gl.getAttribLocation(program, attribData.name)
    };
    attributes[attribData.name] = data2;
  }
  return attributes;
}
function getUniformData(program, gl) {
  var uniforms = {};
  var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (var i2 = 0; i2 < totalUniforms; i2++) {
    var uniformData = gl.getActiveUniform(program, i2);
    var name = uniformData.name.replace(/\[.*?\]$/, "");
    var isArray2 = !!uniformData.name.match(/\[.*?\]$/);
    var type2 = mapType(gl, uniformData.type);
    uniforms[name] = {
      name,
      index: i2,
      type: type2,
      size: uniformData.size,
      isArray: isArray2,
      value: defaultValue(type2, uniformData.size)
    };
  }
  return uniforms;
}
function generateProgram(gl, program) {
  var glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc);
  var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);
  var webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    logProgramError(gl, webGLProgram, glVertShader, glFragShader);
  }
  program.attributeData = getAttributeData(webGLProgram, gl);
  program.uniformData = getUniformData(webGLProgram, gl);
  if (!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
    var keys2 = Object.keys(program.attributeData);
    keys2.sort(function(a2, b2) {
      return a2 > b2 ? 1 : -1;
    });
    for (var i2 = 0; i2 < keys2.length; i2++) {
      program.attributeData[keys2[i2]].location = i2;
      gl.bindAttribLocation(webGLProgram, i2, keys2[i2]);
    }
    gl.linkProgram(webGLProgram);
  }
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  var uniformData = {};
  for (var i2 in program.uniformData) {
    var data2 = program.uniformData[i2];
    uniformData[i2] = {
      location: gl.getUniformLocation(webGLProgram, i2),
      value: defaultValue(data2.type, data2.size)
    };
  }
  var glProgram = new GLProgram(webGLProgram, uniformData);
  return glProgram;
}
var UID = 0;
var defaultSyncData = { textureCount: 0, uboCount: 0 };
var ShaderSystem = (
  /** @class */
  function() {
    function ShaderSystem2(renderer) {
      this.destroyed = false;
      this.renderer = renderer;
      this.systemCheck();
      this.gl = null;
      this.shader = null;
      this.program = null;
      this.cache = {};
      this._uboCache = {};
      this.id = UID++;
    }
    ShaderSystem2.prototype.systemCheck = function() {
      if (!unsafeEvalSupported()) {
        throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
      }
    };
    ShaderSystem2.prototype.contextChange = function(gl) {
      this.gl = gl;
      this.reset();
    };
    ShaderSystem2.prototype.bind = function(shader, dontSync) {
      shader.uniforms.globals = this.renderer.globalUniforms;
      var program = shader.program;
      var glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
      this.shader = shader;
      if (this.program !== program) {
        this.program = program;
        this.gl.useProgram(glProgram.program);
      }
      if (!dontSync) {
        defaultSyncData.textureCount = 0;
        defaultSyncData.uboCount = 0;
        this.syncUniformGroup(shader.uniformGroup, defaultSyncData);
      }
      return glProgram;
    };
    ShaderSystem2.prototype.setUniforms = function(uniforms) {
      var shader = this.shader.program;
      var glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
      shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
    };
    ShaderSystem2.prototype.syncUniformGroup = function(group, syncData) {
      var glProgram = this.getGlProgram();
      if (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) {
        glProgram.uniformDirtyGroups[group.id] = group.dirtyId;
        this.syncUniforms(group, glProgram, syncData);
      }
    };
    ShaderSystem2.prototype.syncUniforms = function(group, glProgram, syncData) {
      var syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
      syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);
    };
    ShaderSystem2.prototype.createSyncGroups = function(group) {
      var id2 = this.getSignature(group, this.shader.program.uniformData, "u");
      if (!this.cache[id2]) {
        this.cache[id2] = generateUniformsSync(group, this.shader.program.uniformData);
      }
      group.syncUniforms[this.shader.program.id] = this.cache[id2];
      return group.syncUniforms[this.shader.program.id];
    };
    ShaderSystem2.prototype.syncUniformBufferGroup = function(group, name) {
      var glProgram = this.getGlProgram();
      if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {
        group.dirtyId = 0;
        var syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);
        group.buffer.update();
        syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData, group.buffer);
      }
      this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);
    };
    ShaderSystem2.prototype.createSyncBufferGroup = function(group, glProgram, name) {
      var gl = this.renderer.gl;
      this.renderer.buffer.bind(group.buffer);
      var uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);
      glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount;
      gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);
      this.shader.uniformBindCount++;
      var id2 = this.getSignature(group, this.shader.program.uniformData, "ubo");
      var uboData = this._uboCache[id2];
      if (!uboData) {
        uboData = this._uboCache[id2] = generateUniformBufferSync(group, this.shader.program.uniformData);
      }
      if (group.autoManage) {
        var data2 = new Float32Array(uboData.size / 4);
        group.buffer.update(data2);
      }
      glProgram.uniformGroups[group.id] = uboData.syncFunc;
      return glProgram.uniformGroups[group.id];
    };
    ShaderSystem2.prototype.getSignature = function(group, uniformData, preFix) {
      var uniforms = group.uniforms;
      var strings2 = [preFix + "-"];
      for (var i2 in uniforms) {
        strings2.push(i2);
        if (uniformData[i2]) {
          strings2.push(uniformData[i2].type);
        }
      }
      return strings2.join("-");
    };
    ShaderSystem2.prototype.getGlProgram = function() {
      if (this.shader) {
        return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
      }
      return null;
    };
    ShaderSystem2.prototype.generateProgram = function(shader) {
      var gl = this.gl;
      var program = shader.program;
      var glProgram = generateProgram(gl, program);
      program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
      return glProgram;
    };
    ShaderSystem2.prototype.reset = function() {
      this.program = null;
      this.shader = null;
    };
    ShaderSystem2.prototype.destroy = function() {
      this.renderer = null;
      this.destroyed = true;
    };
    return ShaderSystem2;
  }()
);
function mapWebGLBlendModesToPixi(gl, array) {
  if (array === void 0) {
    array = [];
  }
  array[BLEND_MODES$4.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$4.ADD] = [gl.ONE, gl.ONE];
  array[BLEND_MODES$4.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$4.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$4.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$4.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$4.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$4.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$4.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$4.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$4.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$4.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$4.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$4.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$4.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$4.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$4.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$4.NONE] = [0, 0];
  array[BLEND_MODES$4.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$4.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  array[BLEND_MODES$4.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$4.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
  array[BLEND_MODES$4.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
  array[BLEND_MODES$4.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$4.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
  array[BLEND_MODES$4.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
  array[BLEND_MODES$4.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$4.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
  array[BLEND_MODES$4.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$4.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
  return array;
}
var BLEND = 0;
var OFFSET = 1;
var CULLING = 2;
var DEPTH_TEST = 3;
var WINDING = 4;
var DEPTH_MASK = 5;
var StateSystem = (
  /** @class */
  function() {
    function StateSystem2() {
      this.gl = null;
      this.stateId = 0;
      this.polygonOffset = 0;
      this.blendMode = BLEND_MODES$4.NONE;
      this._blendEq = false;
      this.map = [];
      this.map[BLEND] = this.setBlend;
      this.map[OFFSET] = this.setOffset;
      this.map[CULLING] = this.setCullFace;
      this.map[DEPTH_TEST] = this.setDepthTest;
      this.map[WINDING] = this.setFrontFace;
      this.map[DEPTH_MASK] = this.setDepthMask;
      this.checks = [];
      this.defaultState = new State();
      this.defaultState.blend = true;
    }
    StateSystem2.prototype.contextChange = function(gl) {
      this.gl = gl;
      this.blendModes = mapWebGLBlendModesToPixi(gl);
      this.set(this.defaultState);
      this.reset();
    };
    StateSystem2.prototype.set = function(state) {
      state = state || this.defaultState;
      if (this.stateId !== state.data) {
        var diff = this.stateId ^ state.data;
        var i2 = 0;
        while (diff) {
          if (diff & 1) {
            this.map[i2].call(this, !!(state.data & 1 << i2));
          }
          diff = diff >> 1;
          i2++;
        }
        this.stateId = state.data;
      }
      for (var i2 = 0; i2 < this.checks.length; i2++) {
        this.checks[i2](this, state);
      }
    };
    StateSystem2.prototype.forceState = function(state) {
      state = state || this.defaultState;
      for (var i2 = 0; i2 < this.map.length; i2++) {
        this.map[i2].call(this, !!(state.data & 1 << i2));
      }
      for (var i2 = 0; i2 < this.checks.length; i2++) {
        this.checks[i2](this, state);
      }
      this.stateId = state.data;
    };
    StateSystem2.prototype.setBlend = function(value) {
      this.updateCheck(StateSystem2.checkBlendMode, value);
      this.gl[value ? "enable" : "disable"](this.gl.BLEND);
    };
    StateSystem2.prototype.setOffset = function(value) {
      this.updateCheck(StateSystem2.checkPolygonOffset, value);
      this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
    };
    StateSystem2.prototype.setDepthTest = function(value) {
      this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
    };
    StateSystem2.prototype.setDepthMask = function(value) {
      this.gl.depthMask(value);
    };
    StateSystem2.prototype.setCullFace = function(value) {
      this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
    };
    StateSystem2.prototype.setFrontFace = function(value) {
      this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
    };
    StateSystem2.prototype.setBlendMode = function(value) {
      if (value === this.blendMode) {
        return;
      }
      this.blendMode = value;
      var mode = this.blendModes[value];
      var gl = this.gl;
      if (mode.length === 2) {
        gl.blendFunc(mode[0], mode[1]);
      } else {
        gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
      }
      if (mode.length === 6) {
        this._blendEq = true;
        gl.blendEquationSeparate(mode[4], mode[5]);
      } else if (this._blendEq) {
        this._blendEq = false;
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
      }
    };
    StateSystem2.prototype.setPolygonOffset = function(value, scale) {
      this.gl.polygonOffset(value, scale);
    };
    StateSystem2.prototype.reset = function() {
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
      this.forceState(this.defaultState);
      this._blendEq = true;
      this.blendMode = -1;
      this.setBlendMode(0);
    };
    StateSystem2.prototype.updateCheck = function(func, value) {
      var index2 = this.checks.indexOf(func);
      if (value && index2 === -1) {
        this.checks.push(func);
      } else if (!value && index2 !== -1) {
        this.checks.splice(index2, 1);
      }
    };
    StateSystem2.checkBlendMode = function(system, state) {
      system.setBlendMode(state.blendMode);
    };
    StateSystem2.checkPolygonOffset = function(system, state) {
      system.setPolygonOffset(1, state.polygonOffset);
    };
    StateSystem2.prototype.destroy = function() {
      this.gl = null;
    };
    return StateSystem2;
  }()
);
var TextureGCSystem = (
  /** @class */
  function() {
    function TextureGCSystem2(renderer) {
      this.renderer = renderer;
      this.count = 0;
      this.checkCount = 0;
      this.maxIdle = settings$2.GC_MAX_IDLE;
      this.checkCountMax = settings$2.GC_MAX_CHECK_COUNT;
      this.mode = settings$2.GC_MODE;
    }
    TextureGCSystem2.prototype.postrender = function() {
      if (!this.renderer.renderingToScreen) {
        return;
      }
      this.count++;
      if (this.mode === GC_MODES$4.MANUAL) {
        return;
      }
      this.checkCount++;
      if (this.checkCount > this.checkCountMax) {
        this.checkCount = 0;
        this.run();
      }
    };
    TextureGCSystem2.prototype.run = function() {
      var tm = this.renderer.texture;
      var managedTextures = tm.managedTextures;
      var wasRemoved = false;
      for (var i2 = 0; i2 < managedTextures.length; i2++) {
        var texture = managedTextures[i2];
        if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
          tm.destroyTexture(texture, true);
          managedTextures[i2] = null;
          wasRemoved = true;
        }
      }
      if (wasRemoved) {
        var j2 = 0;
        for (var i2 = 0; i2 < managedTextures.length; i2++) {
          if (managedTextures[i2] !== null) {
            managedTextures[j2++] = managedTextures[i2];
          }
        }
        managedTextures.length = j2;
      }
    };
    TextureGCSystem2.prototype.unload = function(displayObject) {
      var tm = this.renderer.texture;
      var texture = displayObject._texture;
      if (texture && !texture.framebuffer) {
        tm.destroyTexture(texture);
      }
      for (var i2 = displayObject.children.length - 1; i2 >= 0; i2--) {
        this.unload(displayObject.children[i2]);
      }
    };
    TextureGCSystem2.prototype.destroy = function() {
      this.renderer = null;
    };
    return TextureGCSystem2;
  }()
);
function mapTypeAndFormatToInternalFormat(gl) {
  var _a2, _b2, _c2, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
  var table;
  if ("WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext) {
    table = (_a2 = {}, _a2[TYPES$4.UNSIGNED_BYTE] = (_b2 = {}, _b2[FORMATS$4.RGBA] = gl.RGBA8, _b2[FORMATS$4.RGB] = gl.RGB8, _b2[FORMATS$4.RG] = gl.RG8, _b2[FORMATS$4.RED] = gl.R8, _b2[FORMATS$4.RGBA_INTEGER] = gl.RGBA8UI, _b2[FORMATS$4.RGB_INTEGER] = gl.RGB8UI, _b2[FORMATS$4.RG_INTEGER] = gl.RG8UI, _b2[FORMATS$4.RED_INTEGER] = gl.R8UI, _b2[FORMATS$4.ALPHA] = gl.ALPHA, _b2[FORMATS$4.LUMINANCE] = gl.LUMINANCE, _b2[FORMATS$4.LUMINANCE_ALPHA] = gl.LUMINANCE_ALPHA, _b2), _a2[TYPES$4.BYTE] = (_c2 = {}, _c2[FORMATS$4.RGBA] = gl.RGBA8_SNORM, _c2[FORMATS$4.RGB] = gl.RGB8_SNORM, _c2[FORMATS$4.RG] = gl.RG8_SNORM, _c2[FORMATS$4.RED] = gl.R8_SNORM, _c2[FORMATS$4.RGBA_INTEGER] = gl.RGBA8I, _c2[FORMATS$4.RGB_INTEGER] = gl.RGB8I, _c2[FORMATS$4.RG_INTEGER] = gl.RG8I, _c2[FORMATS$4.RED_INTEGER] = gl.R8I, _c2), _a2[TYPES$4.UNSIGNED_SHORT] = (_d = {}, _d[FORMATS$4.RGBA_INTEGER] = gl.RGBA16UI, _d[FORMATS$4.RGB_INTEGER] = gl.RGB16UI, _d[FORMATS$4.RG_INTEGER] = gl.RG16UI, _d[FORMATS$4.RED_INTEGER] = gl.R16UI, _d[FORMATS$4.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT16, _d), _a2[TYPES$4.SHORT] = (_e = {}, _e[FORMATS$4.RGBA_INTEGER] = gl.RGBA16I, _e[FORMATS$4.RGB_INTEGER] = gl.RGB16I, _e[FORMATS$4.RG_INTEGER] = gl.RG16I, _e[FORMATS$4.RED_INTEGER] = gl.R16I, _e), _a2[TYPES$4.UNSIGNED_INT] = (_f = {}, _f[FORMATS$4.RGBA_INTEGER] = gl.RGBA32UI, _f[FORMATS$4.RGB_INTEGER] = gl.RGB32UI, _f[FORMATS$4.RG_INTEGER] = gl.RG32UI, _f[FORMATS$4.RED_INTEGER] = gl.R32UI, _f[FORMATS$4.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT24, _f), _a2[TYPES$4.INT] = (_g = {}, _g[FORMATS$4.RGBA_INTEGER] = gl.RGBA32I, _g[FORMATS$4.RGB_INTEGER] = gl.RGB32I, _g[FORMATS$4.RG_INTEGER] = gl.RG32I, _g[FORMATS$4.RED_INTEGER] = gl.R32I, _g), _a2[TYPES$4.FLOAT] = (_h = {}, _h[FORMATS$4.RGBA] = gl.RGBA32F, _h[FORMATS$4.RGB] = gl.RGB32F, _h[FORMATS$4.RG] = gl.RG32F, _h[FORMATS$4.RED] = gl.R32F, _h[FORMATS$4.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT32F, _h), _a2[TYPES$4.HALF_FLOAT] = (_j = {}, _j[FORMATS$4.RGBA] = gl.RGBA16F, _j[FORMATS$4.RGB] = gl.RGB16F, _j[FORMATS$4.RG] = gl.RG16F, _j[FORMATS$4.RED] = gl.R16F, _j), _a2[TYPES$4.UNSIGNED_SHORT_5_6_5] = (_k = {}, _k[FORMATS$4.RGB] = gl.RGB565, _k), _a2[TYPES$4.UNSIGNED_SHORT_4_4_4_4] = (_l = {}, _l[FORMATS$4.RGBA] = gl.RGBA4, _l), _a2[TYPES$4.UNSIGNED_SHORT_5_5_5_1] = (_m = {}, _m[FORMATS$4.RGBA] = gl.RGB5_A1, _m), _a2[TYPES$4.UNSIGNED_INT_2_10_10_10_REV] = (_o = {}, _o[FORMATS$4.RGBA] = gl.RGB10_A2, _o[FORMATS$4.RGBA_INTEGER] = gl.RGB10_A2UI, _o), _a2[TYPES$4.UNSIGNED_INT_10F_11F_11F_REV] = (_p = {}, _p[FORMATS$4.RGB] = gl.R11F_G11F_B10F, _p), _a2[TYPES$4.UNSIGNED_INT_5_9_9_9_REV] = (_q = {}, _q[FORMATS$4.RGB] = gl.RGB9_E5, _q), _a2[TYPES$4.UNSIGNED_INT_24_8] = (_r = {}, _r[FORMATS$4.DEPTH_STENCIL] = gl.DEPTH24_STENCIL8, _r), _a2[TYPES$4.FLOAT_32_UNSIGNED_INT_24_8_REV] = (_s = {}, _s[FORMATS$4.DEPTH_STENCIL] = gl.DEPTH32F_STENCIL8, _s), _a2);
  } else {
    table = (_t = {}, _t[TYPES$4.UNSIGNED_BYTE] = (_u = {}, _u[FORMATS$4.RGBA] = gl.RGBA, _u[FORMATS$4.RGB] = gl.RGB, _u[FORMATS$4.ALPHA] = gl.ALPHA, _u[FORMATS$4.LUMINANCE] = gl.LUMINANCE, _u[FORMATS$4.LUMINANCE_ALPHA] = gl.LUMINANCE_ALPHA, _u), _t[TYPES$4.UNSIGNED_SHORT_5_6_5] = (_v = {}, _v[FORMATS$4.RGB] = gl.RGB, _v), _t[TYPES$4.UNSIGNED_SHORT_4_4_4_4] = (_w = {}, _w[FORMATS$4.RGBA] = gl.RGBA, _w), _t[TYPES$4.UNSIGNED_SHORT_5_5_5_1] = (_x = {}, _x[FORMATS$4.RGBA] = gl.RGBA, _x), _t);
  }
  return table;
}
var GLTexture = (
  /** @class */
  function() {
    function GLTexture2(texture) {
      this.texture = texture;
      this.width = -1;
      this.height = -1;
      this.dirtyId = -1;
      this.dirtyStyleId = -1;
      this.mipmap = false;
      this.wrapMode = 33071;
      this.type = TYPES$4.UNSIGNED_BYTE;
      this.internalFormat = FORMATS$4.RGBA;
      this.samplerType = 0;
    }
    return GLTexture2;
  }()
);
var TextureSystem = (
  /** @class */
  function() {
    function TextureSystem2(renderer) {
      this.renderer = renderer;
      this.boundTextures = [];
      this.currentLocation = -1;
      this.managedTextures = [];
      this._unknownBoundTextures = false;
      this.unknownTexture = new BaseTexture();
      this.hasIntegerTextures = false;
    }
    TextureSystem2.prototype.contextChange = function() {
      var gl = this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      this.webGLVersion = this.renderer.context.webGLVersion;
      this.internalFormats = mapTypeAndFormatToInternalFormat(gl);
      var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
      this.boundTextures.length = maxTextures;
      for (var i2 = 0; i2 < maxTextures; i2++) {
        this.boundTextures[i2] = null;
      }
      this.emptyTextures = {};
      var emptyTexture2D = new GLTexture(gl.createTexture());
      gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
      this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
      this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
      for (var i2 = 0; i2 < 6; i2++) {
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      for (var i2 = 0; i2 < this.boundTextures.length; i2++) {
        this.bind(null, i2);
      }
    };
    TextureSystem2.prototype.bind = function(texture, location) {
      if (location === void 0) {
        location = 0;
      }
      var gl = this.gl;
      texture = texture === null || texture === void 0 ? void 0 : texture.castToBaseTexture();
      if (texture && texture.valid && !texture.parentTextureArray) {
        texture.touched = this.renderer.textureGC.count;
        var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
        if (this.boundTextures[location] !== texture) {
          if (this.currentLocation !== location) {
            this.currentLocation = location;
            gl.activeTexture(gl.TEXTURE0 + location);
          }
          gl.bindTexture(texture.target, glTexture.texture);
        }
        if (glTexture.dirtyId !== texture.dirtyId) {
          if (this.currentLocation !== location) {
            this.currentLocation = location;
            gl.activeTexture(gl.TEXTURE0 + location);
          }
          this.updateTexture(texture);
        }
        this.boundTextures[location] = texture;
      } else {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
        this.boundTextures[location] = null;
      }
    };
    TextureSystem2.prototype.reset = function() {
      this._unknownBoundTextures = true;
      this.hasIntegerTextures = false;
      this.currentLocation = -1;
      for (var i2 = 0; i2 < this.boundTextures.length; i2++) {
        this.boundTextures[i2] = this.unknownTexture;
      }
    };
    TextureSystem2.prototype.unbind = function(texture) {
      var _a2 = this, gl = _a2.gl, boundTextures = _a2.boundTextures;
      if (this._unknownBoundTextures) {
        this._unknownBoundTextures = false;
        for (var i2 = 0; i2 < boundTextures.length; i2++) {
          if (boundTextures[i2] === this.unknownTexture) {
            this.bind(null, i2);
          }
        }
      }
      for (var i2 = 0; i2 < boundTextures.length; i2++) {
        if (boundTextures[i2] === texture) {
          if (this.currentLocation !== i2) {
            gl.activeTexture(gl.TEXTURE0 + i2);
            this.currentLocation = i2;
          }
          gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);
          boundTextures[i2] = null;
        }
      }
    };
    TextureSystem2.prototype.ensureSamplerType = function(maxTextures) {
      var _a2 = this, boundTextures = _a2.boundTextures, hasIntegerTextures = _a2.hasIntegerTextures, CONTEXT_UID = _a2.CONTEXT_UID;
      if (!hasIntegerTextures) {
        return;
      }
      for (var i2 = maxTextures - 1; i2 >= 0; --i2) {
        var tex = boundTextures[i2];
        if (tex) {
          var glTexture = tex._glTextures[CONTEXT_UID];
          if (glTexture.samplerType !== SAMPLER_TYPES$4.FLOAT) {
            this.renderer.texture.unbind(tex);
          }
        }
      }
    };
    TextureSystem2.prototype.initTexture = function(texture) {
      var glTexture = new GLTexture(this.gl.createTexture());
      glTexture.dirtyId = -1;
      texture._glTextures[this.CONTEXT_UID] = glTexture;
      this.managedTextures.push(texture);
      texture.on("dispose", this.destroyTexture, this);
      return glTexture;
    };
    TextureSystem2.prototype.initTextureType = function(texture, glTexture) {
      var _a2, _b2;
      glTexture.internalFormat = (_b2 = (_a2 = this.internalFormats[texture.type]) === null || _a2 === void 0 ? void 0 : _a2[texture.format]) !== null && _b2 !== void 0 ? _b2 : texture.format;
      if (this.webGLVersion === 2 && texture.type === TYPES$4.HALF_FLOAT) {
        glTexture.type = this.gl.HALF_FLOAT;
      } else {
        glTexture.type = texture.type;
      }
    };
    TextureSystem2.prototype.updateTexture = function(texture) {
      var glTexture = texture._glTextures[this.CONTEXT_UID];
      if (!glTexture) {
        return;
      }
      var renderer = this.renderer;
      this.initTextureType(texture, glTexture);
      if (texture.resource && texture.resource.upload(renderer, texture, glTexture)) {
        if (glTexture.samplerType !== SAMPLER_TYPES$4.FLOAT) {
          this.hasIntegerTextures = true;
        }
      } else {
        var width = texture.realWidth;
        var height = texture.realHeight;
        var gl = renderer.gl;
        if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {
          glTexture.width = width;
          glTexture.height = height;
          gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);
        }
      }
      if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
        this.updateTextureStyle(texture);
      }
      glTexture.dirtyId = texture.dirtyId;
    };
    TextureSystem2.prototype.destroyTexture = function(texture, skipRemove) {
      var gl = this.gl;
      texture = texture.castToBaseTexture();
      if (texture._glTextures[this.CONTEXT_UID]) {
        this.unbind(texture);
        gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
        texture.off("dispose", this.destroyTexture, this);
        delete texture._glTextures[this.CONTEXT_UID];
        if (!skipRemove) {
          var i2 = this.managedTextures.indexOf(texture);
          if (i2 !== -1) {
            removeItems(this.managedTextures, i2, 1);
          }
        }
      }
    };
    TextureSystem2.prototype.updateTextureStyle = function(texture) {
      var glTexture = texture._glTextures[this.CONTEXT_UID];
      if (!glTexture) {
        return;
      }
      if ((texture.mipmap === MIPMAP_MODES$4.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
        glTexture.mipmap = false;
      } else {
        glTexture.mipmap = texture.mipmap >= 1;
      }
      if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {
        glTexture.wrapMode = WRAP_MODES$4.CLAMP;
      } else {
        glTexture.wrapMode = texture.wrapMode;
      }
      if (texture.resource && texture.resource.style(this.renderer, texture, glTexture))
        ;
      else {
        this.setStyle(texture, glTexture);
      }
      glTexture.dirtyStyleId = texture.dirtyStyleId;
    };
    TextureSystem2.prototype.setStyle = function(texture, glTexture) {
      var gl = this.gl;
      if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES$4.ON_MANUAL) {
        gl.generateMipmap(texture.target);
      }
      gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
      gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
      if (glTexture.mipmap) {
        gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES$4.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
        var anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
        if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES$4.LINEAR) {
          var level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
          gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
        }
      } else {
        gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES$4.LINEAR ? gl.LINEAR : gl.NEAREST);
      }
      gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES$4.LINEAR ? gl.LINEAR : gl.NEAREST);
    };
    TextureSystem2.prototype.destroy = function() {
      this.renderer = null;
    };
    return TextureSystem2;
  }()
);
var _systems = {
  __proto__: null,
  FilterSystem,
  BatchSystem,
  ContextSystem,
  FramebufferSystem,
  GeometrySystem,
  MaskSystem,
  ScissorSystem,
  StencilSystem,
  ProjectionSystem,
  RenderTextureSystem,
  ShaderSystem,
  StateSystem,
  TextureGCSystem,
  TextureSystem
};
var tempMatrix = new Matrix();
var AbstractRenderer = (
  /** @class */
  function(_super) {
    __extends$U(AbstractRenderer2, _super);
    function AbstractRenderer2(type2, options) {
      if (type2 === void 0) {
        type2 = RENDERER_TYPE$4.UNKNOWN;
      }
      var _this = _super.call(this) || this;
      options = Object.assign({}, settings$2.RENDER_OPTIONS, options);
      _this.options = options;
      _this.type = type2;
      _this.screen = new Rectangle(0, 0, options.width, options.height);
      _this.view = options.view || document.createElement("canvas");
      _this.resolution = options.resolution || settings$2.RESOLUTION;
      _this.useContextAlpha = options.useContextAlpha;
      _this.autoDensity = !!options.autoDensity;
      _this.preserveDrawingBuffer = options.preserveDrawingBuffer;
      _this.clearBeforeRender = options.clearBeforeRender;
      _this._backgroundColor = 0;
      _this._backgroundColorRgba = [0, 0, 0, 1];
      _this._backgroundColorString = "#000000";
      _this.backgroundColor = options.backgroundColor || _this._backgroundColor;
      _this.backgroundAlpha = options.backgroundAlpha;
      if (options.transparent !== void 0) {
        deprecation("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead.");
        _this.useContextAlpha = options.transparent;
        _this.backgroundAlpha = options.transparent ? 0 : 1;
      }
      _this._lastObjectRendered = null;
      _this.plugins = {};
      return _this;
    }
    AbstractRenderer2.prototype.initPlugins = function(staticMap) {
      for (var o2 in staticMap) {
        this.plugins[o2] = new staticMap[o2](this);
      }
    };
    Object.defineProperty(AbstractRenderer2.prototype, "width", {
      /**
       * Same as view.width, actual number of pixels in the canvas by horizontal.
       * @member {number}
       * @readonly
       * @default 800
       */
      get: function() {
        return this.view.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(AbstractRenderer2.prototype, "height", {
      /**
       * Same as view.height, actual number of pixels in the canvas by vertical.
       * @member {number}
       * @readonly
       * @default 600
       */
      get: function() {
        return this.view.height;
      },
      enumerable: false,
      configurable: true
    });
    AbstractRenderer2.prototype.resize = function(desiredScreenWidth, desiredScreenHeight) {
      this.view.width = Math.round(desiredScreenWidth * this.resolution);
      this.view.height = Math.round(desiredScreenHeight * this.resolution);
      var screenWidth = this.view.width / this.resolution;
      var screenHeight = this.view.height / this.resolution;
      this.screen.width = screenWidth;
      this.screen.height = screenHeight;
      if (this.autoDensity) {
        this.view.style.width = screenWidth + "px";
        this.view.style.height = screenHeight + "px";
      }
      this.emit("resize", screenWidth, screenHeight);
    };
    AbstractRenderer2.prototype.generateTexture = function(displayObject, options, resolution, region) {
      if (options === void 0) {
        options = {};
      }
      if (typeof options === "number") {
        deprecation("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options.");
        options = { scaleMode: options, resolution, region };
      }
      var manualRegion = options.region, textureOptions = __rest$1(options, ["region"]);
      region = manualRegion || displayObject.getLocalBounds(null, true);
      if (region.width === 0) {
        region.width = 1;
      }
      if (region.height === 0) {
        region.height = 1;
      }
      var renderTexture = RenderTexture.create(__assign$1({ width: region.width, height: region.height }, textureOptions));
      tempMatrix.tx = -region.x;
      tempMatrix.ty = -region.y;
      this.render(displayObject, {
        renderTexture,
        clear: false,
        transform: tempMatrix,
        skipUpdateTransform: !!displayObject.parent
      });
      return renderTexture;
    };
    AbstractRenderer2.prototype.destroy = function(removeView) {
      for (var o2 in this.plugins) {
        this.plugins[o2].destroy();
        this.plugins[o2] = null;
      }
      if (removeView && this.view.parentNode) {
        this.view.parentNode.removeChild(this.view);
      }
      var thisAny = this;
      thisAny.plugins = null;
      thisAny.type = RENDERER_TYPE$4.UNKNOWN;
      thisAny.view = null;
      thisAny.screen = null;
      thisAny._tempDisplayObjectParent = null;
      thisAny.options = null;
      this._backgroundColorRgba = null;
      this._backgroundColorString = null;
      this._lastObjectRendered = null;
    };
    Object.defineProperty(AbstractRenderer2.prototype, "backgroundColor", {
      /**
       * The background color to fill if not transparent
       * @member {number}
       */
      get: function() {
        return this._backgroundColor;
      },
      set: function(value) {
        this._backgroundColor = value;
        this._backgroundColorString = hex2string(value);
        hex2rgb(value, this._backgroundColorRgba);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(AbstractRenderer2.prototype, "backgroundAlpha", {
      /**
       * The background color alpha. Setting this to 0 will make the canvas transparent.
       * @member {number}
       */
      get: function() {
        return this._backgroundColorRgba[3];
      },
      set: function(value) {
        this._backgroundColorRgba[3] = value;
      },
      enumerable: false,
      configurable: true
    });
    return AbstractRenderer2;
  }(EventEmitter$1)
);
var GLBuffer = (
  /** @class */
  function() {
    function GLBuffer2(buffer) {
      this.buffer = buffer || null;
      this.updateID = -1;
      this.byteLength = -1;
      this.refCount = 0;
    }
    return GLBuffer2;
  }()
);
var BufferSystem = (
  /** @class */
  function() {
    function BufferSystem2(renderer) {
      this.renderer = renderer;
      this.managedBuffers = {};
      this.boundBufferBases = {};
    }
    BufferSystem2.prototype.destroy = function() {
      this.renderer = null;
    };
    BufferSystem2.prototype.contextChange = function() {
      this.disposeAll(true);
      this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    };
    BufferSystem2.prototype.bind = function(buffer) {
      var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
      var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      gl.bindBuffer(buffer.type, glBuffer.buffer);
    };
    BufferSystem2.prototype.bindBufferBase = function(buffer, index2) {
      var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
      if (this.boundBufferBases[index2] !== buffer) {
        var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
        this.boundBufferBases[index2] = buffer;
        gl.bindBufferBase(gl.UNIFORM_BUFFER, index2, glBuffer.buffer);
      }
    };
    BufferSystem2.prototype.bindBufferRange = function(buffer, index2, offset) {
      var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
      offset = offset || 0;
      var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      gl.bindBufferRange(gl.UNIFORM_BUFFER, index2 || 0, glBuffer.buffer, offset * 256, 256);
    };
    BufferSystem2.prototype.update = function(buffer) {
      var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
      var glBuffer = buffer._glBuffers[CONTEXT_UID];
      if (buffer._updateID === glBuffer.updateID) {
        return;
      }
      glBuffer.updateID = buffer._updateID;
      gl.bindBuffer(buffer.type, glBuffer.buffer);
      if (glBuffer.byteLength >= buffer.data.byteLength) {
        gl.bufferSubData(buffer.type, 0, buffer.data);
      } else {
        var drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
        glBuffer.byteLength = buffer.data.byteLength;
        gl.bufferData(buffer.type, buffer.data, drawType);
      }
    };
    BufferSystem2.prototype.dispose = function(buffer, contextLost) {
      if (!this.managedBuffers[buffer.id]) {
        return;
      }
      delete this.managedBuffers[buffer.id];
      var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
      var gl = this.gl;
      buffer.disposeRunner.remove(this);
      if (!glBuffer) {
        return;
      }
      if (!contextLost) {
        gl.deleteBuffer(glBuffer.buffer);
      }
      delete buffer._glBuffers[this.CONTEXT_UID];
    };
    BufferSystem2.prototype.disposeAll = function(contextLost) {
      var all3 = Object.keys(this.managedBuffers);
      for (var i2 = 0; i2 < all3.length; i2++) {
        this.dispose(this.managedBuffers[all3[i2]], contextLost);
      }
    };
    BufferSystem2.prototype.createGLBuffer = function(buffer) {
      var _a2 = this, CONTEXT_UID = _a2.CONTEXT_UID, gl = _a2.gl;
      buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());
      this.managedBuffers[buffer.id] = buffer;
      buffer.disposeRunner.add(this);
      return buffer._glBuffers[CONTEXT_UID];
    };
    return BufferSystem2;
  }()
);
var Renderer = (
  /** @class */
  function(_super) {
    __extends$U(Renderer2, _super);
    function Renderer2(options) {
      var _this = _super.call(this, RENDERER_TYPE$4.WEBGL, options) || this;
      options = _this.options;
      _this.gl = null;
      _this.CONTEXT_UID = 0;
      _this.runners = {
        destroy: new Runner("destroy"),
        contextChange: new Runner("contextChange"),
        reset: new Runner("reset"),
        update: new Runner("update"),
        postrender: new Runner("postrender"),
        prerender: new Runner("prerender"),
        resize: new Runner("resize")
      };
      _this.runners.contextChange.add(_this);
      _this.globalUniforms = new UniformGroup({
        projectionMatrix: new Matrix()
      }, true);
      _this.addSystem(MaskSystem, "mask").addSystem(ContextSystem, "context").addSystem(StateSystem, "state").addSystem(ShaderSystem, "shader").addSystem(TextureSystem, "texture").addSystem(BufferSystem, "buffer").addSystem(GeometrySystem, "geometry").addSystem(FramebufferSystem, "framebuffer").addSystem(ScissorSystem, "scissor").addSystem(StencilSystem, "stencil").addSystem(ProjectionSystem, "projection").addSystem(TextureGCSystem, "textureGC").addSystem(FilterSystem, "filter").addSystem(RenderTextureSystem, "renderTexture").addSystem(BatchSystem, "batch");
      _this.initPlugins(Renderer2.__plugins);
      _this.multisample = void 0;
      if (options.context) {
        _this.context.initFromContext(options.context);
      } else {
        _this.context.initFromOptions({
          alpha: !!_this.useContextAlpha,
          antialias: options.antialias,
          premultipliedAlpha: _this.useContextAlpha && _this.useContextAlpha !== "notMultiplied",
          stencil: true,
          preserveDrawingBuffer: options.preserveDrawingBuffer,
          powerPreference: _this.options.powerPreference
        });
      }
      _this.renderingToScreen = true;
      sayHello(_this.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1");
      _this.resize(_this.options.width, _this.options.height);
      return _this;
    }
    Renderer2.create = function(options) {
      if (isWebGLSupported()) {
        return new Renderer2(options);
      }
      throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
    };
    Renderer2.prototype.contextChange = function() {
      var gl = this.gl;
      var samples;
      if (this.context.webGLVersion === 1) {
        var framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        samples = gl.getParameter(gl.SAMPLES);
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      } else {
        var framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
        samples = gl.getParameter(gl.SAMPLES);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);
      }
      if (samples >= MSAA_QUALITY$4.HIGH) {
        this.multisample = MSAA_QUALITY$4.HIGH;
      } else if (samples >= MSAA_QUALITY$4.MEDIUM) {
        this.multisample = MSAA_QUALITY$4.MEDIUM;
      } else if (samples >= MSAA_QUALITY$4.LOW) {
        this.multisample = MSAA_QUALITY$4.LOW;
      } else {
        this.multisample = MSAA_QUALITY$4.NONE;
      }
    };
    Renderer2.prototype.addSystem = function(ClassRef, name) {
      var system = new ClassRef(this);
      if (this[name]) {
        throw new Error('Whoops! The name "' + name + '" is already in use');
      }
      this[name] = system;
      for (var i2 in this.runners) {
        this.runners[i2].add(system);
      }
      return this;
    };
    Renderer2.prototype.render = function(displayObject, options) {
      var renderTexture;
      var clear2;
      var transform;
      var skipUpdateTransform;
      if (options) {
        if (options instanceof RenderTexture) {
          deprecation("6.0.0", "Renderer#render arguments changed, use options instead.");
          renderTexture = options;
          clear2 = arguments[2];
          transform = arguments[3];
          skipUpdateTransform = arguments[4];
        } else {
          renderTexture = options.renderTexture;
          clear2 = options.clear;
          transform = options.transform;
          skipUpdateTransform = options.skipUpdateTransform;
        }
      }
      this.renderingToScreen = !renderTexture;
      this.runners.prerender.emit();
      this.emit("prerender");
      this.projection.transform = transform;
      if (this.context.isLost) {
        return;
      }
      if (!renderTexture) {
        this._lastObjectRendered = displayObject;
      }
      if (!skipUpdateTransform) {
        var cacheParent = displayObject.enableTempParent();
        displayObject.updateTransform();
        displayObject.disableTempParent(cacheParent);
      }
      this.renderTexture.bind(renderTexture);
      this.batch.currentRenderer.start();
      if (clear2 !== void 0 ? clear2 : this.clearBeforeRender) {
        this.renderTexture.clear();
      }
      displayObject.render(this);
      this.batch.currentRenderer.flush();
      if (renderTexture) {
        renderTexture.baseTexture.update();
      }
      this.runners.postrender.emit();
      this.projection.transform = null;
      this.emit("postrender");
    };
    Renderer2.prototype.generateTexture = function(displayObject, options, resolution, region) {
      if (options === void 0) {
        options = {};
      }
      var renderTexture = _super.prototype.generateTexture.call(this, displayObject, options, resolution, region);
      this.framebuffer.blit();
      return renderTexture;
    };
    Renderer2.prototype.resize = function(desiredScreenWidth, desiredScreenHeight) {
      _super.prototype.resize.call(this, desiredScreenWidth, desiredScreenHeight);
      this.runners.resize.emit(this.screen.height, this.screen.width);
    };
    Renderer2.prototype.reset = function() {
      this.runners.reset.emit();
      return this;
    };
    Renderer2.prototype.clear = function() {
      this.renderTexture.bind();
      this.renderTexture.clear();
    };
    Renderer2.prototype.destroy = function(removeView) {
      this.runners.destroy.emit();
      for (var r2 in this.runners) {
        this.runners[r2].destroy();
      }
      _super.prototype.destroy.call(this, removeView);
      this.gl = null;
    };
    Object.defineProperty(Renderer2.prototype, "extract", {
      /**
       * Please use `plugins.extract` instead.
       * @member {PIXI.Extract} extract
       * @deprecated since 6.0.0
       * @readonly
       */
      get: function() {
        deprecation("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead.");
        return this.plugins.extract;
      },
      enumerable: false,
      configurable: true
    });
    Renderer2.registerPlugin = function(pluginName, ctor) {
      Renderer2.__plugins = Renderer2.__plugins || {};
      Renderer2.__plugins[pluginName] = ctor;
    };
    return Renderer2;
  }(AbstractRenderer)
);
function autoDetectRenderer(options) {
  return Renderer.create(options);
}
var $defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var $defaultFilterVertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
var defaultVertex$1 = $defaultVertex;
var defaultFilterVertex = $defaultFilterVertex;
var System = (
  /** @class */
  function() {
    function System2(renderer) {
      deprecation("6.1.0", "System class is deprecated, implemement ISystem interface instead.");
      this.renderer = renderer;
    }
    System2.prototype.destroy = function() {
      this.renderer = null;
    };
    return System2;
  }()
);
var BatchDrawCall = (
  /** @class */
  function() {
    function BatchDrawCall2() {
      this.texArray = null;
      this.blend = 0;
      this.type = DRAW_MODES$4.TRIANGLES;
      this.start = 0;
      this.size = 0;
      this.data = null;
    }
    return BatchDrawCall2;
  }()
);
var BatchTextureArray = (
  /** @class */
  function() {
    function BatchTextureArray2() {
      this.elements = [];
      this.ids = [];
      this.count = 0;
    }
    BatchTextureArray2.prototype.clear = function() {
      for (var i2 = 0; i2 < this.count; i2++) {
        this.elements[i2] = null;
      }
      this.count = 0;
    };
    return BatchTextureArray2;
  }()
);
var ViewableBuffer = (
  /** @class */
  function() {
    function ViewableBuffer2(sizeOrBuffer) {
      if (typeof sizeOrBuffer === "number") {
        this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
      } else if (sizeOrBuffer instanceof Uint8Array) {
        this.rawBinaryData = sizeOrBuffer.buffer;
      } else {
        this.rawBinaryData = sizeOrBuffer;
      }
      this.uint32View = new Uint32Array(this.rawBinaryData);
      this.float32View = new Float32Array(this.rawBinaryData);
    }
    Object.defineProperty(ViewableBuffer2.prototype, "int8View", {
      /** View on the raw binary data as a `Int8Array`. */
      get: function() {
        if (!this._int8View) {
          this._int8View = new Int8Array(this.rawBinaryData);
        }
        return this._int8View;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ViewableBuffer2.prototype, "uint8View", {
      /** View on the raw binary data as a `Uint8Array`. */
      get: function() {
        if (!this._uint8View) {
          this._uint8View = new Uint8Array(this.rawBinaryData);
        }
        return this._uint8View;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ViewableBuffer2.prototype, "int16View", {
      /**  View on the raw binary data as a `Int16Array`. */
      get: function() {
        if (!this._int16View) {
          this._int16View = new Int16Array(this.rawBinaryData);
        }
        return this._int16View;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ViewableBuffer2.prototype, "uint16View", {
      /** View on the raw binary data as a `Uint16Array`. */
      get: function() {
        if (!this._uint16View) {
          this._uint16View = new Uint16Array(this.rawBinaryData);
        }
        return this._uint16View;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ViewableBuffer2.prototype, "int32View", {
      /** View on the raw binary data as a `Int32Array`. */
      get: function() {
        if (!this._int32View) {
          this._int32View = new Int32Array(this.rawBinaryData);
        }
        return this._int32View;
      },
      enumerable: false,
      configurable: true
    });
    ViewableBuffer2.prototype.view = function(type2) {
      return this[type2 + "View"];
    };
    ViewableBuffer2.prototype.destroy = function() {
      this.rawBinaryData = null;
      this._int8View = null;
      this._uint8View = null;
      this._int16View = null;
      this._uint16View = null;
      this._int32View = null;
      this.uint32View = null;
      this.float32View = null;
    };
    ViewableBuffer2.sizeOf = function(type2) {
      switch (type2) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(type2 + " isn't a valid view type");
      }
    };
    return ViewableBuffer2;
  }()
);
var AbstractBatchRenderer = (
  /** @class */
  function(_super) {
    __extends$U(AbstractBatchRenderer2, _super);
    function AbstractBatchRenderer2(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.shaderGenerator = null;
      _this.geometryClass = null;
      _this.vertexSize = null;
      _this.state = State.for2d();
      _this.size = settings$2.SPRITE_BATCH_SIZE * 4;
      _this._vertexCount = 0;
      _this._indexCount = 0;
      _this._bufferedElements = [];
      _this._bufferedTextures = [];
      _this._bufferSize = 0;
      _this._shader = null;
      _this._packedGeometries = [];
      _this._packedGeometryPoolSize = 2;
      _this._flushId = 0;
      _this._aBuffers = {};
      _this._iBuffers = {};
      _this.MAX_TEXTURES = 1;
      _this.renderer.on("prerender", _this.onPrerender, _this);
      renderer.runners.contextChange.add(_this);
      _this._dcIndex = 0;
      _this._aIndex = 0;
      _this._iIndex = 0;
      _this._attributeBuffer = null;
      _this._indexBuffer = null;
      _this._tempBoundTextures = [];
      return _this;
    }
    AbstractBatchRenderer2.prototype.contextChange = function() {
      var gl = this.renderer.gl;
      if (settings$2.PREFER_ENV === ENV$4.WEBGL_LEGACY) {
        this.MAX_TEXTURES = 1;
      } else {
        this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), settings$2.SPRITE_MAX_TEXTURES);
        this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, gl);
      }
      this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
      for (var i2 = 0; i2 < this._packedGeometryPoolSize; i2++) {
        this._packedGeometries[i2] = new this.geometryClass();
      }
      this.initFlushBuffers();
    };
    AbstractBatchRenderer2.prototype.initFlushBuffers = function() {
      var _drawCallPool = AbstractBatchRenderer2._drawCallPool, _textureArrayPool = AbstractBatchRenderer2._textureArrayPool;
      var MAX_SPRITES = this.size / 4;
      var MAX_TA = Math.floor(MAX_SPRITES / this.MAX_TEXTURES) + 1;
      while (_drawCallPool.length < MAX_SPRITES) {
        _drawCallPool.push(new BatchDrawCall());
      }
      while (_textureArrayPool.length < MAX_TA) {
        _textureArrayPool.push(new BatchTextureArray());
      }
      for (var i2 = 0; i2 < this.MAX_TEXTURES; i2++) {
        this._tempBoundTextures[i2] = null;
      }
    };
    AbstractBatchRenderer2.prototype.onPrerender = function() {
      this._flushId = 0;
    };
    AbstractBatchRenderer2.prototype.render = function(element) {
      if (!element._texture.valid) {
        return;
      }
      if (this._vertexCount + element.vertexData.length / 2 > this.size) {
        this.flush();
      }
      this._vertexCount += element.vertexData.length / 2;
      this._indexCount += element.indices.length;
      this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
      this._bufferedElements[this._bufferSize++] = element;
    };
    AbstractBatchRenderer2.prototype.buildTexturesAndDrawCalls = function() {
      var _a2 = this, textures = _a2._bufferedTextures, MAX_TEXTURES = _a2.MAX_TEXTURES;
      var textureArrays = AbstractBatchRenderer2._textureArrayPool;
      var batch2 = this.renderer.batch;
      var boundTextures = this._tempBoundTextures;
      var touch = this.renderer.textureGC.count;
      var TICK = ++BaseTexture._globalBatch;
      var countTexArrays = 0;
      var texArray = textureArrays[0];
      var start = 0;
      batch2.copyBoundTextures(boundTextures, MAX_TEXTURES);
      for (var i2 = 0; i2 < this._bufferSize; ++i2) {
        var tex = textures[i2];
        textures[i2] = null;
        if (tex._batchEnabled === TICK) {
          continue;
        }
        if (texArray.count >= MAX_TEXTURES) {
          batch2.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
          this.buildDrawCalls(texArray, start, i2);
          start = i2;
          texArray = textureArrays[++countTexArrays];
          ++TICK;
        }
        tex._batchEnabled = TICK;
        tex.touched = touch;
        texArray.elements[texArray.count++] = tex;
      }
      if (texArray.count > 0) {
        batch2.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
        this.buildDrawCalls(texArray, start, this._bufferSize);
        ++countTexArrays;
        ++TICK;
      }
      for (var i2 = 0; i2 < boundTextures.length; i2++) {
        boundTextures[i2] = null;
      }
      BaseTexture._globalBatch = TICK;
    };
    AbstractBatchRenderer2.prototype.buildDrawCalls = function(texArray, start, finish) {
      var _a2 = this, elements = _a2._bufferedElements, _attributeBuffer = _a2._attributeBuffer, _indexBuffer = _a2._indexBuffer, vertexSize = _a2.vertexSize;
      var drawCalls = AbstractBatchRenderer2._drawCallPool;
      var dcIndex = this._dcIndex;
      var aIndex = this._aIndex;
      var iIndex = this._iIndex;
      var drawCall = drawCalls[dcIndex];
      drawCall.start = this._iIndex;
      drawCall.texArray = texArray;
      for (var i2 = start; i2 < finish; ++i2) {
        var sprite = elements[i2];
        var tex = sprite._texture.baseTexture;
        var spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
        elements[i2] = null;
        if (start < i2 && drawCall.blend !== spriteBlendMode) {
          drawCall.size = iIndex - drawCall.start;
          start = i2;
          drawCall = drawCalls[++dcIndex];
          drawCall.texArray = texArray;
          drawCall.start = iIndex;
        }
        this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
        aIndex += sprite.vertexData.length / 2 * vertexSize;
        iIndex += sprite.indices.length;
        drawCall.blend = spriteBlendMode;
      }
      if (start < finish) {
        drawCall.size = iIndex - drawCall.start;
        ++dcIndex;
      }
      this._dcIndex = dcIndex;
      this._aIndex = aIndex;
      this._iIndex = iIndex;
    };
    AbstractBatchRenderer2.prototype.bindAndClearTexArray = function(texArray) {
      var textureSystem = this.renderer.texture;
      for (var j2 = 0; j2 < texArray.count; j2++) {
        textureSystem.bind(texArray.elements[j2], texArray.ids[j2]);
        texArray.elements[j2] = null;
      }
      texArray.count = 0;
    };
    AbstractBatchRenderer2.prototype.updateGeometry = function() {
      var _a2 = this, packedGeometries = _a2._packedGeometries, attributeBuffer = _a2._attributeBuffer, indexBuffer = _a2._indexBuffer;
      if (!settings$2.CAN_UPLOAD_SAME_BUFFER) {
        if (this._packedGeometryPoolSize <= this._flushId) {
          this._packedGeometryPoolSize++;
          packedGeometries[this._flushId] = new this.geometryClass();
        }
        packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
        packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
        this.renderer.geometry.bind(packedGeometries[this._flushId]);
        this.renderer.geometry.updateBuffers();
        this._flushId++;
      } else {
        packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
        packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
        this.renderer.geometry.updateBuffers();
      }
    };
    AbstractBatchRenderer2.prototype.drawBatches = function() {
      var dcCount = this._dcIndex;
      var _a2 = this.renderer, gl = _a2.gl, stateSystem = _a2.state;
      var drawCalls = AbstractBatchRenderer2._drawCallPool;
      var curTexArray = null;
      for (var i2 = 0; i2 < dcCount; i2++) {
        var _b2 = drawCalls[i2], texArray = _b2.texArray, type2 = _b2.type, size = _b2.size, start = _b2.start, blend = _b2.blend;
        if (curTexArray !== texArray) {
          curTexArray = texArray;
          this.bindAndClearTexArray(texArray);
        }
        this.state.blendMode = blend;
        stateSystem.set(this.state);
        gl.drawElements(type2, size, gl.UNSIGNED_SHORT, start * 2);
      }
    };
    AbstractBatchRenderer2.prototype.flush = function() {
      if (this._vertexCount === 0) {
        return;
      }
      this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
      this._indexBuffer = this.getIndexBuffer(this._indexCount);
      this._aIndex = 0;
      this._iIndex = 0;
      this._dcIndex = 0;
      this.buildTexturesAndDrawCalls();
      this.updateGeometry();
      this.drawBatches();
      this._bufferSize = 0;
      this._vertexCount = 0;
      this._indexCount = 0;
    };
    AbstractBatchRenderer2.prototype.start = function() {
      this.renderer.state.set(this.state);
      this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES);
      this.renderer.shader.bind(this._shader);
      if (settings$2.CAN_UPLOAD_SAME_BUFFER) {
        this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
      }
    };
    AbstractBatchRenderer2.prototype.stop = function() {
      this.flush();
    };
    AbstractBatchRenderer2.prototype.destroy = function() {
      for (var i2 = 0; i2 < this._packedGeometryPoolSize; i2++) {
        if (this._packedGeometries[i2]) {
          this._packedGeometries[i2].destroy();
        }
      }
      this.renderer.off("prerender", this.onPrerender, this);
      this._aBuffers = null;
      this._iBuffers = null;
      this._packedGeometries = null;
      this._attributeBuffer = null;
      this._indexBuffer = null;
      if (this._shader) {
        this._shader.destroy();
        this._shader = null;
      }
      _super.prototype.destroy.call(this);
    };
    AbstractBatchRenderer2.prototype.getAttributeBuffer = function(size) {
      var roundedP2 = nextPow2(Math.ceil(size / 8));
      var roundedSizeIndex = log2(roundedP2);
      var roundedSize = roundedP2 * 8;
      if (this._aBuffers.length <= roundedSizeIndex) {
        this._iBuffers.length = roundedSizeIndex + 1;
      }
      var buffer = this._aBuffers[roundedSize];
      if (!buffer) {
        this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);
      }
      return buffer;
    };
    AbstractBatchRenderer2.prototype.getIndexBuffer = function(size) {
      var roundedP2 = nextPow2(Math.ceil(size / 12));
      var roundedSizeIndex = log2(roundedP2);
      var roundedSize = roundedP2 * 12;
      if (this._iBuffers.length <= roundedSizeIndex) {
        this._iBuffers.length = roundedSizeIndex + 1;
      }
      var buffer = this._iBuffers[roundedSizeIndex];
      if (!buffer) {
        this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
      }
      return buffer;
    };
    AbstractBatchRenderer2.prototype.packInterleavedGeometry = function(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
      var uint32View = attributeBuffer.uint32View, float32View = attributeBuffer.float32View;
      var packedVertices = aIndex / this.vertexSize;
      var uvs = element.uvs;
      var indicies = element.indices;
      var vertexData = element.vertexData;
      var textureId = element._texture.baseTexture._batchLocation;
      var alpha2 = Math.min(element.worldAlpha, 1);
      var argb = alpha2 < 1 && element._texture.baseTexture.alphaMode ? premultiplyTint(element._tintRGB, alpha2) : element._tintRGB + (alpha2 * 255 << 24);
      for (var i2 = 0; i2 < vertexData.length; i2 += 2) {
        float32View[aIndex++] = vertexData[i2];
        float32View[aIndex++] = vertexData[i2 + 1];
        float32View[aIndex++] = uvs[i2];
        float32View[aIndex++] = uvs[i2 + 1];
        uint32View[aIndex++] = argb;
        float32View[aIndex++] = textureId;
      }
      for (var i2 = 0; i2 < indicies.length; i2++) {
        indexBuffer[iIndex++] = packedVertices + indicies[i2];
      }
    };
    AbstractBatchRenderer2._drawCallPool = [];
    AbstractBatchRenderer2._textureArrayPool = [];
    return AbstractBatchRenderer2;
  }(ObjectRenderer)
);
var BatchShaderGenerator = (
  /** @class */
  function() {
    function BatchShaderGenerator2(vertexSrc, fragTemplate2) {
      this.vertexSrc = vertexSrc;
      this.fragTemplate = fragTemplate2;
      this.programCache = {};
      this.defaultGroupCache = {};
      if (fragTemplate2.indexOf("%count%") < 0) {
        throw new Error('Fragment template must contain "%count%".');
      }
      if (fragTemplate2.indexOf("%forloop%") < 0) {
        throw new Error('Fragment template must contain "%forloop%".');
      }
    }
    BatchShaderGenerator2.prototype.generateShader = function(maxTextures) {
      if (!this.programCache[maxTextures]) {
        var sampleValues = new Int32Array(maxTextures);
        for (var i2 = 0; i2 < maxTextures; i2++) {
          sampleValues[i2] = i2;
        }
        this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);
        var fragmentSrc = this.fragTemplate;
        fragmentSrc = fragmentSrc.replace(/%count%/gi, "" + maxTextures);
        fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
        this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);
      }
      var uniforms = {
        tint: new Float32Array([1, 1, 1, 1]),
        translationMatrix: new Matrix(),
        default: this.defaultGroupCache[maxTextures]
      };
      return new Shader(this.programCache[maxTextures], uniforms);
    };
    BatchShaderGenerator2.prototype.generateSampleSrc = function(maxTextures) {
      var src = "";
      src += "\n";
      src += "\n";
      for (var i2 = 0; i2 < maxTextures; i2++) {
        if (i2 > 0) {
          src += "\nelse ";
        }
        if (i2 < maxTextures - 1) {
          src += "if(vTextureId < " + i2 + ".5)";
        }
        src += "\n{";
        src += "\n	color = texture2D(uSamplers[" + i2 + "], vTextureCoord);";
        src += "\n}";
      }
      src += "\n";
      src += "\n";
      return src;
    };
    return BatchShaderGenerator2;
  }()
);
var BatchGeometry = (
  /** @class */
  function(_super) {
    __extends$U(BatchGeometry2, _super);
    function BatchGeometry2(_static) {
      if (_static === void 0) {
        _static = false;
      }
      var _this = _super.call(this) || this;
      _this._buffer = new Buffer$1(null, _static, false);
      _this._indexBuffer = new Buffer$1(null, _static, true);
      _this.addAttribute("aVertexPosition", _this._buffer, 2, false, TYPES$4.FLOAT).addAttribute("aTextureCoord", _this._buffer, 2, false, TYPES$4.FLOAT).addAttribute("aColor", _this._buffer, 4, true, TYPES$4.UNSIGNED_BYTE).addAttribute("aTextureId", _this._buffer, 1, true, TYPES$4.FLOAT).addIndex(_this._indexBuffer);
      return _this;
    }
    return BatchGeometry2;
  }(Geometry)
);
var defaultVertex = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";
var defaultFragment = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";
var BatchPluginFactory = (
  /** @class */
  function() {
    function BatchPluginFactory2() {
    }
    BatchPluginFactory2.create = function(options) {
      var _a2 = Object.assign({
        vertex: defaultVertex,
        fragment: defaultFragment,
        geometryClass: BatchGeometry,
        vertexSize: 6
      }, options), vertex2 = _a2.vertex, fragment2 = _a2.fragment, vertexSize = _a2.vertexSize, geometryClass = _a2.geometryClass;
      return (
        /** @class */
        function(_super) {
          __extends$U(BatchPlugin, _super);
          function BatchPlugin(renderer) {
            var _this = _super.call(this, renderer) || this;
            _this.shaderGenerator = new BatchShaderGenerator(vertex2, fragment2);
            _this.geometryClass = geometryClass;
            _this.vertexSize = vertexSize;
            return _this;
          }
          return BatchPlugin;
        }(AbstractBatchRenderer)
      );
    };
    Object.defineProperty(BatchPluginFactory2, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       * @readonly
       */
      get: function() {
        return defaultVertex;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BatchPluginFactory2, "defaultFragmentTemplate", {
      /**
       * The default fragment shader source
       * @readonly
       */
      get: function() {
        return defaultFragment;
      },
      enumerable: false,
      configurable: true
    });
    return BatchPluginFactory2;
  }()
);
var BatchRenderer = BatchPluginFactory.create();
var resources = {};
var _loop_1 = function(name) {
  Object.defineProperty(resources, name, {
    get: function() {
      deprecation("6.0.0", "PIXI.systems." + name + " has moved to PIXI." + name);
      return _resources[name];
    }
  });
};
for (var name in _resources) {
  _loop_1(name);
}
var systems = {};
var _loop_2 = function(name) {
  Object.defineProperty(systems, name, {
    get: function() {
      deprecation("6.0.0", "PIXI.resources." + name + " has moved to PIXI." + name);
      return _systems[name];
    }
  });
};
for (var name in _systems) {
  _loop_2(name);
}
/*!
 * @pixi/app - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/app is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Application = (
  /** @class */
  function() {
    function Application2(options) {
      var _this = this;
      this.stage = new Container$1();
      options = Object.assign({
        forceCanvas: false
      }, options);
      this.renderer = autoDetectRenderer(options);
      Application2._plugins.forEach(function(plugin) {
        plugin.init.call(_this, options);
      });
    }
    Application2.registerPlugin = function(plugin) {
      Application2._plugins.push(plugin);
    };
    Application2.prototype.render = function() {
      this.renderer.render(this.stage);
    };
    Object.defineProperty(Application2.prototype, "view", {
      /**
       * Reference to the renderer's canvas element.
       * @member {HTMLCanvasElement}
       * @readonly
       */
      get: function() {
        return this.renderer.view;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Application2.prototype, "screen", {
      /**
       * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
       * @member {PIXI.Rectangle}
       * @readonly
       */
      get: function() {
        return this.renderer.screen;
      },
      enumerable: false,
      configurable: true
    });
    Application2.prototype.destroy = function(removeView, stageOptions) {
      var _this = this;
      var plugins = Application2._plugins.slice(0);
      plugins.reverse();
      plugins.forEach(function(plugin) {
        plugin.destroy.call(_this);
      });
      this.stage.destroy(stageOptions);
      this.stage = null;
      this.renderer.destroy(removeView);
      this.renderer = null;
    };
    Application2._plugins = [];
    return Application2;
  }()
);
var ResizePlugin = (
  /** @class */
  function() {
    function ResizePlugin2() {
    }
    ResizePlugin2.init = function(options) {
      var _this = this;
      Object.defineProperty(
        this,
        "resizeTo",
        /**
         * The HTML element or window to automatically resize the
         * renderer's view element to match width and height.
         * @member {Window|HTMLElement}
         * @name resizeTo
         * @memberof PIXI.Application#
         */
        {
          set: function(dom) {
            globalThis.removeEventListener("resize", this.queueResize);
            this._resizeTo = dom;
            if (dom) {
              globalThis.addEventListener("resize", this.queueResize);
              this.resize();
            }
          },
          get: function() {
            return this._resizeTo;
          }
        }
      );
      this.queueResize = function() {
        if (!_this._resizeTo) {
          return;
        }
        _this.cancelResize();
        _this._resizeId = requestAnimationFrame(function() {
          return _this.resize();
        });
      };
      this.cancelResize = function() {
        if (_this._resizeId) {
          cancelAnimationFrame(_this._resizeId);
          _this._resizeId = null;
        }
      };
      this.resize = function() {
        if (!_this._resizeTo) {
          return;
        }
        _this.cancelResize();
        var width;
        var height;
        if (_this._resizeTo === globalThis.window) {
          width = globalThis.innerWidth;
          height = globalThis.innerHeight;
        } else {
          var _a2 = _this._resizeTo, clientWidth = _a2.clientWidth, clientHeight = _a2.clientHeight;
          width = clientWidth;
          height = clientHeight;
        }
        _this.renderer.resize(width, height);
      };
      this._resizeId = null;
      this._resizeTo = null;
      this.resizeTo = options.resizeTo || null;
    };
    ResizePlugin2.destroy = function() {
      globalThis.removeEventListener("resize", this.queueResize);
      this.cancelResize();
      this.cancelResize = null;
      this.queueResize = null;
      this.resizeTo = null;
      this.resize = null;
    };
    return ResizePlugin2;
  }()
);
Application.registerPlugin(ResizePlugin);
/*!
 * @pixi/extract - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/extract is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var appleIphone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet = /Android/i;
var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
var amazonTablet = /Silk/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i;
var otherBlackBerry = /BlackBerry/i;
var otherBlackBerry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i;
var isAppleTabletOnIos13 = function(navigator2) {
  return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
};
function createMatch(userAgent2) {
  return function(regex) {
    return regex.test(userAgent2);
  };
}
function isMobile$1(param) {
  var nav = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  if (!param && typeof navigator !== "undefined") {
    nav = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      maxTouchPoints: navigator.maxTouchPoints || 0
    };
  } else if (typeof param === "string") {
    nav.userAgent = param;
  } else if (param && param.userAgent) {
    nav = {
      userAgent: param.userAgent,
      platform: param.platform,
      maxTouchPoints: param.maxTouchPoints || 0
    };
  }
  var userAgent2 = nav.userAgent;
  var tmp = userAgent2.split("[FBAN");
  if (typeof tmp[1] !== "undefined") {
    userAgent2 = tmp[0];
  }
  tmp = userAgent2.split("Twitter");
  if (typeof tmp[1] !== "undefined") {
    userAgent2 = tmp[0];
  }
  var match2 = createMatch(userAgent2);
  var result = {
    apple: {
      phone: match2(appleIphone) && !match2(windowsPhone),
      ipod: match2(appleIpod),
      tablet: !match2(appleIphone) && (match2(appleTablet) || isAppleTabletOnIos13(nav)) && !match2(windowsPhone),
      universal: match2(appleUniversal),
      device: (match2(appleIphone) || match2(appleIpod) || match2(appleTablet) || match2(appleUniversal) || isAppleTabletOnIos13(nav)) && !match2(windowsPhone)
    },
    amazon: {
      phone: match2(amazonPhone),
      tablet: !match2(amazonPhone) && match2(amazonTablet),
      device: match2(amazonPhone) || match2(amazonTablet)
    },
    android: {
      phone: !match2(windowsPhone) && match2(amazonPhone) || !match2(windowsPhone) && match2(androidPhone),
      tablet: !match2(windowsPhone) && !match2(amazonPhone) && !match2(androidPhone) && (match2(amazonTablet) || match2(androidTablet)),
      device: !match2(windowsPhone) && (match2(amazonPhone) || match2(amazonTablet) || match2(androidPhone) || match2(androidTablet)) || match2(/\bokhttp\b/i)
    },
    windows: {
      phone: match2(windowsPhone),
      tablet: match2(windowsTablet),
      device: match2(windowsPhone) || match2(windowsTablet)
    },
    other: {
      blackberry: match2(otherBlackBerry),
      blackberry10: match2(otherBlackBerry10),
      opera: match2(otherOpera),
      firefox: match2(otherFirefox),
      chrome: match2(otherChrome),
      device: match2(otherBlackBerry) || match2(otherBlackBerry10) || match2(otherOpera) || match2(otherFirefox) || match2(otherChrome)
    },
    any: false,
    phone: false,
    tablet: false
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}
/*!
 * @pixi/settings - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/settings is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var isMobile = isMobile$1(globalThis.navigator);
function maxRecommendedTextures(max2) {
  var allowMax = true;
  if (isMobile.tablet || isMobile.phone) {
    if (isMobile.apple.device) {
      var match2 = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (match2) {
        var majorVersion = parseInt(match2[1], 10);
        if (majorVersion < 11) {
          allowMax = false;
        }
      }
    }
    if (isMobile.android.device) {
      var match2 = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (match2) {
        var majorVersion = parseInt(match2[1], 10);
        if (majorVersion < 7) {
          allowMax = false;
        }
      }
    }
  }
  return allowMax ? max2 : 4;
}
function canUploadSameBuffer() {
  return !isMobile.apple.device;
}
/*!
 * @pixi/constants - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$1$1;
(function(ENV2) {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
})(ENV$1$1 || (ENV$1$1 = {}));
var RENDERER_TYPE$1$1;
(function(RENDERER_TYPE2) {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE$1$1 || (RENDERER_TYPE$1$1 = {}));
var BUFFER_BITS$1$1;
(function(BUFFER_BITS2) {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS$1$1 || (BUFFER_BITS$1$1 = {}));
var BLEND_MODES$1$1;
(function(BLEND_MODES2) {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
})(BLEND_MODES$1$1 || (BLEND_MODES$1$1 = {}));
var DRAW_MODES$1$1;
(function(DRAW_MODES2) {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$1$1 || (DRAW_MODES$1$1 = {}));
var FORMATS$1$1;
(function(FORMATS2) {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS$1$1 || (FORMATS$1$1 = {}));
var TARGETS$1$1;
(function(TARGETS2) {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$1$1 || (TARGETS$1$1 = {}));
var TYPES$1$1;
(function(TYPES2) {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES$1$1 || (TYPES$1$1 = {}));
var SAMPLER_TYPES$1$1;
(function(SAMPLER_TYPES2) {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
})(SAMPLER_TYPES$1$1 || (SAMPLER_TYPES$1$1 = {}));
var SCALE_MODES$1$1;
(function(SCALE_MODES2) {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES$1$1 || (SCALE_MODES$1$1 = {}));
var WRAP_MODES$1$1;
(function(WRAP_MODES2) {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$1$1 || (WRAP_MODES$1$1 = {}));
var MIPMAP_MODES$1$1;
(function(MIPMAP_MODES2) {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
})(MIPMAP_MODES$1$1 || (MIPMAP_MODES$1$1 = {}));
var ALPHA_MODES$1$1;
(function(ALPHA_MODES2) {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$1$1 || (ALPHA_MODES$1$1 = {}));
var CLEAR_MODES$1$1;
(function(CLEAR_MODES2) {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES$1$1 || (CLEAR_MODES$1$1 = {}));
var GC_MODES$1$1;
(function(GC_MODES2) {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
})(GC_MODES$1$1 || (GC_MODES$1$1 = {}));
var PRECISION$1$1;
(function(PRECISION2) {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
})(PRECISION$1$1 || (PRECISION$1$1 = {}));
var MASK_TYPES$1$1;
(function(MASK_TYPES2) {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
})(MASK_TYPES$1$1 || (MASK_TYPES$1$1 = {}));
var MSAA_QUALITY$1$1;
(function(MSAA_QUALITY2) {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY$1$1 || (MSAA_QUALITY$1$1 = {}));
var BUFFER_TYPE$1$1;
(function(BUFFER_TYPE2) {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$1$1 || (BUFFER_TYPE$1$1 = {}));
var settings$1 = {
  /**
   * If set to true WebGL will attempt make textures mimpaped by default.
   * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
   * @static
   * @name MIPMAP_TEXTURES
   * @memberof PIXI.settings
   * @type {PIXI.MIPMAP_MODES}
   * @default PIXI.MIPMAP_MODES.POW2
   */
  MIPMAP_TEXTURES: MIPMAP_MODES$1$1.POW2,
  /**
   * Default anisotropic filtering level of textures.
   * Usually from 0 to 16
   * @static
   * @name ANISOTROPIC_LEVEL
   * @memberof PIXI.settings
   * @type {number}
   * @default 0
   */
  ANISOTROPIC_LEVEL: 0,
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @static
   * @name RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  RESOLUTION: 1,
  /**
   * Default filter resolution.
   * @static
   * @name FILTER_RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  FILTER_RESOLUTION: 1,
  /**
   * Default filter samples.
   * @static
   * @name FILTER_MULTISAMPLE
   * @memberof PIXI.settings
   * @type {PIXI.MSAA_QUALITY}
   * @default PIXI.MSAA_QUALITY.NONE
   */
  FILTER_MULTISAMPLE: MSAA_QUALITY$1$1.NONE,
  /**
   * The maximum textures that this device supports.
   * @static
   * @name SPRITE_MAX_TEXTURES
   * @memberof PIXI.settings
   * @type {number}
   * @default 32
   */
  SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),
  // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
  // TODO: maybe add PARTICLE.BATCH_SIZE: 15000
  /**
   * The default sprite batch size.
   *
   * The default aims to balance desktop and mobile devices.
   * @static
   * @name SPRITE_BATCH_SIZE
   * @memberof PIXI.settings
   * @type {number}
   * @default 4096
   */
  SPRITE_BATCH_SIZE: 4096,
  /**
   * The default render options if none are supplied to {@link PIXI.Renderer}
   * or {@link PIXI.CanvasRenderer}.
   * @static
   * @name RENDER_OPTIONS
   * @memberof PIXI.settings
   * @type {object}
   * @property {HTMLCanvasElement} [view=null] -
   * @property {boolean} [antialias=false] -
   * @property {boolean} [autoDensity=false] -
   * @property {boolean} [useContextAlpha=true]  -
   * @property {number} [backgroundColor=0x000000] -
   * @property {number} [backgroundAlpha=1] -
   * @property {boolean} [clearBeforeRender=true] -
   * @property {boolean} [preserveDrawingBuffer=false] -
   * @property {number} [width=800] -
   * @property {number} [height=600] -
   * @property {boolean} [legacy=false] -
   */
  RENDER_OPTIONS: {
    view: null,
    antialias: false,
    autoDensity: false,
    backgroundColor: 0,
    backgroundAlpha: 1,
    useContextAlpha: true,
    clearBeforeRender: true,
    preserveDrawingBuffer: false,
    width: 800,
    height: 600,
    legacy: false
  },
  /**
   * Default Garbage Collection mode.
   * @static
   * @name GC_MODE
   * @memberof PIXI.settings
   * @type {PIXI.GC_MODES}
   * @default PIXI.GC_MODES.AUTO
   */
  GC_MODE: GC_MODES$1$1.AUTO,
  /**
   * Default Garbage Collection max idle.
   * @static
   * @name GC_MAX_IDLE
   * @memberof PIXI.settings
   * @type {number}
   * @default 3600
   */
  GC_MAX_IDLE: 60 * 60,
  /**
   * Default Garbage Collection maximum check count.
   * @static
   * @name GC_MAX_CHECK_COUNT
   * @memberof PIXI.settings
   * @type {number}
   * @default 600
   */
  GC_MAX_CHECK_COUNT: 60 * 10,
  /**
   * Default wrap modes that are supported by pixi.
   * @static
   * @name WRAP_MODE
   * @memberof PIXI.settings
   * @type {PIXI.WRAP_MODES}
   * @default PIXI.WRAP_MODES.CLAMP
   */
  WRAP_MODE: WRAP_MODES$1$1.CLAMP,
  /**
   * Default scale mode for textures.
   * @static
   * @name SCALE_MODE
   * @memberof PIXI.settings
   * @type {PIXI.SCALE_MODES}
   * @default PIXI.SCALE_MODES.LINEAR
   */
  SCALE_MODE: SCALE_MODES$1$1.LINEAR,
  /**
   * Default specify float precision in vertex shader.
   * @static
   * @name PRECISION_VERTEX
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.HIGH
   */
  PRECISION_VERTEX: PRECISION$1$1.HIGH,
  /**
   * Default specify float precision in fragment shader.
   * iOS is best set at highp due to https://github.com/pixijs/pixi.js/issues/3742
   * @static
   * @name PRECISION_FRAGMENT
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.MEDIUM
   */
  PRECISION_FRAGMENT: isMobile.apple.device ? PRECISION$1$1.HIGH : PRECISION$1$1.MEDIUM,
  /**
   * Can we upload the same buffer in a single frame?
   * @static
   * @name CAN_UPLOAD_SAME_BUFFER
   * @memberof PIXI.settings
   * @type {boolean}
   */
  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),
  /**
   * Enables bitmap creation before image load. This feature is experimental.
   * @static
   * @name CREATE_IMAGE_BITMAP
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  CREATE_IMAGE_BITMAP: false,
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   * @static
   * @constant
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  ROUND_PIXELS: false
};
/*!
 * @pixi/display - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/display is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings$1.SORTABLE_CHILDREN = false;
var Bounds = (
  /** @class */
  function() {
    function Bounds2() {
      this.minX = Infinity;
      this.minY = Infinity;
      this.maxX = -Infinity;
      this.maxY = -Infinity;
      this.rect = null;
      this.updateID = -1;
    }
    Bounds2.prototype.isEmpty = function() {
      return this.minX > this.maxX || this.minY > this.maxY;
    };
    Bounds2.prototype.clear = function() {
      this.minX = Infinity;
      this.minY = Infinity;
      this.maxX = -Infinity;
      this.maxY = -Infinity;
    };
    Bounds2.prototype.getRectangle = function(rect) {
      if (this.minX > this.maxX || this.minY > this.maxY) {
        return Rectangle.EMPTY;
      }
      rect = rect || new Rectangle(0, 0, 1, 1);
      rect.x = this.minX;
      rect.y = this.minY;
      rect.width = this.maxX - this.minX;
      rect.height = this.maxY - this.minY;
      return rect;
    };
    Bounds2.prototype.addPoint = function(point) {
      this.minX = Math.min(this.minX, point.x);
      this.maxX = Math.max(this.maxX, point.x);
      this.minY = Math.min(this.minY, point.y);
      this.maxY = Math.max(this.maxY, point.y);
    };
    Bounds2.prototype.addPointMatrix = function(matrix, point) {
      var a2 = matrix.a, b2 = matrix.b, c2 = matrix.c, d2 = matrix.d, tx = matrix.tx, ty = matrix.ty;
      var x = a2 * point.x + c2 * point.y + tx;
      var y2 = b2 * point.x + d2 * point.y + ty;
      this.minX = Math.min(this.minX, x);
      this.maxX = Math.max(this.maxX, x);
      this.minY = Math.min(this.minY, y2);
      this.maxY = Math.max(this.maxY, y2);
    };
    Bounds2.prototype.addQuad = function(vertices) {
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      var x = vertices[0];
      var y2 = vertices[1];
      minX = x < minX ? x : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y2 > maxY ? y2 : maxY;
      x = vertices[2];
      y2 = vertices[3];
      minX = x < minX ? x : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y2 > maxY ? y2 : maxY;
      x = vertices[4];
      y2 = vertices[5];
      minX = x < minX ? x : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y2 > maxY ? y2 : maxY;
      x = vertices[6];
      y2 = vertices[7];
      minX = x < minX ? x : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y2 > maxY ? y2 : maxY;
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    };
    Bounds2.prototype.addFrame = function(transform, x0, y0, x1, y1) {
      this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);
    };
    Bounds2.prototype.addFrameMatrix = function(matrix, x0, y0, x1, y1) {
      var a2 = matrix.a;
      var b2 = matrix.b;
      var c2 = matrix.c;
      var d2 = matrix.d;
      var tx = matrix.tx;
      var ty = matrix.ty;
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      var x = a2 * x0 + c2 * y0 + tx;
      var y2 = b2 * x0 + d2 * y0 + ty;
      minX = x < minX ? x : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y2 > maxY ? y2 : maxY;
      x = a2 * x1 + c2 * y0 + tx;
      y2 = b2 * x1 + d2 * y0 + ty;
      minX = x < minX ? x : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y2 > maxY ? y2 : maxY;
      x = a2 * x0 + c2 * y1 + tx;
      y2 = b2 * x0 + d2 * y1 + ty;
      minX = x < minX ? x : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y2 > maxY ? y2 : maxY;
      x = a2 * x1 + c2 * y1 + tx;
      y2 = b2 * x1 + d2 * y1 + ty;
      minX = x < minX ? x : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y2 > maxY ? y2 : maxY;
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    };
    Bounds2.prototype.addVertexData = function(vertexData, beginOffset, endOffset) {
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      for (var i2 = beginOffset; i2 < endOffset; i2 += 2) {
        var x = vertexData[i2];
        var y2 = vertexData[i2 + 1];
        minX = x < minX ? x : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y2 > maxY ? y2 : maxY;
      }
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    };
    Bounds2.prototype.addVertices = function(transform, vertices, beginOffset, endOffset) {
      this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);
    };
    Bounds2.prototype.addVerticesMatrix = function(matrix, vertices, beginOffset, endOffset, padX, padY) {
      if (padX === void 0) {
        padX = 0;
      }
      if (padY === void 0) {
        padY = padX;
      }
      var a2 = matrix.a;
      var b2 = matrix.b;
      var c2 = matrix.c;
      var d2 = matrix.d;
      var tx = matrix.tx;
      var ty = matrix.ty;
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      for (var i2 = beginOffset; i2 < endOffset; i2 += 2) {
        var rawX = vertices[i2];
        var rawY = vertices[i2 + 1];
        var x = a2 * rawX + c2 * rawY + tx;
        var y2 = d2 * rawY + b2 * rawX + ty;
        minX = Math.min(minX, x - padX);
        maxX = Math.max(maxX, x + padX);
        minY = Math.min(minY, y2 - padY);
        maxY = Math.max(maxY, y2 + padY);
      }
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    };
    Bounds2.prototype.addBounds = function(bounds) {
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      this.minX = bounds.minX < minX ? bounds.minX : minX;
      this.minY = bounds.minY < minY ? bounds.minY : minY;
      this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
      this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
    };
    Bounds2.prototype.addBoundsMask = function(bounds, mask2) {
      var _minX = bounds.minX > mask2.minX ? bounds.minX : mask2.minX;
      var _minY = bounds.minY > mask2.minY ? bounds.minY : mask2.minY;
      var _maxX = bounds.maxX < mask2.maxX ? bounds.maxX : mask2.maxX;
      var _maxY = bounds.maxY < mask2.maxY ? bounds.maxY : mask2.maxY;
      if (_minX <= _maxX && _minY <= _maxY) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        this.minX = _minX < minX ? _minX : minX;
        this.minY = _minY < minY ? _minY : minY;
        this.maxX = _maxX > maxX ? _maxX : maxX;
        this.maxY = _maxY > maxY ? _maxY : maxY;
      }
    };
    Bounds2.prototype.addBoundsMatrix = function(bounds, matrix) {
      this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
    };
    Bounds2.prototype.addBoundsArea = function(bounds, area2) {
      var _minX = bounds.minX > area2.x ? bounds.minX : area2.x;
      var _minY = bounds.minY > area2.y ? bounds.minY : area2.y;
      var _maxX = bounds.maxX < area2.x + area2.width ? bounds.maxX : area2.x + area2.width;
      var _maxY = bounds.maxY < area2.y + area2.height ? bounds.maxY : area2.y + area2.height;
      if (_minX <= _maxX && _minY <= _maxY) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        this.minX = _minX < minX ? _minX : minX;
        this.minY = _minY < minY ? _minY : minY;
        this.maxX = _maxX > maxX ? _maxX : maxX;
        this.maxY = _maxY > maxY ? _maxY : maxY;
      }
    };
    Bounds2.prototype.pad = function(paddingX, paddingY) {
      if (paddingX === void 0) {
        paddingX = 0;
      }
      if (paddingY === void 0) {
        paddingY = paddingX;
      }
      if (!this.isEmpty()) {
        this.minX -= paddingX;
        this.maxX += paddingX;
        this.minY -= paddingY;
        this.maxY += paddingY;
      }
    };
    Bounds2.prototype.addFramePad = function(x0, y0, x1, y1, padX, padY) {
      x0 -= padX;
      y0 -= padY;
      x1 += padX;
      y1 += padY;
      this.minX = this.minX < x0 ? this.minX : x0;
      this.maxX = this.maxX > x1 ? this.maxX : x1;
      this.minY = this.minY < y0 ? this.minY : y0;
      this.maxY = this.maxY > y1 ? this.maxY : y1;
    };
    return Bounds2;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$T = function(d2, b2) {
  extendStatics$T = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (b3.hasOwnProperty(p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$T(d2, b2);
};
function __extends$T(d2, b2) {
  extendStatics$T(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var DisplayObject = (
  /** @class */
  function(_super) {
    __extends$T(DisplayObject2, _super);
    function DisplayObject2() {
      var _this = _super.call(this) || this;
      _this.tempDisplayObjectParent = null;
      _this.transform = new Transform();
      _this.alpha = 1;
      _this.visible = true;
      _this.renderable = true;
      _this.cullable = false;
      _this.cullArea = null;
      _this.parent = null;
      _this.worldAlpha = 1;
      _this._lastSortedIndex = 0;
      _this._zIndex = 0;
      _this.filterArea = null;
      _this.filters = null;
      _this._enabledFilters = null;
      _this._bounds = new Bounds();
      _this._localBounds = null;
      _this._boundsID = 0;
      _this._boundsRect = null;
      _this._localBoundsRect = null;
      _this._mask = null;
      _this._maskRefCount = 0;
      _this._destroyed = false;
      _this.isSprite = false;
      _this.isMask = false;
      return _this;
    }
    DisplayObject2.mixin = function(source) {
      var keys2 = Object.keys(source);
      for (var i2 = 0; i2 < keys2.length; ++i2) {
        var propertyName = keys2[i2];
        Object.defineProperty(DisplayObject2.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
      }
    };
    Object.defineProperty(DisplayObject2.prototype, "destroyed", {
      /**
       * Fired when this DisplayObject is added to a Container.
       * @instance
       * @event added
       * @param {PIXI.Container} container - The container added to.
       */
      /**
       * Fired when this DisplayObject is removed from a Container.
       * @instance
       * @event removed
       * @param {PIXI.Container} container - The container removed from.
       */
      /**
       * Fired when this DisplayObject is destroyed. This event is emitted once
       * destroy is finished.
       * @instance
       * @event destroyed
       */
      /** Readonly flag for destroyed display objects. */
      get: function() {
        return this._destroyed;
      },
      enumerable: false,
      configurable: true
    });
    DisplayObject2.prototype._recursivePostUpdateTransform = function() {
      if (this.parent) {
        this.parent._recursivePostUpdateTransform();
        this.transform.updateTransform(this.parent.transform);
      } else {
        this.transform.updateTransform(this._tempDisplayObjectParent.transform);
      }
    };
    DisplayObject2.prototype.updateTransform = function() {
      this._boundsID++;
      this.transform.updateTransform(this.parent.transform);
      this.worldAlpha = this.alpha * this.parent.worldAlpha;
    };
    DisplayObject2.prototype.getBounds = function(skipUpdate, rect) {
      if (!skipUpdate) {
        if (!this.parent) {
          this.parent = this._tempDisplayObjectParent;
          this.updateTransform();
          this.parent = null;
        } else {
          this._recursivePostUpdateTransform();
          this.updateTransform();
        }
      }
      if (this._bounds.updateID !== this._boundsID) {
        this.calculateBounds();
        this._bounds.updateID = this._boundsID;
      }
      if (!rect) {
        if (!this._boundsRect) {
          this._boundsRect = new Rectangle();
        }
        rect = this._boundsRect;
      }
      return this._bounds.getRectangle(rect);
    };
    DisplayObject2.prototype.getLocalBounds = function(rect) {
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new Rectangle();
        }
        rect = this._localBoundsRect;
      }
      if (!this._localBounds) {
        this._localBounds = new Bounds();
      }
      var transformRef = this.transform;
      var parentRef = this.parent;
      this.parent = null;
      this.transform = this._tempDisplayObjectParent.transform;
      var worldBounds = this._bounds;
      var worldBoundsID = this._boundsID;
      this._bounds = this._localBounds;
      var bounds = this.getBounds(false, rect);
      this.parent = parentRef;
      this.transform = transformRef;
      this._bounds = worldBounds;
      this._bounds.updateID += this._boundsID - worldBoundsID;
      return bounds;
    };
    DisplayObject2.prototype.toGlobal = function(position2, point, skipUpdate) {
      if (skipUpdate === void 0) {
        skipUpdate = false;
      }
      if (!skipUpdate) {
        this._recursivePostUpdateTransform();
        if (!this.parent) {
          this.parent = this._tempDisplayObjectParent;
          this.displayObjectUpdateTransform();
          this.parent = null;
        } else {
          this.displayObjectUpdateTransform();
        }
      }
      return this.worldTransform.apply(position2, point);
    };
    DisplayObject2.prototype.toLocal = function(position2, from2, point, skipUpdate) {
      if (from2) {
        position2 = from2.toGlobal(position2, point, skipUpdate);
      }
      if (!skipUpdate) {
        this._recursivePostUpdateTransform();
        if (!this.parent) {
          this.parent = this._tempDisplayObjectParent;
          this.displayObjectUpdateTransform();
          this.parent = null;
        } else {
          this.displayObjectUpdateTransform();
        }
      }
      return this.worldTransform.applyInverse(position2, point);
    };
    DisplayObject2.prototype.setParent = function(container2) {
      if (!container2 || !container2.addChild) {
        throw new Error("setParent: Argument must be a Container");
      }
      container2.addChild(this);
      return container2;
    };
    DisplayObject2.prototype.setTransform = function(x, y2, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {
      if (x === void 0) {
        x = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      if (scaleX === void 0) {
        scaleX = 1;
      }
      if (scaleY === void 0) {
        scaleY = 1;
      }
      if (rotation === void 0) {
        rotation = 0;
      }
      if (skewX === void 0) {
        skewX = 0;
      }
      if (skewY === void 0) {
        skewY = 0;
      }
      if (pivotX === void 0) {
        pivotX = 0;
      }
      if (pivotY === void 0) {
        pivotY = 0;
      }
      this.position.x = x;
      this.position.y = y2;
      this.scale.x = !scaleX ? 1 : scaleX;
      this.scale.y = !scaleY ? 1 : scaleY;
      this.rotation = rotation;
      this.skew.x = skewX;
      this.skew.y = skewY;
      this.pivot.x = pivotX;
      this.pivot.y = pivotY;
      return this;
    };
    DisplayObject2.prototype.destroy = function(_options) {
      if (this.parent) {
        this.parent.removeChild(this);
      }
      this._destroyed = true;
      this.transform = null;
      this.parent = null;
      this._bounds = null;
      this.mask = null;
      this.cullArea = null;
      this.filters = null;
      this.filterArea = null;
      this.hitArea = null;
      this.interactive = false;
      this.interactiveChildren = false;
      this.emit("destroyed");
      this.removeAllListeners();
    };
    Object.defineProperty(DisplayObject2.prototype, "_tempDisplayObjectParent", {
      /**
       * @protected
       * @member {PIXI.Container}
       */
      get: function() {
        if (this.tempDisplayObjectParent === null) {
          this.tempDisplayObjectParent = new TemporaryDisplayObject();
        }
        return this.tempDisplayObjectParent;
      },
      enumerable: false,
      configurable: true
    });
    DisplayObject2.prototype.enableTempParent = function() {
      var myParent = this.parent;
      this.parent = this._tempDisplayObjectParent;
      return myParent;
    };
    DisplayObject2.prototype.disableTempParent = function(cacheParent) {
      this.parent = cacheParent;
    };
    Object.defineProperty(DisplayObject2.prototype, "x", {
      /**
       * The position of the displayObject on the x axis relative to the local coordinates of the parent.
       * An alias to position.x
       */
      get: function() {
        return this.position.x;
      },
      set: function(value) {
        this.transform.position.x = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "y", {
      /**
       * The position of the displayObject on the y axis relative to the local coordinates of the parent.
       * An alias to position.y
       */
      get: function() {
        return this.position.y;
      },
      set: function(value) {
        this.transform.position.y = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "worldTransform", {
      /**
       * Current transform of the object based on world (parent) factors.
       * @readonly
       */
      get: function() {
        return this.transform.worldTransform;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "localTransform", {
      /**
       * Current transform of the object based on local factors: position, scale, other stuff.
       * @readonly
       */
      get: function() {
        return this.transform.localTransform;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "position", {
      /**
       * The coordinate of the object relative to the local coordinates of the parent.
       * @since 4.0.0
       */
      get: function() {
        return this.transform.position;
      },
      set: function(value) {
        this.transform.position.copyFrom(value);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "scale", {
      /**
       * The scale factors of this object along the local coordinate axes.
       *
       * The default scale is (1, 1).
       * @since 4.0.0
       */
      get: function() {
        return this.transform.scale;
      },
      set: function(value) {
        this.transform.scale.copyFrom(value);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "pivot", {
      /**
       * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
       * is the projection of `pivot` in the parent's local space.
       *
       * By default, the pivot is the origin (0, 0).
       * @since 4.0.0
       */
      get: function() {
        return this.transform.pivot;
      },
      set: function(value) {
        this.transform.pivot.copyFrom(value);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "skew", {
      /**
       * The skew factor for the object in radians.
       * @since 4.0.0
       */
      get: function() {
        return this.transform.skew;
      },
      set: function(value) {
        this.transform.skew.copyFrom(value);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "rotation", {
      /**
       * The rotation of the object in radians.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get: function() {
        return this.transform.rotation;
      },
      set: function(value) {
        this.transform.rotation = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "angle", {
      /**
       * The angle of the object in degrees.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get: function() {
        return this.transform.rotation * RAD_TO_DEG;
      },
      set: function(value) {
        this.transform.rotation = value * DEG_TO_RAD;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "zIndex", {
      /**
       * The zIndex of the displayObject.
       *
       * If a container has the sortableChildren property set to true, children will be automatically
       * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
       * and thus rendered on top of other display objects within the same container.
       * @see PIXI.Container#sortableChildren
       */
      get: function() {
        return this._zIndex;
      },
      set: function(value) {
        this._zIndex = value;
        if (this.parent) {
          this.parent.sortDirty = true;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "worldVisible", {
      /**
       * Indicates if the object is globally visible.
       * @readonly
       */
      get: function() {
        var item = this;
        do {
          if (!item.visible) {
            return false;
          }
          item = item.parent;
        } while (item);
        return true;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DisplayObject2.prototype, "mask", {
      /**
       * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
       * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
       * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it
       * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
       * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
       * To remove a mask, set this property to `null`.
       *
       * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
       * @example
       * const graphics = new PIXI.Graphics();
       * graphics.beginFill(0xFF3300);
       * graphics.drawRect(50, 250, 100, 100);
       * graphics.endFill();
       *
       * const sprite = new PIXI.Sprite(texture);
       * sprite.mask = graphics;
       * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
       */
      get: function() {
        return this._mask;
      },
      set: function(value) {
        if (this._mask === value) {
          return;
        }
        if (this._mask) {
          var maskObject = this._mask.maskObject || this._mask;
          maskObject._maskRefCount--;
          if (maskObject._maskRefCount === 0) {
            maskObject.renderable = true;
            maskObject.isMask = false;
          }
        }
        this._mask = value;
        if (this._mask) {
          var maskObject = this._mask.maskObject || this._mask;
          if (maskObject._maskRefCount === 0) {
            maskObject.renderable = false;
            maskObject.isMask = true;
          }
          maskObject._maskRefCount++;
        }
      },
      enumerable: false,
      configurable: true
    });
    return DisplayObject2;
  }(EventEmitter$1)
);
var TemporaryDisplayObject = (
  /** @class */
  function(_super) {
    __extends$T(TemporaryDisplayObject2, _super);
    function TemporaryDisplayObject2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.sortDirty = null;
      return _this;
    }
    return TemporaryDisplayObject2;
  }(DisplayObject)
);
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
/*!
 * @pixi/constants - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$2;
(function(ENV2) {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
})(ENV$2 || (ENV$2 = {}));
var RENDERER_TYPE$2;
(function(RENDERER_TYPE2) {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE$2 || (RENDERER_TYPE$2 = {}));
var BUFFER_BITS$2;
(function(BUFFER_BITS2) {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS$2 || (BUFFER_BITS$2 = {}));
var BLEND_MODES$2;
(function(BLEND_MODES2) {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
})(BLEND_MODES$2 || (BLEND_MODES$2 = {}));
var DRAW_MODES$2;
(function(DRAW_MODES2) {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$2 || (DRAW_MODES$2 = {}));
var FORMATS$2;
(function(FORMATS2) {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS$2 || (FORMATS$2 = {}));
var TARGETS$2;
(function(TARGETS2) {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$2 || (TARGETS$2 = {}));
var TYPES$2;
(function(TYPES2) {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES$2 || (TYPES$2 = {}));
var SAMPLER_TYPES$2;
(function(SAMPLER_TYPES2) {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
})(SAMPLER_TYPES$2 || (SAMPLER_TYPES$2 = {}));
var SCALE_MODES$2;
(function(SCALE_MODES2) {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES$2 || (SCALE_MODES$2 = {}));
var WRAP_MODES$2;
(function(WRAP_MODES2) {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$2 || (WRAP_MODES$2 = {}));
var MIPMAP_MODES$2;
(function(MIPMAP_MODES2) {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
})(MIPMAP_MODES$2 || (MIPMAP_MODES$2 = {}));
var ALPHA_MODES$2;
(function(ALPHA_MODES2) {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$2 || (ALPHA_MODES$2 = {}));
var CLEAR_MODES$2;
(function(CLEAR_MODES2) {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES$2 || (CLEAR_MODES$2 = {}));
var GC_MODES$2;
(function(GC_MODES2) {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
})(GC_MODES$2 || (GC_MODES$2 = {}));
var PRECISION$2;
(function(PRECISION2) {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
})(PRECISION$2 || (PRECISION$2 = {}));
var MASK_TYPES$2;
(function(MASK_TYPES2) {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
})(MASK_TYPES$2 || (MASK_TYPES$2 = {}));
var MSAA_QUALITY$2;
(function(MSAA_QUALITY2) {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY$2 || (MSAA_QUALITY$2 = {}));
var BUFFER_TYPE$2;
(function(BUFFER_TYPE2) {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$2 || (BUFFER_TYPE$2 = {}));
function sortChildren(a2, b2) {
  if (a2.zIndex === b2.zIndex) {
    return a2._lastSortedIndex - b2._lastSortedIndex;
  }
  return a2.zIndex - b2.zIndex;
}
var Container = (
  /** @class */
  function(_super) {
    __extends$T(Container2, _super);
    function Container2() {
      var _this = _super.call(this) || this;
      _this.children = [];
      _this.sortableChildren = settings$1.SORTABLE_CHILDREN;
      _this.sortDirty = false;
      return _this;
    }
    Container2.prototype.onChildrenChange = function(_length) {
    };
    Container2.prototype.addChild = function() {
      var arguments$1 = arguments;
      var children = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        children[_i] = arguments$1[_i];
      }
      if (children.length > 1) {
        for (var i2 = 0; i2 < children.length; i2++) {
          this.addChild(children[i2]);
        }
      } else {
        var child = children[0];
        if (child.parent) {
          child.parent.removeChild(child);
        }
        child.parent = this;
        this.sortDirty = true;
        child.transform._parentID = -1;
        this.children.push(child);
        this._boundsID++;
        this.onChildrenChange(this.children.length - 1);
        this.emit("childAdded", child, this, this.children.length - 1);
        child.emit("added", this);
      }
      return children[0];
    };
    Container2.prototype.addChildAt = function(child, index2) {
      if (index2 < 0 || index2 > this.children.length) {
        throw new Error(child + "addChildAt: The index " + index2 + " supplied is out of bounds " + this.children.length);
      }
      if (child.parent) {
        child.parent.removeChild(child);
      }
      child.parent = this;
      this.sortDirty = true;
      child.transform._parentID = -1;
      this.children.splice(index2, 0, child);
      this._boundsID++;
      this.onChildrenChange(index2);
      child.emit("added", this);
      this.emit("childAdded", child, this, index2);
      return child;
    };
    Container2.prototype.swapChildren = function(child, child2) {
      if (child === child2) {
        return;
      }
      var index1 = this.getChildIndex(child);
      var index2 = this.getChildIndex(child2);
      this.children[index1] = child2;
      this.children[index2] = child;
      this.onChildrenChange(index1 < index2 ? index1 : index2);
    };
    Container2.prototype.getChildIndex = function(child) {
      var index2 = this.children.indexOf(child);
      if (index2 === -1) {
        throw new Error("The supplied DisplayObject must be a child of the caller");
      }
      return index2;
    };
    Container2.prototype.setChildIndex = function(child, index2) {
      if (index2 < 0 || index2 >= this.children.length) {
        throw new Error("The index " + index2 + " supplied is out of bounds " + this.children.length);
      }
      var currentIndex = this.getChildIndex(child);
      removeItems(this.children, currentIndex, 1);
      this.children.splice(index2, 0, child);
      this.onChildrenChange(index2);
    };
    Container2.prototype.getChildAt = function(index2) {
      if (index2 < 0 || index2 >= this.children.length) {
        throw new Error("getChildAt: Index (" + index2 + ") does not exist.");
      }
      return this.children[index2];
    };
    Container2.prototype.removeChild = function() {
      var arguments$1 = arguments;
      var children = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        children[_i] = arguments$1[_i];
      }
      if (children.length > 1) {
        for (var i2 = 0; i2 < children.length; i2++) {
          this.removeChild(children[i2]);
        }
      } else {
        var child = children[0];
        var index2 = this.children.indexOf(child);
        if (index2 === -1) {
          return null;
        }
        child.parent = null;
        child.transform._parentID = -1;
        removeItems(this.children, index2, 1);
        this._boundsID++;
        this.onChildrenChange(index2);
        child.emit("removed", this);
        this.emit("childRemoved", child, this, index2);
      }
      return children[0];
    };
    Container2.prototype.removeChildAt = function(index2) {
      var child = this.getChildAt(index2);
      child.parent = null;
      child.transform._parentID = -1;
      removeItems(this.children, index2, 1);
      this._boundsID++;
      this.onChildrenChange(index2);
      child.emit("removed", this);
      this.emit("childRemoved", child, this, index2);
      return child;
    };
    Container2.prototype.removeChildren = function(beginIndex, endIndex) {
      if (beginIndex === void 0) {
        beginIndex = 0;
      }
      if (endIndex === void 0) {
        endIndex = this.children.length;
      }
      var begin = beginIndex;
      var end2 = endIndex;
      var range2 = end2 - begin;
      var removed;
      if (range2 > 0 && range2 <= end2) {
        removed = this.children.splice(begin, range2);
        for (var i2 = 0; i2 < removed.length; ++i2) {
          removed[i2].parent = null;
          if (removed[i2].transform) {
            removed[i2].transform._parentID = -1;
          }
        }
        this._boundsID++;
        this.onChildrenChange(beginIndex);
        for (var i2 = 0; i2 < removed.length; ++i2) {
          removed[i2].emit("removed", this);
          this.emit("childRemoved", removed[i2], this, i2);
        }
        return removed;
      } else if (range2 === 0 && this.children.length === 0) {
        return [];
      }
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    };
    Container2.prototype.sortChildren = function() {
      var sortRequired = false;
      for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
        var child = this.children[i2];
        child._lastSortedIndex = i2;
        if (!sortRequired && child.zIndex !== 0) {
          sortRequired = true;
        }
      }
      if (sortRequired && this.children.length > 1) {
        this.children.sort(sortChildren);
      }
      this.sortDirty = false;
    };
    Container2.prototype.updateTransform = function() {
      if (this.sortableChildren && this.sortDirty) {
        this.sortChildren();
      }
      this._boundsID++;
      this.transform.updateTransform(this.parent.transform);
      this.worldAlpha = this.alpha * this.parent.worldAlpha;
      for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
        var child = this.children[i2];
        if (child.visible) {
          child.updateTransform();
        }
      }
    };
    Container2.prototype.calculateBounds = function() {
      this._bounds.clear();
      this._calculateBounds();
      for (var i2 = 0; i2 < this.children.length; i2++) {
        var child = this.children[i2];
        if (!child.visible || !child.renderable) {
          continue;
        }
        child.calculateBounds();
        if (child._mask) {
          var maskObject = child._mask.maskObject || child._mask;
          maskObject.calculateBounds();
          this._bounds.addBoundsMask(child._bounds, maskObject._bounds);
        } else if (child.filterArea) {
          this._bounds.addBoundsArea(child._bounds, child.filterArea);
        } else {
          this._bounds.addBounds(child._bounds);
        }
      }
      this._bounds.updateID = this._boundsID;
    };
    Container2.prototype.getLocalBounds = function(rect, skipChildrenUpdate) {
      if (skipChildrenUpdate === void 0) {
        skipChildrenUpdate = false;
      }
      var result = _super.prototype.getLocalBounds.call(this, rect);
      if (!skipChildrenUpdate) {
        for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
          var child = this.children[i2];
          if (child.visible) {
            child.updateTransform();
          }
        }
      }
      return result;
    };
    Container2.prototype._calculateBounds = function() {
    };
    Container2.prototype._renderWithCulling = function(renderer) {
      var sourceFrame = renderer.renderTexture.sourceFrame;
      if (!(sourceFrame.width > 0 && sourceFrame.height > 0)) {
        return;
      }
      var bounds;
      var transform;
      if (this.cullArea) {
        bounds = this.cullArea;
        transform = this.worldTransform;
      } else if (this._render !== Container2.prototype._render) {
        bounds = this.getBounds(true);
      }
      if (bounds && sourceFrame.intersects(bounds, transform)) {
        this._render(renderer);
      } else if (this.cullArea) {
        return;
      }
      for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
        var child = this.children[i2];
        var childCullable = child.cullable;
        child.cullable = childCullable || !this.cullArea;
        child.render(renderer);
        child.cullable = childCullable;
      }
    };
    Container2.prototype.render = function(renderer) {
      if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
        return;
      }
      if (this._mask || this.filters && this.filters.length) {
        this.renderAdvanced(renderer);
      } else if (this.cullable) {
        this._renderWithCulling(renderer);
      } else {
        this._render(renderer);
        for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
          this.children[i2].render(renderer);
        }
      }
    };
    Container2.prototype.renderAdvanced = function(renderer) {
      var filters2 = this.filters;
      var mask2 = this._mask;
      if (filters2) {
        if (!this._enabledFilters) {
          this._enabledFilters = [];
        }
        this._enabledFilters.length = 0;
        for (var i2 = 0; i2 < filters2.length; i2++) {
          if (filters2[i2].enabled) {
            this._enabledFilters.push(filters2[i2]);
          }
        }
      }
      var flush = filters2 && this._enabledFilters && this._enabledFilters.length || mask2 && (!mask2.isMaskData || mask2.enabled && (mask2.autoDetect || mask2.type !== MASK_TYPES$2.NONE));
      if (flush) {
        renderer.batch.flush();
      }
      if (filters2 && this._enabledFilters && this._enabledFilters.length) {
        renderer.filter.push(this, this._enabledFilters);
      }
      if (mask2) {
        renderer.mask.push(this, this._mask);
      }
      if (this.cullable) {
        this._renderWithCulling(renderer);
      } else {
        this._render(renderer);
        for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
          this.children[i2].render(renderer);
        }
      }
      if (flush) {
        renderer.batch.flush();
      }
      if (mask2) {
        renderer.mask.pop(this);
      }
      if (filters2 && this._enabledFilters && this._enabledFilters.length) {
        renderer.filter.pop();
      }
    };
    Container2.prototype._render = function(_renderer) {
    };
    Container2.prototype.destroy = function(options) {
      _super.prototype.destroy.call(this);
      this.sortDirty = false;
      var destroyChildren = typeof options === "boolean" ? options : options && options.children;
      var oldChildren = this.removeChildren(0, this.children.length);
      if (destroyChildren) {
        for (var i2 = 0; i2 < oldChildren.length; ++i2) {
          oldChildren[i2].destroy(options);
        }
      }
    };
    Object.defineProperty(Container2.prototype, "width", {
      /** The width of the Container, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.scale.x * this.getLocalBounds().width;
      },
      set: function(value) {
        var width = this.getLocalBounds().width;
        if (width !== 0) {
          this.scale.x = value / width;
        } else {
          this.scale.x = 1;
        }
        this._width = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Container2.prototype, "height", {
      /** The height of the Container, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.scale.y * this.getLocalBounds().height;
      },
      set: function(value) {
        var height = this.getLocalBounds().height;
        if (height !== 0) {
          this.scale.y = value / height;
        } else {
          this.scale.y = 1;
        }
        this._height = value;
      },
      enumerable: false,
      configurable: true
    });
    return Container2;
  }(DisplayObject)
);
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
var TEMP_RECT = new Rectangle();
var BYTES_PER_PIXEL = 4;
var Extract = (
  /** @class */
  function() {
    function Extract2(renderer) {
      this.renderer = renderer;
    }
    Extract2.prototype.image = function(target, format2, quality) {
      var image = new Image();
      image.src = this.base64(target, format2, quality);
      return image;
    };
    Extract2.prototype.base64 = function(target, format2, quality) {
      return this.canvas(target).toDataURL(format2, quality);
    };
    Extract2.prototype.canvas = function(target) {
      var renderer = this.renderer;
      var resolution;
      var frame2;
      var flipY = false;
      var renderTexture;
      var generated = false;
      if (target) {
        if (target instanceof RenderTexture) {
          renderTexture = target;
        } else {
          renderTexture = this.renderer.generateTexture(target);
          generated = true;
        }
      }
      if (renderTexture) {
        resolution = renderTexture.baseTexture.resolution;
        frame2 = renderTexture.frame;
        flipY = false;
        renderer.renderTexture.bind(renderTexture);
      } else {
        resolution = this.renderer.resolution;
        flipY = true;
        frame2 = TEMP_RECT;
        frame2.width = this.renderer.width;
        frame2.height = this.renderer.height;
        renderer.renderTexture.bind(null);
      }
      var width = Math.floor(frame2.width * resolution + 1e-4);
      var height = Math.floor(frame2.height * resolution + 1e-4);
      var canvasBuffer = new CanvasRenderTarget(width, height, 1);
      var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
      var gl = renderer.gl;
      gl.readPixels(frame2.x * resolution, frame2.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
      var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);
      Extract2.arrayPostDivide(webglPixels, canvasData.data);
      canvasBuffer.context.putImageData(canvasData, 0, 0);
      if (flipY) {
        var target_1 = new CanvasRenderTarget(canvasBuffer.width, canvasBuffer.height, 1);
        target_1.context.scale(1, -1);
        target_1.context.drawImage(canvasBuffer.canvas, 0, -height);
        canvasBuffer.destroy();
        canvasBuffer = target_1;
      }
      if (generated) {
        renderTexture.destroy(true);
      }
      return canvasBuffer.canvas;
    };
    Extract2.prototype.pixels = function(target, options) {
      var renderer = this.renderer;
      var resolution;
      var frame2;
      var renderTexture;
      var generated = false;
      if (target) {
        if (target instanceof RenderTexture) {
          renderTexture = target;
        } else if (target instanceof DisplayObject) {
          renderTexture = this.renderer.generateTexture(target);
          generated = true;
        }
      }
      if (renderTexture) {
        if (options) {
          resolution = options.resolution;
          frame2 = renderTexture.frame;
          renderer.renderTexture.bind(renderTexture);
        } else {
          resolution = renderTexture.baseTexture.resolution;
          frame2 = renderTexture.frame;
          renderer.renderTexture.bind(renderTexture);
        }
      } else if (options) {
        resolution = options.resolution;
        frame2 = TEMP_RECT;
        frame2.width = options.width;
        frame2.height = options.height;
        renderer.renderTexture.bind(null);
      } else {
        resolution = renderer.resolution;
        frame2 = TEMP_RECT;
        frame2.width = renderer.width;
        frame2.height = renderer.height;
        renderer.renderTexture.bind(null);
      }
      var width = frame2.width * resolution;
      var height = frame2.height * resolution;
      var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
      var gl = renderer.gl;
      gl.readPixels(frame2.x * resolution, frame2.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
      if (generated) {
        renderTexture.destroy(true);
      }
      Extract2.arrayPostDivide(webglPixels, webglPixels);
      return webglPixels;
    };
    Extract2.prototype.destroy = function() {
      this.renderer = null;
    };
    Extract2.arrayPostDivide = function(pixels, out) {
      for (var i2 = 0; i2 < pixels.length; i2 += 4) {
        var alpha2 = out[i2 + 3] = pixels[i2 + 3];
        if (alpha2 !== 0) {
          out[i2] = Math.round(Math.min(pixels[i2] * 255 / alpha2, 255));
          out[i2 + 1] = Math.round(Math.min(pixels[i2 + 1] * 255 / alpha2, 255));
          out[i2 + 2] = Math.round(Math.min(pixels[i2 + 2] * 255 / alpha2, 255));
        } else {
          out[i2] = pixels[i2];
          out[i2 + 1] = pixels[i2 + 1];
          out[i2 + 2] = pixels[i2 + 2];
        }
      }
    };
    return Extract2;
  }()
);
/*!
 * @pixi/loaders - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/loaders is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var SignalBinding = (
  /** @class */
  function() {
    function SignalBinding2(fn2, once, thisArg) {
      if (once === void 0) {
        once = false;
      }
      this._fn = fn2;
      this._once = once;
      this._thisArg = thisArg;
      this._next = this._prev = this._owner = null;
    }
    SignalBinding2.prototype.detach = function() {
      if (this._owner === null) {
        return false;
      }
      this._owner.detach(this);
      return true;
    };
    return SignalBinding2;
  }()
);
function _addSignalBinding(self2, node2) {
  if (!self2._head) {
    self2._head = node2;
    self2._tail = node2;
  } else {
    self2._tail._next = node2;
    node2._prev = self2._tail;
    self2._tail = node2;
  }
  node2._owner = self2;
  return node2;
}
var Signal = (
  /** @class */
  function() {
    function Signal2() {
      this._head = this._tail = void 0;
    }
    Signal2.prototype.handlers = function(exists) {
      if (exists === void 0) {
        exists = false;
      }
      var node2 = this._head;
      if (exists) {
        return !!node2;
      }
      var ee2 = [];
      while (node2) {
        ee2.push(node2);
        node2 = node2._next;
      }
      return ee2;
    };
    Signal2.prototype.has = function(node2) {
      if (!(node2 instanceof SignalBinding)) {
        throw new Error("MiniSignal#has(): First arg must be a SignalBinding object.");
      }
      return node2._owner === this;
    };
    Signal2.prototype.dispatch = function() {
      var arguments$1 = arguments;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments$1[_i];
      }
      var node2 = this._head;
      if (!node2) {
        return false;
      }
      while (node2) {
        if (node2._once) {
          this.detach(node2);
        }
        node2._fn.apply(node2._thisArg, args);
        node2 = node2._next;
      }
      return true;
    };
    Signal2.prototype.add = function(fn2, thisArg) {
      if (thisArg === void 0) {
        thisArg = null;
      }
      if (typeof fn2 !== "function") {
        throw new Error("MiniSignal#add(): First arg must be a Function.");
      }
      return _addSignalBinding(this, new SignalBinding(fn2, false, thisArg));
    };
    Signal2.prototype.once = function(fn2, thisArg) {
      if (thisArg === void 0) {
        thisArg = null;
      }
      if (typeof fn2 !== "function") {
        throw new Error("MiniSignal#once(): First arg must be a Function.");
      }
      return _addSignalBinding(this, new SignalBinding(fn2, true, thisArg));
    };
    Signal2.prototype.detach = function(node2) {
      if (!(node2 instanceof SignalBinding)) {
        throw new Error("MiniSignal#detach(): First arg must be a SignalBinding object.");
      }
      if (node2._owner !== this) {
        return this;
      }
      if (node2._prev) {
        node2._prev._next = node2._next;
      }
      if (node2._next) {
        node2._next._prev = node2._prev;
      }
      if (node2 === this._head) {
        this._head = node2._next;
        if (node2._next === null) {
          this._tail = null;
        }
      } else if (node2 === this._tail) {
        this._tail = node2._prev;
        this._tail._next = null;
      }
      node2._owner = null;
      return this;
    };
    Signal2.prototype.detachAll = function() {
      var node2 = this._head;
      if (!node2) {
        return this;
      }
      this._head = this._tail = null;
      while (node2) {
        node2._owner = null;
        node2 = node2._next;
      }
      return this;
    };
    return Signal2;
  }()
);
function parseUri(str, opts) {
  opts = opts || {};
  var o2 = {
    // eslint-disable-next-line max-len
    key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
    q: {
      name: "queryKey",
      parser: /(?:^|&)([^&=]*)=?([^&]*)/g
    },
    parser: {
      // eslint-disable-next-line max-len
      strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
      // eslint-disable-next-line max-len
      loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
  };
  var m2 = o2.parser[opts.strictMode ? "strict" : "loose"].exec(str);
  var uri2 = {};
  var i2 = 14;
  while (i2--) {
    uri2[o2.key[i2]] = m2[i2] || "";
  }
  uri2[o2.q.name] = {};
  uri2[o2.key[12]].replace(o2.q.parser, function(_t0, t1, t2) {
    if (t1) {
      uri2[o2.q.name][t1] = t2;
    }
  });
  return uri2;
}
var useXdr;
var tempAnchor = null;
var STATUS_NONE = 0;
var STATUS_OK = 200;
var STATUS_EMPTY = 204;
var STATUS_IE_BUG_EMPTY = 1223;
var STATUS_TYPE_OK = 2;
function _noop$1() {
}
function setExtMap(map2, extname, val) {
  if (extname && extname.indexOf(".") === 0) {
    extname = extname.substring(1);
  }
  if (!extname) {
    return;
  }
  map2[extname] = val;
}
function reqType(xhr2) {
  return xhr2.toString().replace("object ", "");
}
var LoaderResource = (
  /** @class */
  function() {
    function LoaderResource2(name, url2, options) {
      this._dequeue = _noop$1;
      this._onLoadBinding = null;
      this._elementTimer = 0;
      this._boundComplete = null;
      this._boundOnError = null;
      this._boundOnProgress = null;
      this._boundOnTimeout = null;
      this._boundXhrOnError = null;
      this._boundXhrOnTimeout = null;
      this._boundXhrOnAbort = null;
      this._boundXhrOnLoad = null;
      if (typeof name !== "string" || typeof url2 !== "string") {
        throw new Error("Both name and url are required for constructing a resource.");
      }
      options = options || {};
      this._flags = 0;
      this._setFlag(LoaderResource2.STATUS_FLAGS.DATA_URL, url2.indexOf("data:") === 0);
      this.name = name;
      this.url = url2;
      this.extension = this._getExtension();
      this.data = null;
      this.crossOrigin = options.crossOrigin === true ? "anonymous" : options.crossOrigin;
      this.timeout = options.timeout || 0;
      this.loadType = options.loadType || this._determineLoadType();
      this.xhrType = options.xhrType;
      this.metadata = options.metadata || {};
      this.error = null;
      this.xhr = null;
      this.children = [];
      this.type = LoaderResource2.TYPE.UNKNOWN;
      this.progressChunk = 0;
      this._dequeue = _noop$1;
      this._onLoadBinding = null;
      this._elementTimer = 0;
      this._boundComplete = this.complete.bind(this);
      this._boundOnError = this._onError.bind(this);
      this._boundOnProgress = this._onProgress.bind(this);
      this._boundOnTimeout = this._onTimeout.bind(this);
      this._boundXhrOnError = this._xhrOnError.bind(this);
      this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);
      this._boundXhrOnAbort = this._xhrOnAbort.bind(this);
      this._boundXhrOnLoad = this._xhrOnLoad.bind(this);
      this.onStart = new Signal();
      this.onProgress = new Signal();
      this.onComplete = new Signal();
      this.onAfterMiddleware = new Signal();
    }
    LoaderResource2.setExtensionLoadType = function(extname, loadType) {
      setExtMap(LoaderResource2._loadTypeMap, extname, loadType);
    };
    LoaderResource2.setExtensionXhrType = function(extname, xhrType) {
      setExtMap(LoaderResource2._xhrTypeMap, extname, xhrType);
    };
    Object.defineProperty(LoaderResource2.prototype, "isDataUrl", {
      /**
       * When the resource starts to load.
       * @memberof PIXI.LoaderResource
       * @callback OnStartSignal
       * @param {PIXI.Resource} resource - The resource that the event happened on.
       */
      /**
       * When the resource reports loading progress.
       * @memberof PIXI.LoaderResource
       * @callback OnProgressSignal
       * @param {PIXI.Resource} resource - The resource that the event happened on.
       * @param {number} percentage - The progress of the load in the range [0, 1].
       */
      /**
       * When the resource finishes loading.
       * @memberof PIXI.LoaderResource
       * @callback OnCompleteSignal
       * @param {PIXI.Resource} resource - The resource that the event happened on.
       */
      /**
       * @memberof PIXI.LoaderResource
       * @typedef {object} IMetadata
       * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The
       *      element to use for loading, instead of creating one.
       * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This
       *      is useful if you want to pass in a `loadElement` that you already added load sources to.
       * @property {string|string[]} [mimeType] - The mime type to use for the source element
       *      of a video/audio elment. If the urls are an array, you can pass this as an array as well
       *      where each index is the mime type to use for the corresponding url index.
       */
      /**
       * Stores whether or not this url is a data url.
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return this._hasFlag(LoaderResource2.STATUS_FLAGS.DATA_URL);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LoaderResource2.prototype, "isComplete", {
      /**
       * Describes if this resource has finished loading. Is true when the resource has completely
       * loaded.
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return this._hasFlag(LoaderResource2.STATUS_FLAGS.COMPLETE);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LoaderResource2.prototype, "isLoading", {
      /**
       * Describes if this resource is currently loading. Is true when the resource starts loading,
       * and is false again when complete.
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return this._hasFlag(LoaderResource2.STATUS_FLAGS.LOADING);
      },
      enumerable: false,
      configurable: true
    });
    LoaderResource2.prototype.complete = function() {
      this._clearEvents();
      this._finish();
    };
    LoaderResource2.prototype.abort = function(message) {
      if (this.error) {
        return;
      }
      this.error = new Error(message);
      this._clearEvents();
      if (this.xhr) {
        this.xhr.abort();
      } else if (this.xdr) {
        this.xdr.abort();
      } else if (this.data) {
        if (this.data.src) {
          this.data.src = LoaderResource2.EMPTY_GIF;
        } else {
          while (this.data.firstChild) {
            this.data.removeChild(this.data.firstChild);
          }
        }
      }
      this._finish();
    };
    LoaderResource2.prototype.load = function(cb2) {
      var _this = this;
      if (this.isLoading) {
        return;
      }
      if (this.isComplete) {
        if (cb2) {
          setTimeout(function() {
            return cb2(_this);
          }, 1);
        }
        return;
      } else if (cb2) {
        this.onComplete.once(cb2);
      }
      this._setFlag(LoaderResource2.STATUS_FLAGS.LOADING, true);
      this.onStart.dispatch(this);
      if (this.crossOrigin === false || typeof this.crossOrigin !== "string") {
        this.crossOrigin = this._determineCrossOrigin(this.url);
      }
      switch (this.loadType) {
        case LoaderResource2.LOAD_TYPE.IMAGE:
          this.type = LoaderResource2.TYPE.IMAGE;
          this._loadElement("image");
          break;
        case LoaderResource2.LOAD_TYPE.AUDIO:
          this.type = LoaderResource2.TYPE.AUDIO;
          this._loadSourceElement("audio");
          break;
        case LoaderResource2.LOAD_TYPE.VIDEO:
          this.type = LoaderResource2.TYPE.VIDEO;
          this._loadSourceElement("video");
          break;
        case LoaderResource2.LOAD_TYPE.XHR:
        default:
          if (typeof useXdr === "undefined") {
            useXdr = !!(globalThis.XDomainRequest && !("withCredentials" in new XMLHttpRequest()));
          }
          if (useXdr && this.crossOrigin) {
            this._loadXdr();
          } else {
            this._loadXhr();
          }
          break;
      }
    };
    LoaderResource2.prototype._hasFlag = function(flag) {
      return (this._flags & flag) !== 0;
    };
    LoaderResource2.prototype._setFlag = function(flag, value) {
      this._flags = value ? this._flags | flag : this._flags & ~flag;
    };
    LoaderResource2.prototype._clearEvents = function() {
      clearTimeout(this._elementTimer);
      if (this.data && this.data.removeEventListener) {
        this.data.removeEventListener("error", this._boundOnError, false);
        this.data.removeEventListener("load", this._boundComplete, false);
        this.data.removeEventListener("progress", this._boundOnProgress, false);
        this.data.removeEventListener("canplaythrough", this._boundComplete, false);
      }
      if (this.xhr) {
        if (this.xhr.removeEventListener) {
          this.xhr.removeEventListener("error", this._boundXhrOnError, false);
          this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, false);
          this.xhr.removeEventListener("abort", this._boundXhrOnAbort, false);
          this.xhr.removeEventListener("progress", this._boundOnProgress, false);
          this.xhr.removeEventListener("load", this._boundXhrOnLoad, false);
        } else {
          this.xhr.onerror = null;
          this.xhr.ontimeout = null;
          this.xhr.onprogress = null;
          this.xhr.onload = null;
        }
      }
    };
    LoaderResource2.prototype._finish = function() {
      if (this.isComplete) {
        throw new Error("Complete called again for an already completed resource.");
      }
      this._setFlag(LoaderResource2.STATUS_FLAGS.COMPLETE, true);
      this._setFlag(LoaderResource2.STATUS_FLAGS.LOADING, false);
      this.onComplete.dispatch(this);
    };
    LoaderResource2.prototype._loadElement = function(type2) {
      if (this.metadata.loadElement) {
        this.data = this.metadata.loadElement;
      } else if (type2 === "image" && typeof globalThis.Image !== "undefined") {
        this.data = new Image();
      } else {
        this.data = document.createElement(type2);
      }
      if (this.crossOrigin) {
        this.data.crossOrigin = this.crossOrigin;
      }
      if (!this.metadata.skipSource) {
        this.data.src = this.url;
      }
      this.data.addEventListener("error", this._boundOnError, false);
      this.data.addEventListener("load", this._boundComplete, false);
      this.data.addEventListener("progress", this._boundOnProgress, false);
      if (this.timeout) {
        this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
      }
    };
    LoaderResource2.prototype._loadSourceElement = function(type2) {
      if (this.metadata.loadElement) {
        this.data = this.metadata.loadElement;
      } else if (type2 === "audio" && typeof globalThis.Audio !== "undefined") {
        this.data = new Audio();
      } else {
        this.data = document.createElement(type2);
      }
      if (this.data === null) {
        this.abort("Unsupported element: " + type2);
        return;
      }
      if (this.crossOrigin) {
        this.data.crossOrigin = this.crossOrigin;
      }
      if (!this.metadata.skipSource) {
        if (navigator.isCocoonJS) {
          this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
        } else if (Array.isArray(this.url)) {
          var mimeTypes = this.metadata.mimeType;
          for (var i2 = 0; i2 < this.url.length; ++i2) {
            this.data.appendChild(this._createSource(type2, this.url[i2], Array.isArray(mimeTypes) ? mimeTypes[i2] : mimeTypes));
          }
        } else {
          var mimeTypes = this.metadata.mimeType;
          this.data.appendChild(this._createSource(type2, this.url, Array.isArray(mimeTypes) ? mimeTypes[0] : mimeTypes));
        }
      }
      this.data.addEventListener("error", this._boundOnError, false);
      this.data.addEventListener("load", this._boundComplete, false);
      this.data.addEventListener("progress", this._boundOnProgress, false);
      this.data.addEventListener("canplaythrough", this._boundComplete, false);
      this.data.load();
      if (this.timeout) {
        this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
      }
    };
    LoaderResource2.prototype._loadXhr = function() {
      if (typeof this.xhrType !== "string") {
        this.xhrType = this._determineXhrType();
      }
      var xhr2 = this.xhr = new XMLHttpRequest();
      if (this.crossOrigin === "use-credentials") {
        xhr2.withCredentials = true;
      }
      xhr2.open("GET", this.url, true);
      xhr2.timeout = this.timeout;
      if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.JSON || this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT) {
        xhr2.responseType = LoaderResource2.XHR_RESPONSE_TYPE.TEXT;
      } else {
        xhr2.responseType = this.xhrType;
      }
      xhr2.addEventListener("error", this._boundXhrOnError, false);
      xhr2.addEventListener("timeout", this._boundXhrOnTimeout, false);
      xhr2.addEventListener("abort", this._boundXhrOnAbort, false);
      xhr2.addEventListener("progress", this._boundOnProgress, false);
      xhr2.addEventListener("load", this._boundXhrOnLoad, false);
      xhr2.send();
    };
    LoaderResource2.prototype._loadXdr = function() {
      if (typeof this.xhrType !== "string") {
        this.xhrType = this._determineXhrType();
      }
      var xdr = this.xhr = new globalThis.XDomainRequest();
      xdr.timeout = this.timeout || 5e3;
      xdr.onerror = this._boundXhrOnError;
      xdr.ontimeout = this._boundXhrOnTimeout;
      xdr.onprogress = this._boundOnProgress;
      xdr.onload = this._boundXhrOnLoad;
      xdr.open("GET", this.url, true);
      setTimeout(function() {
        return xdr.send();
      }, 1);
    };
    LoaderResource2.prototype._createSource = function(type2, url2, mime) {
      if (!mime) {
        mime = type2 + "/" + this._getExtension(url2);
      }
      var source = document.createElement("source");
      source.src = url2;
      source.type = mime;
      return source;
    };
    LoaderResource2.prototype._onError = function(event) {
      this.abort("Failed to load element using: " + event.target.nodeName);
    };
    LoaderResource2.prototype._onProgress = function(event) {
      if (event && event.lengthComputable) {
        this.onProgress.dispatch(this, event.loaded / event.total);
      }
    };
    LoaderResource2.prototype._onTimeout = function() {
      this.abort("Load timed out.");
    };
    LoaderResource2.prototype._xhrOnError = function() {
      var xhr2 = this.xhr;
      this.abort(reqType(xhr2) + " Request failed. Status: " + xhr2.status + ', text: "' + xhr2.statusText + '"');
    };
    LoaderResource2.prototype._xhrOnTimeout = function() {
      var xhr2 = this.xhr;
      this.abort(reqType(xhr2) + " Request timed out.");
    };
    LoaderResource2.prototype._xhrOnAbort = function() {
      var xhr2 = this.xhr;
      this.abort(reqType(xhr2) + " Request was aborted by the user.");
    };
    LoaderResource2.prototype._xhrOnLoad = function() {
      var xhr2 = this.xhr;
      var text2 = "";
      var status = typeof xhr2.status === "undefined" ? STATUS_OK : xhr2.status;
      if (xhr2.responseType === "" || xhr2.responseType === "text" || typeof xhr2.responseType === "undefined") {
        text2 = xhr2.responseText;
      }
      if (status === STATUS_NONE && (text2.length > 0 || xhr2.responseType === LoaderResource2.XHR_RESPONSE_TYPE.BUFFER)) {
        status = STATUS_OK;
      } else if (status === STATUS_IE_BUG_EMPTY) {
        status = STATUS_EMPTY;
      }
      var statusType = status / 100 | 0;
      if (statusType === STATUS_TYPE_OK) {
        if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.TEXT) {
          this.data = text2;
          this.type = LoaderResource2.TYPE.TEXT;
        } else if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.JSON) {
          try {
            this.data = JSON.parse(text2);
            this.type = LoaderResource2.TYPE.JSON;
          } catch (e2) {
            this.abort("Error trying to parse loaded json: " + e2);
            return;
          }
        } else if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT) {
          try {
            if (globalThis.DOMParser) {
              var domparser = new DOMParser();
              this.data = domparser.parseFromString(text2, "text/xml");
            } else {
              var div = document.createElement("div");
              div.innerHTML = text2;
              this.data = div;
            }
            this.type = LoaderResource2.TYPE.XML;
          } catch (e$12) {
            this.abort("Error trying to parse loaded xml: " + e$12);
            return;
          }
        } else {
          this.data = xhr2.response || text2;
        }
      } else {
        this.abort("[" + xhr2.status + "] " + xhr2.statusText + ": " + xhr2.responseURL);
        return;
      }
      this.complete();
    };
    LoaderResource2.prototype._determineCrossOrigin = function(url2, loc) {
      if (url2.indexOf("data:") === 0) {
        return "";
      }
      if (globalThis.origin !== globalThis.location.origin) {
        return "anonymous";
      }
      loc = loc || globalThis.location;
      if (!tempAnchor) {
        tempAnchor = document.createElement("a");
      }
      tempAnchor.href = url2;
      var parsedUrl = parseUri(tempAnchor.href, { strictMode: true });
      var samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
      var protocol = parsedUrl.protocol ? parsedUrl.protocol + ":" : "";
      if (parsedUrl.host !== loc.hostname || !samePort || protocol !== loc.protocol) {
        return "anonymous";
      }
      return "";
    };
    LoaderResource2.prototype._determineXhrType = function() {
      return LoaderResource2._xhrTypeMap[this.extension] || LoaderResource2.XHR_RESPONSE_TYPE.TEXT;
    };
    LoaderResource2.prototype._determineLoadType = function() {
      return LoaderResource2._loadTypeMap[this.extension] || LoaderResource2.LOAD_TYPE.XHR;
    };
    LoaderResource2.prototype._getExtension = function(url2) {
      if (url2 === void 0) {
        url2 = this.url;
      }
      var ext = "";
      if (this.isDataUrl) {
        var slashIndex = url2.indexOf("/");
        ext = url2.substring(slashIndex + 1, url2.indexOf(";", slashIndex));
      } else {
        var queryStart = url2.indexOf("?");
        var hashStart = url2.indexOf("#");
        var index2 = Math.min(queryStart > -1 ? queryStart : url2.length, hashStart > -1 ? hashStart : url2.length);
        url2 = url2.substring(0, index2);
        ext = url2.substring(url2.lastIndexOf(".") + 1);
      }
      return ext.toLowerCase();
    };
    LoaderResource2.prototype._getMimeFromXhrType = function(type2) {
      switch (type2) {
        case LoaderResource2.XHR_RESPONSE_TYPE.BUFFER:
          return "application/octet-binary";
        case LoaderResource2.XHR_RESPONSE_TYPE.BLOB:
          return "application/blob";
        case LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT:
          return "application/xml";
        case LoaderResource2.XHR_RESPONSE_TYPE.JSON:
          return "application/json";
        case LoaderResource2.XHR_RESPONSE_TYPE.DEFAULT:
        case LoaderResource2.XHR_RESPONSE_TYPE.TEXT:
        default:
          return "text/plain";
      }
    };
    return LoaderResource2;
  }()
);
(function(LoaderResource2) {
  (function(STATUS_FLAGS) {
    STATUS_FLAGS[STATUS_FLAGS["NONE"] = 0] = "NONE";
    STATUS_FLAGS[STATUS_FLAGS["DATA_URL"] = 1] = "DATA_URL";
    STATUS_FLAGS[STATUS_FLAGS["COMPLETE"] = 2] = "COMPLETE";
    STATUS_FLAGS[STATUS_FLAGS["LOADING"] = 4] = "LOADING";
  })(LoaderResource2.STATUS_FLAGS || (LoaderResource2.STATUS_FLAGS = {}));
  (function(TYPE) {
    TYPE[TYPE["UNKNOWN"] = 0] = "UNKNOWN";
    TYPE[TYPE["JSON"] = 1] = "JSON";
    TYPE[TYPE["XML"] = 2] = "XML";
    TYPE[TYPE["IMAGE"] = 3] = "IMAGE";
    TYPE[TYPE["AUDIO"] = 4] = "AUDIO";
    TYPE[TYPE["VIDEO"] = 5] = "VIDEO";
    TYPE[TYPE["TEXT"] = 6] = "TEXT";
  })(LoaderResource2.TYPE || (LoaderResource2.TYPE = {}));
  (function(LOAD_TYPE) {
    LOAD_TYPE[LOAD_TYPE["XHR"] = 1] = "XHR";
    LOAD_TYPE[LOAD_TYPE["IMAGE"] = 2] = "IMAGE";
    LOAD_TYPE[LOAD_TYPE["AUDIO"] = 3] = "AUDIO";
    LOAD_TYPE[LOAD_TYPE["VIDEO"] = 4] = "VIDEO";
  })(LoaderResource2.LOAD_TYPE || (LoaderResource2.LOAD_TYPE = {}));
  (function(XHR_RESPONSE_TYPE) {
    XHR_RESPONSE_TYPE["DEFAULT"] = "text";
    XHR_RESPONSE_TYPE["BUFFER"] = "arraybuffer";
    XHR_RESPONSE_TYPE["BLOB"] = "blob";
    XHR_RESPONSE_TYPE["DOCUMENT"] = "document";
    XHR_RESPONSE_TYPE["JSON"] = "json";
    XHR_RESPONSE_TYPE["TEXT"] = "text";
  })(LoaderResource2.XHR_RESPONSE_TYPE || (LoaderResource2.XHR_RESPONSE_TYPE = {}));
  LoaderResource2._loadTypeMap = {
    // images
    gif: LoaderResource2.LOAD_TYPE.IMAGE,
    png: LoaderResource2.LOAD_TYPE.IMAGE,
    bmp: LoaderResource2.LOAD_TYPE.IMAGE,
    jpg: LoaderResource2.LOAD_TYPE.IMAGE,
    jpeg: LoaderResource2.LOAD_TYPE.IMAGE,
    tif: LoaderResource2.LOAD_TYPE.IMAGE,
    tiff: LoaderResource2.LOAD_TYPE.IMAGE,
    webp: LoaderResource2.LOAD_TYPE.IMAGE,
    tga: LoaderResource2.LOAD_TYPE.IMAGE,
    svg: LoaderResource2.LOAD_TYPE.IMAGE,
    "svg+xml": LoaderResource2.LOAD_TYPE.IMAGE,
    // audio
    mp3: LoaderResource2.LOAD_TYPE.AUDIO,
    ogg: LoaderResource2.LOAD_TYPE.AUDIO,
    wav: LoaderResource2.LOAD_TYPE.AUDIO,
    // videos
    mp4: LoaderResource2.LOAD_TYPE.VIDEO,
    webm: LoaderResource2.LOAD_TYPE.VIDEO
  };
  LoaderResource2._xhrTypeMap = {
    // xml
    xhtml: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    html: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    htm: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    xml: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    tmx: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    svg: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.
    // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,
    // this should probably be fine.
    tsx: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    // images
    gif: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    png: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    bmp: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    jpg: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    jpeg: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    tif: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    tiff: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    webp: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    tga: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    // json
    json: LoaderResource2.XHR_RESPONSE_TYPE.JSON,
    // text
    text: LoaderResource2.XHR_RESPONSE_TYPE.TEXT,
    txt: LoaderResource2.XHR_RESPONSE_TYPE.TEXT,
    // fonts
    ttf: LoaderResource2.XHR_RESPONSE_TYPE.BUFFER,
    otf: LoaderResource2.XHR_RESPONSE_TYPE.BUFFER
  };
  LoaderResource2.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
})(LoaderResource || (LoaderResource = {}));
function _noop() {
}
function onlyOnce(fn2) {
  return function onceWrapper() {
    var arguments$1 = arguments;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments$1[_i];
    }
    if (fn2 === null) {
      throw new Error("Callback was already called.");
    }
    var callFn = fn2;
    fn2 = null;
    callFn.apply(this, args);
  };
}
var AsyncQueueItem = (
  /** @class */
  function() {
    function AsyncQueueItem2(data2, callback) {
      this.data = data2;
      this.callback = callback;
    }
    return AsyncQueueItem2;
  }()
);
var AsyncQueue = (
  /** @class */
  function() {
    function AsyncQueue2(worker, concurrency) {
      var _this = this;
      if (concurrency === void 0) {
        concurrency = 1;
      }
      this.workers = 0;
      this.saturated = _noop;
      this.unsaturated = _noop;
      this.empty = _noop;
      this.drain = _noop;
      this.error = _noop;
      this.started = false;
      this.paused = false;
      this._tasks = [];
      this._insert = function(data2, insertAtFront, callback) {
        if (callback && typeof callback !== "function") {
          throw new Error("task callback must be a function");
        }
        _this.started = true;
        if (data2 == null && _this.idle()) {
          setTimeout(function() {
            return _this.drain();
          }, 1);
          return;
        }
        var item = new AsyncQueueItem(data2, typeof callback === "function" ? callback : _noop);
        if (insertAtFront) {
          _this._tasks.unshift(item);
        } else {
          _this._tasks.push(item);
        }
        setTimeout(_this.process, 1);
      };
      this.process = function() {
        while (!_this.paused && _this.workers < _this.concurrency && _this._tasks.length) {
          var task = _this._tasks.shift();
          if (_this._tasks.length === 0) {
            _this.empty();
          }
          _this.workers += 1;
          if (_this.workers === _this.concurrency) {
            _this.saturated();
          }
          _this._worker(task.data, onlyOnce(_this._next(task)));
        }
      };
      this._worker = worker;
      if (concurrency === 0) {
        throw new Error("Concurrency must not be zero");
      }
      this.concurrency = concurrency;
      this.buffer = concurrency / 4;
    }
    AsyncQueue2.prototype._next = function(task) {
      var _this = this;
      return function() {
        var arguments$1 = arguments;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments$1[_i];
        }
        _this.workers -= 1;
        task.callback.apply(task, args);
        if (args[0] != null) {
          _this.error(args[0], task.data);
        }
        if (_this.workers <= _this.concurrency - _this.buffer) {
          _this.unsaturated();
        }
        if (_this.idle()) {
          _this.drain();
        }
        _this.process();
      };
    };
    AsyncQueue2.prototype.push = function(data2, callback) {
      this._insert(data2, false, callback);
    };
    AsyncQueue2.prototype.kill = function() {
      this.workers = 0;
      this.drain = _noop;
      this.started = false;
      this._tasks = [];
    };
    AsyncQueue2.prototype.unshift = function(data2, callback) {
      this._insert(data2, true, callback);
    };
    AsyncQueue2.prototype.length = function() {
      return this._tasks.length;
    };
    AsyncQueue2.prototype.running = function() {
      return this.workers;
    };
    AsyncQueue2.prototype.idle = function() {
      return this._tasks.length + this.workers === 0;
    };
    AsyncQueue2.prototype.pause = function() {
      if (this.paused === true) {
        return;
      }
      this.paused = true;
    };
    AsyncQueue2.prototype.resume = function() {
      if (this.paused === false) {
        return;
      }
      this.paused = false;
      for (var w2 = 1; w2 <= this.concurrency; w2++) {
        this.process();
      }
    };
    AsyncQueue2.eachSeries = function(array, iterator, callback, deferNext) {
      var i2 = 0;
      var len = array.length;
      function next2(err) {
        if (err || i2 === len) {
          if (callback) {
            callback(err);
          }
          return;
        }
        if (deferNext) {
          setTimeout(function() {
            iterator(array[i2++], next2);
          }, 1);
        } else {
          iterator(array[i2++], next2);
        }
      }
      next2();
    };
    AsyncQueue2.queue = function(worker, concurrency) {
      return new AsyncQueue2(worker, concurrency);
    };
    return AsyncQueue2;
  }()
);
var MAX_PROGRESS = 100;
var rgxExtractUrlHash = /(#[\w-]+)?$/;
var Loader = (
  /** @class */
  function() {
    function Loader2(baseUrl, concurrency) {
      var _this = this;
      if (baseUrl === void 0) {
        baseUrl = "";
      }
      if (concurrency === void 0) {
        concurrency = 10;
      }
      this.progress = 0;
      this.loading = false;
      this.defaultQueryString = "";
      this._beforeMiddleware = [];
      this._afterMiddleware = [];
      this._resourcesParsing = [];
      this._boundLoadResource = function(r2, d2) {
        return _this._loadResource(r2, d2);
      };
      this.resources = {};
      this.baseUrl = baseUrl;
      this._beforeMiddleware = [];
      this._afterMiddleware = [];
      this._resourcesParsing = [];
      this._boundLoadResource = function(r2, d2) {
        return _this._loadResource(r2, d2);
      };
      this._queue = AsyncQueue.queue(this._boundLoadResource, concurrency);
      this._queue.pause();
      this.resources = {};
      this.onProgress = new Signal();
      this.onError = new Signal();
      this.onLoad = new Signal();
      this.onStart = new Signal();
      this.onComplete = new Signal();
      for (var i2 = 0; i2 < Loader2._plugins.length; ++i2) {
        var plugin = Loader2._plugins[i2];
        var pre = plugin.pre, use3 = plugin.use;
        if (pre) {
          this.pre(pre);
        }
        if (use3) {
          this.use(use3);
        }
      }
      this._protected = false;
    }
    Loader2.prototype._add = function(name, url2, options, callback) {
      if (this.loading && (!options || !options.parentResource)) {
        throw new Error("Cannot add resources while the loader is running.");
      }
      if (this.resources[name]) {
        throw new Error('Resource named "' + name + '" already exists.');
      }
      url2 = this._prepareUrl(url2);
      this.resources[name] = new LoaderResource(name, url2, options);
      if (typeof callback === "function") {
        this.resources[name].onAfterMiddleware.once(callback);
      }
      if (this.loading) {
        var parent = options.parentResource;
        var incompleteChildren = [];
        for (var i2 = 0; i2 < parent.children.length; ++i2) {
          if (!parent.children[i2].isComplete) {
            incompleteChildren.push(parent.children[i2]);
          }
        }
        var fullChunk = parent.progressChunk * (incompleteChildren.length + 1);
        var eachChunk = fullChunk / (incompleteChildren.length + 2);
        parent.children.push(this.resources[name]);
        parent.progressChunk = eachChunk;
        for (var i2 = 0; i2 < incompleteChildren.length; ++i2) {
          incompleteChildren[i2].progressChunk = eachChunk;
        }
        this.resources[name].progressChunk = eachChunk;
      }
      this._queue.push(this.resources[name]);
      return this;
    };
    Loader2.prototype.pre = function(fn2) {
      this._beforeMiddleware.push(fn2);
      return this;
    };
    Loader2.prototype.use = function(fn2) {
      this._afterMiddleware.push(fn2);
      return this;
    };
    Loader2.prototype.reset = function() {
      this.progress = 0;
      this.loading = false;
      this._queue.kill();
      this._queue.pause();
      for (var k2 in this.resources) {
        var res = this.resources[k2];
        if (res._onLoadBinding) {
          res._onLoadBinding.detach();
        }
        if (res.isLoading) {
          res.abort("loader reset");
        }
      }
      this.resources = {};
      return this;
    };
    Loader2.prototype.load = function(cb2) {
      if (typeof cb2 === "function") {
        this.onComplete.once(cb2);
      }
      if (this.loading) {
        return this;
      }
      if (this._queue.idle()) {
        this._onStart();
        this._onComplete();
      } else {
        var numTasks = this._queue._tasks.length;
        var chunk = MAX_PROGRESS / numTasks;
        for (var i2 = 0; i2 < this._queue._tasks.length; ++i2) {
          this._queue._tasks[i2].data.progressChunk = chunk;
        }
        this._onStart();
        this._queue.resume();
      }
      return this;
    };
    Object.defineProperty(Loader2.prototype, "concurrency", {
      /**
       * The number of resources to load concurrently.
       * @default 10
       */
      get: function() {
        return this._queue.concurrency;
      },
      set: function(concurrency) {
        this._queue.concurrency = concurrency;
      },
      enumerable: false,
      configurable: true
    });
    Loader2.prototype._prepareUrl = function(url2) {
      var parsedUrl = parseUri(url2, { strictMode: true });
      var result;
      if (parsedUrl.protocol || !parsedUrl.path || url2.indexOf("//") === 0) {
        result = url2;
      } else if (this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && url2.charAt(0) !== "/") {
        result = this.baseUrl + "/" + url2;
      } else {
        result = this.baseUrl + url2;
      }
      if (this.defaultQueryString) {
        var hash2 = rgxExtractUrlHash.exec(result)[0];
        result = result.slice(0, result.length - hash2.length);
        if (result.indexOf("?") !== -1) {
          result += "&" + this.defaultQueryString;
        } else {
          result += "?" + this.defaultQueryString;
        }
        result += hash2;
      }
      return result;
    };
    Loader2.prototype._loadResource = function(resource, dequeue) {
      var _this = this;
      resource._dequeue = dequeue;
      AsyncQueue.eachSeries(this._beforeMiddleware, function(fn2, next2) {
        fn2.call(_this, resource, function() {
          next2(resource.isComplete ? {} : null);
        });
      }, function() {
        if (resource.isComplete) {
          _this._onLoad(resource);
        } else {
          resource._onLoadBinding = resource.onComplete.once(_this._onLoad, _this);
          resource.load();
        }
      }, true);
    };
    Loader2.prototype._onStart = function() {
      this.progress = 0;
      this.loading = true;
      this.onStart.dispatch(this);
    };
    Loader2.prototype._onComplete = function() {
      this.progress = MAX_PROGRESS;
      this.loading = false;
      this.onComplete.dispatch(this, this.resources);
    };
    Loader2.prototype._onLoad = function(resource) {
      var _this = this;
      resource._onLoadBinding = null;
      this._resourcesParsing.push(resource);
      resource._dequeue();
      AsyncQueue.eachSeries(this._afterMiddleware, function(fn2, next2) {
        fn2.call(_this, resource, next2);
      }, function() {
        resource.onAfterMiddleware.dispatch(resource);
        _this.progress = Math.min(MAX_PROGRESS, _this.progress + resource.progressChunk);
        _this.onProgress.dispatch(_this, resource);
        if (resource.error) {
          _this.onError.dispatch(resource.error, _this, resource);
        } else {
          _this.onLoad.dispatch(_this, resource);
        }
        _this._resourcesParsing.splice(_this._resourcesParsing.indexOf(resource), 1);
        if (_this._queue.idle() && _this._resourcesParsing.length === 0) {
          _this._onComplete();
        }
      }, true);
    };
    Loader2.prototype.destroy = function() {
      if (!this._protected) {
        this.reset();
      }
    };
    Object.defineProperty(Loader2, "shared", {
      /** A premade instance of the loader that can be used to load resources. */
      get: function() {
        var shared = Loader2._shared;
        if (!shared) {
          shared = new Loader2();
          shared._protected = true;
          Loader2._shared = shared;
        }
        return shared;
      },
      enumerable: false,
      configurable: true
    });
    Loader2.registerPlugin = function(plugin) {
      Loader2._plugins.push(plugin);
      if (plugin.add) {
        plugin.add();
      }
      return Loader2;
    };
    Loader2._plugins = [];
    return Loader2;
  }()
);
Loader.prototype.add = function add(name, url2, options, callback) {
  if (Array.isArray(name)) {
    for (var i2 = 0; i2 < name.length; ++i2) {
      this.add(name[i2]);
    }
    return this;
  }
  if (typeof name === "object") {
    options = name;
    callback = url2 || options.callback || options.onComplete;
    url2 = options.url;
    name = options.name || options.key || options.url;
  }
  if (typeof url2 !== "string") {
    callback = options;
    options = url2;
    url2 = name;
  }
  if (typeof url2 !== "string") {
    throw new Error("No url passed to add resource to loader.");
  }
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  return this._add(name, url2, options, callback);
};
var AppLoaderPlugin = (
  /** @class */
  function() {
    function AppLoaderPlugin2() {
    }
    AppLoaderPlugin2.init = function(options) {
      options = Object.assign({
        sharedLoader: false
      }, options);
      this.loader = options.sharedLoader ? Loader.shared : new Loader();
    };
    AppLoaderPlugin2.destroy = function() {
      if (this.loader) {
        this.loader.destroy();
        this.loader = null;
      }
    };
    return AppLoaderPlugin2;
  }()
);
var TextureLoader = (
  /** @class */
  function() {
    function TextureLoader2() {
    }
    TextureLoader2.add = function() {
      LoaderResource.setExtensionLoadType("svg", LoaderResource.LOAD_TYPE.XHR);
      LoaderResource.setExtensionXhrType("svg", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
    };
    TextureLoader2.use = function(resource, next2) {
      if (resource.data && (resource.type === LoaderResource.TYPE.IMAGE || resource.extension === "svg")) {
        var data2 = resource.data, url2 = resource.url, name = resource.name, metadata = resource.metadata;
        Texture.fromLoader(data2, url2, name, metadata).then(function(texture) {
          resource.texture = texture;
          next2();
        }).catch(next2);
      } else {
        next2();
      }
    };
    return TextureLoader2;
  }()
);
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function encodeBinary(input) {
  var output2 = "";
  var inx = 0;
  while (inx < input.length) {
    var bytebuffer = [0, 0, 0];
    var encodedCharIndexes = [0, 0, 0, 0];
    for (var jnx = 0; jnx < bytebuffer.length; ++jnx) {
      if (inx < input.length) {
        bytebuffer[jnx] = input.charCodeAt(inx++) & 255;
      } else {
        bytebuffer[jnx] = 0;
      }
    }
    encodedCharIndexes[0] = bytebuffer[0] >> 2;
    encodedCharIndexes[1] = (bytebuffer[0] & 3) << 4 | bytebuffer[1] >> 4;
    encodedCharIndexes[2] = (bytebuffer[1] & 15) << 2 | bytebuffer[2] >> 6;
    encodedCharIndexes[3] = bytebuffer[2] & 63;
    var paddingBytes = inx - (input.length - 1);
    switch (paddingBytes) {
      case 2:
        encodedCharIndexes[3] = 64;
        encodedCharIndexes[2] = 64;
        break;
      case 1:
        encodedCharIndexes[3] = 64;
        break;
    }
    for (var jnx = 0; jnx < encodedCharIndexes.length; ++jnx) {
      output2 += _keyStr.charAt(encodedCharIndexes[jnx]);
    }
  }
  return output2;
}
function parsing(resource, next2) {
  if (!resource.data) {
    next2();
    return;
  }
  if (resource.xhr && resource.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BLOB) {
    if (!self.Blob || typeof resource.data === "string") {
      var type2 = resource.xhr.getResponseHeader("content-type");
      if (type2 && type2.indexOf("image") === 0) {
        resource.data = new Image();
        resource.data.src = "data:" + type2 + ";base64," + encodeBinary(resource.xhr.responseText);
        resource.type = LoaderResource.TYPE.IMAGE;
        resource.data.onload = function() {
          resource.data.onload = null;
          next2();
        };
        return;
      }
    } else if (resource.data.type.indexOf("image") === 0) {
      var Url_1 = globalThis.URL || globalThis.webkitURL;
      var src_1 = Url_1.createObjectURL(resource.data);
      resource.blob = resource.data;
      resource.data = new Image();
      resource.data.src = src_1;
      resource.type = LoaderResource.TYPE.IMAGE;
      resource.data.onload = function() {
        Url_1.revokeObjectURL(src_1);
        resource.data.onload = null;
        next2();
      };
      return;
    }
  }
  next2();
}
Loader.registerPlugin({ use: parsing });
Loader.registerPlugin(TextureLoader);
/*!
 * @pixi/compressed-textures - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/compressed-textures is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var _a$2;
var INTERNAL_FORMATS;
(function(INTERNAL_FORMATS2) {
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
})(INTERNAL_FORMATS || (INTERNAL_FORMATS = {}));
var INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = (_a$2 = {}, // WEBGL_compressed_texture_s3tc
_a$2[INTERNAL_FORMATS.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, // WEBGL_compressed_texture_s3tc
_a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, // WEBGL_compressed_texture_etc
_a$2[INTERNAL_FORMATS.COMPRESSED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, // WEBGL_compressed_texture_pvrtc
_a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, // WEBGL_compressed_texture_etc1
_a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, // @see https://www.khronos.org/registry/OpenGL/extensions/AMD/AMD_compressed_ATC_texture.txt
// WEBGL_compressed_texture_atc
_a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ATC_WEBGL] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, _a$2);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$S = function(d2, b2) {
  extendStatics$S = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (b3.hasOwnProperty(p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$S(d2, b2);
};
function __extends$S(d2, b2) {
  extendStatics$S(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __awaiter(thisArg, _arguments, P2, generator) {
  return new (P2 || (P2 = Promise))(function(resolve2, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject2(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject2(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : new P2(function(resolve3) {
        resolve3(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _24 = { label: 0, sent: function() {
    if (t2[0] & 1) {
      throw t2[1];
    }
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) {
      throw new TypeError("Generator is already executing.");
    }
    while (_24) {
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) {
          return t2;
        }
        if (y2 = 0, t2) {
          op = [op[0] & 2, t2.value];
        }
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _24.label++;
            return { value: op[1], done: false };
          case 5:
            _24.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _24.ops.pop();
            _24.trys.pop();
            continue;
          default:
            if (!(t2 = _24.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _24 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _24.label = op[1];
              break;
            }
            if (op[0] === 6 && _24.label < t2[1]) {
              _24.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _24.label < t2[2]) {
              _24.label = t2[2];
              _24.ops.push(op);
              break;
            }
            if (t2[2]) {
              _24.ops.pop();
            }
            _24.trys.pop();
            continue;
        }
        op = body.call(thisArg, _24);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    }
    if (op[0] & 5) {
      throw op[1];
    }
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var BlobResource = (
  /** @class */
  function(_super) {
    __extends$S(BlobResource2, _super);
    function BlobResource2(source, options) {
      if (options === void 0) {
        options = { width: 1, height: 1, autoLoad: true };
      }
      var _this = this;
      var origin;
      var data2;
      if (typeof source === "string") {
        origin = source;
        data2 = new Uint8Array();
      } else {
        origin = null;
        data2 = source;
      }
      _this = _super.call(this, data2, options) || this;
      _this.origin = origin;
      _this.buffer = data2 ? new ViewableBuffer(data2) : null;
      if (_this.origin && options.autoLoad !== false) {
        _this.load();
      }
      if (data2 && data2.length) {
        _this.loaded = true;
        _this.onBlobLoaded(_this.buffer.rawBinaryData);
      }
      return _this;
    }
    BlobResource2.prototype.onBlobLoaded = function(_data) {
    };
    BlobResource2.prototype.load = function() {
      return __awaiter(this, void 0, Promise, function() {
        var response, blob, arrayBuffer;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, fetch(this.origin)];
            case 1:
              response = _a2.sent();
              return [4, response.blob()];
            case 2:
              blob = _a2.sent();
              return [4, blob.arrayBuffer()];
            case 3:
              arrayBuffer = _a2.sent();
              this.data = new Uint32Array(arrayBuffer);
              this.buffer = new ViewableBuffer(arrayBuffer);
              this.loaded = true;
              this.onBlobLoaded(arrayBuffer);
              this.update();
              return [2, this];
          }
        });
      });
    };
    return BlobResource2;
  }(BufferResource)
);
var CompressedTextureResource = (
  /** @class */
  function(_super) {
    __extends$S(CompressedTextureResource2, _super);
    function CompressedTextureResource2(source, options) {
      var _this = _super.call(this, source, options) || this;
      _this.format = options.format;
      _this.levels = options.levels || 1;
      _this._width = options.width;
      _this._height = options.height;
      _this._extension = CompressedTextureResource2._formatToExtension(_this.format);
      if (options.levelBuffers || _this.buffer) {
        _this._levelBuffers = options.levelBuffers || CompressedTextureResource2._createLevelBuffers(
          source instanceof Uint8Array ? source : _this.buffer.uint8View,
          _this.format,
          _this.levels,
          4,
          4,
          // PVRTC has 8x4 blocks in 2bpp mode
          _this.width,
          _this.height
        );
      }
      return _this;
    }
    CompressedTextureResource2.prototype.upload = function(renderer, _texture, _glTexture) {
      var gl = renderer.gl;
      var extension = renderer.context.extensions[this._extension];
      if (!extension) {
        throw new Error(this._extension + " textures are not supported on the current machine");
      }
      if (!this._levelBuffers) {
        return false;
      }
      for (var i2 = 0, j2 = this.levels; i2 < j2; i2++) {
        var _a2 = this._levelBuffers[i2], levelID = _a2.levelID, levelWidth = _a2.levelWidth, levelHeight = _a2.levelHeight, levelBuffer = _a2.levelBuffer;
        gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);
      }
      return true;
    };
    CompressedTextureResource2.prototype.onBlobLoaded = function() {
      this._levelBuffers = CompressedTextureResource2._createLevelBuffers(
        this.buffer.uint8View,
        this.format,
        this.levels,
        4,
        4,
        // PVRTC has 8x4 blocks in 2bpp mode
        this.width,
        this.height
      );
    };
    CompressedTextureResource2._formatToExtension = function(format2) {
      if (format2 >= 33776 && format2 <= 33779) {
        return "s3tc";
      } else if (format2 >= 37488 && format2 <= 37497) {
        return "etc";
      } else if (format2 >= 35840 && format2 <= 35843) {
        return "pvrtc";
      } else if (format2 >= 36196) {
        return "etc1";
      } else if (format2 >= 35986 && format2 <= 34798) {
        return "atc";
      }
      throw new Error("Invalid (compressed) texture format given!");
    };
    CompressedTextureResource2._createLevelBuffers = function(buffer, format2, levels, blockWidth, blockHeight, imageWidth, imageHeight) {
      var buffers = new Array(levels);
      var offset = buffer.byteOffset;
      var levelWidth = imageWidth;
      var levelHeight = imageHeight;
      var alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
      var alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
      var levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
      for (var i2 = 0; i2 < levels; i2++) {
        buffers[i2] = {
          levelID: i2,
          levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,
          levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,
          levelBuffer: new Uint8Array(buffer.buffer, offset, levelSize)
        };
        offset += levelSize;
        levelWidth = levelWidth >> 1 || 1;
        levelHeight = levelHeight >> 1 || 1;
        alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
        alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
        levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
      }
      return buffers;
    };
    return CompressedTextureResource2;
  }(BlobResource)
);
var CompressedTextureLoader = (
  /** @class */
  function() {
    function CompressedTextureLoader2() {
    }
    CompressedTextureLoader2.use = function(resource, next2) {
      var data2 = resource.data;
      var loader = this;
      if (resource.type === LoaderResource.TYPE.JSON && data2 && data2.cacheID && data2.textures) {
        var textures = data2.textures;
        var textureURL = void 0;
        var fallbackURL = void 0;
        for (var i2 = 0, j2 = textures.length; i2 < j2; i2++) {
          var texture = textures[i2];
          var url_1 = texture.src;
          var format2 = texture.format;
          if (!format2) {
            fallbackURL = url_1;
          }
          if (CompressedTextureLoader2.textureFormats[format2]) {
            textureURL = url_1;
            break;
          }
        }
        textureURL = textureURL || fallbackURL;
        if (!textureURL) {
          next2(new Error("Cannot load compressed-textures in " + resource.url + ", make sure you provide a fallback"));
          return;
        }
        if (textureURL === resource.url) {
          next2(new Error("URL of compressed texture cannot be the same as the manifest's URL"));
          return;
        }
        var loadOptions = {
          crossOrigin: resource.crossOrigin,
          metadata: resource.metadata.imageMetadata,
          parentResource: resource
        };
        var resourcePath = url.resolve(resource.url.replace(loader.baseUrl, ""), textureURL);
        var resourceName = data2.cacheID;
        loader.add(resourceName, resourcePath, loadOptions, function(res) {
          if (res.error) {
            next2(res.error);
            return;
          }
          var _a2 = res.texture, texture2 = _a2 === void 0 ? null : _a2, _b2 = res.textures, textures2 = _b2 === void 0 ? {} : _b2;
          Object.assign(resource, { texture: texture2, textures: textures2 });
          next2();
        });
      } else {
        next2();
      }
    };
    Object.defineProperty(CompressedTextureLoader2, "textureExtensions", {
      /**  Map of available texture extensions. */
      get: function() {
        if (!CompressedTextureLoader2._textureExtensions) {
          var canvas = document.createElement("canvas");
          var gl = canvas.getContext("webgl");
          if (!gl) {
            console.warn("WebGL not available for compressed textures. Silently failing.");
            return {};
          }
          var extensions = {
            s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            etc: gl.getExtension("WEBGL_compressed_texture_etc"),
            etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: gl.getExtension("WEBGL_compressed_texture_atc"),
            astc: gl.getExtension("WEBGL_compressed_texture_astc")
          };
          CompressedTextureLoader2._textureExtensions = extensions;
        }
        return CompressedTextureLoader2._textureExtensions;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CompressedTextureLoader2, "textureFormats", {
      /** Map of available texture formats. */
      get: function() {
        if (!CompressedTextureLoader2._textureFormats) {
          var extensions = CompressedTextureLoader2.textureExtensions;
          CompressedTextureLoader2._textureFormats = {};
          for (var extensionName in extensions) {
            var extension = extensions[extensionName];
            if (!extension) {
              continue;
            }
            Object.assign(CompressedTextureLoader2._textureFormats, Object.getPrototypeOf(extension));
          }
        }
        return CompressedTextureLoader2._textureFormats;
      },
      enumerable: false,
      configurable: true
    });
    return CompressedTextureLoader2;
  }()
);
function registerCompressedTextures(url2, resources2, metadata) {
  var result = {
    textures: {},
    texture: null
  };
  if (!resources2) {
    return result;
  }
  var textures = resources2.map(function(resource) {
    return new Texture(new BaseTexture(resource, Object.assign({
      mipmap: MIPMAP_MODES$4.OFF,
      alphaMode: ALPHA_MODES$4.NO_PREMULTIPLIED_ALPHA
    }, metadata)));
  });
  textures.forEach(function(texture, i2) {
    var baseTexture = texture.baseTexture;
    var cacheID = url2 + "-" + (i2 + 1);
    BaseTexture.addToCache(baseTexture, cacheID);
    Texture.addToCache(texture, cacheID);
    if (i2 === 0) {
      BaseTexture.addToCache(baseTexture, url2);
      Texture.addToCache(texture, url2);
      result.texture = texture;
    }
    result.textures[cacheID] = texture;
  });
  return result;
}
var _a$1, _b$1;
LoaderResource.setExtensionXhrType("dds", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
var DDS_MAGIC_SIZE = 4;
var DDS_HEADER_SIZE = 124;
var DDS_HEADER_PF_SIZE = 32;
var DDS_HEADER_DX10_SIZE = 20;
var DDS_MAGIC = 542327876;
var DDS_FIELDS = {
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
};
var DDS_PF_FIELDS = {
  SIZE: 0,
  FLAGS: 1,
  FOURCC: 2,
  RGB_BITCOUNT: 3,
  R_BIT_MASK: 4,
  G_BIT_MASK: 5,
  B_BIT_MASK: 6,
  A_BIT_MASK: 7
};
var DDS_DX10_FIELDS = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
};
var DXGI_FORMAT;
(function(DXGI_FORMAT2) {
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_UNKNOWN"] = 0] = "DXGI_FORMAT_UNKNOWN";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_TYPELESS"] = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_FLOAT"] = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_UINT"] = 3] = "DXGI_FORMAT_R32G32B32A32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_SINT"] = 4] = "DXGI_FORMAT_R32G32B32A32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_TYPELESS"] = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_FLOAT"] = 6] = "DXGI_FORMAT_R32G32B32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_UINT"] = 7] = "DXGI_FORMAT_R32G32B32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_SINT"] = 8] = "DXGI_FORMAT_R32G32B32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_TYPELESS"] = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_FLOAT"] = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UNORM"] = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UINT"] = 12] = "DXGI_FORMAT_R16G16B16A16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SNORM"] = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SINT"] = 14] = "DXGI_FORMAT_R16G16B16A16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_TYPELESS"] = 15] = "DXGI_FORMAT_R32G32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_FLOAT"] = 16] = "DXGI_FORMAT_R32G32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_UINT"] = 17] = "DXGI_FORMAT_R32G32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_SINT"] = 18] = "DXGI_FORMAT_R32G32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G8X24_TYPELESS"] = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT_S8X24_UINT"] = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS"] = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X32_TYPELESS_G8X24_UINT"] = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_TYPELESS"] = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UNORM"] = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UINT"] = 25] = "DXGI_FORMAT_R10G10B10A2_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R11G11B10_FLOAT"] = 26] = "DXGI_FORMAT_R11G11B10_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_TYPELESS"] = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM"] = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM_SRGB"] = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UINT"] = 30] = "DXGI_FORMAT_R8G8B8A8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SNORM"] = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SINT"] = 32] = "DXGI_FORMAT_R8G8B8A8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_TYPELESS"] = 33] = "DXGI_FORMAT_R16G16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_FLOAT"] = 34] = "DXGI_FORMAT_R16G16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UNORM"] = 35] = "DXGI_FORMAT_R16G16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UINT"] = 36] = "DXGI_FORMAT_R16G16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SNORM"] = 37] = "DXGI_FORMAT_R16G16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SINT"] = 38] = "DXGI_FORMAT_R16G16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_TYPELESS"] = 39] = "DXGI_FORMAT_R32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT"] = 40] = "DXGI_FORMAT_D32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT"] = 41] = "DXGI_FORMAT_R32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_UINT"] = 42] = "DXGI_FORMAT_R32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_SINT"] = 43] = "DXGI_FORMAT_R32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24G8_TYPELESS"] = 44] = "DXGI_FORMAT_R24G8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D24_UNORM_S8_UINT"] = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24_UNORM_X8_TYPELESS"] = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X24_TYPELESS_G8_UINT"] = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_TYPELESS"] = 48] = "DXGI_FORMAT_R8G8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UNORM"] = 49] = "DXGI_FORMAT_R8G8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UINT"] = 50] = "DXGI_FORMAT_R8G8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SNORM"] = 51] = "DXGI_FORMAT_R8G8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SINT"] = 52] = "DXGI_FORMAT_R8G8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_TYPELESS"] = 53] = "DXGI_FORMAT_R16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_FLOAT"] = 54] = "DXGI_FORMAT_R16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D16_UNORM"] = 55] = "DXGI_FORMAT_D16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UNORM"] = 56] = "DXGI_FORMAT_R16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UINT"] = 57] = "DXGI_FORMAT_R16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SNORM"] = 58] = "DXGI_FORMAT_R16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SINT"] = 59] = "DXGI_FORMAT_R16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_TYPELESS"] = 60] = "DXGI_FORMAT_R8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UNORM"] = 61] = "DXGI_FORMAT_R8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UINT"] = 62] = "DXGI_FORMAT_R8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SNORM"] = 63] = "DXGI_FORMAT_R8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SINT"] = 64] = "DXGI_FORMAT_R8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8_UNORM"] = 65] = "DXGI_FORMAT_A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R1_UNORM"] = 66] = "DXGI_FORMAT_R1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R9G9B9E5_SHAREDEXP"] = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_B8G8_UNORM"] = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_G8R8_G8B8_UNORM"] = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_TYPELESS"] = 70] = "DXGI_FORMAT_BC1_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM"] = 71] = "DXGI_FORMAT_BC1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM_SRGB"] = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_TYPELESS"] = 73] = "DXGI_FORMAT_BC2_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM"] = 74] = "DXGI_FORMAT_BC2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM_SRGB"] = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_TYPELESS"] = 76] = "DXGI_FORMAT_BC3_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM"] = 77] = "DXGI_FORMAT_BC3_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM_SRGB"] = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_TYPELESS"] = 79] = "DXGI_FORMAT_BC4_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_UNORM"] = 80] = "DXGI_FORMAT_BC4_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_SNORM"] = 81] = "DXGI_FORMAT_BC4_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_TYPELESS"] = 82] = "DXGI_FORMAT_BC5_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_UNORM"] = 83] = "DXGI_FORMAT_BC5_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_SNORM"] = 84] = "DXGI_FORMAT_BC5_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G6R5_UNORM"] = 85] = "DXGI_FORMAT_B5G6R5_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G5R5A1_UNORM"] = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM"] = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM"] = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM"] = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_TYPELESS"] = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM_SRGB"] = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_TYPELESS"] = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM_SRGB"] = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_TYPELESS"] = 94] = "DXGI_FORMAT_BC6H_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_UF16"] = 95] = "DXGI_FORMAT_BC6H_UF16";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_SF16"] = 96] = "DXGI_FORMAT_BC6H_SF16";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_TYPELESS"] = 97] = "DXGI_FORMAT_BC7_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM"] = 98] = "DXGI_FORMAT_BC7_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM_SRGB"] = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AYUV"] = 100] = "DXGI_FORMAT_AYUV";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y410"] = 101] = "DXGI_FORMAT_Y410";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y416"] = 102] = "DXGI_FORMAT_Y416";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV12"] = 103] = "DXGI_FORMAT_NV12";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P010"] = 104] = "DXGI_FORMAT_P010";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P016"] = 105] = "DXGI_FORMAT_P016";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_420_OPAQUE"] = 106] = "DXGI_FORMAT_420_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_YUY2"] = 107] = "DXGI_FORMAT_YUY2";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y210"] = 108] = "DXGI_FORMAT_Y210";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y216"] = 109] = "DXGI_FORMAT_Y216";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV11"] = 110] = "DXGI_FORMAT_NV11";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AI44"] = 111] = "DXGI_FORMAT_AI44";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_IA44"] = 112] = "DXGI_FORMAT_IA44";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P8"] = 113] = "DXGI_FORMAT_P8";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8P8"] = 114] = "DXGI_FORMAT_A8P8";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B4G4R4A4_UNORM"] = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P208"] = 116] = "DXGI_FORMAT_P208";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V208"] = 117] = "DXGI_FORMAT_V208";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V408"] = 118] = "DXGI_FORMAT_V408";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE"] = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE"] = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_FORCE_UINT"] = 121] = "DXGI_FORMAT_FORCE_UINT";
})(DXGI_FORMAT || (DXGI_FORMAT = {}));
var D3D10_RESOURCE_DIMENSION;
(function(D3D10_RESOURCE_DIMENSION2) {
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE1D"] = 2] = "DDS_DIMENSION_TEXTURE1D";
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE2D"] = 3] = "DDS_DIMENSION_TEXTURE2D";
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE3D"] = 6] = "DDS_DIMENSION_TEXTURE3D";
})(D3D10_RESOURCE_DIMENSION || (D3D10_RESOURCE_DIMENSION = {}));
var PF_FLAGS = 1;
var DDPF_ALPHA = 2;
var DDPF_FOURCC = 4;
var DDPF_RGB = 64;
var DDPF_YUV = 512;
var DDPF_LUMINANCE = 131072;
var FOURCC_DXT1 = 827611204;
var FOURCC_DXT3 = 861165636;
var FOURCC_DXT5 = 894720068;
var FOURCC_DX10 = 808540228;
var DDS_RESOURCE_MISC_TEXTURECUBE = 4;
var FOURCC_TO_FORMAT = (_a$1 = {}, _a$1[FOURCC_DXT1] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _a$1[FOURCC_DXT3] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _a$1[FOURCC_DXT5] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _a$1);
var DXGI_TO_FORMAT = (_b$1 = {}, // WEBGL_compressed_texture_s3tc
_b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, // WEBGL_compressed_texture_s3tc_srgb
_b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, _b$1);
var DDSLoader = (
  /** @class */
  function() {
    function DDSLoader2() {
    }
    DDSLoader2.use = function(resource, next2) {
      if (resource.extension === "dds" && resource.data) {
        try {
          Object.assign(resource, registerCompressedTextures(resource.name || resource.url, DDSLoader2.parse(resource.data), resource.metadata));
        } catch (err) {
          next2(err);
          return;
        }
      }
      next2();
    };
    DDSLoader2.parse = function(arrayBuffer) {
      var data2 = new Uint32Array(arrayBuffer);
      var magicWord = data2[0];
      if (magicWord !== DDS_MAGIC) {
        throw new Error("Invalid DDS file magic word");
      }
      var header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
      var height = header[DDS_FIELDS.HEIGHT];
      var width = header[DDS_FIELDS.WIDTH];
      var mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT];
      var pixelFormat = new Uint32Array(arrayBuffer, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT);
      var formatFlags = pixelFormat[PF_FLAGS];
      if (formatFlags & DDPF_FOURCC) {
        var fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];
        if (fourCC !== FOURCC_DX10) {
          var internalFormat_1 = FOURCC_TO_FORMAT[fourCC];
          var dataOffset_1 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
          var texData = new Uint8Array(arrayBuffer, dataOffset_1);
          var resource = new CompressedTextureResource(texData, {
            format: internalFormat_1,
            width,
            height,
            levels: mipmapCount
            // CompressedTextureResource will separate the levelBuffers for us!
          });
          return [resource];
        }
        var dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
        var dx10Header = new Uint32Array(data2.buffer, dx10Offset, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);
        var dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT];
        var resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION];
        var miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG];
        var arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE];
        var internalFormat_2 = DXGI_TO_FORMAT[dxgiFormat];
        if (internalFormat_2 === void 0) {
          throw new Error("DDSLoader cannot parse texture data with DXGI format " + dxgiFormat);
        }
        if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE) {
          throw new Error("DDSLoader does not support cubemap textures");
        }
        if (resourceDimension === D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D) {
          throw new Error("DDSLoader does not supported 3D texture data");
        }
        var imageBuffers = new Array();
        var dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
        if (arraySize === 1) {
          imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));
        } else {
          var pixelSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat_2];
          var imageSize = 0;
          var levelWidth = width;
          var levelHeight = height;
          for (var i2 = 0; i2 < mipmapCount; i2++) {
            var alignedLevelWidth = Math.max(1, levelWidth + 3 & ~3);
            var alignedLevelHeight = Math.max(1, levelHeight + 3 & ~3);
            var levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;
            imageSize += levelSize;
            levelWidth = levelWidth >>> 1;
            levelHeight = levelHeight >>> 1;
          }
          var imageOffset = dataOffset;
          for (var i2 = 0; i2 < arraySize; i2++) {
            imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize));
            imageOffset += imageSize;
          }
        }
        return imageBuffers.map(function(buffer) {
          return new CompressedTextureResource(buffer, {
            format: internalFormat_2,
            width,
            height,
            levels: mipmapCount
          });
        });
      }
      if (formatFlags & DDPF_RGB) {
        throw new Error("DDSLoader does not support uncompressed texture data.");
      }
      if (formatFlags & DDPF_YUV) {
        throw new Error("DDSLoader does not supported YUV uncompressed texture data.");
      }
      if (formatFlags & DDPF_LUMINANCE) {
        throw new Error("DDSLoader does not support single-channel (lumninance) texture data!");
      }
      if (formatFlags & DDPF_ALPHA) {
        throw new Error("DDSLoader does not support single-channel (alpha) texture data!");
      }
      throw new Error("DDSLoader failed to load a texture file due to an unknown reason!");
    };
    return DDSLoader2;
  }()
);
var _a$3, _b, _c;
LoaderResource.setExtensionXhrType("ktx", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
var FILE_IDENTIFIER$1 = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
var ENDIANNESS = 67305985;
var KTX_FIELDS = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
};
var FILE_HEADER_SIZE = 64;
var TYPES_TO_BYTES_PER_COMPONENT = (_a$3 = {}, _a$3[TYPES$4.UNSIGNED_BYTE] = 1, _a$3[TYPES$4.UNSIGNED_SHORT] = 2, _a$3[TYPES$4.INT] = 4, _a$3[TYPES$4.UNSIGNED_INT] = 4, _a$3[TYPES$4.FLOAT] = 4, _a$3[TYPES$4.HALF_FLOAT] = 8, _a$3);
var FORMATS_TO_COMPONENTS = (_b = {}, _b[FORMATS$4.RGBA] = 4, _b[FORMATS$4.RGB] = 3, _b[FORMATS$4.RG] = 2, _b[FORMATS$4.RED] = 1, _b[FORMATS$4.LUMINANCE] = 1, _b[FORMATS$4.LUMINANCE_ALPHA] = 2, _b[FORMATS$4.ALPHA] = 1, _b);
var TYPES_TO_BYTES_PER_PIXEL = (_c = {}, _c[TYPES$4.UNSIGNED_SHORT_4_4_4_4] = 2, _c[TYPES$4.UNSIGNED_SHORT_5_5_5_1] = 2, _c[TYPES$4.UNSIGNED_SHORT_5_6_5] = 2, _c);
var KTXLoader = (
  /** @class */
  function() {
    function KTXLoader2() {
    }
    KTXLoader2.use = function(resource, next2) {
      if (resource.extension === "ktx" && resource.data) {
        try {
          var url_1 = resource.name || resource.url;
          var _a2 = KTXLoader2.parse(url_1, resource.data), compressed = _a2.compressed, uncompressed = _a2.uncompressed, kvData_1 = _a2.kvData;
          if (compressed) {
            var result = registerCompressedTextures(url_1, compressed, resource.metadata);
            if (kvData_1 && result.textures) {
              for (var textureId in result.textures) {
                result.textures[textureId].baseTexture.ktxKeyValueData = kvData_1;
              }
            }
            Object.assign(resource, result);
          } else if (uncompressed) {
            var textures_1 = {};
            uncompressed.forEach(function(image, i2) {
              var texture = new Texture(new BaseTexture(image.resource, {
                mipmap: MIPMAP_MODES$4.OFF,
                alphaMode: ALPHA_MODES$4.NO_PREMULTIPLIED_ALPHA,
                type: image.type,
                format: image.format
              }));
              var cacheID = url_1 + "-" + (i2 + 1);
              if (kvData_1) {
                texture.baseTexture.ktxKeyValueData = kvData_1;
              }
              BaseTexture.addToCache(texture.baseTexture, cacheID);
              Texture.addToCache(texture, cacheID);
              if (i2 === 0) {
                textures_1[url_1] = texture;
                BaseTexture.addToCache(texture.baseTexture, url_1);
                Texture.addToCache(texture, url_1);
              }
              textures_1[cacheID] = texture;
            });
            Object.assign(resource, { textures: textures_1 });
          }
        } catch (err) {
          next2(err);
          return;
        }
      }
      next2();
    };
    KTXLoader2.parse = function(url2, arrayBuffer) {
      var dataView = new DataView(arrayBuffer);
      if (!KTXLoader2.validate(url2, dataView)) {
        return null;
      }
      var littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, true) === ENDIANNESS;
      var glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian);
      var glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian);
      var glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian);
      var pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian);
      var pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1;
      var pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1;
      var numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;
      var numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian);
      var numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);
      var bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
      if (pixelHeight === 0 || pixelDepth !== 1) {
        throw new Error("Only 2D textures are supported");
      }
      if (numberOfFaces !== 1) {
        throw new Error("CubeTextures are not supported by KTXLoader yet!");
      }
      if (numberOfArrayElements !== 1) {
        throw new Error("WebGL does not support array textures");
      }
      var blockWidth = 4;
      var blockHeight = 4;
      var alignedWidth = pixelWidth + 3 & ~3;
      var alignedHeight = pixelHeight + 3 & ~3;
      var imageBuffers = new Array(numberOfArrayElements);
      var imagePixels = pixelWidth * pixelHeight;
      if (glType === 0) {
        imagePixels = alignedWidth * alignedHeight;
      }
      var imagePixelByteSize;
      if (glType !== 0) {
        if (TYPES_TO_BYTES_PER_COMPONENT[glType]) {
          imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat];
        } else {
          imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType];
        }
      } else {
        imagePixelByteSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];
      }
      if (imagePixelByteSize === void 0) {
        throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
      }
      var kvData = KTXLoader2.loadKeyValueData ? KTXLoader2.parseKvData(dataView, bytesOfKeyValueData, littleEndian) : null;
      var imageByteSize = imagePixels * imagePixelByteSize;
      var mipByteSize = imageByteSize;
      var mipWidth = pixelWidth;
      var mipHeight = pixelHeight;
      var alignedMipWidth = alignedWidth;
      var alignedMipHeight = alignedHeight;
      var imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;
      for (var mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
        var imageSize = dataView.getUint32(imageOffset, littleEndian);
        var elementOffset = imageOffset + 4;
        for (var arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {
          var mips = imageBuffers[arrayElement];
          if (!mips) {
            mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels);
          }
          mips[mipmapLevel] = {
            levelID: mipmapLevel,
            // don't align mipWidth when texture not compressed! (glType not zero)
            levelWidth: numberOfMipmapLevels > 1 || glType !== 0 ? mipWidth : alignedMipWidth,
            levelHeight: numberOfMipmapLevels > 1 || glType !== 0 ? mipHeight : alignedMipHeight,
            levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)
          };
          elementOffset += mipByteSize;
        }
        imageOffset += imageSize + 4;
        imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;
        mipWidth = mipWidth >> 1 || 1;
        mipHeight = mipHeight >> 1 || 1;
        alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1);
        alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1);
        mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
      }
      if (glType !== 0) {
        return {
          uncompressed: imageBuffers.map(function(levelBuffers) {
            var buffer = levelBuffers[0].levelBuffer;
            var convertToInt = false;
            if (glType === TYPES$4.FLOAT) {
              buffer = new Float32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
            } else if (glType === TYPES$4.UNSIGNED_INT) {
              convertToInt = true;
              buffer = new Uint32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
            } else if (glType === TYPES$4.INT) {
              convertToInt = true;
              buffer = new Int32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
            }
            return {
              resource: new BufferResource(buffer, {
                width: levelBuffers[0].levelWidth,
                height: levelBuffers[0].levelHeight
              }),
              type: glType,
              format: convertToInt ? KTXLoader2.convertFormatToInteger(glFormat) : glFormat
            };
          }),
          kvData
        };
      }
      return {
        compressed: imageBuffers.map(function(levelBuffers) {
          return new CompressedTextureResource(null, {
            format: glInternalFormat,
            width: pixelWidth,
            height: pixelHeight,
            levels: numberOfMipmapLevels,
            levelBuffers
          });
        }),
        kvData
      };
    };
    KTXLoader2.validate = function(url2, dataView) {
      for (var i2 = 0; i2 < FILE_IDENTIFIER$1.length; i2++) {
        if (dataView.getUint8(i2) !== FILE_IDENTIFIER$1[i2]) {
          console.error(url2 + " is not a valid *.ktx file!");
          return false;
        }
      }
      return true;
    };
    KTXLoader2.convertFormatToInteger = function(format2) {
      switch (format2) {
        case FORMATS$4.RGBA:
          return FORMATS$4.RGBA_INTEGER;
        case FORMATS$4.RGB:
          return FORMATS$4.RGB_INTEGER;
        case FORMATS$4.RG:
          return FORMATS$4.RG_INTEGER;
        case FORMATS$4.RED:
          return FORMATS$4.RED_INTEGER;
        default:
          return format2;
      }
    };
    KTXLoader2.parseKvData = function(dataView, bytesOfKeyValueData, littleEndian) {
      var kvData = /* @__PURE__ */ new Map();
      var bytesIntoKeyValueData = 0;
      while (bytesIntoKeyValueData < bytesOfKeyValueData) {
        var keyAndValueByteSize = dataView.getUint32(FILE_HEADER_SIZE + bytesIntoKeyValueData, littleEndian);
        var keyAndValueByteOffset = FILE_HEADER_SIZE + bytesIntoKeyValueData + 4;
        var valuePadding = 3 - (keyAndValueByteSize + 3) % 4;
        if (keyAndValueByteSize === 0 || keyAndValueByteSize > bytesOfKeyValueData - bytesIntoKeyValueData) {
          console.error("KTXLoader: keyAndValueByteSize out of bounds");
          break;
        }
        var keyNulByte = 0;
        for (; keyNulByte < keyAndValueByteSize; keyNulByte++) {
          if (dataView.getUint8(keyAndValueByteOffset + keyNulByte) === 0) {
            break;
          }
        }
        if (keyNulByte === -1) {
          console.error("KTXLoader: Failed to find null byte terminating kvData key");
          break;
        }
        var key = new TextDecoder().decode(new Uint8Array(dataView.buffer, keyAndValueByteOffset, keyNulByte));
        var value = new DataView(dataView.buffer, keyAndValueByteOffset + keyNulByte + 1, keyAndValueByteSize - keyNulByte - 1);
        kvData.set(key, value);
        bytesIntoKeyValueData += 4 + keyAndValueByteSize + valuePadding;
      }
      return kvData;
    };
    KTXLoader2.loadKeyValueData = false;
    return KTXLoader2;
  }()
);
/*!
 * @pixi/particle-container - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/particle-container is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$R = function(d2, b2) {
  extendStatics$R = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (b3.hasOwnProperty(p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$R(d2, b2);
};
function __extends$R(d2, b2) {
  extendStatics$R(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var ParticleContainer = (
  /** @class */
  function(_super) {
    __extends$R(ParticleContainer2, _super);
    function ParticleContainer2(maxSize, properties, batchSize, autoResize) {
      if (maxSize === void 0) {
        maxSize = 1500;
      }
      if (batchSize === void 0) {
        batchSize = 16384;
      }
      if (autoResize === void 0) {
        autoResize = false;
      }
      var _this = _super.call(this) || this;
      var maxBatchSize = 16384;
      if (batchSize > maxBatchSize) {
        batchSize = maxBatchSize;
      }
      _this._properties = [false, true, false, false, false];
      _this._maxSize = maxSize;
      _this._batchSize = batchSize;
      _this._buffers = null;
      _this._bufferUpdateIDs = [];
      _this._updateID = 0;
      _this.interactiveChildren = false;
      _this.blendMode = BLEND_MODES$4.NORMAL;
      _this.autoResize = autoResize;
      _this.roundPixels = true;
      _this.baseTexture = null;
      _this.setProperties(properties);
      _this._tint = 0;
      _this.tintRgb = new Float32Array(4);
      _this.tint = 16777215;
      return _this;
    }
    ParticleContainer2.prototype.setProperties = function(properties) {
      if (properties) {
        this._properties[0] = "vertices" in properties || "scale" in properties ? !!properties.vertices || !!properties.scale : this._properties[0];
        this._properties[1] = "position" in properties ? !!properties.position : this._properties[1];
        this._properties[2] = "rotation" in properties ? !!properties.rotation : this._properties[2];
        this._properties[3] = "uvs" in properties ? !!properties.uvs : this._properties[3];
        this._properties[4] = "tint" in properties || "alpha" in properties ? !!properties.tint || !!properties.alpha : this._properties[4];
      }
    };
    ParticleContainer2.prototype.updateTransform = function() {
      this.displayObjectUpdateTransform();
    };
    Object.defineProperty(ParticleContainer2.prototype, "tint", {
      /**
       * The tint applied to the container. This is a hex value.
       * A value of 0xFFFFFF will remove any tint effect.
       * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
       * @default 0xFFFFFF
       */
      get: function() {
        return this._tint;
      },
      set: function(value) {
        this._tint = value;
        hex2rgb(value, this.tintRgb);
      },
      enumerable: false,
      configurable: true
    });
    ParticleContainer2.prototype.render = function(renderer) {
      var _this = this;
      if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
        return;
      }
      if (!this.baseTexture) {
        this.baseTexture = this.children[0]._texture.baseTexture;
        if (!this.baseTexture.valid) {
          this.baseTexture.once("update", function() {
            return _this.onChildrenChange(0);
          });
        }
      }
      renderer.batch.setObjectRenderer(renderer.plugins.particle);
      renderer.plugins.particle.render(this);
    };
    ParticleContainer2.prototype.onChildrenChange = function(smallestChildIndex) {
      var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
      while (this._bufferUpdateIDs.length < bufferIndex) {
        this._bufferUpdateIDs.push(0);
      }
      this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
    };
    ParticleContainer2.prototype.dispose = function() {
      if (this._buffers) {
        for (var i2 = 0; i2 < this._buffers.length; ++i2) {
          this._buffers[i2].destroy();
        }
        this._buffers = null;
      }
    };
    ParticleContainer2.prototype.destroy = function(options) {
      _super.prototype.destroy.call(this, options);
      this.dispose();
      this._properties = null;
      this._buffers = null;
      this._bufferUpdateIDs = null;
    };
    return ParticleContainer2;
  }(Container$1)
);
var ParticleBuffer = (
  /** @class */
  function() {
    function ParticleBuffer2(properties, dynamicPropertyFlags, size) {
      this.geometry = new Geometry();
      this.indexBuffer = null;
      this.size = size;
      this.dynamicProperties = [];
      this.staticProperties = [];
      for (var i2 = 0; i2 < properties.length; ++i2) {
        var property2 = properties[i2];
        property2 = {
          attributeName: property2.attributeName,
          size: property2.size,
          uploadFunction: property2.uploadFunction,
          type: property2.type || TYPES$4.FLOAT,
          offset: property2.offset
        };
        if (dynamicPropertyFlags[i2]) {
          this.dynamicProperties.push(property2);
        } else {
          this.staticProperties.push(property2);
        }
      }
      this.staticStride = 0;
      this.staticBuffer = null;
      this.staticData = null;
      this.staticDataUint32 = null;
      this.dynamicStride = 0;
      this.dynamicBuffer = null;
      this.dynamicData = null;
      this.dynamicDataUint32 = null;
      this._updateID = 0;
      this.initBuffers();
    }
    ParticleBuffer2.prototype.initBuffers = function() {
      var geometry = this.geometry;
      var dynamicOffset = 0;
      this.indexBuffer = new Buffer$1(createIndicesForQuads(this.size), true, true);
      geometry.addIndex(this.indexBuffer);
      this.dynamicStride = 0;
      for (var i2 = 0; i2 < this.dynamicProperties.length; ++i2) {
        var property2 = this.dynamicProperties[i2];
        property2.offset = dynamicOffset;
        dynamicOffset += property2.size;
        this.dynamicStride += property2.size;
      }
      var dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
      this.dynamicData = new Float32Array(dynBuffer);
      this.dynamicDataUint32 = new Uint32Array(dynBuffer);
      this.dynamicBuffer = new Buffer$1(this.dynamicData, false, false);
      var staticOffset = 0;
      this.staticStride = 0;
      for (var i2 = 0; i2 < this.staticProperties.length; ++i2) {
        var property2 = this.staticProperties[i2];
        property2.offset = staticOffset;
        staticOffset += property2.size;
        this.staticStride += property2.size;
      }
      var statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
      this.staticData = new Float32Array(statBuffer);
      this.staticDataUint32 = new Uint32Array(statBuffer);
      this.staticBuffer = new Buffer$1(this.staticData, true, false);
      for (var i2 = 0; i2 < this.dynamicProperties.length; ++i2) {
        var property2 = this.dynamicProperties[i2];
        geometry.addAttribute(property2.attributeName, this.dynamicBuffer, 0, property2.type === TYPES$4.UNSIGNED_BYTE, property2.type, this.dynamicStride * 4, property2.offset * 4);
      }
      for (var i2 = 0; i2 < this.staticProperties.length; ++i2) {
        var property2 = this.staticProperties[i2];
        geometry.addAttribute(property2.attributeName, this.staticBuffer, 0, property2.type === TYPES$4.UNSIGNED_BYTE, property2.type, this.staticStride * 4, property2.offset * 4);
      }
    };
    ParticleBuffer2.prototype.uploadDynamic = function(children, startIndex, amount) {
      for (var i2 = 0; i2 < this.dynamicProperties.length; i2++) {
        var property2 = this.dynamicProperties[i2];
        property2.uploadFunction(children, startIndex, amount, property2.type === TYPES$4.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property2.offset);
      }
      this.dynamicBuffer._updateID++;
    };
    ParticleBuffer2.prototype.uploadStatic = function(children, startIndex, amount) {
      for (var i2 = 0; i2 < this.staticProperties.length; i2++) {
        var property2 = this.staticProperties[i2];
        property2.uploadFunction(children, startIndex, amount, property2.type === TYPES$4.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property2.offset);
      }
      this.staticBuffer._updateID++;
    };
    ParticleBuffer2.prototype.destroy = function() {
      this.indexBuffer = null;
      this.dynamicProperties = null;
      this.dynamicBuffer = null;
      this.dynamicData = null;
      this.dynamicDataUint32 = null;
      this.staticProperties = null;
      this.staticBuffer = null;
      this.staticData = null;
      this.staticDataUint32 = null;
      this.geometry.destroy();
    };
    return ParticleBuffer2;
  }()
);
var fragment$B = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}";
var vertex$y = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n";
var ParticleRenderer = (
  /** @class */
  function(_super) {
    __extends$R(ParticleRenderer2, _super);
    function ParticleRenderer2(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.shader = null;
      _this.properties = null;
      _this.tempMatrix = new Matrix();
      _this.properties = [
        // verticesData
        {
          attributeName: "aVertexPosition",
          size: 2,
          uploadFunction: _this.uploadVertices,
          offset: 0
        },
        // positionData
        {
          attributeName: "aPositionCoord",
          size: 2,
          uploadFunction: _this.uploadPosition,
          offset: 0
        },
        // rotationData
        {
          attributeName: "aRotation",
          size: 1,
          uploadFunction: _this.uploadRotation,
          offset: 0
        },
        // uvsData
        {
          attributeName: "aTextureCoord",
          size: 2,
          uploadFunction: _this.uploadUvs,
          offset: 0
        },
        // tintData
        {
          attributeName: "aColor",
          size: 1,
          type: TYPES$4.UNSIGNED_BYTE,
          uploadFunction: _this.uploadTint,
          offset: 0
        }
      ];
      _this.shader = Shader.from(vertex$y, fragment$B, {});
      _this.state = State.for2d();
      return _this;
    }
    ParticleRenderer2.prototype.render = function(container2) {
      var children = container2.children;
      var maxSize = container2._maxSize;
      var batchSize = container2._batchSize;
      var renderer = this.renderer;
      var totalChildren = children.length;
      if (totalChildren === 0) {
        return;
      } else if (totalChildren > maxSize && !container2.autoResize) {
        totalChildren = maxSize;
      }
      var buffers = container2._buffers;
      if (!buffers) {
        buffers = container2._buffers = this.generateBuffers(container2);
      }
      var baseTexture = children[0]._texture.baseTexture;
      this.state.blendMode = correctBlendMode(container2.blendMode, baseTexture.alphaMode);
      renderer.state.set(this.state);
      var gl = renderer.gl;
      var m2 = container2.worldTransform.copyTo(this.tempMatrix);
      m2.prepend(renderer.globalUniforms.uniforms.projectionMatrix);
      this.shader.uniforms.translationMatrix = m2.toArray(true);
      this.shader.uniforms.uColor = premultiplyRgba(container2.tintRgb, container2.worldAlpha, this.shader.uniforms.uColor, baseTexture.alphaMode);
      this.shader.uniforms.uSampler = baseTexture;
      this.renderer.shader.bind(this.shader);
      var updateStatic = false;
      for (var i2 = 0, j2 = 0; i2 < totalChildren; i2 += batchSize, j2 += 1) {
        var amount = totalChildren - i2;
        if (amount > batchSize) {
          amount = batchSize;
        }
        if (j2 >= buffers.length) {
          buffers.push(this._generateOneMoreBuffer(container2));
        }
        var buffer = buffers[j2];
        buffer.uploadDynamic(children, i2, amount);
        var bid = container2._bufferUpdateIDs[j2] || 0;
        updateStatic = updateStatic || buffer._updateID < bid;
        if (updateStatic) {
          buffer._updateID = container2._updateID;
          buffer.uploadStatic(children, i2, amount);
        }
        renderer.geometry.bind(buffer.geometry);
        gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
      }
    };
    ParticleRenderer2.prototype.generateBuffers = function(container2) {
      var buffers = [];
      var size = container2._maxSize;
      var batchSize = container2._batchSize;
      var dynamicPropertyFlags = container2._properties;
      for (var i2 = 0; i2 < size; i2 += batchSize) {
        buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
      }
      return buffers;
    };
    ParticleRenderer2.prototype._generateOneMoreBuffer = function(container2) {
      var batchSize = container2._batchSize;
      var dynamicPropertyFlags = container2._properties;
      return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
    };
    ParticleRenderer2.prototype.uploadVertices = function(children, startIndex, amount, array, stride, offset) {
      var w0 = 0;
      var w1 = 0;
      var h0 = 0;
      var h1 = 0;
      for (var i2 = 0; i2 < amount; ++i2) {
        var sprite = children[startIndex + i2];
        var texture = sprite._texture;
        var sx = sprite.scale.x;
        var sy = sprite.scale.y;
        var trim2 = texture.trim;
        var orig = texture.orig;
        if (trim2) {
          w1 = trim2.x - sprite.anchor.x * orig.width;
          w0 = w1 + trim2.width;
          h1 = trim2.y - sprite.anchor.y * orig.height;
          h0 = h1 + trim2.height;
        } else {
          w0 = orig.width * (1 - sprite.anchor.x);
          w1 = orig.width * -sprite.anchor.x;
          h0 = orig.height * (1 - sprite.anchor.y);
          h1 = orig.height * -sprite.anchor.y;
        }
        array[offset] = w1 * sx;
        array[offset + 1] = h1 * sy;
        array[offset + stride] = w0 * sx;
        array[offset + stride + 1] = h1 * sy;
        array[offset + stride * 2] = w0 * sx;
        array[offset + stride * 2 + 1] = h0 * sy;
        array[offset + stride * 3] = w1 * sx;
        array[offset + stride * 3 + 1] = h0 * sy;
        offset += stride * 4;
      }
    };
    ParticleRenderer2.prototype.uploadPosition = function(children, startIndex, amount, array, stride, offset) {
      for (var i2 = 0; i2 < amount; i2++) {
        var spritePosition = children[startIndex + i2].position;
        array[offset] = spritePosition.x;
        array[offset + 1] = spritePosition.y;
        array[offset + stride] = spritePosition.x;
        array[offset + stride + 1] = spritePosition.y;
        array[offset + stride * 2] = spritePosition.x;
        array[offset + stride * 2 + 1] = spritePosition.y;
        array[offset + stride * 3] = spritePosition.x;
        array[offset + stride * 3 + 1] = spritePosition.y;
        offset += stride * 4;
      }
    };
    ParticleRenderer2.prototype.uploadRotation = function(children, startIndex, amount, array, stride, offset) {
      for (var i2 = 0; i2 < amount; i2++) {
        var spriteRotation = children[startIndex + i2].rotation;
        array[offset] = spriteRotation;
        array[offset + stride] = spriteRotation;
        array[offset + stride * 2] = spriteRotation;
        array[offset + stride * 3] = spriteRotation;
        offset += stride * 4;
      }
    };
    ParticleRenderer2.prototype.uploadUvs = function(children, startIndex, amount, array, stride, offset) {
      for (var i2 = 0; i2 < amount; ++i2) {
        var textureUvs = children[startIndex + i2]._texture._uvs;
        if (textureUvs) {
          array[offset] = textureUvs.x0;
          array[offset + 1] = textureUvs.y0;
          array[offset + stride] = textureUvs.x1;
          array[offset + stride + 1] = textureUvs.y1;
          array[offset + stride * 2] = textureUvs.x2;
          array[offset + stride * 2 + 1] = textureUvs.y2;
          array[offset + stride * 3] = textureUvs.x3;
          array[offset + stride * 3 + 1] = textureUvs.y3;
          offset += stride * 4;
        } else {
          array[offset] = 0;
          array[offset + 1] = 0;
          array[offset + stride] = 0;
          array[offset + stride + 1] = 0;
          array[offset + stride * 2] = 0;
          array[offset + stride * 2 + 1] = 0;
          array[offset + stride * 3] = 0;
          array[offset + stride * 3 + 1] = 0;
          offset += stride * 4;
        }
      }
    };
    ParticleRenderer2.prototype.uploadTint = function(children, startIndex, amount, array, stride, offset) {
      for (var i2 = 0; i2 < amount; ++i2) {
        var sprite = children[startIndex + i2];
        var premultiplied = sprite._texture.baseTexture.alphaMode > 0;
        var alpha2 = sprite.alpha;
        var argb = alpha2 < 1 && premultiplied ? premultiplyTint(sprite._tintRGB, alpha2) : sprite._tintRGB + (alpha2 * 255 << 24);
        array[offset] = argb;
        array[offset + stride] = argb;
        array[offset + stride * 2] = argb;
        array[offset + stride * 3] = argb;
        offset += stride * 4;
      }
    };
    ParticleRenderer2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      if (this.shader) {
        this.shader.destroy();
        this.shader = null;
      }
      this.tempMatrix = null;
    };
    return ParticleRenderer2;
  }(ObjectRenderer)
);
/*!
 * @pixi/graphics - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/graphics is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var LINE_JOIN;
(function(LINE_JOIN2) {
  LINE_JOIN2["MITER"] = "miter";
  LINE_JOIN2["BEVEL"] = "bevel";
  LINE_JOIN2["ROUND"] = "round";
})(LINE_JOIN || (LINE_JOIN = {}));
var LINE_CAP;
(function(LINE_CAP2) {
  LINE_CAP2["BUTT"] = "butt";
  LINE_CAP2["ROUND"] = "round";
  LINE_CAP2["SQUARE"] = "square";
})(LINE_CAP || (LINE_CAP = {}));
var GRAPHICS_CURVES = {
  adaptive: true,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount: function(length2, defaultSegments) {
    if (defaultSegments === void 0) {
      defaultSegments = 20;
    }
    if (!this.adaptive || !length2 || isNaN(length2)) {
      return defaultSegments;
    }
    var result = Math.ceil(length2 / this.maxLength);
    if (result < this.minSegments) {
      result = this.minSegments;
    } else if (result > this.maxSegments) {
      result = this.maxSegments;
    }
    return result;
  }
};
var FillStyle = (
  /** @class */
  function() {
    function FillStyle2() {
      this.color = 16777215;
      this.alpha = 1;
      this.texture = Texture.WHITE;
      this.matrix = null;
      this.visible = false;
      this.reset();
    }
    FillStyle2.prototype.clone = function() {
      var obj = new FillStyle2();
      obj.color = this.color;
      obj.alpha = this.alpha;
      obj.texture = this.texture;
      obj.matrix = this.matrix;
      obj.visible = this.visible;
      return obj;
    };
    FillStyle2.prototype.reset = function() {
      this.color = 16777215;
      this.alpha = 1;
      this.texture = Texture.WHITE;
      this.matrix = null;
      this.visible = false;
    };
    FillStyle2.prototype.destroy = function() {
      this.texture = null;
      this.matrix = null;
    };
    return FillStyle2;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$Q = function(d2, b2) {
  extendStatics$Q = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (b3.hasOwnProperty(p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$Q(d2, b2);
};
function __extends$Q(d2, b2) {
  extendStatics$Q(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function fixOrientation(points, hole) {
  var _a2, _b2;
  if (hole === void 0) {
    hole = false;
  }
  var m2 = points.length;
  if (m2 < 6) {
    return;
  }
  var area2 = 0;
  for (var i2 = 0, x1 = points[m2 - 2], y1 = points[m2 - 1]; i2 < m2; i2 += 2) {
    var x2 = points[i2];
    var y2 = points[i2 + 1];
    area2 += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  if (!hole && area2 > 0 || hole && area2 <= 0) {
    var n2 = m2 / 2;
    for (var i2 = n2 + n2 % 2; i2 < m2; i2 += 2) {
      var i1 = m2 - i2 - 2;
      var i22 = m2 - i2 - 1;
      var i3 = i2;
      var i4 = i2 + 1;
      _a2 = [points[i3], points[i1]], points[i1] = _a2[0], points[i3] = _a2[1];
      _b2 = [points[i4], points[i22]], points[i22] = _b2[0], points[i4] = _b2[1];
    }
  }
}
var buildPoly = {
  build: function(graphicsData) {
    graphicsData.points = graphicsData.shape.points.slice();
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    var points = graphicsData.points;
    var holes = graphicsData.holes;
    var verts = graphicsGeometry.points;
    var indices3 = graphicsGeometry.indices;
    if (points.length >= 6) {
      fixOrientation(points, false);
      var holeArray = [];
      for (var i2 = 0; i2 < holes.length; i2++) {
        var hole = holes[i2];
        fixOrientation(hole.points, true);
        holeArray.push(points.length / 2);
        points = points.concat(hole.points);
      }
      var triangles = earcut$1(points, holeArray, 2);
      if (!triangles) {
        return;
      }
      var vertPos = verts.length / 2;
      for (var i2 = 0; i2 < triangles.length; i2 += 3) {
        indices3.push(triangles[i2] + vertPos);
        indices3.push(triangles[i2 + 1] + vertPos);
        indices3.push(triangles[i2 + 2] + vertPos);
      }
      for (var i2 = 0; i2 < points.length; i2++) {
        verts.push(points[i2]);
      }
    }
  }
};
var buildCircle = {
  build: function(graphicsData) {
    var points = graphicsData.points;
    var x;
    var y2;
    var dx;
    var dy;
    var rx;
    var ry;
    if (graphicsData.type === SHAPES.CIRC) {
      var circle = graphicsData.shape;
      x = circle.x;
      y2 = circle.y;
      rx = ry = circle.radius;
      dx = dy = 0;
    } else if (graphicsData.type === SHAPES.ELIP) {
      var ellipse = graphicsData.shape;
      x = ellipse.x;
      y2 = ellipse.y;
      rx = ellipse.width;
      ry = ellipse.height;
      dx = dy = 0;
    } else {
      var roundedRect = graphicsData.shape;
      var halfWidth = roundedRect.width / 2;
      var halfHeight = roundedRect.height / 2;
      x = roundedRect.x + halfWidth;
      y2 = roundedRect.y + halfHeight;
      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
      dx = halfWidth - rx;
      dy = halfHeight - ry;
    }
    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
      points.length = 0;
      return;
    }
    var n2 = Math.ceil(2.3 * Math.sqrt(rx + ry));
    var m2 = n2 * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
    points.length = m2;
    if (m2 === 0) {
      return;
    }
    if (n2 === 0) {
      points.length = 8;
      points[0] = points[6] = x + dx;
      points[1] = points[3] = y2 + dy;
      points[2] = points[4] = x - dx;
      points[5] = points[7] = y2 - dy;
      return;
    }
    var j1 = 0;
    var j2 = n2 * 4 + (dx ? 2 : 0) + 2;
    var j3 = j2;
    var j4 = m2;
    {
      var x0 = dx + rx;
      var y0 = dy;
      var x1 = x + x0;
      var x2 = x - x0;
      var y1 = y2 + y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x2;
      if (dy) {
        var y22 = y2 - y0;
        points[j3++] = x2;
        points[j3++] = y22;
        points[--j4] = y22;
        points[--j4] = x1;
      }
    }
    for (var i2 = 1; i2 < n2; i2++) {
      var a2 = Math.PI / 2 * (i2 / n2);
      var x0 = dx + Math.cos(a2) * rx;
      var y0 = dy + Math.sin(a2) * ry;
      var x1 = x + x0;
      var x2 = x - x0;
      var y1 = y2 + y0;
      var y22 = y2 - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x2;
      points[j3++] = x2;
      points[j3++] = y22;
      points[--j4] = y22;
      points[--j4] = x1;
    }
    {
      var x0 = dx;
      var y0 = dy + ry;
      var x1 = x + x0;
      var x2 = x - x0;
      var y1 = y2 + y0;
      var y22 = y2 - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j4] = y22;
      points[--j4] = x1;
      if (dx) {
        points[j1++] = x2;
        points[j1++] = y1;
        points[--j4] = y22;
        points[--j4] = x2;
      }
    }
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    var points = graphicsData.points;
    var verts = graphicsGeometry.points;
    var indices3 = graphicsGeometry.indices;
    var vertPos = verts.length / 2;
    var center = vertPos;
    var x;
    var y2;
    if (graphicsData.type !== SHAPES.RREC) {
      var circle = graphicsData.shape;
      x = circle.x;
      y2 = circle.y;
    } else {
      var roundedRect = graphicsData.shape;
      x = roundedRect.x + roundedRect.width / 2;
      y2 = roundedRect.y + roundedRect.height / 2;
    }
    var matrix = graphicsData.matrix;
    verts.push(graphicsData.matrix ? matrix.a * x + matrix.c * y2 + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y2 + matrix.ty : y2);
    vertPos++;
    verts.push(points[0], points[1]);
    for (var i2 = 2; i2 < points.length; i2 += 2) {
      verts.push(points[i2], points[i2 + 1]);
      indices3.push(vertPos++, center, vertPos);
    }
    indices3.push(center + 1, center, vertPos);
  }
};
var buildRectangle = {
  build: function(graphicsData) {
    var rectData = graphicsData.shape;
    var x = rectData.x;
    var y2 = rectData.y;
    var width = rectData.width;
    var height = rectData.height;
    var points = graphicsData.points;
    points.length = 0;
    points.push(x, y2, x + width, y2, x + width, y2 + height, x, y2 + height);
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    var points = graphicsData.points;
    var verts = graphicsGeometry.points;
    var vertPos = verts.length / 2;
    verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
  }
};
function getPt(n1, n2, perc) {
  var diff = n2 - n1;
  return n1 + diff * perc;
}
function quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out) {
  if (out === void 0) {
    out = [];
  }
  var n2 = 20;
  var points = out;
  var xa2 = 0;
  var ya2 = 0;
  var xb2 = 0;
  var yb2 = 0;
  var x = 0;
  var y2 = 0;
  for (var i2 = 0, j2 = 0; i2 <= n2; ++i2) {
    j2 = i2 / n2;
    xa2 = getPt(fromX, cpX, j2);
    ya2 = getPt(fromY, cpY, j2);
    xb2 = getPt(cpX, toX, j2);
    yb2 = getPt(cpY, toY, j2);
    x = getPt(xa2, xb2, j2);
    y2 = getPt(ya2, yb2, j2);
    if (i2 === 0 && points[points.length - 2] === x && points[points.length - 1] === y2) {
      continue;
    }
    points.push(x, y2);
  }
  return points;
}
var buildRoundedRectangle = {
  build: function(graphicsData) {
    if (Graphics.nextRoundedRectBehavior) {
      buildCircle.build(graphicsData);
      return;
    }
    var rrectData = graphicsData.shape;
    var points = graphicsData.points;
    var x = rrectData.x;
    var y2 = rrectData.y;
    var width = rrectData.width;
    var height = rrectData.height;
    var radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));
    points.length = 0;
    if (!radius) {
      points.push(x, y2, x + width, y2, x + width, y2 + height, x, y2 + height);
    } else {
      quadraticBezierCurve(x, y2 + radius, x, y2, x + radius, y2, points);
      quadraticBezierCurve(x + width - radius, y2, x + width, y2, x + width, y2 + radius, points);
      quadraticBezierCurve(x + width, y2 + height - radius, x + width, y2 + height, x + width - radius, y2 + height, points);
      quadraticBezierCurve(x + radius, y2 + height, x, y2 + height, x, y2 + height - radius, points);
    }
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    if (Graphics.nextRoundedRectBehavior) {
      buildCircle.triangulate(graphicsData, graphicsGeometry);
      return;
    }
    var points = graphicsData.points;
    var verts = graphicsGeometry.points;
    var indices3 = graphicsGeometry.indices;
    var vecPos = verts.length / 2;
    var triangles = earcut$1(points, null, 2);
    for (var i2 = 0, j2 = triangles.length; i2 < j2; i2 += 3) {
      indices3.push(triangles[i2] + vecPos);
      indices3.push(triangles[i2 + 1] + vecPos);
      indices3.push(triangles[i2 + 2] + vecPos);
    }
    for (var i2 = 0, j2 = points.length; i2 < j2; i2++) {
      verts.push(points[i2], points[++i2]);
    }
  }
};
function square(x, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  var ix = x - nx * innerWeight;
  var iy = y2 - ny * innerWeight;
  var ox = x + nx * outerWeight;
  var oy = y2 + ny * outerWeight;
  var exx;
  var eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  var eix = ix + exx;
  var eiy = iy + eyy;
  var eox = ox + exx;
  var eoy = oy + eyy;
  verts.push(eix, eiy);
  verts.push(eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  var cx2p0x = sx - cx;
  var cy2p0y = sy - cy;
  var angle0 = Math.atan2(cx2p0x, cy2p0y);
  var angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  var startAngle = angle0;
  var angleDiff = angle1 - angle0;
  var absAngleDiff = Math.abs(angleDiff);
  var radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  var segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  var angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy);
    verts.push(sx, sy);
    for (var i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
      verts.push(cx, cy);
      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
    }
    verts.push(cx, cy);
    verts.push(ex, ey);
  } else {
    verts.push(sx, sy);
    verts.push(cx, cy);
    for (var i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
      verts.push(cx, cy);
    }
    verts.push(ex, ey);
    verts.push(cx, cy);
  }
  return segCount * 2;
}
function buildNonNativeLine(graphicsData, graphicsGeometry) {
  var shape = graphicsData.shape;
  var points = graphicsData.points || shape.points.slice();
  var eps = graphicsGeometry.closePointEps;
  if (points.length === 0) {
    return;
  }
  var style = graphicsData.lineStyle;
  var firstPoint = new Point(points[0], points[1]);
  var lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  var closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    var midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    var midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  var verts = graphicsGeometry.points;
  var length2 = points.length / 2;
  var indexCount = points.length;
  var indexStart = verts.length / 2;
  var width = style.width / 2;
  var widthSquared = width * width;
  var miterLimitSquared = style.miterLimit * style.miterLimit;
  var x0 = points[0];
  var y0 = points[1];
  var x1 = points[2];
  var y1 = points[3];
  var x2 = 0;
  var y2 = 0;
  var perpx = -(y0 - y1);
  var perpy = x0 - x1;
  var perp1x = 0;
  var perp1y = 0;
  var dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  var ratio = style.alignment;
  var innerWeight = (1 - ratio) * 2;
  var outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight);
  verts.push(x0 + perpx * outerWeight, y0 + perpy * outerWeight);
  for (var i2 = 1; i2 < length2 - 1; ++i2) {
    x0 = points[(i2 - 1) * 2];
    y0 = points[(i2 - 1) * 2 + 1];
    x1 = points[i2 * 2];
    y1 = points[i2 * 2 + 1];
    x2 = points[(i2 + 1) * 2];
    y2 = points[(i2 + 1) * 2 + 1];
    perpx = -(y0 - y1);
    perpy = x0 - x1;
    dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x2;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    var dx0 = x1 - x0;
    var dy0 = y0 - y1;
    var dx1 = x1 - x2;
    var dy1 = y2 - y1;
    var cross = dy0 * dx1 - dy1 * dx0;
    var clockwise = cross < 0;
    if (Math.abs(cross) < 0.1) {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      continue;
    }
    var c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);
    var c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    var px = (dx0 * c2 - dx1 * c1) / cross;
    var py = (dy1 * c1 - dy0 * c2) / cross;
    var pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    var imx = x1 + (px - x1) * innerWeight;
    var imy = y1 + (py - y1) * innerWeight;
    var omx = x1 - (px - x1) * outerWeight;
    var omy = y1 - (py - y1) * outerWeight;
    var smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    var insideWeight = clockwise ? innerWeight : outerWeight;
    var smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    var insideMiterOk = pdist <= smallerInsideDiagonalSq;
    if (insideMiterOk) {
      if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared) {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
          verts.push(omx, omy);
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
        indexCount += 2;
      } else if (style.join === LINE_JOIN.ROUND) {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
          indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
          verts.push(omx, omy);
          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
      } else {
        verts.push(imx, imy);
        verts.push(omx, omy);
      }
    } else {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      if (style.join === LINE_JOIN.ROUND) {
        if (clockwise) {
          indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;
        } else {
          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;
        }
      } else if (style.join === LINE_JOIN.MITER && pdist / widthSquared <= miterLimitSquared) {
        if (clockwise) {
          verts.push(omx, omy);
          verts.push(omx, omy);
        } else {
          verts.push(imx, imy);
          verts.push(imx, imy);
        }
        indexCount += 2;
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length2 - 2) * 2];
  y0 = points[(length2 - 2) * 2 + 1];
  x1 = points[(length2 - 1) * 2];
  y1 = points[(length2 - 1) * 2 + 1];
  perpx = -(y0 - y1);
  perpy = x0 - x1;
  dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
  verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);
    }
  }
  var indices3 = graphicsGeometry.indices;
  var eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;
  for (var i2 = indexStart; i2 < indexCount + indexStart - 2; ++i2) {
    x0 = verts[i2 * 2];
    y0 = verts[i2 * 2 + 1];
    x1 = verts[(i2 + 1) * 2];
    y1 = verts[(i2 + 1) * 2 + 1];
    x2 = verts[(i2 + 2) * 2];
    y2 = verts[(i2 + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
      continue;
    }
    indices3.push(i2, i2 + 1, i2 + 2);
  }
}
function buildNativeLine(graphicsData, graphicsGeometry) {
  var i2 = 0;
  var shape = graphicsData.shape;
  var points = graphicsData.points || shape.points;
  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  if (points.length === 0) {
    return;
  }
  var verts = graphicsGeometry.points;
  var indices3 = graphicsGeometry.indices;
  var length2 = points.length / 2;
  var startIndex = verts.length / 2;
  var currentIndex = startIndex;
  verts.push(points[0], points[1]);
  for (i2 = 1; i2 < length2; i2++) {
    verts.push(points[i2 * 2], points[i2 * 2 + 1]);
    indices3.push(currentIndex, currentIndex + 1);
    currentIndex++;
  }
  if (closedShape) {
    indices3.push(currentIndex, startIndex);
  }
}
function buildLine(graphicsData, graphicsGeometry) {
  if (graphicsData.lineStyle.native) {
    buildNativeLine(graphicsData, graphicsGeometry);
  } else {
    buildNonNativeLine(graphicsData, graphicsGeometry);
  }
}
var ArcUtils = (
  /** @class */
  function() {
    function ArcUtils2() {
    }
    ArcUtils2.curveTo = function(x1, y1, x2, y2, radius, points) {
      var fromX = points[points.length - 2];
      var fromY = points[points.length - 1];
      var a1 = fromY - y1;
      var b1 = fromX - x1;
      var a2 = y2 - y1;
      var b2 = x2 - x1;
      var mm = Math.abs(a1 * b2 - b1 * a2);
      if (mm < 1e-8 || radius === 0) {
        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
          points.push(x1, y1);
        }
        return null;
      }
      var dd2 = a1 * a1 + b1 * b1;
      var cc2 = a2 * a2 + b2 * b2;
      var tt = a1 * a2 + b1 * b2;
      var k1 = radius * Math.sqrt(dd2) / mm;
      var k2 = radius * Math.sqrt(cc2) / mm;
      var j1 = k1 * tt / dd2;
      var j2 = k2 * tt / cc2;
      var cx = k1 * b2 + k2 * b1;
      var cy = k1 * a2 + k2 * a1;
      var px = b1 * (k2 + j1);
      var py = a1 * (k2 + j1);
      var qx = b2 * (k1 + j2);
      var qy = a2 * (k1 + j2);
      var startAngle = Math.atan2(py - cy, px - cx);
      var endAngle = Math.atan2(qy - cy, qx - cx);
      return {
        cx: cx + x1,
        cy: cy + y1,
        radius,
        startAngle,
        endAngle,
        anticlockwise: b1 * a2 > b2 * a1
      };
    };
    ArcUtils2.arc = function(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {
      var sweep = endAngle - startAngle;
      var n2 = GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);
      var theta = sweep / (n2 * 2);
      var theta2 = theta * 2;
      var cTheta = Math.cos(theta);
      var sTheta = Math.sin(theta);
      var segMinus = n2 - 1;
      var remainder = segMinus % 1 / segMinus;
      for (var i2 = 0; i2 <= segMinus; ++i2) {
        var real = i2 + remainder * i2;
        var angle = theta + startAngle + theta2 * real;
        var c2 = Math.cos(angle);
        var s2 = -Math.sin(angle);
        points.push((cTheta * c2 + sTheta * s2) * radius + cx, (cTheta * -s2 + sTheta * c2) * radius + cy);
      }
    };
    return ArcUtils2;
  }()
);
var BezierUtils = (
  /** @class */
  function() {
    function BezierUtils2() {
    }
    BezierUtils2.curveLength = function(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
      var n2 = 10;
      var result = 0;
      var t2 = 0;
      var t22 = 0;
      var t3 = 0;
      var nt = 0;
      var nt2 = 0;
      var nt3 = 0;
      var x = 0;
      var y2 = 0;
      var dx = 0;
      var dy = 0;
      var prevX = fromX;
      var prevY = fromY;
      for (var i2 = 1; i2 <= n2; ++i2) {
        t2 = i2 / n2;
        t22 = t2 * t2;
        t3 = t22 * t2;
        nt = 1 - t2;
        nt2 = nt * nt;
        nt3 = nt2 * nt;
        x = nt3 * fromX + 3 * nt2 * t2 * cpX + 3 * nt * t22 * cpX2 + t3 * toX;
        y2 = nt3 * fromY + 3 * nt2 * t2 * cpY + 3 * nt * t22 * cpY2 + t3 * toY;
        dx = prevX - x;
        dy = prevY - y2;
        prevX = x;
        prevY = y2;
        result += Math.sqrt(dx * dx + dy * dy);
      }
      return result;
    };
    BezierUtils2.curveTo = function(cpX, cpY, cpX2, cpY2, toX, toY, points) {
      var fromX = points[points.length - 2];
      var fromY = points[points.length - 1];
      points.length -= 2;
      var n2 = GRAPHICS_CURVES._segmentsCount(BezierUtils2.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
      var dt = 0;
      var dt2 = 0;
      var dt3 = 0;
      var t2 = 0;
      var t3 = 0;
      points.push(fromX, fromY);
      for (var i2 = 1, j2 = 0; i2 <= n2; ++i2) {
        j2 = i2 / n2;
        dt = 1 - j2;
        dt2 = dt * dt;
        dt3 = dt2 * dt;
        t2 = j2 * j2;
        t3 = t2 * j2;
        points.push(dt3 * fromX + 3 * dt2 * j2 * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j2 * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
      }
    };
    return BezierUtils2;
  }()
);
var QuadraticUtils = (
  /** @class */
  function() {
    function QuadraticUtils2() {
    }
    QuadraticUtils2.curveLength = function(fromX, fromY, cpX, cpY, toX, toY) {
      var ax = fromX - 2 * cpX + toX;
      var ay = fromY - 2 * cpY + toY;
      var bx = 2 * cpX - 2 * fromX;
      var by = 2 * cpY - 2 * fromY;
      var a2 = 4 * (ax * ax + ay * ay);
      var b2 = 4 * (ax * bx + ay * by);
      var c2 = bx * bx + by * by;
      var s2 = 2 * Math.sqrt(a2 + b2 + c2);
      var a22 = Math.sqrt(a2);
      var a32 = 2 * a2 * a22;
      var c22 = 2 * Math.sqrt(c2);
      var ba2 = b2 / a22;
      return (a32 * s2 + a22 * b2 * (s2 - c22) + (4 * c2 * a2 - b2 * b2) * Math.log((2 * a22 + ba2 + s2) / (ba2 + c22))) / (4 * a32);
    };
    QuadraticUtils2.curveTo = function(cpX, cpY, toX, toY, points) {
      var fromX = points[points.length - 2];
      var fromY = points[points.length - 1];
      var n2 = GRAPHICS_CURVES._segmentsCount(QuadraticUtils2.curveLength(fromX, fromY, cpX, cpY, toX, toY));
      var xa2 = 0;
      var ya2 = 0;
      for (var i2 = 1; i2 <= n2; ++i2) {
        var j2 = i2 / n2;
        xa2 = fromX + (cpX - fromX) * j2;
        ya2 = fromY + (cpY - fromY) * j2;
        points.push(xa2 + (cpX + (toX - cpX) * j2 - xa2) * j2, ya2 + (cpY + (toY - cpY) * j2 - ya2) * j2);
      }
    };
    return QuadraticUtils2;
  }()
);
var BatchPart = (
  /** @class */
  function() {
    function BatchPart2() {
      this.reset();
    }
    BatchPart2.prototype.begin = function(style, startIndex, attribStart) {
      this.reset();
      this.style = style;
      this.start = startIndex;
      this.attribStart = attribStart;
    };
    BatchPart2.prototype.end = function(endIndex, endAttrib) {
      this.attribSize = endAttrib - this.attribStart;
      this.size = endIndex - this.start;
    };
    BatchPart2.prototype.reset = function() {
      this.style = null;
      this.size = 0;
      this.start = 0;
      this.attribStart = 0;
      this.attribSize = 0;
    };
    return BatchPart2;
  }()
);
var _a;
var FILL_COMMANDS = (_a = {}, _a[SHAPES.POLY] = buildPoly, _a[SHAPES.CIRC] = buildCircle, _a[SHAPES.ELIP] = buildCircle, _a[SHAPES.RECT] = buildRectangle, _a[SHAPES.RREC] = buildRoundedRectangle, _a);
var BATCH_POOL = [];
var DRAW_CALL_POOL = [];
var GraphicsData = (
  /** @class */
  function() {
    function GraphicsData2(shape, fillStyle, lineStyle, matrix) {
      if (fillStyle === void 0) {
        fillStyle = null;
      }
      if (lineStyle === void 0) {
        lineStyle = null;
      }
      if (matrix === void 0) {
        matrix = null;
      }
      this.points = [];
      this.holes = [];
      this.shape = shape;
      this.lineStyle = lineStyle;
      this.fillStyle = fillStyle;
      this.matrix = matrix;
      this.type = shape.type;
    }
    GraphicsData2.prototype.clone = function() {
      return new GraphicsData2(this.shape, this.fillStyle, this.lineStyle, this.matrix);
    };
    GraphicsData2.prototype.destroy = function() {
      this.shape = null;
      this.holes.length = 0;
      this.holes = null;
      this.points.length = 0;
      this.points = null;
      this.lineStyle = null;
      this.fillStyle = null;
    };
    return GraphicsData2;
  }()
);
var tmpPoint = new Point();
var tmpBounds = new Bounds$1();
var GraphicsGeometry = (
  /** @class */
  function(_super) {
    __extends$Q(GraphicsGeometry2, _super);
    function GraphicsGeometry2() {
      var _this = _super.call(this) || this;
      _this.closePointEps = 1e-4;
      _this.boundsPadding = 0;
      _this.uvsFloat32 = null;
      _this.indicesUint16 = null;
      _this.batchable = false;
      _this.points = [];
      _this.colors = [];
      _this.uvs = [];
      _this.indices = [];
      _this.textureIds = [];
      _this.graphicsData = [];
      _this.drawCalls = [];
      _this.batchDirty = -1;
      _this.batches = [];
      _this.dirty = 0;
      _this.cacheDirty = -1;
      _this.clearDirty = 0;
      _this.shapeIndex = 0;
      _this._bounds = new Bounds$1();
      _this.boundsDirty = -1;
      return _this;
    }
    Object.defineProperty(GraphicsGeometry2.prototype, "bounds", {
      /**
       * Get the current bounds of the graphic geometry.
       * @readonly
       */
      get: function() {
        if (this.boundsDirty !== this.dirty) {
          this.boundsDirty = this.dirty;
          this.calculateBounds();
        }
        return this._bounds;
      },
      enumerable: false,
      configurable: true
    });
    GraphicsGeometry2.prototype.invalidate = function() {
      this.boundsDirty = -1;
      this.dirty++;
      this.batchDirty++;
      this.shapeIndex = 0;
      this.points.length = 0;
      this.colors.length = 0;
      this.uvs.length = 0;
      this.indices.length = 0;
      this.textureIds.length = 0;
      for (var i2 = 0; i2 < this.drawCalls.length; i2++) {
        this.drawCalls[i2].texArray.clear();
        DRAW_CALL_POOL.push(this.drawCalls[i2]);
      }
      this.drawCalls.length = 0;
      for (var i2 = 0; i2 < this.batches.length; i2++) {
        var batchPart = this.batches[i2];
        batchPart.reset();
        BATCH_POOL.push(batchPart);
      }
      this.batches.length = 0;
    };
    GraphicsGeometry2.prototype.clear = function() {
      if (this.graphicsData.length > 0) {
        this.invalidate();
        this.clearDirty++;
        this.graphicsData.length = 0;
      }
      return this;
    };
    GraphicsGeometry2.prototype.drawShape = function(shape, fillStyle, lineStyle, matrix) {
      if (fillStyle === void 0) {
        fillStyle = null;
      }
      if (lineStyle === void 0) {
        lineStyle = null;
      }
      if (matrix === void 0) {
        matrix = null;
      }
      var data2 = new GraphicsData(shape, fillStyle, lineStyle, matrix);
      this.graphicsData.push(data2);
      this.dirty++;
      return this;
    };
    GraphicsGeometry2.prototype.drawHole = function(shape, matrix) {
      if (matrix === void 0) {
        matrix = null;
      }
      if (!this.graphicsData.length) {
        return null;
      }
      var data2 = new GraphicsData(shape, null, null, matrix);
      var lastShape = this.graphicsData[this.graphicsData.length - 1];
      data2.lineStyle = lastShape.lineStyle;
      lastShape.holes.push(data2);
      this.dirty++;
      return this;
    };
    GraphicsGeometry2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      for (var i2 = 0; i2 < this.graphicsData.length; ++i2) {
        this.graphicsData[i2].destroy();
      }
      this.points.length = 0;
      this.points = null;
      this.colors.length = 0;
      this.colors = null;
      this.uvs.length = 0;
      this.uvs = null;
      this.indices.length = 0;
      this.indices = null;
      this.indexBuffer.destroy();
      this.indexBuffer = null;
      this.graphicsData.length = 0;
      this.graphicsData = null;
      this.drawCalls.length = 0;
      this.drawCalls = null;
      this.batches.length = 0;
      this.batches = null;
      this._bounds = null;
    };
    GraphicsGeometry2.prototype.containsPoint = function(point) {
      var graphicsData = this.graphicsData;
      for (var i2 = 0; i2 < graphicsData.length; ++i2) {
        var data2 = graphicsData[i2];
        if (!data2.fillStyle.visible) {
          continue;
        }
        if (data2.shape) {
          if (data2.matrix) {
            data2.matrix.applyInverse(point, tmpPoint);
          } else {
            tmpPoint.copyFrom(point);
          }
          if (data2.shape.contains(tmpPoint.x, tmpPoint.y)) {
            var hitHole = false;
            if (data2.holes) {
              for (var i_1 = 0; i_1 < data2.holes.length; i_1++) {
                var hole = data2.holes[i_1];
                if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {
                  hitHole = true;
                  break;
                }
              }
            }
            if (!hitHole) {
              return true;
            }
          }
        }
      }
      return false;
    };
    GraphicsGeometry2.prototype.updateBatches = function(allow32Indices) {
      if (!this.graphicsData.length) {
        this.batchable = true;
        return;
      }
      if (!this.validateBatching()) {
        return;
      }
      this.cacheDirty = this.dirty;
      var uvs = this.uvs;
      var graphicsData = this.graphicsData;
      var batchPart = null;
      var currentStyle = null;
      if (this.batches.length > 0) {
        batchPart = this.batches[this.batches.length - 1];
        currentStyle = batchPart.style;
      }
      for (var i2 = this.shapeIndex; i2 < graphicsData.length; i2++) {
        this.shapeIndex++;
        var data2 = graphicsData[i2];
        var fillStyle = data2.fillStyle;
        var lineStyle = data2.lineStyle;
        var command = FILL_COMMANDS[data2.type];
        command.build(data2);
        if (data2.matrix) {
          this.transformPoints(data2.points, data2.matrix);
        }
        if (fillStyle.visible || lineStyle.visible) {
          this.processHoles(data2.holes);
        }
        for (var j2 = 0; j2 < 2; j2++) {
          var style = j2 === 0 ? fillStyle : lineStyle;
          if (!style.visible) {
            continue;
          }
          var nextTexture = style.texture.baseTexture;
          var index_1 = this.indices.length;
          var attribIndex = this.points.length / 2;
          nextTexture.wrapMode = WRAP_MODES$4.REPEAT;
          if (j2 === 0) {
            this.processFill(data2);
          } else {
            this.processLine(data2);
          }
          var size = this.points.length / 2 - attribIndex;
          if (size === 0) {
            continue;
          }
          if (batchPart && !this._compareStyles(currentStyle, style)) {
            batchPart.end(index_1, attribIndex);
            batchPart = null;
          }
          if (!batchPart) {
            batchPart = BATCH_POOL.pop() || new BatchPart();
            batchPart.begin(style, index_1, attribIndex);
            this.batches.push(batchPart);
            currentStyle = style;
          }
          this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);
        }
      }
      var index2 = this.indices.length;
      var attrib = this.points.length / 2;
      if (batchPart) {
        batchPart.end(index2, attrib);
      }
      if (this.batches.length === 0) {
        this.batchable = true;
        return;
      }
      if (this.indicesUint16 && this.indices.length === this.indicesUint16.length) {
        this.indicesUint16.set(this.indices);
      } else {
        var need32 = attrib > 65535 && allow32Indices;
        this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
      }
      this.batchable = this.isBatchable();
      if (this.batchable) {
        this.packBatches();
      } else {
        this.buildDrawCalls();
      }
    };
    GraphicsGeometry2.prototype._compareStyles = function(styleA, styleB) {
      if (!styleA || !styleB) {
        return false;
      }
      if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
        return false;
      }
      if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
        return false;
      }
      if (!!styleA.native !== !!styleB.native) {
        return false;
      }
      return true;
    };
    GraphicsGeometry2.prototype.validateBatching = function() {
      if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
        return false;
      }
      for (var i2 = 0, l2 = this.graphicsData.length; i2 < l2; i2++) {
        var data2 = this.graphicsData[i2];
        var fill = data2.fillStyle;
        var line2 = data2.lineStyle;
        if (fill && !fill.texture.baseTexture.valid) {
          return false;
        }
        if (line2 && !line2.texture.baseTexture.valid) {
          return false;
        }
      }
      return true;
    };
    GraphicsGeometry2.prototype.packBatches = function() {
      this.batchDirty++;
      this.uvsFloat32 = new Float32Array(this.uvs);
      var batches = this.batches;
      for (var i2 = 0, l2 = batches.length; i2 < l2; i2++) {
        var batch2 = batches[i2];
        for (var j2 = 0; j2 < batch2.size; j2++) {
          var index2 = batch2.start + j2;
          this.indicesUint16[index2] = this.indicesUint16[index2] - batch2.attribStart;
        }
      }
    };
    GraphicsGeometry2.prototype.isBatchable = function() {
      if (this.points.length > 65535 * 2) {
        return false;
      }
      var batches = this.batches;
      for (var i2 = 0; i2 < batches.length; i2++) {
        if (batches[i2].style.native) {
          return false;
        }
      }
      return this.points.length < GraphicsGeometry2.BATCHABLE_SIZE * 2;
    };
    GraphicsGeometry2.prototype.buildDrawCalls = function() {
      var TICK = ++BaseTexture._globalBatch;
      for (var i2 = 0; i2 < this.drawCalls.length; i2++) {
        this.drawCalls[i2].texArray.clear();
        DRAW_CALL_POOL.push(this.drawCalls[i2]);
      }
      this.drawCalls.length = 0;
      var colors = this.colors;
      var textureIds = this.textureIds;
      var currentGroup = DRAW_CALL_POOL.pop();
      if (!currentGroup) {
        currentGroup = new BatchDrawCall();
        currentGroup.texArray = new BatchTextureArray();
      }
      currentGroup.texArray.count = 0;
      currentGroup.start = 0;
      currentGroup.size = 0;
      currentGroup.type = DRAW_MODES$4.TRIANGLES;
      var textureCount = 0;
      var currentTexture = null;
      var textureId = 0;
      var native2 = false;
      var drawMode = DRAW_MODES$4.TRIANGLES;
      var index2 = 0;
      this.drawCalls.push(currentGroup);
      for (var i2 = 0; i2 < this.batches.length; i2++) {
        var data2 = this.batches[i2];
        var MAX_TEXTURES = 8;
        var style = data2.style;
        var nextTexture = style.texture.baseTexture;
        if (native2 !== !!style.native) {
          native2 = !!style.native;
          drawMode = native2 ? DRAW_MODES$4.LINES : DRAW_MODES$4.TRIANGLES;
          currentTexture = null;
          textureCount = MAX_TEXTURES;
          TICK++;
        }
        if (currentTexture !== nextTexture) {
          currentTexture = nextTexture;
          if (nextTexture._batchEnabled !== TICK) {
            if (textureCount === MAX_TEXTURES) {
              TICK++;
              textureCount = 0;
              if (currentGroup.size > 0) {
                currentGroup = DRAW_CALL_POOL.pop();
                if (!currentGroup) {
                  currentGroup = new BatchDrawCall();
                  currentGroup.texArray = new BatchTextureArray();
                }
                this.drawCalls.push(currentGroup);
              }
              currentGroup.start = index2;
              currentGroup.size = 0;
              currentGroup.texArray.count = 0;
              currentGroup.type = drawMode;
            }
            nextTexture.touched = 1;
            nextTexture._batchEnabled = TICK;
            nextTexture._batchLocation = textureCount;
            nextTexture.wrapMode = WRAP_MODES$4.REPEAT;
            currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;
            textureCount++;
          }
        }
        currentGroup.size += data2.size;
        index2 += data2.size;
        textureId = nextTexture._batchLocation;
        this.addColors(colors, style.color, style.alpha, data2.attribSize, data2.attribStart);
        this.addTextureIds(textureIds, textureId, data2.attribSize, data2.attribStart);
      }
      BaseTexture._globalBatch = TICK;
      this.packAttributes();
    };
    GraphicsGeometry2.prototype.packAttributes = function() {
      var verts = this.points;
      var uvs = this.uvs;
      var colors = this.colors;
      var textureIds = this.textureIds;
      var glPoints = new ArrayBuffer(verts.length * 3 * 4);
      var f32 = new Float32Array(glPoints);
      var u32 = new Uint32Array(glPoints);
      var p = 0;
      for (var i2 = 0; i2 < verts.length / 2; i2++) {
        f32[p++] = verts[i2 * 2];
        f32[p++] = verts[i2 * 2 + 1];
        f32[p++] = uvs[i2 * 2];
        f32[p++] = uvs[i2 * 2 + 1];
        u32[p++] = colors[i2];
        f32[p++] = textureIds[i2];
      }
      this._buffer.update(glPoints);
      this._indexBuffer.update(this.indicesUint16);
    };
    GraphicsGeometry2.prototype.processFill = function(data2) {
      if (data2.holes.length) {
        buildPoly.triangulate(data2, this);
      } else {
        var command = FILL_COMMANDS[data2.type];
        command.triangulate(data2, this);
      }
    };
    GraphicsGeometry2.prototype.processLine = function(data2) {
      buildLine(data2, this);
      for (var i2 = 0; i2 < data2.holes.length; i2++) {
        buildLine(data2.holes[i2], this);
      }
    };
    GraphicsGeometry2.prototype.processHoles = function(holes) {
      for (var i2 = 0; i2 < holes.length; i2++) {
        var hole = holes[i2];
        var command = FILL_COMMANDS[hole.type];
        command.build(hole);
        if (hole.matrix) {
          this.transformPoints(hole.points, hole.matrix);
        }
      }
    };
    GraphicsGeometry2.prototype.calculateBounds = function() {
      var bounds = this._bounds;
      var sequenceBounds = tmpBounds;
      var curMatrix = Matrix.IDENTITY;
      this._bounds.clear();
      sequenceBounds.clear();
      for (var i2 = 0; i2 < this.graphicsData.length; i2++) {
        var data2 = this.graphicsData[i2];
        var shape = data2.shape;
        var type2 = data2.type;
        var lineStyle = data2.lineStyle;
        var nextMatrix = data2.matrix || Matrix.IDENTITY;
        var lineWidth = 0;
        if (lineStyle && lineStyle.visible) {
          lineWidth = lineStyle.width;
          if (type2 !== SHAPES.POLY || data2.fillStyle.visible) {
            lineWidth *= Math.max(0, lineStyle.alignment);
          } else {
            lineWidth *= Math.max(lineStyle.alignment, 1 - lineStyle.alignment);
          }
        }
        if (curMatrix !== nextMatrix) {
          if (!sequenceBounds.isEmpty()) {
            bounds.addBoundsMatrix(sequenceBounds, curMatrix);
            sequenceBounds.clear();
          }
          curMatrix = nextMatrix;
        }
        if (type2 === SHAPES.RECT || type2 === SHAPES.RREC) {
          var rect = shape;
          sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, lineWidth, lineWidth);
        } else if (type2 === SHAPES.CIRC) {
          var circle = shape;
          sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y, circle.radius + lineWidth, circle.radius + lineWidth);
        } else if (type2 === SHAPES.ELIP) {
          var ellipse = shape;
          sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y, ellipse.width + lineWidth, ellipse.height + lineWidth);
        } else {
          var poly = shape;
          bounds.addVerticesMatrix(curMatrix, poly.points, 0, poly.points.length, lineWidth, lineWidth);
        }
      }
      if (!sequenceBounds.isEmpty()) {
        bounds.addBoundsMatrix(sequenceBounds, curMatrix);
      }
      bounds.pad(this.boundsPadding, this.boundsPadding);
    };
    GraphicsGeometry2.prototype.transformPoints = function(points, matrix) {
      for (var i2 = 0; i2 < points.length / 2; i2++) {
        var x = points[i2 * 2];
        var y2 = points[i2 * 2 + 1];
        points[i2 * 2] = matrix.a * x + matrix.c * y2 + matrix.tx;
        points[i2 * 2 + 1] = matrix.b * x + matrix.d * y2 + matrix.ty;
      }
    };
    GraphicsGeometry2.prototype.addColors = function(colors, color2, alpha2, size, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var rgb = (color2 >> 16) + (color2 & 65280) + ((color2 & 255) << 16);
      var rgba2 = premultiplyTint(rgb, alpha2);
      colors.length = Math.max(colors.length, offset + size);
      for (var i2 = 0; i2 < size; i2++) {
        colors[offset + i2] = rgba2;
      }
    };
    GraphicsGeometry2.prototype.addTextureIds = function(textureIds, id2, size, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      textureIds.length = Math.max(textureIds.length, offset + size);
      for (var i2 = 0; i2 < size; i2++) {
        textureIds[offset + i2] = id2;
      }
    };
    GraphicsGeometry2.prototype.addUvs = function(verts, uvs, texture, start, size, matrix) {
      if (matrix === void 0) {
        matrix = null;
      }
      var index2 = 0;
      var uvsStart = uvs.length;
      var frame2 = texture.frame;
      while (index2 < size) {
        var x = verts[(start + index2) * 2];
        var y2 = verts[(start + index2) * 2 + 1];
        if (matrix) {
          var nx = matrix.a * x + matrix.c * y2 + matrix.tx;
          y2 = matrix.b * x + matrix.d * y2 + matrix.ty;
          x = nx;
        }
        index2++;
        uvs.push(x / frame2.width, y2 / frame2.height);
      }
      var baseTexture = texture.baseTexture;
      if (frame2.width < baseTexture.width || frame2.height < baseTexture.height) {
        this.adjustUvs(uvs, texture, uvsStart, size);
      }
    };
    GraphicsGeometry2.prototype.adjustUvs = function(uvs, texture, start, size) {
      var baseTexture = texture.baseTexture;
      var eps = 1e-6;
      var finish = start + size * 2;
      var frame2 = texture.frame;
      var scaleX = frame2.width / baseTexture.width;
      var scaleY = frame2.height / baseTexture.height;
      var offsetX = frame2.x / frame2.width;
      var offsetY = frame2.y / frame2.height;
      var minX = Math.floor(uvs[start] + eps);
      var minY = Math.floor(uvs[start + 1] + eps);
      for (var i2 = start + 2; i2 < finish; i2 += 2) {
        minX = Math.min(minX, Math.floor(uvs[i2] + eps));
        minY = Math.min(minY, Math.floor(uvs[i2 + 1] + eps));
      }
      offsetX -= minX;
      offsetY -= minY;
      for (var i2 = start; i2 < finish; i2 += 2) {
        uvs[i2] = (uvs[i2] + offsetX) * scaleX;
        uvs[i2 + 1] = (uvs[i2 + 1] + offsetY) * scaleY;
      }
    };
    GraphicsGeometry2.BATCHABLE_SIZE = 100;
    return GraphicsGeometry2;
  }(BatchGeometry)
);
var LineStyle = (
  /** @class */
  function(_super) {
    __extends$Q(LineStyle2, _super);
    function LineStyle2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.width = 0;
      _this.alignment = 0.5;
      _this.native = false;
      _this.cap = LINE_CAP.BUTT;
      _this.join = LINE_JOIN.MITER;
      _this.miterLimit = 10;
      return _this;
    }
    LineStyle2.prototype.clone = function() {
      var obj = new LineStyle2();
      obj.color = this.color;
      obj.alpha = this.alpha;
      obj.texture = this.texture;
      obj.matrix = this.matrix;
      obj.visible = this.visible;
      obj.width = this.width;
      obj.alignment = this.alignment;
      obj.native = this.native;
      obj.cap = this.cap;
      obj.join = this.join;
      obj.miterLimit = this.miterLimit;
      return obj;
    };
    LineStyle2.prototype.reset = function() {
      _super.prototype.reset.call(this);
      this.color = 0;
      this.alignment = 0.5;
      this.width = 0;
      this.native = false;
    };
    return LineStyle2;
  }(FillStyle)
);
var temp = new Float32Array(3);
var DEFAULT_SHADERS = {};
var Graphics = (
  /** @class */
  function(_super) {
    __extends$Q(Graphics2, _super);
    function Graphics2(geometry) {
      if (geometry === void 0) {
        geometry = null;
      }
      var _this = _super.call(this) || this;
      _this.shader = null;
      _this.pluginName = "batch";
      _this.currentPath = null;
      _this.batches = [];
      _this.batchTint = -1;
      _this.batchDirty = -1;
      _this.vertexData = null;
      _this._fillStyle = new FillStyle();
      _this._lineStyle = new LineStyle();
      _this._matrix = null;
      _this._holeMode = false;
      _this.state = State.for2d();
      _this._geometry = geometry || new GraphicsGeometry();
      _this._geometry.refCount++;
      _this._transformID = -1;
      _this.tint = 16777215;
      _this.blendMode = BLEND_MODES$4.NORMAL;
      return _this;
    }
    Object.defineProperty(Graphics2.prototype, "geometry", {
      /**
       * Includes vertex positions, face indices, normals, colors, UVs, and
       * custom attributes within buffers, reducing the cost of passing all
       * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.
       * @readonly
       */
      get: function() {
        return this._geometry;
      },
      enumerable: false,
      configurable: true
    });
    Graphics2.prototype.clone = function() {
      this.finishPoly();
      return new Graphics2(this._geometry);
    };
    Object.defineProperty(Graphics2.prototype, "blendMode", {
      get: function() {
        return this.state.blendMode;
      },
      /**
       * The blend mode to be applied to the graphic shape. Apply a value of
       * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each
       * primitive in the GraphicsGeometry list is rendered sequentially, modes
       * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will
       * be applied per-primitive.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      set: function(value) {
        this.state.blendMode = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Graphics2.prototype, "tint", {
      /**
       * The tint applied to each graphic shape. This is a hex value. A value of
       * 0xFFFFFF will remove any tint effect.
       * @default 0xFFFFFF
       */
      get: function() {
        return this._tint;
      },
      set: function(value) {
        this._tint = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Graphics2.prototype, "fill", {
      /**
       * The current fill style.
       * @readonly
       */
      get: function() {
        return this._fillStyle;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Graphics2.prototype, "line", {
      /**
       * The current line style.
       * @readonly
       */
      get: function() {
        return this._lineStyle;
      },
      enumerable: false,
      configurable: true
    });
    Graphics2.prototype.lineStyle = function(options, color2, alpha2, alignment, native2) {
      if (options === void 0) {
        options = null;
      }
      if (color2 === void 0) {
        color2 = 0;
      }
      if (alpha2 === void 0) {
        alpha2 = 1;
      }
      if (alignment === void 0) {
        alignment = 0.5;
      }
      if (native2 === void 0) {
        native2 = false;
      }
      if (typeof options === "number") {
        options = { width: options, color: color2, alpha: alpha2, alignment, native: native2 };
      }
      return this.lineTextureStyle(options);
    };
    Graphics2.prototype.lineTextureStyle = function(options) {
      options = Object.assign({
        width: 0,
        texture: Texture.WHITE,
        color: options && options.texture ? 16777215 : 0,
        alpha: 1,
        matrix: null,
        alignment: 0.5,
        native: false,
        cap: LINE_CAP.BUTT,
        join: LINE_JOIN.MITER,
        miterLimit: 10
      }, options);
      if (this.currentPath) {
        this.startPoly();
      }
      var visible = options.width > 0 && options.alpha > 0;
      if (!visible) {
        this._lineStyle.reset();
      } else {
        if (options.matrix) {
          options.matrix = options.matrix.clone();
          options.matrix.invert();
        }
        Object.assign(this._lineStyle, { visible }, options);
      }
      return this;
    };
    Graphics2.prototype.startPoly = function() {
      if (this.currentPath) {
        var points = this.currentPath.points;
        var len = this.currentPath.points.length;
        if (len > 2) {
          this.drawShape(this.currentPath);
          this.currentPath = new Polygon();
          this.currentPath.closeStroke = false;
          this.currentPath.points.push(points[len - 2], points[len - 1]);
        }
      } else {
        this.currentPath = new Polygon();
        this.currentPath.closeStroke = false;
      }
    };
    Graphics2.prototype.finishPoly = function() {
      if (this.currentPath) {
        if (this.currentPath.points.length > 2) {
          this.drawShape(this.currentPath);
          this.currentPath = null;
        } else {
          this.currentPath.points.length = 0;
        }
      }
    };
    Graphics2.prototype.moveTo = function(x, y2) {
      this.startPoly();
      this.currentPath.points[0] = x;
      this.currentPath.points[1] = y2;
      return this;
    };
    Graphics2.prototype.lineTo = function(x, y2) {
      if (!this.currentPath) {
        this.moveTo(0, 0);
      }
      var points = this.currentPath.points;
      var fromX = points[points.length - 2];
      var fromY = points[points.length - 1];
      if (fromX !== x || fromY !== y2) {
        points.push(x, y2);
      }
      return this;
    };
    Graphics2.prototype._initCurve = function(x, y2) {
      if (x === void 0) {
        x = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      if (this.currentPath) {
        if (this.currentPath.points.length === 0) {
          this.currentPath.points = [x, y2];
        }
      } else {
        this.moveTo(x, y2);
      }
    };
    Graphics2.prototype.quadraticCurveTo = function(cpX, cpY, toX, toY) {
      this._initCurve();
      var points = this.currentPath.points;
      if (points.length === 0) {
        this.moveTo(0, 0);
      }
      QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
      return this;
    };
    Graphics2.prototype.bezierCurveTo = function(cpX, cpY, cpX2, cpY2, toX, toY) {
      this._initCurve();
      BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
      return this;
    };
    Graphics2.prototype.arcTo = function(x1, y1, x2, y2, radius) {
      this._initCurve(x1, y1);
      var points = this.currentPath.points;
      var result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
      if (result) {
        var cx = result.cx, cy = result.cy, radius_1 = result.radius, startAngle = result.startAngle, endAngle = result.endAngle, anticlockwise = result.anticlockwise;
        this.arc(cx, cy, radius_1, startAngle, endAngle, anticlockwise);
      }
      return this;
    };
    Graphics2.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise) {
      if (anticlockwise === void 0) {
        anticlockwise = false;
      }
      if (startAngle === endAngle) {
        return this;
      }
      if (!anticlockwise && endAngle <= startAngle) {
        endAngle += PI_2;
      } else if (anticlockwise && startAngle <= endAngle) {
        startAngle += PI_2;
      }
      var sweep = endAngle - startAngle;
      if (sweep === 0) {
        return this;
      }
      var startX = cx + Math.cos(startAngle) * radius;
      var startY = cy + Math.sin(startAngle) * radius;
      var eps = this._geometry.closePointEps;
      var points = this.currentPath ? this.currentPath.points : null;
      if (points) {
        var xDiff = Math.abs(points[points.length - 2] - startX);
        var yDiff = Math.abs(points[points.length - 1] - startY);
        if (xDiff < eps && yDiff < eps)
          ;
        else {
          points.push(startX, startY);
        }
      } else {
        this.moveTo(startX, startY);
        points = this.currentPath.points;
      }
      ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
      return this;
    };
    Graphics2.prototype.beginFill = function(color2, alpha2) {
      if (color2 === void 0) {
        color2 = 0;
      }
      if (alpha2 === void 0) {
        alpha2 = 1;
      }
      return this.beginTextureFill({ texture: Texture.WHITE, color: color2, alpha: alpha2 });
    };
    Graphics2.prototype.beginTextureFill = function(options) {
      options = Object.assign({
        texture: Texture.WHITE,
        color: 16777215,
        alpha: 1,
        matrix: null
      }, options);
      if (this.currentPath) {
        this.startPoly();
      }
      var visible = options.alpha > 0;
      if (!visible) {
        this._fillStyle.reset();
      } else {
        if (options.matrix) {
          options.matrix = options.matrix.clone();
          options.matrix.invert();
        }
        Object.assign(this._fillStyle, { visible }, options);
      }
      return this;
    };
    Graphics2.prototype.endFill = function() {
      this.finishPoly();
      this._fillStyle.reset();
      return this;
    };
    Graphics2.prototype.drawRect = function(x, y2, width, height) {
      return this.drawShape(new Rectangle(x, y2, width, height));
    };
    Graphics2.prototype.drawRoundedRect = function(x, y2, width, height, radius) {
      return this.drawShape(new RoundedRectangle(x, y2, width, height, radius));
    };
    Graphics2.prototype.drawCircle = function(x, y2, radius) {
      return this.drawShape(new Circle(x, y2, radius));
    };
    Graphics2.prototype.drawEllipse = function(x, y2, width, height) {
      return this.drawShape(new Ellipse(x, y2, width, height));
    };
    Graphics2.prototype.drawPolygon = function() {
      var arguments$1 = arguments;
      var path = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        path[_i] = arguments$1[_i];
      }
      var points;
      var closeStroke = true;
      var poly = path[0];
      if (poly.points) {
        closeStroke = poly.closeStroke;
        points = poly.points;
      } else if (Array.isArray(path[0])) {
        points = path[0];
      } else {
        points = path;
      }
      var shape = new Polygon(points);
      shape.closeStroke = closeStroke;
      this.drawShape(shape);
      return this;
    };
    Graphics2.prototype.drawShape = function(shape) {
      if (!this._holeMode) {
        this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
      } else {
        this._geometry.drawHole(shape, this._matrix);
      }
      return this;
    };
    Graphics2.prototype.clear = function() {
      this._geometry.clear();
      this._lineStyle.reset();
      this._fillStyle.reset();
      this._boundsID++;
      this._matrix = null;
      this._holeMode = false;
      this.currentPath = null;
      return this;
    };
    Graphics2.prototype.isFastRect = function() {
      var data2 = this._geometry.graphicsData;
      return data2.length === 1 && data2[0].shape.type === SHAPES.RECT && !data2[0].matrix && !data2[0].holes.length && !(data2[0].lineStyle.visible && data2[0].lineStyle.width);
    };
    Graphics2.prototype._render = function(renderer) {
      this.finishPoly();
      var geometry = this._geometry;
      var hasuint32 = renderer.context.supports.uint32Indices;
      geometry.updateBatches(hasuint32);
      if (geometry.batchable) {
        if (this.batchDirty !== geometry.batchDirty) {
          this._populateBatches();
        }
        this._renderBatched(renderer);
      } else {
        renderer.batch.flush();
        this._renderDirect(renderer);
      }
    };
    Graphics2.prototype._populateBatches = function() {
      var geometry = this._geometry;
      var blendMode = this.blendMode;
      var len = geometry.batches.length;
      this.batchTint = -1;
      this._transformID = -1;
      this.batchDirty = geometry.batchDirty;
      this.batches.length = len;
      this.vertexData = new Float32Array(geometry.points);
      for (var i2 = 0; i2 < len; i2++) {
        var gI = geometry.batches[i2];
        var color2 = gI.style.color;
        var vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
        var uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
        var indices3 = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
        var batch2 = {
          vertexData,
          blendMode,
          indices: indices3,
          uvs,
          _batchRGB: hex2rgb(color2),
          _tintRGB: color2,
          _texture: gI.style.texture,
          alpha: gI.style.alpha,
          worldAlpha: 1
        };
        this.batches[i2] = batch2;
      }
    };
    Graphics2.prototype._renderBatched = function(renderer) {
      if (!this.batches.length) {
        return;
      }
      renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
      this.calculateVertices();
      this.calculateTints();
      for (var i2 = 0, l2 = this.batches.length; i2 < l2; i2++) {
        var batch2 = this.batches[i2];
        batch2.worldAlpha = this.worldAlpha * batch2.alpha;
        renderer.plugins[this.pluginName].render(batch2);
      }
    };
    Graphics2.prototype._renderDirect = function(renderer) {
      var shader = this._resolveDirectShader(renderer);
      var geometry = this._geometry;
      var tint = this.tint;
      var worldAlpha = this.worldAlpha;
      var uniforms = shader.uniforms;
      var drawCalls = geometry.drawCalls;
      uniforms.translationMatrix = this.transform.worldTransform;
      uniforms.tint[0] = (tint >> 16 & 255) / 255 * worldAlpha;
      uniforms.tint[1] = (tint >> 8 & 255) / 255 * worldAlpha;
      uniforms.tint[2] = (tint & 255) / 255 * worldAlpha;
      uniforms.tint[3] = worldAlpha;
      renderer.shader.bind(shader);
      renderer.geometry.bind(geometry, shader);
      renderer.state.set(this.state);
      for (var i2 = 0, l2 = drawCalls.length; i2 < l2; i2++) {
        this._renderDrawCallDirect(renderer, geometry.drawCalls[i2]);
      }
    };
    Graphics2.prototype._renderDrawCallDirect = function(renderer, drawCall) {
      var texArray = drawCall.texArray, type2 = drawCall.type, size = drawCall.size, start = drawCall.start;
      var groupTextureCount = texArray.count;
      for (var j2 = 0; j2 < groupTextureCount; j2++) {
        renderer.texture.bind(texArray.elements[j2], j2);
      }
      renderer.geometry.draw(type2, size, start);
    };
    Graphics2.prototype._resolveDirectShader = function(renderer) {
      var shader = this.shader;
      var pluginName = this.pluginName;
      if (!shader) {
        if (!DEFAULT_SHADERS[pluginName]) {
          var MAX_TEXTURES = renderer.plugins[pluginName].MAX_TEXTURES;
          var sampleValues = new Int32Array(MAX_TEXTURES);
          for (var i2 = 0; i2 < MAX_TEXTURES; i2++) {
            sampleValues[i2] = i2;
          }
          var uniforms = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new Matrix(),
            default: UniformGroup.from({ uSamplers: sampleValues }, true)
          };
          var program = renderer.plugins[pluginName]._shader.program;
          DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);
        }
        shader = DEFAULT_SHADERS[pluginName];
      }
      return shader;
    };
    Graphics2.prototype._calculateBounds = function() {
      this.finishPoly();
      var geometry = this._geometry;
      if (!geometry.graphicsData.length) {
        return;
      }
      var _a2 = geometry.bounds, minX = _a2.minX, minY = _a2.minY, maxX = _a2.maxX, maxY = _a2.maxY;
      this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
    };
    Graphics2.prototype.containsPoint = function(point) {
      this.worldTransform.applyInverse(point, Graphics2._TEMP_POINT);
      return this._geometry.containsPoint(Graphics2._TEMP_POINT);
    };
    Graphics2.prototype.calculateTints = function() {
      if (this.batchTint !== this.tint) {
        this.batchTint = this.tint;
        var tintRGB = hex2rgb(this.tint, temp);
        for (var i2 = 0; i2 < this.batches.length; i2++) {
          var batch2 = this.batches[i2];
          var batchTint = batch2._batchRGB;
          var r2 = tintRGB[0] * batchTint[0] * 255;
          var g2 = tintRGB[1] * batchTint[1] * 255;
          var b2 = tintRGB[2] * batchTint[2] * 255;
          var color2 = (r2 << 16) + (g2 << 8) + (b2 | 0);
          batch2._tintRGB = (color2 >> 16) + (color2 & 65280) + ((color2 & 255) << 16);
        }
      }
    };
    Graphics2.prototype.calculateVertices = function() {
      var wtID = this.transform._worldID;
      if (this._transformID === wtID) {
        return;
      }
      this._transformID = wtID;
      var wt = this.transform.worldTransform;
      var a2 = wt.a;
      var b2 = wt.b;
      var c2 = wt.c;
      var d2 = wt.d;
      var tx = wt.tx;
      var ty = wt.ty;
      var data2 = this._geometry.points;
      var vertexData = this.vertexData;
      var count = 0;
      for (var i2 = 0; i2 < data2.length; i2 += 2) {
        var x = data2[i2];
        var y2 = data2[i2 + 1];
        vertexData[count++] = a2 * x + c2 * y2 + tx;
        vertexData[count++] = d2 * y2 + b2 * x + ty;
      }
    };
    Graphics2.prototype.closePath = function() {
      var currentPath = this.currentPath;
      if (currentPath) {
        currentPath.closeStroke = true;
        this.finishPoly();
      }
      return this;
    };
    Graphics2.prototype.setMatrix = function(matrix) {
      this._matrix = matrix;
      return this;
    };
    Graphics2.prototype.beginHole = function() {
      this.finishPoly();
      this._holeMode = true;
      return this;
    };
    Graphics2.prototype.endHole = function() {
      this.finishPoly();
      this._holeMode = false;
      return this;
    };
    Graphics2.prototype.destroy = function(options) {
      this._geometry.refCount--;
      if (this._geometry.refCount === 0) {
        this._geometry.dispose();
      }
      this._matrix = null;
      this.currentPath = null;
      this._lineStyle.destroy();
      this._lineStyle = null;
      this._fillStyle.destroy();
      this._fillStyle = null;
      this._geometry = null;
      this.shader = null;
      this.vertexData = null;
      this.batches.length = 0;
      this.batches = null;
      _super.prototype.destroy.call(this, options);
    };
    Graphics2.nextRoundedRectBehavior = false;
    Graphics2._TEMP_POINT = new Point();
    return Graphics2;
  }(Container$1)
);
var graphicsUtils = {
  buildPoly,
  buildCircle,
  buildRectangle,
  buildRoundedRectangle,
  buildLine,
  ArcUtils,
  BezierUtils,
  QuadraticUtils,
  BatchPart,
  FILL_COMMANDS,
  BATCH_POOL,
  DRAW_CALL_POOL
};
/*!
 * @pixi/sprite - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/sprite is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$P = function(d2, b2) {
  extendStatics$P = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (b3.hasOwnProperty(p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$P(d2, b2);
};
function __extends$P(d2, b2) {
  extendStatics$P(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var tempPoint$2 = new Point();
var indices2 = new Uint16Array([0, 1, 2, 0, 2, 3]);
var Sprite = (
  /** @class */
  function(_super) {
    __extends$P(Sprite2, _super);
    function Sprite2(texture) {
      var _this = _super.call(this) || this;
      _this._anchor = new ObservablePoint(_this._onAnchorUpdate, _this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);
      _this._texture = null;
      _this._width = 0;
      _this._height = 0;
      _this._tint = null;
      _this._tintRGB = null;
      _this.tint = 16777215;
      _this.blendMode = BLEND_MODES$4.NORMAL;
      _this._cachedTint = 16777215;
      _this.uvs = null;
      _this.texture = texture || Texture.EMPTY;
      _this.vertexData = new Float32Array(8);
      _this.vertexTrimmedData = null;
      _this._transformID = -1;
      _this._textureID = -1;
      _this._transformTrimmedID = -1;
      _this._textureTrimmedID = -1;
      _this.indices = indices2;
      _this.pluginName = "batch";
      _this.isSprite = true;
      _this._roundPixels = settings$2.ROUND_PIXELS;
      return _this;
    }
    Sprite2.prototype._onTextureUpdate = function() {
      this._textureID = -1;
      this._textureTrimmedID = -1;
      this._cachedTint = 16777215;
      if (this._width) {
        this.scale.x = sign(this.scale.x) * this._width / this._texture.orig.width;
      }
      if (this._height) {
        this.scale.y = sign(this.scale.y) * this._height / this._texture.orig.height;
      }
    };
    Sprite2.prototype._onAnchorUpdate = function() {
      this._transformID = -1;
      this._transformTrimmedID = -1;
    };
    Sprite2.prototype.calculateVertices = function() {
      var texture = this._texture;
      if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
        return;
      }
      if (this._textureID !== texture._updateID) {
        this.uvs = this._texture._uvs.uvsFloat32;
      }
      this._transformID = this.transform._worldID;
      this._textureID = texture._updateID;
      var wt = this.transform.worldTransform;
      var a2 = wt.a;
      var b2 = wt.b;
      var c2 = wt.c;
      var d2 = wt.d;
      var tx = wt.tx;
      var ty = wt.ty;
      var vertexData = this.vertexData;
      var trim2 = texture.trim;
      var orig = texture.orig;
      var anchor = this._anchor;
      var w0 = 0;
      var w1 = 0;
      var h0 = 0;
      var h1 = 0;
      if (trim2) {
        w1 = trim2.x - anchor._x * orig.width;
        w0 = w1 + trim2.width;
        h1 = trim2.y - anchor._y * orig.height;
        h0 = h1 + trim2.height;
      } else {
        w1 = -anchor._x * orig.width;
        w0 = w1 + orig.width;
        h1 = -anchor._y * orig.height;
        h0 = h1 + orig.height;
      }
      vertexData[0] = a2 * w1 + c2 * h1 + tx;
      vertexData[1] = d2 * h1 + b2 * w1 + ty;
      vertexData[2] = a2 * w0 + c2 * h1 + tx;
      vertexData[3] = d2 * h1 + b2 * w0 + ty;
      vertexData[4] = a2 * w0 + c2 * h0 + tx;
      vertexData[5] = d2 * h0 + b2 * w0 + ty;
      vertexData[6] = a2 * w1 + c2 * h0 + tx;
      vertexData[7] = d2 * h0 + b2 * w1 + ty;
      if (this._roundPixels) {
        var resolution = settings$2.RESOLUTION;
        for (var i2 = 0; i2 < vertexData.length; ++i2) {
          vertexData[i2] = Math.round((vertexData[i2] * resolution | 0) / resolution);
        }
      }
    };
    Sprite2.prototype.calculateTrimmedVertices = function() {
      if (!this.vertexTrimmedData) {
        this.vertexTrimmedData = new Float32Array(8);
      } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
        return;
      }
      this._transformTrimmedID = this.transform._worldID;
      this._textureTrimmedID = this._texture._updateID;
      var texture = this._texture;
      var vertexData = this.vertexTrimmedData;
      var orig = texture.orig;
      var anchor = this._anchor;
      var wt = this.transform.worldTransform;
      var a2 = wt.a;
      var b2 = wt.b;
      var c2 = wt.c;
      var d2 = wt.d;
      var tx = wt.tx;
      var ty = wt.ty;
      var w1 = -anchor._x * orig.width;
      var w0 = w1 + orig.width;
      var h1 = -anchor._y * orig.height;
      var h0 = h1 + orig.height;
      vertexData[0] = a2 * w1 + c2 * h1 + tx;
      vertexData[1] = d2 * h1 + b2 * w1 + ty;
      vertexData[2] = a2 * w0 + c2 * h1 + tx;
      vertexData[3] = d2 * h1 + b2 * w0 + ty;
      vertexData[4] = a2 * w0 + c2 * h0 + tx;
      vertexData[5] = d2 * h0 + b2 * w0 + ty;
      vertexData[6] = a2 * w1 + c2 * h0 + tx;
      vertexData[7] = d2 * h0 + b2 * w1 + ty;
    };
    Sprite2.prototype._render = function(renderer) {
      this.calculateVertices();
      renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
      renderer.plugins[this.pluginName].render(this);
    };
    Sprite2.prototype._calculateBounds = function() {
      var trim2 = this._texture.trim;
      var orig = this._texture.orig;
      if (!trim2 || trim2.width === orig.width && trim2.height === orig.height) {
        this.calculateVertices();
        this._bounds.addQuad(this.vertexData);
      } else {
        this.calculateTrimmedVertices();
        this._bounds.addQuad(this.vertexTrimmedData);
      }
    };
    Sprite2.prototype.getLocalBounds = function(rect) {
      if (this.children.length === 0) {
        if (!this._localBounds) {
          this._localBounds = new Bounds$1();
        }
        this._localBounds.minX = this._texture.orig.width * -this._anchor._x;
        this._localBounds.minY = this._texture.orig.height * -this._anchor._y;
        this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
        this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
        if (!rect) {
          if (!this._localBoundsRect) {
            this._localBoundsRect = new Rectangle();
          }
          rect = this._localBoundsRect;
        }
        return this._localBounds.getRectangle(rect);
      }
      return _super.prototype.getLocalBounds.call(this, rect);
    };
    Sprite2.prototype.containsPoint = function(point) {
      this.worldTransform.applyInverse(point, tempPoint$2);
      var width = this._texture.orig.width;
      var height = this._texture.orig.height;
      var x1 = -width * this.anchor.x;
      var y1 = 0;
      if (tempPoint$2.x >= x1 && tempPoint$2.x < x1 + width) {
        y1 = -height * this.anchor.y;
        if (tempPoint$2.y >= y1 && tempPoint$2.y < y1 + height) {
          return true;
        }
      }
      return false;
    };
    Sprite2.prototype.destroy = function(options) {
      _super.prototype.destroy.call(this, options);
      this._texture.off("update", this._onTextureUpdate, this);
      this._anchor = null;
      var destroyTexture = typeof options === "boolean" ? options : options && options.texture;
      if (destroyTexture) {
        var destroyBaseTexture = typeof options === "boolean" ? options : options && options.baseTexture;
        this._texture.destroy(!!destroyBaseTexture);
      }
      this._texture = null;
    };
    Sprite2.from = function(source, options) {
      var texture = source instanceof Texture ? source : Texture.from(source, options);
      return new Sprite2(texture);
    };
    Object.defineProperty(Sprite2.prototype, "roundPixels", {
      get: function() {
        return this._roundPixels;
      },
      /**
       * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
       *
       * Advantages can include sharper image quality (like text) and faster rendering on canvas.
       * The main disadvantage is movement of objects may appear less smooth.
       *
       * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}.
       * @default false
       */
      set: function(value) {
        if (this._roundPixels !== value) {
          this._transformID = -1;
        }
        this._roundPixels = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "width", {
      /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return Math.abs(this.scale.x) * this._texture.orig.width;
      },
      set: function(value) {
        var s2 = sign(this.scale.x) || 1;
        this.scale.x = s2 * value / this._texture.orig.width;
        this._width = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "height", {
      /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return Math.abs(this.scale.y) * this._texture.orig.height;
      },
      set: function(value) {
        var s2 = sign(this.scale.y) || 1;
        this.scale.y = s2 * value / this._texture.orig.height;
        this._height = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "anchor", {
      /**
       * The anchor sets the origin point of the sprite. The default value is taken from the {@link PIXI.Texture|Texture}
       * and passed to the constructor.
       *
       * The default is `(0,0)`, this means the sprite's origin is the top left.
       *
       * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
       *
       * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
       *
       * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
       * @example
       * const sprite = new PIXI.Sprite(texture);
       * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
       */
      get: function() {
        return this._anchor;
      },
      set: function(value) {
        this._anchor.copyFrom(value);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "tint", {
      /**
       * The tint applied to the sprite. This is a hex value.
       *
       * A value of 0xFFFFFF will remove any tint effect.
       * @default 0xFFFFFF
       */
      get: function() {
        return this._tint;
      },
      set: function(value) {
        this._tint = value;
        this._tintRGB = (value >> 16) + (value & 65280) + ((value & 255) << 16);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sprite2.prototype, "texture", {
      /** The texture that the sprite is using. */
      get: function() {
        return this._texture;
      },
      set: function(value) {
        if (this._texture === value) {
          return;
        }
        if (this._texture) {
          this._texture.off("update", this._onTextureUpdate, this);
        }
        this._texture = value || Texture.EMPTY;
        this._cachedTint = 16777215;
        this._textureID = -1;
        this._textureTrimmedID = -1;
        if (value) {
          if (value.baseTexture.valid) {
            this._onTextureUpdate();
          } else {
            value.once("update", this._onTextureUpdate, this);
          }
        }
      },
      enumerable: false,
      configurable: true
    });
    return Sprite2;
  }(Container$1)
);
/*!
 * @pixi/text - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/text is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$O = function(d2, b2) {
  extendStatics$O = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (b3.hasOwnProperty(p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$O(d2, b2);
};
function __extends$O(d2, b2) {
  extendStatics$O(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var TEXT_GRADIENT;
(function(TEXT_GRADIENT2) {
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";
})(TEXT_GRADIENT || (TEXT_GRADIENT = {}));
var defaultStyle = {
  align: "left",
  breakWords: false,
  dropShadow: false,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: false,
  whiteSpace: "pre",
  wordWrap: false,
  wordWrapWidth: 100,
  leading: 0
};
var genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
var TextStyle = (
  /** @class */
  function() {
    function TextStyle2(style) {
      this.styleID = 0;
      this.reset();
      deepCopyProperties(this, style, style);
    }
    TextStyle2.prototype.clone = function() {
      var clonedProperties = {};
      deepCopyProperties(clonedProperties, this, defaultStyle);
      return new TextStyle2(clonedProperties);
    };
    TextStyle2.prototype.reset = function() {
      deepCopyProperties(this, defaultStyle, defaultStyle);
    };
    Object.defineProperty(TextStyle2.prototype, "align", {
      /**
       * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
       *
       * @member {string}
       */
      get: function() {
        return this._align;
      },
      set: function(align) {
        if (this._align !== align) {
          this._align = align;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "breakWords", {
      /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
      get: function() {
        return this._breakWords;
      },
      set: function(breakWords) {
        if (this._breakWords !== breakWords) {
          this._breakWords = breakWords;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "dropShadow", {
      /** Set a drop shadow for the text. */
      get: function() {
        return this._dropShadow;
      },
      set: function(dropShadow) {
        if (this._dropShadow !== dropShadow) {
          this._dropShadow = dropShadow;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "dropShadowAlpha", {
      /** Set alpha for the drop shadow. */
      get: function() {
        return this._dropShadowAlpha;
      },
      set: function(dropShadowAlpha) {
        if (this._dropShadowAlpha !== dropShadowAlpha) {
          this._dropShadowAlpha = dropShadowAlpha;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "dropShadowAngle", {
      /** Set a angle of the drop shadow. */
      get: function() {
        return this._dropShadowAngle;
      },
      set: function(dropShadowAngle) {
        if (this._dropShadowAngle !== dropShadowAngle) {
          this._dropShadowAngle = dropShadowAngle;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "dropShadowBlur", {
      /** Set a shadow blur radius. */
      get: function() {
        return this._dropShadowBlur;
      },
      set: function(dropShadowBlur) {
        if (this._dropShadowBlur !== dropShadowBlur) {
          this._dropShadowBlur = dropShadowBlur;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "dropShadowColor", {
      /** A fill style to be used on the dropshadow e.g 'red', '#00FF00'. */
      get: function() {
        return this._dropShadowColor;
      },
      set: function(dropShadowColor) {
        var outputColor = getColor(dropShadowColor);
        if (this._dropShadowColor !== outputColor) {
          this._dropShadowColor = outputColor;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "dropShadowDistance", {
      /** Set a distance of the drop shadow. */
      get: function() {
        return this._dropShadowDistance;
      },
      set: function(dropShadowDistance) {
        if (this._dropShadowDistance !== dropShadowDistance) {
          this._dropShadowDistance = dropShadowDistance;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "fill", {
      /**
       * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.
       *
       * Can be an array to create a gradient eg ['#000000','#FFFFFF']
       * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
       *
       * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
       */
      get: function() {
        return this._fill;
      },
      set: function(fill) {
        var outputColor = getColor(fill);
        if (this._fill !== outputColor) {
          this._fill = outputColor;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "fillGradientType", {
      /**
       * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.
       *
       * @see PIXI.TEXT_GRADIENT
       */
      get: function() {
        return this._fillGradientType;
      },
      set: function(fillGradientType) {
        if (this._fillGradientType !== fillGradientType) {
          this._fillGradientType = fillGradientType;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "fillGradientStops", {
      /**
       * If fill is an array of colours to create a gradient, this array can set the stop points
       * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
       */
      get: function() {
        return this._fillGradientStops;
      },
      set: function(fillGradientStops) {
        if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
          this._fillGradientStops = fillGradientStops;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "fontFamily", {
      /** The font family. */
      get: function() {
        return this._fontFamily;
      },
      set: function(fontFamily) {
        if (this.fontFamily !== fontFamily) {
          this._fontFamily = fontFamily;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "fontSize", {
      /**
       * The font size
       * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')
       */
      get: function() {
        return this._fontSize;
      },
      set: function(fontSize) {
        if (this._fontSize !== fontSize) {
          this._fontSize = fontSize;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "fontStyle", {
      /**
       * The font style
       * ('normal', 'italic' or 'oblique')
       *
       * @member {string}
       */
      get: function() {
        return this._fontStyle;
      },
      set: function(fontStyle) {
        if (this._fontStyle !== fontStyle) {
          this._fontStyle = fontStyle;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "fontVariant", {
      /**
       * The font variant
       * ('normal' or 'small-caps')
       *
       * @member {string}
       */
      get: function() {
        return this._fontVariant;
      },
      set: function(fontVariant) {
        if (this._fontVariant !== fontVariant) {
          this._fontVariant = fontVariant;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "fontWeight", {
      /**
       * The font weight
       * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')
       *
       * @member {string}
       */
      get: function() {
        return this._fontWeight;
      },
      set: function(fontWeight) {
        if (this._fontWeight !== fontWeight) {
          this._fontWeight = fontWeight;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "letterSpacing", {
      /** The amount of spacing between letters, default is 0. */
      get: function() {
        return this._letterSpacing;
      },
      set: function(letterSpacing) {
        if (this._letterSpacing !== letterSpacing) {
          this._letterSpacing = letterSpacing;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "lineHeight", {
      /** The line height, a number that represents the vertical space that a letter uses. */
      get: function() {
        return this._lineHeight;
      },
      set: function(lineHeight) {
        if (this._lineHeight !== lineHeight) {
          this._lineHeight = lineHeight;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "leading", {
      /** The space between lines. */
      get: function() {
        return this._leading;
      },
      set: function(leading) {
        if (this._leading !== leading) {
          this._leading = leading;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "lineJoin", {
      /**
       * The lineJoin property sets the type of corner created, it can resolve spiked text issues.
       * Default is 'miter' (creates a sharp corner).
       *
       * @member {string}
       */
      get: function() {
        return this._lineJoin;
      },
      set: function(lineJoin) {
        if (this._lineJoin !== lineJoin) {
          this._lineJoin = lineJoin;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "miterLimit", {
      /**
       * The miter limit to use when using the 'miter' lineJoin mode.
       *
       * This can reduce or increase the spikiness of rendered text.
       */
      get: function() {
        return this._miterLimit;
      },
      set: function(miterLimit) {
        if (this._miterLimit !== miterLimit) {
          this._miterLimit = miterLimit;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "padding", {
      /**
       * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
       * by adding padding to all sides of the text.
       */
      get: function() {
        return this._padding;
      },
      set: function(padding) {
        if (this._padding !== padding) {
          this._padding = padding;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "stroke", {
      /**
       * A canvas fillstyle that will be used on the text stroke
       * e.g 'blue', '#FCFF00'
       */
      get: function() {
        return this._stroke;
      },
      set: function(stroke) {
        var outputColor = getColor(stroke);
        if (this._stroke !== outputColor) {
          this._stroke = outputColor;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "strokeThickness", {
      /**
       * A number that represents the thickness of the stroke.
       *
       * @default 0
       */
      get: function() {
        return this._strokeThickness;
      },
      set: function(strokeThickness) {
        if (this._strokeThickness !== strokeThickness) {
          this._strokeThickness = strokeThickness;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "textBaseline", {
      /**
       * The baseline of the text that is rendered.
       *
       * @member {string}
       */
      get: function() {
        return this._textBaseline;
      },
      set: function(textBaseline) {
        if (this._textBaseline !== textBaseline) {
          this._textBaseline = textBaseline;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "trim", {
      /** Trim transparent borders. */
      get: function() {
        return this._trim;
      },
      set: function(trim2) {
        if (this._trim !== trim2) {
          this._trim = trim2;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "whiteSpace", {
      /**
       * How newlines and spaces should be handled.
       * Default is 'pre' (preserve, preserve).
       *
       *  value       | New lines     |   Spaces
       *  ---         | ---           |   ---
       * 'normal'     | Collapse      |   Collapse
       * 'pre'        | Preserve      |   Preserve
       * 'pre-line'   | Preserve      |   Collapse
       *
       * @member {string}
       */
      get: function() {
        return this._whiteSpace;
      },
      set: function(whiteSpace) {
        if (this._whiteSpace !== whiteSpace) {
          this._whiteSpace = whiteSpace;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "wordWrap", {
      /** Indicates if word wrap should be used. */
      get: function() {
        return this._wordWrap;
      },
      set: function(wordWrap) {
        if (this._wordWrap !== wordWrap) {
          this._wordWrap = wordWrap;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextStyle2.prototype, "wordWrapWidth", {
      /** The width at which text will wrap, it needs wordWrap to be set to true. */
      get: function() {
        return this._wordWrapWidth;
      },
      set: function(wordWrapWidth) {
        if (this._wordWrapWidth !== wordWrapWidth) {
          this._wordWrapWidth = wordWrapWidth;
          this.styleID++;
        }
      },
      enumerable: false,
      configurable: true
    });
    TextStyle2.prototype.toFontString = function() {
      var fontSizeString = typeof this.fontSize === "number" ? this.fontSize + "px" : this.fontSize;
      var fontFamilies = this.fontFamily;
      if (!Array.isArray(this.fontFamily)) {
        fontFamilies = this.fontFamily.split(",");
      }
      for (var i2 = fontFamilies.length - 1; i2 >= 0; i2--) {
        var fontFamily = fontFamilies[i2].trim();
        if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && genericFontFamilies.indexOf(fontFamily) < 0) {
          fontFamily = '"' + fontFamily + '"';
        }
        fontFamilies[i2] = fontFamily;
      }
      return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + fontSizeString + " " + fontFamilies.join(",");
    };
    return TextStyle2;
  }()
);
function getSingleColor(color2) {
  if (typeof color2 === "number") {
    return hex2string(color2);
  } else if (typeof color2 === "string") {
    if (color2.indexOf("0x") === 0) {
      color2 = color2.replace("0x", "#");
    }
  }
  return color2;
}
function getColor(color2) {
  if (!Array.isArray(color2)) {
    return getSingleColor(color2);
  } else {
    for (var i2 = 0; i2 < color2.length; ++i2) {
      color2[i2] = getSingleColor(color2[i2]);
    }
    return color2;
  }
}
function areArraysEqual(array1, array2) {
  if (!Array.isArray(array1) || !Array.isArray(array2)) {
    return false;
  }
  if (array1.length !== array2.length) {
    return false;
  }
  for (var i2 = 0; i2 < array1.length; ++i2) {
    if (array1[i2] !== array2[i2]) {
      return false;
    }
  }
  return true;
}
function deepCopyProperties(target, source, propertyObj) {
  for (var prop in propertyObj) {
    if (Array.isArray(source[prop])) {
      target[prop] = source[prop].slice();
    } else {
      target[prop] = source[prop];
    }
  }
}
var TextMetrics = (
  /** @class */
  function() {
    function TextMetrics2(text2, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
      this.text = text2;
      this.style = style;
      this.width = width;
      this.height = height;
      this.lines = lines;
      this.lineWidths = lineWidths;
      this.lineHeight = lineHeight;
      this.maxLineWidth = maxLineWidth;
      this.fontProperties = fontProperties;
    }
    TextMetrics2.measureText = function(text2, style, wordWrap, canvas) {
      if (canvas === void 0) {
        canvas = TextMetrics2._canvas;
      }
      wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;
      var font = style.toFontString();
      var fontProperties = TextMetrics2.measureFont(font);
      if (fontProperties.fontSize === 0) {
        fontProperties.fontSize = style.fontSize;
        fontProperties.ascent = style.fontSize;
      }
      var context2 = canvas.getContext("2d");
      context2.font = font;
      var outputText = wordWrap ? TextMetrics2.wordWrap(text2, style, canvas) : text2;
      var lines = outputText.split(/(?:\r\n|\r|\n)/);
      var lineWidths = new Array(lines.length);
      var maxLineWidth = 0;
      for (var i2 = 0; i2 < lines.length; i2++) {
        var lineWidth = context2.measureText(lines[i2]).width + (lines[i2].length - 1) * style.letterSpacing;
        lineWidths[i2] = lineWidth;
        maxLineWidth = Math.max(maxLineWidth, lineWidth);
      }
      var width = maxLineWidth + style.strokeThickness;
      if (style.dropShadow) {
        width += style.dropShadowDistance;
      }
      var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
      var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness) + (lines.length - 1) * (lineHeight + style.leading);
      if (style.dropShadow) {
        height += style.dropShadowDistance;
      }
      return new TextMetrics2(text2, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
    };
    TextMetrics2.wordWrap = function(text2, style, canvas) {
      if (canvas === void 0) {
        canvas = TextMetrics2._canvas;
      }
      var context2 = canvas.getContext("2d");
      var width = 0;
      var line2 = "";
      var lines = "";
      var cache = /* @__PURE__ */ Object.create(null);
      var letterSpacing = style.letterSpacing, whiteSpace = style.whiteSpace;
      var collapseSpaces = TextMetrics2.collapseSpaces(whiteSpace);
      var collapseNewlines = TextMetrics2.collapseNewlines(whiteSpace);
      var canPrependSpaces = !collapseSpaces;
      var wordWrapWidth = style.wordWrapWidth + letterSpacing;
      var tokens = TextMetrics2.tokenize(text2);
      for (var i2 = 0; i2 < tokens.length; i2++) {
        var token2 = tokens[i2];
        if (TextMetrics2.isNewline(token2)) {
          if (!collapseNewlines) {
            lines += TextMetrics2.addLine(line2);
            canPrependSpaces = !collapseSpaces;
            line2 = "";
            width = 0;
            continue;
          }
          token2 = " ";
        }
        if (collapseSpaces) {
          var currIsBreakingSpace = TextMetrics2.isBreakingSpace(token2);
          var lastIsBreakingSpace = TextMetrics2.isBreakingSpace(line2[line2.length - 1]);
          if (currIsBreakingSpace && lastIsBreakingSpace) {
            continue;
          }
        }
        var tokenWidth = TextMetrics2.getFromCache(token2, letterSpacing, cache, context2);
        if (tokenWidth > wordWrapWidth) {
          if (line2 !== "") {
            lines += TextMetrics2.addLine(line2);
            line2 = "";
            width = 0;
          }
          if (TextMetrics2.canBreakWords(token2, style.breakWords)) {
            var characters2 = TextMetrics2.wordWrapSplit(token2);
            for (var j2 = 0; j2 < characters2.length; j2++) {
              var char2 = characters2[j2];
              var k2 = 1;
              while (characters2[j2 + k2]) {
                var nextChar = characters2[j2 + k2];
                var lastChar = char2[char2.length - 1];
                if (!TextMetrics2.canBreakChars(lastChar, nextChar, token2, j2, style.breakWords)) {
                  char2 += nextChar;
                } else {
                  break;
                }
                k2++;
              }
              j2 += char2.length - 1;
              var characterWidth = TextMetrics2.getFromCache(char2, letterSpacing, cache, context2);
              if (characterWidth + width > wordWrapWidth) {
                lines += TextMetrics2.addLine(line2);
                canPrependSpaces = false;
                line2 = "";
                width = 0;
              }
              line2 += char2;
              width += characterWidth;
            }
          } else {
            if (line2.length > 0) {
              lines += TextMetrics2.addLine(line2);
              line2 = "";
              width = 0;
            }
            var isLastToken = i2 === tokens.length - 1;
            lines += TextMetrics2.addLine(token2, !isLastToken);
            canPrependSpaces = false;
            line2 = "";
            width = 0;
          }
        } else {
          if (tokenWidth + width > wordWrapWidth) {
            canPrependSpaces = false;
            lines += TextMetrics2.addLine(line2);
            line2 = "";
            width = 0;
          }
          if (line2.length > 0 || !TextMetrics2.isBreakingSpace(token2) || canPrependSpaces) {
            line2 += token2;
            width += tokenWidth;
          }
        }
      }
      lines += TextMetrics2.addLine(line2, false);
      return lines;
    };
    TextMetrics2.addLine = function(line2, newLine) {
      if (newLine === void 0) {
        newLine = true;
      }
      line2 = TextMetrics2.trimRight(line2);
      line2 = newLine ? line2 + "\n" : line2;
      return line2;
    };
    TextMetrics2.getFromCache = function(key, letterSpacing, cache, context2) {
      var width = cache[key];
      if (typeof width !== "number") {
        var spacing = key.length * letterSpacing;
        width = context2.measureText(key).width + spacing;
        cache[key] = width;
      }
      return width;
    };
    TextMetrics2.collapseSpaces = function(whiteSpace) {
      return whiteSpace === "normal" || whiteSpace === "pre-line";
    };
    TextMetrics2.collapseNewlines = function(whiteSpace) {
      return whiteSpace === "normal";
    };
    TextMetrics2.trimRight = function(text2) {
      if (typeof text2 !== "string") {
        return "";
      }
      for (var i2 = text2.length - 1; i2 >= 0; i2--) {
        var char2 = text2[i2];
        if (!TextMetrics2.isBreakingSpace(char2)) {
          break;
        }
        text2 = text2.slice(0, -1);
      }
      return text2;
    };
    TextMetrics2.isNewline = function(char2) {
      if (typeof char2 !== "string") {
        return false;
      }
      return TextMetrics2._newlines.indexOf(char2.charCodeAt(0)) >= 0;
    };
    TextMetrics2.isBreakingSpace = function(char2, _nextChar) {
      if (typeof char2 !== "string") {
        return false;
      }
      return TextMetrics2._breakingSpaces.indexOf(char2.charCodeAt(0)) >= 0;
    };
    TextMetrics2.tokenize = function(text2) {
      var tokens = [];
      var token2 = "";
      if (typeof text2 !== "string") {
        return tokens;
      }
      for (var i2 = 0; i2 < text2.length; i2++) {
        var char2 = text2[i2];
        var nextChar = text2[i2 + 1];
        if (TextMetrics2.isBreakingSpace(char2, nextChar) || TextMetrics2.isNewline(char2)) {
          if (token2 !== "") {
            tokens.push(token2);
            token2 = "";
          }
          tokens.push(char2);
          continue;
        }
        token2 += char2;
      }
      if (token2 !== "") {
        tokens.push(token2);
      }
      return tokens;
    };
    TextMetrics2.canBreakWords = function(_token, breakWords) {
      return breakWords;
    };
    TextMetrics2.canBreakChars = function(_char, _nextChar, _token, _index, _breakWords) {
      return true;
    };
    TextMetrics2.wordWrapSplit = function(token2) {
      return token2.split("");
    };
    TextMetrics2.measureFont = function(font) {
      if (TextMetrics2._fonts[font]) {
        return TextMetrics2._fonts[font];
      }
      var properties = {
        ascent: 0,
        descent: 0,
        fontSize: 0
      };
      var canvas = TextMetrics2._canvas;
      var context2 = TextMetrics2._context;
      context2.font = font;
      var metricsString = TextMetrics2.METRICS_STRING + TextMetrics2.BASELINE_SYMBOL;
      var width = Math.ceil(context2.measureText(metricsString).width);
      var baseline = Math.ceil(context2.measureText(TextMetrics2.BASELINE_SYMBOL).width);
      var height = Math.ceil(TextMetrics2.HEIGHT_MULTIPLIER * baseline);
      baseline = baseline * TextMetrics2.BASELINE_MULTIPLIER | 0;
      canvas.width = width;
      canvas.height = height;
      context2.fillStyle = "#f00";
      context2.fillRect(0, 0, width, height);
      context2.font = font;
      context2.textBaseline = "alphabetic";
      context2.fillStyle = "#000";
      context2.fillText(metricsString, 0, baseline);
      var imagedata = context2.getImageData(0, 0, width, height).data;
      var pixels = imagedata.length;
      var line2 = width * 4;
      var i2 = 0;
      var idx = 0;
      var stop = false;
      for (i2 = 0; i2 < baseline; ++i2) {
        for (var j2 = 0; j2 < line2; j2 += 4) {
          if (imagedata[idx + j2] !== 255) {
            stop = true;
            break;
          }
        }
        if (!stop) {
          idx += line2;
        } else {
          break;
        }
      }
      properties.ascent = baseline - i2;
      idx = pixels - line2;
      stop = false;
      for (i2 = height; i2 > baseline; --i2) {
        for (var j2 = 0; j2 < line2; j2 += 4) {
          if (imagedata[idx + j2] !== 255) {
            stop = true;
            break;
          }
        }
        if (!stop) {
          idx -= line2;
        } else {
          break;
        }
      }
      properties.descent = i2 - baseline;
      properties.fontSize = properties.ascent + properties.descent;
      TextMetrics2._fonts[font] = properties;
      return properties;
    };
    TextMetrics2.clearMetrics = function(font) {
      if (font === void 0) {
        font = "";
      }
      if (font) {
        delete TextMetrics2._fonts[font];
      } else {
        TextMetrics2._fonts = {};
      }
    };
    Object.defineProperty(TextMetrics2, "_canvas", {
      /**
       * Cached canvas element for measuring text
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      get: function() {
        if (!TextMetrics2.__canvas) {
          var canvas = void 0;
          try {
            var c2 = new OffscreenCanvas(0, 0);
            var context2 = c2.getContext("2d");
            if (context2 && context2.measureText) {
              TextMetrics2.__canvas = c2;
              return c2;
            }
            canvas = document.createElement("canvas");
          } catch (ex) {
            canvas = document.createElement("canvas");
          }
          canvas.width = canvas.height = 10;
          TextMetrics2.__canvas = canvas;
        }
        return TextMetrics2.__canvas;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextMetrics2, "_context", {
      /**
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      get: function() {
        if (!TextMetrics2.__context) {
          TextMetrics2.__context = TextMetrics2._canvas.getContext("2d");
        }
        return TextMetrics2.__context;
      },
      enumerable: false,
      configurable: true
    });
    return TextMetrics2;
  }()
);
TextMetrics._fonts = {};
TextMetrics.METRICS_STRING = "|q";
TextMetrics.BASELINE_SYMBOL = "M";
TextMetrics.BASELINE_MULTIPLIER = 1.4;
TextMetrics.HEIGHT_MULTIPLIER = 2;
TextMetrics._newlines = [
  10,
  13
];
TextMetrics._breakingSpaces = [
  9,
  32,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8200,
  8201,
  8202,
  8287,
  12288
];
var defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
};
var Text = (
  /** @class */
  function(_super) {
    __extends$O(Text2, _super);
    function Text2(text2, style, canvas) {
      var _this = this;
      var ownCanvas = false;
      if (!canvas) {
        canvas = document.createElement("canvas");
        ownCanvas = true;
      }
      canvas.width = 3;
      canvas.height = 3;
      var texture = Texture.from(canvas);
      texture.orig = new Rectangle();
      texture.trim = new Rectangle();
      _this = _super.call(this, texture) || this;
      _this._ownCanvas = ownCanvas;
      _this.canvas = canvas;
      _this.context = _this.canvas.getContext("2d");
      _this._resolution = settings$2.RESOLUTION;
      _this._autoResolution = true;
      _this._text = null;
      _this._style = null;
      _this._styleListener = null;
      _this._font = "";
      _this.text = text2;
      _this.style = style;
      _this.localStyleID = -1;
      return _this;
    }
    Text2.prototype.updateText = function(respectDirty) {
      var style = this._style;
      if (this.localStyleID !== style.styleID) {
        this.dirty = true;
        this.localStyleID = style.styleID;
      }
      if (!this.dirty && respectDirty) {
        return;
      }
      this._font = this._style.toFontString();
      var context2 = this.context;
      var measured = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);
      var width = measured.width;
      var height = measured.height;
      var lines = measured.lines;
      var lineHeight = measured.lineHeight;
      var lineWidths = measured.lineWidths;
      var maxLineWidth = measured.maxLineWidth;
      var fontProperties = measured.fontProperties;
      this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);
      this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);
      context2.scale(this._resolution, this._resolution);
      context2.clearRect(0, 0, this.canvas.width, this.canvas.height);
      context2.font = this._font;
      context2.lineWidth = style.strokeThickness;
      context2.textBaseline = style.textBaseline;
      context2.lineJoin = style.lineJoin;
      context2.miterLimit = style.miterLimit;
      var linePositionX;
      var linePositionY;
      var passesCount = style.dropShadow ? 2 : 1;
      for (var i2 = 0; i2 < passesCount; ++i2) {
        var isShadowPass = style.dropShadow && i2 === 0;
        var dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
        var dsOffsetShadow = dsOffsetText * this._resolution;
        if (isShadowPass) {
          context2.fillStyle = "black";
          context2.strokeStyle = "black";
          var dropShadowColor = style.dropShadowColor;
          var rgb = hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : string2hex(dropShadowColor));
          var dropShadowBlur = style.dropShadowBlur * this._resolution;
          var dropShadowDistance = style.dropShadowDistance * this._resolution;
          context2.shadowColor = "rgba(" + rgb[0] * 255 + "," + rgb[1] * 255 + "," + rgb[2] * 255 + "," + style.dropShadowAlpha + ")";
          context2.shadowBlur = dropShadowBlur;
          context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
          context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;
        } else {
          context2.fillStyle = this._generateFillStyle(style, lines, measured);
          context2.strokeStyle = style.stroke;
          context2.shadowColor = "black";
          context2.shadowBlur = 0;
          context2.shadowOffsetX = 0;
          context2.shadowOffsetY = 0;
        }
        var linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
        if (!Text2.nextLineHeightBehavior || lineHeight - fontProperties.fontSize < 0) {
          linePositionYShift = 0;
        }
        for (var i_1 = 0; i_1 < lines.length; i_1++) {
          linePositionX = style.strokeThickness / 2;
          linePositionY = style.strokeThickness / 2 + i_1 * lineHeight + fontProperties.ascent + linePositionYShift;
          if (style.align === "right") {
            linePositionX += maxLineWidth - lineWidths[i_1];
          } else if (style.align === "center") {
            linePositionX += (maxLineWidth - lineWidths[i_1]) / 2;
          }
          if (style.stroke && style.strokeThickness) {
            this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);
          }
          if (style.fill) {
            this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
          }
        }
      }
      this.updateTexture();
    };
    Text2.prototype.drawLetterSpacing = function(text2, x, y2, isStroke) {
      if (isStroke === void 0) {
        isStroke = false;
      }
      var style = this._style;
      var letterSpacing = style.letterSpacing;
      var supportLetterSpacing = Text2.experimentalLetterSpacing && ("letterSpacing" in CanvasRenderingContext2D.prototype || "textLetterSpacing" in CanvasRenderingContext2D.prototype);
      if (letterSpacing === 0 || supportLetterSpacing) {
        if (supportLetterSpacing) {
          this.context.letterSpacing = letterSpacing;
          this.context.textLetterSpacing = letterSpacing;
        }
        if (isStroke) {
          this.context.strokeText(text2, x, y2);
        } else {
          this.context.fillText(text2, x, y2);
        }
        return;
      }
      var currentPosition = x;
      var stringArray = Array.from ? Array.from(text2) : text2.split("");
      var previousWidth = this.context.measureText(text2).width;
      var currentWidth = 0;
      for (var i2 = 0; i2 < stringArray.length; ++i2) {
        var currentChar = stringArray[i2];
        if (isStroke) {
          this.context.strokeText(currentChar, currentPosition, y2);
        } else {
          this.context.fillText(currentChar, currentPosition, y2);
        }
        var textStr = "";
        for (var j2 = i2 + 1; j2 < stringArray.length; ++j2) {
          textStr += stringArray[j2];
        }
        currentWidth = this.context.measureText(textStr).width;
        currentPosition += previousWidth - currentWidth + letterSpacing;
        previousWidth = currentWidth;
      }
    };
    Text2.prototype.updateTexture = function() {
      var canvas = this.canvas;
      if (this._style.trim) {
        var trimmed = trimCanvas(canvas);
        if (trimmed.data) {
          canvas.width = trimmed.width;
          canvas.height = trimmed.height;
          this.context.putImageData(trimmed.data, 0, 0);
        }
      }
      var texture = this._texture;
      var style = this._style;
      var padding = style.trim ? 0 : style.padding;
      var baseTexture = texture.baseTexture;
      texture.trim.width = texture._frame.width = canvas.width / this._resolution;
      texture.trim.height = texture._frame.height = canvas.height / this._resolution;
      texture.trim.x = -padding;
      texture.trim.y = -padding;
      texture.orig.width = texture._frame.width - padding * 2;
      texture.orig.height = texture._frame.height - padding * 2;
      this._onTextureUpdate();
      baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);
      texture.updateUvs();
      this.dirty = false;
    };
    Text2.prototype._render = function(renderer) {
      if (this._autoResolution && this._resolution !== renderer.resolution) {
        this._resolution = renderer.resolution;
        this.dirty = true;
      }
      this.updateText(true);
      _super.prototype._render.call(this, renderer);
    };
    Text2.prototype.updateTransform = function() {
      this.updateText(true);
      _super.prototype.updateTransform.call(this);
    };
    Text2.prototype.getBounds = function(skipUpdate, rect) {
      this.updateText(true);
      if (this._textureID === -1) {
        skipUpdate = false;
      }
      return _super.prototype.getBounds.call(this, skipUpdate, rect);
    };
    Text2.prototype.getLocalBounds = function(rect) {
      this.updateText(true);
      return _super.prototype.getLocalBounds.call(this, rect);
    };
    Text2.prototype._calculateBounds = function() {
      this.calculateVertices();
      this._bounds.addQuad(this.vertexData);
    };
    Text2.prototype._generateFillStyle = function(style, lines, metrics) {
      var fillStyle = style.fill;
      if (!Array.isArray(fillStyle)) {
        return fillStyle;
      } else if (fillStyle.length === 1) {
        return fillStyle[0];
      }
      var gradient;
      var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
      var padding = style.padding || 0;
      var width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;
      var height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;
      var fill = fillStyle.slice();
      var fillGradientStops = style.fillGradientStops.slice();
      if (!fillGradientStops.length) {
        var lengthPlus1 = fill.length + 1;
        for (var i2 = 1; i2 < lengthPlus1; ++i2) {
          fillGradientStops.push(i2 / lengthPlus1);
        }
      }
      fill.unshift(fillStyle[0]);
      fillGradientStops.unshift(0);
      fill.push(fillStyle[fillStyle.length - 1]);
      fillGradientStops.push(1);
      if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
        gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
        var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
        for (var i2 = 0; i2 < lines.length; i2++) {
          var lastLineBottom = metrics.lineHeight * (i2 - 1) + textHeight;
          var thisLineTop = metrics.lineHeight * i2;
          var thisLineGradientStart = thisLineTop;
          if (i2 > 0 && lastLineBottom > thisLineTop) {
            thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;
          }
          var thisLineBottom = thisLineTop + textHeight;
          var nextLineTop = metrics.lineHeight * (i2 + 1);
          var thisLineGradientEnd = thisLineBottom;
          if (i2 + 1 < lines.length && nextLineTop < thisLineBottom) {
            thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;
          }
          var gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;
          for (var j2 = 0; j2 < fill.length; j2++) {
            var lineStop = 0;
            if (typeof fillGradientStops[j2] === "number") {
              lineStop = fillGradientStops[j2];
            } else {
              lineStop = j2 / fill.length;
            }
            var globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));
            globalStop = Number(globalStop.toFixed(5));
            gradient.addColorStop(globalStop, fill[j2]);
          }
        }
      } else {
        gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);
        var totalIterations = fill.length + 1;
        var currentIteration = 1;
        for (var i2 = 0; i2 < fill.length; i2++) {
          var stop = void 0;
          if (typeof fillGradientStops[i2] === "number") {
            stop = fillGradientStops[i2];
          } else {
            stop = currentIteration / totalIterations;
          }
          gradient.addColorStop(stop, fill[i2]);
          currentIteration++;
        }
      }
      return gradient;
    };
    Text2.prototype.destroy = function(options) {
      if (typeof options === "boolean") {
        options = { children: options };
      }
      options = Object.assign({}, defaultDestroyOptions, options);
      _super.prototype.destroy.call(this, options);
      if (this._ownCanvas) {
        this.canvas.height = this.canvas.width = 0;
      }
      this.context = null;
      this.canvas = null;
      this._style = null;
    };
    Object.defineProperty(Text2.prototype, "width", {
      /** The width of the Text, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        this.updateText(true);
        return Math.abs(this.scale.x) * this._texture.orig.width;
      },
      set: function(value) {
        this.updateText(true);
        var s2 = sign(this.scale.x) || 1;
        this.scale.x = s2 * value / this._texture.orig.width;
        this._width = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Text2.prototype, "height", {
      /** The height of the Text, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        this.updateText(true);
        return Math.abs(this.scale.y) * this._texture.orig.height;
      },
      set: function(value) {
        this.updateText(true);
        var s2 = sign(this.scale.y) || 1;
        this.scale.y = s2 * value / this._texture.orig.height;
        this._height = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Text2.prototype, "style", {
      /**
       * Set the style of the text.
       *
       * Set up an event listener to listen for changes on the style object and mark the text as dirty.
       */
      get: function() {
        return this._style;
      },
      set: function(style) {
        style = style || {};
        if (style instanceof TextStyle) {
          this._style = style;
        } else {
          this._style = new TextStyle(style);
        }
        this.localStyleID = -1;
        this.dirty = true;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Text2.prototype, "text", {
      /** Set the copy for the text object. To split a line you can use '\n'. */
      get: function() {
        return this._text;
      },
      set: function(text2) {
        text2 = String(text2 === null || text2 === void 0 ? "" : text2);
        if (this._text === text2) {
          return;
        }
        this._text = text2;
        this.dirty = true;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Text2.prototype, "resolution", {
      /**
       * The resolution / device pixel ratio of the canvas.
       *
       * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
       * @default 1
       */
      get: function() {
        return this._resolution;
      },
      set: function(value) {
        this._autoResolution = false;
        if (this._resolution === value) {
          return;
        }
        this._resolution = value;
        this.dirty = true;
      },
      enumerable: false,
      configurable: true
    });
    Text2.nextLineHeightBehavior = false;
    Text2.experimentalLetterSpacing = false;
    return Text2;
  }(Sprite)
);
/*!
 * @pixi/prepare - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/prepare is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings$2.UPLOADS_PER_FRAME = 4;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$N = function(d2, b2) {
  extendStatics$N = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (b3.hasOwnProperty(p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$N(d2, b2);
};
function __extends$N(d2, b2) {
  extendStatics$N(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var CountLimiter = (
  /** @class */
  function() {
    function CountLimiter2(maxItemsPerFrame) {
      this.maxItemsPerFrame = maxItemsPerFrame;
      this.itemsLeft = 0;
    }
    CountLimiter2.prototype.beginFrame = function() {
      this.itemsLeft = this.maxItemsPerFrame;
    };
    CountLimiter2.prototype.allowedToUpload = function() {
      return this.itemsLeft-- > 0;
    };
    return CountLimiter2;
  }()
);
function findMultipleBaseTextures(item, queue) {
  var result = false;
  if (item && item._textures && item._textures.length) {
    for (var i2 = 0; i2 < item._textures.length; i2++) {
      if (item._textures[i2] instanceof Texture) {
        var baseTexture = item._textures[i2].baseTexture;
        if (queue.indexOf(baseTexture) === -1) {
          queue.push(baseTexture);
          result = true;
        }
      }
    }
  }
  return result;
}
function findBaseTexture(item, queue) {
  if (item.baseTexture instanceof BaseTexture) {
    var texture = item.baseTexture;
    if (queue.indexOf(texture) === -1) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function findTexture(item, queue) {
  if (item._texture && item._texture instanceof Texture) {
    var texture = item._texture.baseTexture;
    if (queue.indexOf(texture) === -1) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function drawText(_helper, item) {
  if (item instanceof Text) {
    item.updateText(true);
    return true;
  }
  return false;
}
function calculateTextStyle(_helper, item) {
  if (item instanceof TextStyle) {
    var font = item.toFontString();
    TextMetrics.measureFont(font);
    return true;
  }
  return false;
}
function findText(item, queue) {
  if (item instanceof Text) {
    if (queue.indexOf(item.style) === -1) {
      queue.push(item.style);
    }
    if (queue.indexOf(item) === -1) {
      queue.push(item);
    }
    var texture = item._texture.baseTexture;
    if (queue.indexOf(texture) === -1) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function findTextStyle(item, queue) {
  if (item instanceof TextStyle) {
    if (queue.indexOf(item) === -1) {
      queue.push(item);
    }
    return true;
  }
  return false;
}
var BasePrepare = (
  /** @class */
  function() {
    function BasePrepare2(renderer) {
      var _this = this;
      this.limiter = new CountLimiter(settings$2.UPLOADS_PER_FRAME);
      this.renderer = renderer;
      this.uploadHookHelper = null;
      this.queue = [];
      this.addHooks = [];
      this.uploadHooks = [];
      this.completes = [];
      this.ticking = false;
      this.delayedTick = function() {
        if (!_this.queue) {
          return;
        }
        _this.prepareItems();
      };
      this.registerFindHook(findText);
      this.registerFindHook(findTextStyle);
      this.registerFindHook(findMultipleBaseTextures);
      this.registerFindHook(findBaseTexture);
      this.registerFindHook(findTexture);
      this.registerUploadHook(drawText);
      this.registerUploadHook(calculateTextStyle);
    }
    BasePrepare2.prototype.upload = function(item, done) {
      if (typeof item === "function") {
        done = item;
        item = null;
      }
      if (item) {
        this.add(item);
      }
      if (this.queue.length) {
        if (done) {
          this.completes.push(done);
        }
        if (!this.ticking) {
          this.ticking = true;
          Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
        }
      } else if (done) {
        done();
      }
    };
    BasePrepare2.prototype.tick = function() {
      setTimeout(this.delayedTick, 0);
    };
    BasePrepare2.prototype.prepareItems = function() {
      this.limiter.beginFrame();
      while (this.queue.length && this.limiter.allowedToUpload()) {
        var item = this.queue[0];
        var uploaded = false;
        if (item && !item._destroyed) {
          for (var i2 = 0, len = this.uploadHooks.length; i2 < len; i2++) {
            if (this.uploadHooks[i2](this.uploadHookHelper, item)) {
              this.queue.shift();
              uploaded = true;
              break;
            }
          }
        }
        if (!uploaded) {
          this.queue.shift();
        }
      }
      if (!this.queue.length) {
        this.ticking = false;
        var completes = this.completes.slice(0);
        this.completes.length = 0;
        for (var i2 = 0, len = completes.length; i2 < len; i2++) {
          completes[i2]();
        }
      } else {
        Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
      }
    };
    BasePrepare2.prototype.registerFindHook = function(addHook) {
      if (addHook) {
        this.addHooks.push(addHook);
      }
      return this;
    };
    BasePrepare2.prototype.registerUploadHook = function(uploadHook) {
      if (uploadHook) {
        this.uploadHooks.push(uploadHook);
      }
      return this;
    };
    BasePrepare2.prototype.add = function(item) {
      for (var i2 = 0, len = this.addHooks.length; i2 < len; i2++) {
        if (this.addHooks[i2](item, this.queue)) {
          break;
        }
      }
      if (item instanceof Container$1) {
        for (var i2 = item.children.length - 1; i2 >= 0; i2--) {
          this.add(item.children[i2]);
        }
      }
      return this;
    };
    BasePrepare2.prototype.destroy = function() {
      if (this.ticking) {
        Ticker.system.remove(this.tick, this);
      }
      this.ticking = false;
      this.addHooks = null;
      this.uploadHooks = null;
      this.renderer = null;
      this.completes = null;
      this.queue = null;
      this.limiter = null;
      this.uploadHookHelper = null;
    };
    return BasePrepare2;
  }()
);
function uploadBaseTextures(renderer, item) {
  if (item instanceof BaseTexture) {
    if (!item._glTextures[renderer.CONTEXT_UID]) {
      renderer.texture.bind(item);
    }
    return true;
  }
  return false;
}
function uploadGraphics(renderer, item) {
  if (!(item instanceof Graphics)) {
    return false;
  }
  var geometry = item.geometry;
  item.finishPoly();
  geometry.updateBatches();
  var batches = geometry.batches;
  for (var i2 = 0; i2 < batches.length; i2++) {
    var texture = batches[i2].style.texture;
    if (texture) {
      uploadBaseTextures(renderer, texture.baseTexture);
    }
  }
  if (!geometry.batchable) {
    renderer.geometry.bind(geometry, item._resolveDirectShader(renderer));
  }
  return true;
}
function findGraphics(item, queue) {
  if (item instanceof Graphics) {
    queue.push(item);
    return true;
  }
  return false;
}
var Prepare = (
  /** @class */
  function(_super) {
    __extends$N(Prepare2, _super);
    function Prepare2(renderer) {
      var _this = _super.call(this, renderer) || this;
      _this.uploadHookHelper = _this.renderer;
      _this.registerFindHook(findGraphics);
      _this.registerUploadHook(uploadBaseTextures);
      _this.registerUploadHook(uploadGraphics);
      return _this;
    }
    return Prepare2;
  }(BasePrepare)
);
var TimeLimiter = (
  /** @class */
  function() {
    function TimeLimiter2(maxMilliseconds) {
      this.maxMilliseconds = maxMilliseconds;
      this.frameStart = 0;
    }
    TimeLimiter2.prototype.beginFrame = function() {
      this.frameStart = Date.now();
    };
    TimeLimiter2.prototype.allowedToUpload = function() {
      return Date.now() - this.frameStart < this.maxMilliseconds;
    };
    return TimeLimiter2;
  }()
);
/*!
 * @pixi/spritesheet - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/spritesheet is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Spritesheet = (
  /** @class */
  function() {
    function Spritesheet2(texture, data2, resolutionFilename) {
      if (resolutionFilename === void 0) {
        resolutionFilename = null;
      }
      this._texture = texture instanceof Texture ? texture : null;
      this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;
      this.textures = {};
      this.animations = {};
      this.data = data2;
      var resource = this.baseTexture.resource;
      this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));
      this._frames = this.data.frames;
      this._frameKeys = Object.keys(this._frames);
      this._batchIndex = 0;
      this._callback = null;
    }
    Spritesheet2.prototype._updateResolution = function(resolutionFilename) {
      if (resolutionFilename === void 0) {
        resolutionFilename = null;
      }
      var scale = this.data.meta.scale;
      var resolution = getResolutionOfUrl(resolutionFilename, null);
      if (resolution === null) {
        resolution = scale !== void 0 ? parseFloat(scale) : 1;
      }
      if (resolution !== 1) {
        this.baseTexture.setResolution(resolution);
      }
      return resolution;
    };
    Spritesheet2.prototype.parse = function(callback) {
      this._batchIndex = 0;
      this._callback = callback;
      if (this._frameKeys.length <= Spritesheet2.BATCH_SIZE) {
        this._processFrames(0);
        this._processAnimations();
        this._parseComplete();
      } else {
        this._nextBatch();
      }
    };
    Spritesheet2.prototype._processFrames = function(initialFrameIndex) {
      var frameIndex = initialFrameIndex;
      var maxFrames = Spritesheet2.BATCH_SIZE;
      while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
        var i2 = this._frameKeys[frameIndex];
        var data2 = this._frames[i2];
        var rect = data2.frame;
        if (rect) {
          var frame2 = null;
          var trim2 = null;
          var sourceSize = data2.trimmed !== false && data2.sourceSize ? data2.sourceSize : data2.frame;
          var orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
          if (data2.rotated) {
            frame2 = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
          } else {
            frame2 = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
          }
          if (data2.trimmed !== false && data2.spriteSourceSize) {
            trim2 = new Rectangle(Math.floor(data2.spriteSourceSize.x) / this.resolution, Math.floor(data2.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
          }
          this.textures[i2] = new Texture(this.baseTexture, frame2, orig, trim2, data2.rotated ? 2 : 0, data2.anchor);
          Texture.addToCache(this.textures[i2], i2);
        }
        frameIndex++;
      }
    };
    Spritesheet2.prototype._processAnimations = function() {
      var animations = this.data.animations || {};
      for (var animName in animations) {
        this.animations[animName] = [];
        for (var i2 = 0; i2 < animations[animName].length; i2++) {
          var frameName = animations[animName][i2];
          this.animations[animName].push(this.textures[frameName]);
        }
      }
    };
    Spritesheet2.prototype._parseComplete = function() {
      var callback = this._callback;
      this._callback = null;
      this._batchIndex = 0;
      callback.call(this, this.textures);
    };
    Spritesheet2.prototype._nextBatch = function() {
      var _this = this;
      this._processFrames(this._batchIndex * Spritesheet2.BATCH_SIZE);
      this._batchIndex++;
      setTimeout(function() {
        if (_this._batchIndex * Spritesheet2.BATCH_SIZE < _this._frameKeys.length) {
          _this._nextBatch();
        } else {
          _this._processAnimations();
          _this._parseComplete();
        }
      }, 0);
    };
    Spritesheet2.prototype.destroy = function(destroyBase) {
      var _a2;
      if (destroyBase === void 0) {
        destroyBase = false;
      }
      for (var i2 in this.textures) {
        this.textures[i2].destroy();
      }
      this._frames = null;
      this._frameKeys = null;
      this.data = null;
      this.textures = null;
      if (destroyBase) {
        (_a2 = this._texture) === null || _a2 === void 0 ? void 0 : _a2.destroy();
        this.baseTexture.destroy();
      }
      this._texture = null;
      this.baseTexture = null;
    };
    Spritesheet2.BATCH_SIZE = 1e3;
    return Spritesheet2;
  }()
);
var SpritesheetLoader = (
  /** @class */
  function() {
    function SpritesheetLoader2() {
    }
    SpritesheetLoader2.use = function(resource, next2) {
      var _a2, _b2;
      var loader = this;
      var imageResourceName = resource.name + "_image";
      if (!resource.data || resource.type !== LoaderResource.TYPE.JSON || !resource.data.frames || loader.resources[imageResourceName]) {
        next2();
        return;
      }
      var multiPacks = (_b2 = (_a2 = resource.data) === null || _a2 === void 0 ? void 0 : _a2.meta) === null || _b2 === void 0 ? void 0 : _b2.related_multi_packs;
      if (Array.isArray(multiPacks)) {
        var _loop_12 = function(item2) {
          if (typeof item2 !== "string") {
            return "continue";
          }
          var itemName = item2.replace(".json", "");
          var itemUrl = url.resolve(resource.url.replace(loader.baseUrl, ""), item2);
          if (loader.resources[itemName] || Object.values(loader.resources).some(function(r2) {
            return url.format(url.parse(r2.url)) === itemUrl;
          })) {
            return "continue";
          }
          var options = {
            crossOrigin: resource.crossOrigin,
            loadType: LoaderResource.LOAD_TYPE.XHR,
            xhrType: LoaderResource.XHR_RESPONSE_TYPE.JSON,
            parentResource: resource,
            metadata: resource.metadata
          };
          loader.add(itemName, itemUrl, options);
        };
        for (var _i = 0, multiPacks_1 = multiPacks; _i < multiPacks_1.length; _i++) {
          var item = multiPacks_1[_i];
          _loop_12(item);
        }
      }
      var loadOptions = {
        crossOrigin: resource.crossOrigin,
        metadata: resource.metadata.imageMetadata,
        parentResource: resource
      };
      var resourcePath = SpritesheetLoader2.getResourcePath(resource, loader.baseUrl);
      loader.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res) {
        if (res.error) {
          next2(res.error);
          return;
        }
        var spritesheet = new Spritesheet(res.texture, resource.data, resource.url);
        spritesheet.parse(function() {
          resource.spritesheet = spritesheet;
          resource.textures = spritesheet.textures;
          next2();
        });
      });
    };
    SpritesheetLoader2.getResourcePath = function(resource, baseUrl) {
      if (resource.isDataUrl) {
        return resource.data.meta.image;
      }
      return url.resolve(resource.url.replace(baseUrl, ""), resource.data.meta.image);
    };
    return SpritesheetLoader2;
  }()
);
/*!
 * @pixi/sprite-tiling - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/sprite-tiling is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$M = function(d2, b2) {
  extendStatics$M = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (b3.hasOwnProperty(p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$M(d2, b2);
};
function __extends$M(d2, b2) {
  extendStatics$M(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var tempPoint$1 = new Point();
var TilingSprite = (
  /** @class */
  function(_super) {
    __extends$M(TilingSprite2, _super);
    function TilingSprite2(texture, width, height) {
      if (width === void 0) {
        width = 100;
      }
      if (height === void 0) {
        height = 100;
      }
      var _this = _super.call(this, texture) || this;
      _this.tileTransform = new Transform();
      _this._width = width;
      _this._height = height;
      _this.uvMatrix = _this.texture.uvMatrix || new TextureMatrix(texture);
      _this.pluginName = "tilingSprite";
      _this.uvRespectAnchor = false;
      return _this;
    }
    Object.defineProperty(TilingSprite2.prototype, "clampMargin", {
      /**
       * Changes frame clamping in corresponding textureTransform, shortcut
       * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
       * @default 0.5
       * @member {number}
       */
      get: function() {
        return this.uvMatrix.clampMargin;
      },
      set: function(value) {
        this.uvMatrix.clampMargin = value;
        this.uvMatrix.update(true);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TilingSprite2.prototype, "tileScale", {
      /** The scaling of the image that is being tiled. */
      get: function() {
        return this.tileTransform.scale;
      },
      set: function(value) {
        this.tileTransform.scale.copyFrom(value);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TilingSprite2.prototype, "tilePosition", {
      /** The offset of the image that is being tiled. */
      get: function() {
        return this.tileTransform.position;
      },
      set: function(value) {
        this.tileTransform.position.copyFrom(value);
      },
      enumerable: false,
      configurable: true
    });
    TilingSprite2.prototype._onTextureUpdate = function() {
      if (this.uvMatrix) {
        this.uvMatrix.texture = this._texture;
      }
      this._cachedTint = 16777215;
    };
    TilingSprite2.prototype._render = function(renderer) {
      var texture = this._texture;
      if (!texture || !texture.valid) {
        return;
      }
      this.tileTransform.updateLocalTransform();
      this.uvMatrix.update();
      renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
      renderer.plugins[this.pluginName].render(this);
    };
    TilingSprite2.prototype._calculateBounds = function() {
      var minX = this._width * -this._anchor._x;
      var minY = this._height * -this._anchor._y;
      var maxX = this._width * (1 - this._anchor._x);
      var maxY = this._height * (1 - this._anchor._y);
      this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
    };
    TilingSprite2.prototype.getLocalBounds = function(rect) {
      if (this.children.length === 0) {
        this._bounds.minX = this._width * -this._anchor._x;
        this._bounds.minY = this._height * -this._anchor._y;
        this._bounds.maxX = this._width * (1 - this._anchor._x);
        this._bounds.maxY = this._height * (1 - this._anchor._y);
        if (!rect) {
          if (!this._localBoundsRect) {
            this._localBoundsRect = new Rectangle();
          }
          rect = this._localBoundsRect;
        }
        return this._bounds.getRectangle(rect);
      }
      return _super.prototype.getLocalBounds.call(this, rect);
    };
    TilingSprite2.prototype.containsPoint = function(point) {
      this.worldTransform.applyInverse(point, tempPoint$1);
      var width = this._width;
      var height = this._height;
      var x1 = -width * this.anchor._x;
      if (tempPoint$1.x >= x1 && tempPoint$1.x < x1 + width) {
        var y1 = -height * this.anchor._y;
        if (tempPoint$1.y >= y1 && tempPoint$1.y < y1 + height) {
          return true;
        }
      }
      return false;
    };
    TilingSprite2.prototype.destroy = function(options) {
      _super.prototype.destroy.call(this, options);
      this.tileTransform = null;
      this.uvMatrix = null;
    };
    TilingSprite2.from = function(source, options) {
      var texture = source instanceof Texture ? source : Texture.from(source, options);
      return new TilingSprite2(texture, options.width, options.height);
    };
    Object.defineProperty(TilingSprite2.prototype, "width", {
      /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this._width;
      },
      set: function(value) {
        this._width = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TilingSprite2.prototype, "height", {
      /** The height of the TilingSprite, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this._height;
      },
      set: function(value) {
        this._height = value;
      },
      enumerable: false,
      configurable: true
    });
    return TilingSprite2;
  }(Sprite)
);
var fragmentSimpleSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n";
var gl1VertexSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
var gl1FragmentSrc = "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n";
var gl2VertexSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
var gl2FragmentSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n";
var tempMat = new Matrix();
var TilingSpriteRenderer = (
  /** @class */
  function(_super) {
    __extends$M(TilingSpriteRenderer2, _super);
    function TilingSpriteRenderer2(renderer) {
      var _this = _super.call(this, renderer) || this;
      renderer.runners.contextChange.add(_this);
      _this.quad = new QuadUv();
      _this.state = State.for2d();
      return _this;
    }
    TilingSpriteRenderer2.prototype.contextChange = function() {
      var renderer = this.renderer;
      var uniforms = { globals: renderer.globalUniforms };
      this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);
      this.shader = renderer.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);
    };
    TilingSpriteRenderer2.prototype.render = function(ts) {
      var renderer = this.renderer;
      var quad = this.quad;
      var vertices = quad.vertices;
      vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
      vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
      vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);
      vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
      var anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;
      var anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;
      vertices = quad.uvs;
      vertices[0] = vertices[6] = -anchorX;
      vertices[1] = vertices[3] = -anchorY;
      vertices[2] = vertices[4] = 1 - anchorX;
      vertices[5] = vertices[7] = 1 - anchorY;
      quad.invalidate();
      var tex = ts._texture;
      var baseTex = tex.baseTexture;
      var lt = ts.tileTransform.localTransform;
      var uv = ts.uvMatrix;
      var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
      if (isSimple) {
        if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
          if (baseTex.wrapMode === WRAP_MODES$4.CLAMP) {
            baseTex.wrapMode = WRAP_MODES$4.REPEAT;
          }
        } else {
          isSimple = baseTex.wrapMode !== WRAP_MODES$4.CLAMP;
        }
      }
      var shader = isSimple ? this.simpleShader : this.shader;
      var w2 = tex.width;
      var h2 = tex.height;
      var W2 = ts._width;
      var H2 = ts._height;
      tempMat.set(lt.a * w2 / W2, lt.b * w2 / H2, lt.c * h2 / W2, lt.d * h2 / H2, lt.tx / W2, lt.ty / H2);
      tempMat.invert();
      if (isSimple) {
        tempMat.prepend(uv.mapCoord);
      } else {
        shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
        shader.uniforms.uClampFrame = uv.uClampFrame;
        shader.uniforms.uClampOffset = uv.uClampOffset;
      }
      shader.uniforms.uTransform = tempMat.toArray(true);
      shader.uniforms.uColor = premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, baseTex.alphaMode);
      shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
      shader.uniforms.uSampler = tex;
      renderer.shader.bind(shader);
      renderer.geometry.bind(quad);
      this.state.blendMode = correctBlendMode(ts.blendMode, baseTex.alphaMode);
      renderer.state.set(this.state);
      renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
    };
    return TilingSpriteRenderer2;
  }(ObjectRenderer)
);
/*!
 * @pixi/mesh - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/mesh is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$L = function(d2, b2) {
  extendStatics$L = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (b3.hasOwnProperty(p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$L(d2, b2);
};
function __extends$L(d2, b2) {
  extendStatics$L(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var MeshBatchUvs = (
  /** @class */
  function() {
    function MeshBatchUvs2(uvBuffer, uvMatrix) {
      this.uvBuffer = uvBuffer;
      this.uvMatrix = uvMatrix;
      this.data = null;
      this._bufferUpdateId = -1;
      this._textureUpdateId = -1;
      this._updateID = 0;
    }
    MeshBatchUvs2.prototype.update = function(forceUpdate) {
      if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {
        return;
      }
      this._bufferUpdateId = this.uvBuffer._updateID;
      this._textureUpdateId = this.uvMatrix._updateID;
      var data2 = this.uvBuffer.data;
      if (!this.data || this.data.length !== data2.length) {
        this.data = new Float32Array(data2.length);
      }
      this.uvMatrix.multiplyUvs(data2, this.data);
      this._updateID++;
    };
    return MeshBatchUvs2;
  }()
);
var tempPoint = new Point();
var tempPolygon = new Polygon();
var Mesh = (
  /** @class */
  function(_super) {
    __extends$L(Mesh2, _super);
    function Mesh2(geometry, shader, state, drawMode) {
      if (drawMode === void 0) {
        drawMode = DRAW_MODES$4.TRIANGLES;
      }
      var _this = _super.call(this) || this;
      _this.geometry = geometry;
      _this.shader = shader;
      _this.state = state || State.for2d();
      _this.drawMode = drawMode;
      _this.start = 0;
      _this.size = 0;
      _this.uvs = null;
      _this.indices = null;
      _this.vertexData = new Float32Array(1);
      _this.vertexDirty = -1;
      _this._transformID = -1;
      _this._roundPixels = settings$2.ROUND_PIXELS;
      _this.batchUvs = null;
      return _this;
    }
    Object.defineProperty(Mesh2.prototype, "geometry", {
      /**
       * Includes vertex positions, face indices, normals, colors, UVs, and
       * custom attributes within buffers, reducing the cost of passing all
       * this data to the GPU. Can be shared between multiple Mesh objects.
       */
      get: function() {
        return this._geometry;
      },
      set: function(value) {
        if (this._geometry === value) {
          return;
        }
        if (this._geometry) {
          this._geometry.refCount--;
          if (this._geometry.refCount === 0) {
            this._geometry.dispose();
          }
        }
        this._geometry = value;
        if (this._geometry) {
          this._geometry.refCount++;
        }
        this.vertexDirty = -1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Mesh2.prototype, "uvBuffer", {
      /**
       * To change mesh uv's, change its uvBuffer data and increment its _updateID.
       * @readonly
       */
      get: function() {
        return this.geometry.buffers[1];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Mesh2.prototype, "verticesBuffer", {
      /**
       * To change mesh vertices, change its uvBuffer data and increment its _updateID.
       * Incrementing _updateID is optional because most of Mesh objects do it anyway.
       * @readonly
       */
      get: function() {
        return this.geometry.buffers[0];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Mesh2.prototype, "material", {
      get: function() {
        return this.shader;
      },
      /** Alias for {@link PIXI.Mesh#shader}. */
      set: function(value) {
        this.shader = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Mesh2.prototype, "blendMode", {
      get: function() {
        return this.state.blendMode;
      },
      /**
       * The blend mode to be applied to the Mesh. Apply a value of
       * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
       * @default PIXI.BLEND_MODES.NORMAL;
       */
      set: function(value) {
        this.state.blendMode = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Mesh2.prototype, "roundPixels", {
      get: function() {
        return this._roundPixels;
      },
      /**
       * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
       * Advantages can include sharper image quality (like text) and faster rendering on canvas.
       * The main disadvantage is movement of objects may appear less smooth.
       * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
       * @default false
       */
      set: function(value) {
        if (this._roundPixels !== value) {
          this._transformID = -1;
        }
        this._roundPixels = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Mesh2.prototype, "tint", {
      /**
       * The multiply tint applied to the Mesh. This is a hex value. A value of
       * `0xFFFFFF` will remove any tint effect.
       *
       * Null for non-MeshMaterial shaders
       * @default 0xFFFFFF
       */
      get: function() {
        return "tint" in this.shader ? this.shader.tint : null;
      },
      set: function(value) {
        this.shader.tint = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Mesh2.prototype, "texture", {
      /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */
      get: function() {
        return "texture" in this.shader ? this.shader.texture : null;
      },
      set: function(value) {
        this.shader.texture = value;
      },
      enumerable: false,
      configurable: true
    });
    Mesh2.prototype._render = function(renderer) {
      var vertices = this.geometry.buffers[0].data;
      var shader = this.shader;
      if (shader.batchable && this.drawMode === DRAW_MODES$4.TRIANGLES && vertices.length < Mesh2.BATCHABLE_SIZE * 2) {
        this._renderToBatch(renderer);
      } else {
        this._renderDefault(renderer);
      }
    };
    Mesh2.prototype._renderDefault = function(renderer) {
      var shader = this.shader;
      shader.alpha = this.worldAlpha;
      if (shader.update) {
        shader.update();
      }
      renderer.batch.flush();
      shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
      renderer.shader.bind(shader);
      renderer.state.set(this.state);
      renderer.geometry.bind(this.geometry, shader);
      renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
    };
    Mesh2.prototype._renderToBatch = function(renderer) {
      var geometry = this.geometry;
      var shader = this.shader;
      if (shader.uvMatrix) {
        shader.uvMatrix.update();
        this.calculateUvs();
      }
      this.calculateVertices();
      this.indices = geometry.indexBuffer.data;
      this._tintRGB = shader._tintRGB;
      this._texture = shader.texture;
      var pluginName = this.material.pluginName;
      renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
      renderer.plugins[pluginName].render(this);
    };
    Mesh2.prototype.calculateVertices = function() {
      var geometry = this.geometry;
      var verticesBuffer = geometry.buffers[0];
      var vertices = verticesBuffer.data;
      var vertexDirtyId = verticesBuffer._updateID;
      if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
        return;
      }
      this._transformID = this.transform._worldID;
      if (this.vertexData.length !== vertices.length) {
        this.vertexData = new Float32Array(vertices.length);
      }
      var wt = this.transform.worldTransform;
      var a2 = wt.a;
      var b2 = wt.b;
      var c2 = wt.c;
      var d2 = wt.d;
      var tx = wt.tx;
      var ty = wt.ty;
      var vertexData = this.vertexData;
      for (var i2 = 0; i2 < vertexData.length / 2; i2++) {
        var x = vertices[i2 * 2];
        var y2 = vertices[i2 * 2 + 1];
        vertexData[i2 * 2] = a2 * x + c2 * y2 + tx;
        vertexData[i2 * 2 + 1] = b2 * x + d2 * y2 + ty;
      }
      if (this._roundPixels) {
        var resolution = settings$2.RESOLUTION;
        for (var i2 = 0; i2 < vertexData.length; ++i2) {
          vertexData[i2] = Math.round((vertexData[i2] * resolution | 0) / resolution);
        }
      }
      this.vertexDirty = vertexDirtyId;
    };
    Mesh2.prototype.calculateUvs = function() {
      var geomUvs = this.geometry.buffers[1];
      var shader = this.shader;
      if (!shader.uvMatrix.isSimple) {
        if (!this.batchUvs) {
          this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);
        }
        this.batchUvs.update();
        this.uvs = this.batchUvs.data;
      } else {
        this.uvs = geomUvs.data;
      }
    };
    Mesh2.prototype._calculateBounds = function() {
      this.calculateVertices();
      this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
    };
    Mesh2.prototype.containsPoint = function(point) {
      if (!this.getBounds().contains(point.x, point.y)) {
        return false;
      }
      this.worldTransform.applyInverse(point, tempPoint);
      var vertices = this.geometry.getBuffer("aVertexPosition").data;
      var points = tempPolygon.points;
      var indices3 = this.geometry.getIndex().data;
      var len = indices3.length;
      var step = this.drawMode === 4 ? 3 : 1;
      for (var i2 = 0; i2 + 2 < len; i2 += step) {
        var ind0 = indices3[i2] * 2;
        var ind1 = indices3[i2 + 1] * 2;
        var ind2 = indices3[i2 + 2] * 2;
        points[0] = vertices[ind0];
        points[1] = vertices[ind0 + 1];
        points[2] = vertices[ind1];
        points[3] = vertices[ind1 + 1];
        points[4] = vertices[ind2];
        points[5] = vertices[ind2 + 1];
        if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
          return true;
        }
      }
      return false;
    };
    Mesh2.prototype.destroy = function(options) {
      _super.prototype.destroy.call(this, options);
      if (this._cachedTexture) {
        this._cachedTexture.destroy();
        this._cachedTexture = null;
      }
      this.geometry = null;
      this.shader = null;
      this.state = null;
      this.uvs = null;
      this.indices = null;
      this.vertexData = null;
    };
    Mesh2.BATCHABLE_SIZE = 100;
    return Mesh2;
  }(Container$1)
);
var fragment$A = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n";
var vertex$x = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n";
var MeshMaterial = (
  /** @class */
  function(_super) {
    __extends$L(MeshMaterial2, _super);
    function MeshMaterial2(uSampler, options) {
      var _this = this;
      var uniforms = {
        uSampler,
        alpha: 1,
        uTextureMatrix: Matrix.IDENTITY,
        uColor: new Float32Array([1, 1, 1, 1])
      };
      options = Object.assign({
        tint: 16777215,
        alpha: 1,
        pluginName: "batch"
      }, options);
      if (options.uniforms) {
        Object.assign(uniforms, options.uniforms);
      }
      _this = _super.call(this, options.program || Program.from(vertex$x, fragment$A), uniforms) || this;
      _this._colorDirty = false;
      _this.uvMatrix = new TextureMatrix(uSampler);
      _this.batchable = options.program === void 0;
      _this.pluginName = options.pluginName;
      _this.tint = options.tint;
      _this.alpha = options.alpha;
      return _this;
    }
    Object.defineProperty(MeshMaterial2.prototype, "texture", {
      /** Reference to the texture being rendered. */
      get: function() {
        return this.uniforms.uSampler;
      },
      set: function(value) {
        if (this.uniforms.uSampler !== value) {
          if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value.baseTexture.alphaMode) {
            this._colorDirty = true;
          }
          this.uniforms.uSampler = value;
          this.uvMatrix.texture = value;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MeshMaterial2.prototype, "alpha", {
      get: function() {
        return this._alpha;
      },
      /**
       * This gets automatically set by the object using this.
       * @default 1
       */
      set: function(value) {
        if (value === this._alpha) {
          return;
        }
        this._alpha = value;
        this._colorDirty = true;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MeshMaterial2.prototype, "tint", {
      get: function() {
        return this._tint;
      },
      /**
       * Multiply tint for the material.
       * @default 0xFFFFFF
       */
      set: function(value) {
        if (value === this._tint) {
          return;
        }
        this._tint = value;
        this._tintRGB = (value >> 16) + (value & 65280) + ((value & 255) << 16);
        this._colorDirty = true;
      },
      enumerable: false,
      configurable: true
    });
    MeshMaterial2.prototype.update = function() {
      if (this._colorDirty) {
        this._colorDirty = false;
        var baseTexture = this.texture.baseTexture;
        premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, baseTexture.alphaMode);
      }
      if (this.uvMatrix.update()) {
        this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
      }
    };
    return MeshMaterial2;
  }(Shader)
);
var MeshGeometry = (
  /** @class */
  function(_super) {
    __extends$L(MeshGeometry2, _super);
    function MeshGeometry2(vertices, uvs, index2) {
      var _this = _super.call(this) || this;
      var verticesBuffer = new Buffer$1(vertices);
      var uvsBuffer = new Buffer$1(uvs, true);
      var indexBuffer = new Buffer$1(index2, true, true);
      _this.addAttribute("aVertexPosition", verticesBuffer, 2, false, TYPES$4.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, TYPES$4.FLOAT).addIndex(indexBuffer);
      _this._updateId = -1;
      return _this;
    }
    Object.defineProperty(MeshGeometry2.prototype, "vertexDirtyId", {
      /**
       * If the vertex position is updated.
       * @readonly
       * @private
       */
      get: function() {
        return this.buffers[0]._updateID;
      },
      enumerable: false,
      configurable: true
    });
    return MeshGeometry2;
  }(Geometry)
);
/*!
 * @pixi/text-bitmap - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/text-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$K = function(d2, b2) {
  extendStatics$K = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (b3.hasOwnProperty(p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$K(d2, b2);
};
function __extends$K(d2, b2) {
  extendStatics$K(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var BitmapFontData = (
  /** @class */
  function() {
    function BitmapFontData2() {
      this.info = [];
      this.common = [];
      this.page = [];
      this.char = [];
      this.kerning = [];
      this.distanceField = [];
    }
    return BitmapFontData2;
  }()
);
var TextFormat = (
  /** @class */
  function() {
    function TextFormat2() {
    }
    TextFormat2.test = function(data2) {
      return typeof data2 === "string" && data2.indexOf("info face=") === 0;
    };
    TextFormat2.parse = function(txt) {
      var items = txt.match(/^[a-z]+\s+.+$/gm);
      var rawData = {
        info: [],
        common: [],
        page: [],
        char: [],
        chars: [],
        kerning: [],
        kernings: [],
        distanceField: []
      };
      for (var i2 in items) {
        var name = items[i2].match(/^[a-z]+/gm)[0];
        var attributeList = items[i2].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
        var itemData = {};
        for (var i_1 in attributeList) {
          var split = attributeList[i_1].split("=");
          var key = split[0];
          var strValue = split[1].replace(/"/gm, "");
          var floatValue = parseFloat(strValue);
          var value = isNaN(floatValue) ? strValue : floatValue;
          itemData[key] = value;
        }
        rawData[name].push(itemData);
      }
      var font = new BitmapFontData();
      rawData.info.forEach(function(info) {
        return font.info.push({
          face: info.face,
          size: parseInt(info.size, 10)
        });
      });
      rawData.common.forEach(function(common2) {
        return font.common.push({
          lineHeight: parseInt(common2.lineHeight, 10)
        });
      });
      rawData.page.forEach(function(page) {
        return font.page.push({
          id: parseInt(page.id, 10),
          file: page.file
        });
      });
      rawData.char.forEach(function(char2) {
        return font.char.push({
          id: parseInt(char2.id, 10),
          page: parseInt(char2.page, 10),
          x: parseInt(char2.x, 10),
          y: parseInt(char2.y, 10),
          width: parseInt(char2.width, 10),
          height: parseInt(char2.height, 10),
          xoffset: parseInt(char2.xoffset, 10),
          yoffset: parseInt(char2.yoffset, 10),
          xadvance: parseInt(char2.xadvance, 10)
        });
      });
      rawData.kerning.forEach(function(kerning) {
        return font.kerning.push({
          first: parseInt(kerning.first, 10),
          second: parseInt(kerning.second, 10),
          amount: parseInt(kerning.amount, 10)
        });
      });
      rawData.distanceField.forEach(function(df2) {
        return font.distanceField.push({
          distanceRange: parseInt(df2.distanceRange, 10),
          fieldType: df2.fieldType
        });
      });
      return font;
    };
    return TextFormat2;
  }()
);
var XMLFormat = (
  /** @class */
  function() {
    function XMLFormat2() {
    }
    XMLFormat2.test = function(data2) {
      return data2 instanceof XMLDocument && data2.getElementsByTagName("page").length && data2.getElementsByTagName("info")[0].getAttribute("face") !== null;
    };
    XMLFormat2.parse = function(xml) {
      var data2 = new BitmapFontData();
      var info = xml.getElementsByTagName("info");
      var common2 = xml.getElementsByTagName("common");
      var page = xml.getElementsByTagName("page");
      var char2 = xml.getElementsByTagName("char");
      var kerning = xml.getElementsByTagName("kerning");
      var distanceField = xml.getElementsByTagName("distanceField");
      for (var i2 = 0; i2 < info.length; i2++) {
        data2.info.push({
          face: info[i2].getAttribute("face"),
          size: parseInt(info[i2].getAttribute("size"), 10)
        });
      }
      for (var i2 = 0; i2 < common2.length; i2++) {
        data2.common.push({
          lineHeight: parseInt(common2[i2].getAttribute("lineHeight"), 10)
        });
      }
      for (var i2 = 0; i2 < page.length; i2++) {
        data2.page.push({
          id: parseInt(page[i2].getAttribute("id"), 10) || 0,
          file: page[i2].getAttribute("file")
        });
      }
      for (var i2 = 0; i2 < char2.length; i2++) {
        var letter = char2[i2];
        data2.char.push({
          id: parseInt(letter.getAttribute("id"), 10),
          page: parseInt(letter.getAttribute("page"), 10) || 0,
          x: parseInt(letter.getAttribute("x"), 10),
          y: parseInt(letter.getAttribute("y"), 10),
          width: parseInt(letter.getAttribute("width"), 10),
          height: parseInt(letter.getAttribute("height"), 10),
          xoffset: parseInt(letter.getAttribute("xoffset"), 10),
          yoffset: parseInt(letter.getAttribute("yoffset"), 10),
          xadvance: parseInt(letter.getAttribute("xadvance"), 10)
        });
      }
      for (var i2 = 0; i2 < kerning.length; i2++) {
        data2.kerning.push({
          first: parseInt(kerning[i2].getAttribute("first"), 10),
          second: parseInt(kerning[i2].getAttribute("second"), 10),
          amount: parseInt(kerning[i2].getAttribute("amount"), 10)
        });
      }
      for (var i2 = 0; i2 < distanceField.length; i2++) {
        data2.distanceField.push({
          fieldType: distanceField[i2].getAttribute("fieldType"),
          distanceRange: parseInt(distanceField[i2].getAttribute("distanceRange"), 10)
        });
      }
      return data2;
    };
    return XMLFormat2;
  }()
);
var XMLStringFormat = (
  /** @class */
  function() {
    function XMLStringFormat2() {
    }
    XMLStringFormat2.test = function(data2) {
      if (typeof data2 === "string" && data2.indexOf("<font>") > -1) {
        var xml = new globalThis.DOMParser().parseFromString(data2, "text/xml");
        return XMLFormat.test(xml);
      }
      return false;
    };
    XMLStringFormat2.parse = function(xmlTxt) {
      var xml = new globalThis.DOMParser().parseFromString(xmlTxt, "text/xml");
      return XMLFormat.parse(xml);
    };
    return XMLStringFormat2;
  }()
);
var formats = [
  TextFormat,
  XMLFormat,
  XMLStringFormat
];
function autoDetectFormat(data2) {
  for (var i2 = 0; i2 < formats.length; i2++) {
    if (formats[i2].test(data2)) {
      return formats[i2];
    }
  }
  return null;
}
function generateFillStyle(canvas, context2, style, resolution, lines, metrics) {
  var fillStyle = style.fill;
  if (!Array.isArray(fillStyle)) {
    return fillStyle;
  } else if (fillStyle.length === 1) {
    return fillStyle[0];
  }
  var gradient;
  var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
  var padding = style.padding || 0;
  var width = canvas.width / resolution - dropShadowCorrection - padding * 2;
  var height = canvas.height / resolution - dropShadowCorrection - padding * 2;
  var fill = fillStyle.slice();
  var fillGradientStops = style.fillGradientStops.slice();
  if (!fillGradientStops.length) {
    var lengthPlus1 = fill.length + 1;
    for (var i2 = 1; i2 < lengthPlus1; ++i2) {
      fillGradientStops.push(i2 / lengthPlus1);
    }
  }
  fill.unshift(fillStyle[0]);
  fillGradientStops.unshift(0);
  fill.push(fillStyle[fillStyle.length - 1]);
  fillGradientStops.push(1);
  if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
    gradient = context2.createLinearGradient(width / 2, padding, width / 2, height + padding);
    var lastIterationStop = 0;
    var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
    var gradStopLineHeight = textHeight / height;
    for (var i2 = 0; i2 < lines.length; i2++) {
      var thisLineTop = metrics.lineHeight * i2;
      for (var j2 = 0; j2 < fill.length; j2++) {
        var lineStop = 0;
        if (typeof fillGradientStops[j2] === "number") {
          lineStop = fillGradientStops[j2];
        } else {
          lineStop = j2 / fill.length;
        }
        var globalStop = thisLineTop / height + lineStop * gradStopLineHeight;
        var clampedStop = Math.max(lastIterationStop, globalStop);
        clampedStop = Math.min(clampedStop, 1);
        gradient.addColorStop(clampedStop, fill[j2]);
        lastIterationStop = clampedStop;
      }
    }
  } else {
    gradient = context2.createLinearGradient(padding, height / 2, width + padding, height / 2);
    var totalIterations = fill.length + 1;
    var currentIteration = 1;
    for (var i2 = 0; i2 < fill.length; i2++) {
      var stop = void 0;
      if (typeof fillGradientStops[i2] === "number") {
        stop = fillGradientStops[i2];
      } else {
        stop = currentIteration / totalIterations;
      }
      gradient.addColorStop(stop, fill[i2]);
      currentIteration++;
    }
  }
  return gradient;
}
function drawGlyph(canvas, context2, metrics, x, y2, resolution, style) {
  var char2 = metrics.text;
  var fontProperties = metrics.fontProperties;
  context2.translate(x, y2);
  context2.scale(resolution, resolution);
  var tx = style.strokeThickness / 2;
  var ty = -(style.strokeThickness / 2);
  context2.font = style.toFontString();
  context2.lineWidth = style.strokeThickness;
  context2.textBaseline = style.textBaseline;
  context2.lineJoin = style.lineJoin;
  context2.miterLimit = style.miterLimit;
  context2.fillStyle = generateFillStyle(canvas, context2, style, resolution, [char2], metrics);
  context2.strokeStyle = style.stroke;
  if (style.dropShadow) {
    var dropShadowColor = style.dropShadowColor;
    var rgb = hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : string2hex(dropShadowColor));
    var dropShadowBlur = style.dropShadowBlur * resolution;
    var dropShadowDistance = style.dropShadowDistance * resolution;
    context2.shadowColor = "rgba(" + rgb[0] * 255 + "," + rgb[1] * 255 + "," + rgb[2] * 255 + "," + style.dropShadowAlpha + ")";
    context2.shadowBlur = dropShadowBlur;
    context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
    context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;
  } else {
    context2.shadowColor = "black";
    context2.shadowBlur = 0;
    context2.shadowOffsetX = 0;
    context2.shadowOffsetY = 0;
  }
  if (style.stroke && style.strokeThickness) {
    context2.strokeText(char2, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  if (style.fill) {
    context2.fillText(char2, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  context2.setTransform(1, 0, 0, 1, 0, 0);
  context2.fillStyle = "rgba(0, 0, 0, 0)";
}
function splitTextToCharacters(text2) {
  return Array.from ? Array.from(text2) : text2.split("");
}
function resolveCharacters(chars2) {
  if (typeof chars2 === "string") {
    chars2 = [chars2];
  }
  var result = [];
  for (var i2 = 0, j2 = chars2.length; i2 < j2; i2++) {
    var item = chars2[i2];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + item.length + ".");
      }
      var startCode = item[0].charCodeAt(0);
      var endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (var i_1 = startCode, j_1 = endCode; i_1 <= j_1; i_1++) {
        result.push(String.fromCharCode(i_1));
      }
    } else {
      result.push.apply(result, splitTextToCharacters(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}
function extractCharCode(str) {
  return str.codePointAt ? str.codePointAt(0) : str.charCodeAt(0);
}
var BitmapFont = (
  /** @class */
  function() {
    function BitmapFont2(data2, textures, ownsTextures) {
      var _a2, _b2;
      var info = data2.info[0];
      var common2 = data2.common[0];
      var page = data2.page[0];
      var distanceField = data2.distanceField[0];
      var res = getResolutionOfUrl(page.file);
      var pageTextures = {};
      this._ownsTextures = ownsTextures;
      this.font = info.face;
      this.size = info.size;
      this.lineHeight = common2.lineHeight / res;
      this.chars = {};
      this.pageTextures = pageTextures;
      for (var i2 = 0; i2 < data2.page.length; i2++) {
        var _c2 = data2.page[i2], id2 = _c2.id, file = _c2.file;
        pageTextures[id2] = textures instanceof Array ? textures[i2] : textures[file];
        if ((distanceField === null || distanceField === void 0 ? void 0 : distanceField.fieldType) && distanceField.fieldType !== "none") {
          pageTextures[id2].baseTexture.alphaMode = ALPHA_MODES$4.NO_PREMULTIPLIED_ALPHA;
        }
      }
      for (var i2 = 0; i2 < data2.char.length; i2++) {
        var _d = data2.char[i2], id2 = _d.id, page_1 = _d.page;
        var _e = data2.char[i2], x = _e.x, y2 = _e.y, width = _e.width, height = _e.height, xoffset = _e.xoffset, yoffset = _e.yoffset, xadvance = _e.xadvance;
        x /= res;
        y2 /= res;
        width /= res;
        height /= res;
        xoffset /= res;
        yoffset /= res;
        xadvance /= res;
        var rect = new Rectangle(x + pageTextures[page_1].frame.x / res, y2 + pageTextures[page_1].frame.y / res, width, height);
        this.chars[id2] = {
          xOffset: xoffset,
          yOffset: yoffset,
          xAdvance: xadvance,
          kerning: {},
          texture: new Texture(pageTextures[page_1].baseTexture, rect),
          page: page_1
        };
      }
      for (var i2 = 0; i2 < data2.kerning.length; i2++) {
        var _f = data2.kerning[i2], first = _f.first, second = _f.second, amount = _f.amount;
        first /= res;
        second /= res;
        amount /= res;
        if (this.chars[second]) {
          this.chars[second].kerning[first] = amount;
        }
      }
      this.distanceFieldRange = distanceField === null || distanceField === void 0 ? void 0 : distanceField.distanceRange;
      this.distanceFieldType = (_b2 = (_a2 = distanceField === null || distanceField === void 0 ? void 0 : distanceField.fieldType) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) !== null && _b2 !== void 0 ? _b2 : "none";
    }
    BitmapFont2.prototype.destroy = function() {
      for (var id2 in this.chars) {
        this.chars[id2].texture.destroy();
        this.chars[id2].texture = null;
      }
      for (var id2 in this.pageTextures) {
        if (this._ownsTextures) {
          this.pageTextures[id2].destroy(true);
        }
        this.pageTextures[id2] = null;
      }
      this.chars = null;
      this.pageTextures = null;
    };
    BitmapFont2.install = function(data2, textures, ownsTextures) {
      var fontData;
      if (data2 instanceof BitmapFontData) {
        fontData = data2;
      } else {
        var format2 = autoDetectFormat(data2);
        if (!format2) {
          throw new Error("Unrecognized data format for font.");
        }
        fontData = format2.parse(data2);
      }
      if (textures instanceof Texture) {
        textures = [textures];
      }
      var font = new BitmapFont2(fontData, textures, ownsTextures);
      BitmapFont2.available[font.font] = font;
      return font;
    };
    BitmapFont2.uninstall = function(name) {
      var font = BitmapFont2.available[name];
      if (!font) {
        throw new Error("No font found named '" + name + "'");
      }
      font.destroy();
      delete BitmapFont2.available[name];
    };
    BitmapFont2.from = function(name, textStyle, options) {
      if (!name) {
        throw new Error("[BitmapFont] Property `name` is required.");
      }
      var _a2 = Object.assign({}, BitmapFont2.defaultOptions, options), chars2 = _a2.chars, padding = _a2.padding, resolution = _a2.resolution, textureWidth = _a2.textureWidth, textureHeight = _a2.textureHeight;
      var charsList = resolveCharacters(chars2);
      var style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
      var lineWidth = textureWidth;
      var fontData = new BitmapFontData();
      fontData.info[0] = {
        face: style.fontFamily,
        size: style.fontSize
      };
      fontData.common[0] = {
        lineHeight: style.fontSize
      };
      var positionX = 0;
      var positionY = 0;
      var canvas;
      var context2;
      var baseTexture;
      var maxCharHeight = 0;
      var textures = [];
      for (var i2 = 0; i2 < charsList.length; i2++) {
        if (!canvas) {
          canvas = document.createElement("canvas");
          canvas.width = textureWidth;
          canvas.height = textureHeight;
          context2 = canvas.getContext("2d");
          baseTexture = new BaseTexture(canvas, { resolution });
          textures.push(new Texture(baseTexture));
          fontData.page.push({
            id: textures.length - 1,
            file: ""
          });
        }
        var metrics = TextMetrics.measureText(charsList[i2], style, false, canvas);
        var width = metrics.width;
        var height = Math.ceil(metrics.height);
        var textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
        if (positionY >= textureHeight - height * resolution) {
          if (positionY === 0) {
            throw new Error("[BitmapFont] textureHeight " + textureHeight + "px is " + ("too small for " + style.fontSize + "px fonts"));
          }
          --i2;
          canvas = null;
          context2 = null;
          baseTexture = null;
          positionY = 0;
          positionX = 0;
          maxCharHeight = 0;
          continue;
        }
        maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);
        if (textureGlyphWidth * resolution + positionX >= lineWidth) {
          --i2;
          positionY += maxCharHeight * resolution;
          positionY = Math.ceil(positionY);
          positionX = 0;
          maxCharHeight = 0;
          continue;
        }
        drawGlyph(canvas, context2, metrics, positionX, positionY, resolution, style);
        var id2 = extractCharCode(metrics.text);
        fontData.char.push({
          id: id2,
          page: textures.length - 1,
          x: positionX / resolution,
          y: positionY / resolution,
          width: textureGlyphWidth,
          height,
          xoffset: 0,
          yoffset: 0,
          xadvance: Math.ceil(width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0))
        });
        positionX += (textureGlyphWidth + 2 * padding) * resolution;
        positionX = Math.ceil(positionX);
      }
      for (var i2 = 0, len = charsList.length; i2 < len; i2++) {
        var first = charsList[i2];
        for (var j2 = 0; j2 < len; j2++) {
          var second = charsList[j2];
          var c1 = context2.measureText(first).width;
          var c2 = context2.measureText(second).width;
          var total = context2.measureText(first + second).width;
          var amount = total - (c1 + c2);
          if (amount) {
            fontData.kerning.push({
              first: extractCharCode(first),
              second: extractCharCode(second),
              amount
            });
          }
        }
      }
      var font = new BitmapFont2(fontData, textures, true);
      if (BitmapFont2.available[name] !== void 0) {
        BitmapFont2.uninstall(name);
      }
      BitmapFont2.available[name] = font;
      return font;
    };
    BitmapFont2.ALPHA = [["a", "z"], ["A", "Z"], " "];
    BitmapFont2.NUMERIC = [["0", "9"]];
    BitmapFont2.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
    BitmapFont2.ASCII = [[" ", "~"]];
    BitmapFont2.defaultOptions = {
      resolution: 1,
      textureWidth: 512,
      textureHeight: 512,
      padding: 4,
      chars: BitmapFont2.ALPHANUMERIC
    };
    BitmapFont2.available = {};
    return BitmapFont2;
  }()
);
var msdfFrag = "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r\n\r\n}\r\n";
var msdfVert = "// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";
var pageMeshDataDefaultPageMeshData = [];
var pageMeshDataMSDFPageMeshData = [];
var charRenderDataPool = [];
var BitmapText = (
  /** @class */
  function(_super) {
    __extends$K(BitmapText2, _super);
    function BitmapText2(text2, style) {
      if (style === void 0) {
        style = {};
      }
      var _this = _super.call(this) || this;
      _this._tint = 16777215;
      var _a2 = Object.assign({}, BitmapText2.styleDefaults, style), align = _a2.align, tint = _a2.tint, maxWidth = _a2.maxWidth, letterSpacing = _a2.letterSpacing, fontName = _a2.fontName, fontSize = _a2.fontSize;
      if (!BitmapFont.available[fontName]) {
        throw new Error('Missing BitmapFont "' + fontName + '"');
      }
      _this._activePagesMeshData = [];
      _this._textWidth = 0;
      _this._textHeight = 0;
      _this._align = align;
      _this._tint = tint;
      _this._fontName = fontName;
      _this._fontSize = fontSize || BitmapFont.available[fontName].size;
      _this.text = text2;
      _this._maxWidth = maxWidth;
      _this._maxLineHeight = 0;
      _this._letterSpacing = letterSpacing;
      _this._anchor = new ObservablePoint(function() {
        _this.dirty = true;
      }, _this, 0, 0);
      _this._roundPixels = settings$2.ROUND_PIXELS;
      _this.dirty = true;
      _this._resolution = settings$2.RESOLUTION;
      _this._autoResolution = true;
      _this._textureCache = {};
      return _this;
    }
    BitmapText2.prototype.updateText = function() {
      var _a2;
      var data2 = BitmapFont.available[this._fontName];
      var scale = this._fontSize / data2.size;
      var pos = new Point();
      var chars2 = [];
      var lineWidths = [];
      var lineSpaces = [];
      var text2 = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ";
      var charsInput = splitTextToCharacters(text2);
      var maxWidth = this._maxWidth * data2.size / this._fontSize;
      var pageMeshDataPool = data2.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
      var prevCharCode = null;
      var lastLineWidth = 0;
      var maxLineWidth = 0;
      var line2 = 0;
      var lastBreakPos = -1;
      var lastBreakWidth = 0;
      var spacesRemoved = 0;
      var maxLineHeight = 0;
      var spaceCount = 0;
      for (var i2 = 0; i2 < charsInput.length; i2++) {
        var char2 = charsInput[i2];
        var charCode = extractCharCode(char2);
        if (/(?:\s)/.test(char2)) {
          lastBreakPos = i2;
          lastBreakWidth = lastLineWidth;
          spaceCount++;
        }
        if (char2 === "\r" || char2 === "\n") {
          lineWidths.push(lastLineWidth);
          lineSpaces.push(-1);
          maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
          ++line2;
          ++spacesRemoved;
          pos.x = 0;
          pos.y += data2.lineHeight;
          prevCharCode = null;
          spaceCount = 0;
          continue;
        }
        var charData = data2.chars[charCode];
        if (!charData) {
          continue;
        }
        if (prevCharCode && charData.kerning[prevCharCode]) {
          pos.x += charData.kerning[prevCharCode];
        }
        var charRenderData = charRenderDataPool.pop() || {
          texture: Texture.EMPTY,
          line: 0,
          charCode: 0,
          prevSpaces: 0,
          position: new Point()
        };
        charRenderData.texture = charData.texture;
        charRenderData.line = line2;
        charRenderData.charCode = charCode;
        charRenderData.position.x = pos.x + charData.xOffset + this._letterSpacing / 2;
        charRenderData.position.y = pos.y + charData.yOffset;
        charRenderData.prevSpaces = spaceCount;
        chars2.push(charRenderData);
        lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance, charData.texture.orig.width);
        pos.x += charData.xAdvance + this._letterSpacing;
        maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
        prevCharCode = charCode;
        if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
          ++spacesRemoved;
          removeItems(chars2, 1 + lastBreakPos - spacesRemoved, 1 + i2 - lastBreakPos);
          i2 = lastBreakPos;
          lastBreakPos = -1;
          lineWidths.push(lastBreakWidth);
          lineSpaces.push(chars2.length > 0 ? chars2[chars2.length - 1].prevSpaces : 0);
          maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
          line2++;
          pos.x = 0;
          pos.y += data2.lineHeight;
          prevCharCode = null;
          spaceCount = 0;
        }
      }
      var lastChar = charsInput[charsInput.length - 1];
      if (lastChar !== "\r" && lastChar !== "\n") {
        if (/(?:\s)/.test(lastChar)) {
          lastLineWidth = lastBreakWidth;
        }
        lineWidths.push(lastLineWidth);
        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        lineSpaces.push(-1);
      }
      var lineAlignOffsets = [];
      for (var i2 = 0; i2 <= line2; i2++) {
        var alignOffset = 0;
        if (this._align === "right") {
          alignOffset = maxLineWidth - lineWidths[i2];
        } else if (this._align === "center") {
          alignOffset = (maxLineWidth - lineWidths[i2]) / 2;
        } else if (this._align === "justify") {
          alignOffset = lineSpaces[i2] < 0 ? 0 : (maxLineWidth - lineWidths[i2]) / lineSpaces[i2];
        }
        lineAlignOffsets.push(alignOffset);
      }
      var lenChars = chars2.length;
      var pagesMeshData = {};
      var newPagesMeshData = [];
      var activePagesMeshData = this._activePagesMeshData;
      for (var i2 = 0; i2 < activePagesMeshData.length; i2++) {
        pageMeshDataPool.push(activePagesMeshData[i2]);
      }
      for (var i2 = 0; i2 < lenChars; i2++) {
        var texture = chars2[i2].texture;
        var baseTextureUid = texture.baseTexture.uid;
        if (!pagesMeshData[baseTextureUid]) {
          var pageMeshData = pageMeshDataPool.pop();
          if (!pageMeshData) {
            var geometry = new MeshGeometry();
            var material = void 0;
            var meshBlendMode = void 0;
            if (data2.distanceFieldType === "none") {
              material = new MeshMaterial(Texture.EMPTY);
              meshBlendMode = BLEND_MODES$4.NORMAL;
            } else {
              material = new MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } });
              meshBlendMode = BLEND_MODES$4.NORMAL_NPM;
            }
            var mesh = new Mesh(geometry, material);
            mesh.blendMode = meshBlendMode;
            pageMeshData = {
              index: 0,
              indexCount: 0,
              vertexCount: 0,
              uvsCount: 0,
              total: 0,
              mesh,
              vertices: null,
              uvs: null,
              indices: null
            };
          }
          pageMeshData.index = 0;
          pageMeshData.indexCount = 0;
          pageMeshData.vertexCount = 0;
          pageMeshData.uvsCount = 0;
          pageMeshData.total = 0;
          var _textureCache = this._textureCache;
          _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);
          pageMeshData.mesh.texture = _textureCache[baseTextureUid];
          pageMeshData.mesh.tint = this._tint;
          newPagesMeshData.push(pageMeshData);
          pagesMeshData[baseTextureUid] = pageMeshData;
        }
        pagesMeshData[baseTextureUid].total++;
      }
      for (var i2 = 0; i2 < activePagesMeshData.length; i2++) {
        if (newPagesMeshData.indexOf(activePagesMeshData[i2]) === -1) {
          this.removeChild(activePagesMeshData[i2].mesh);
        }
      }
      for (var i2 = 0; i2 < newPagesMeshData.length; i2++) {
        if (newPagesMeshData[i2].mesh.parent !== this) {
          this.addChild(newPagesMeshData[i2].mesh);
        }
      }
      this._activePagesMeshData = newPagesMeshData;
      for (var i2 in pagesMeshData) {
        var pageMeshData = pagesMeshData[i2];
        var total = pageMeshData.total;
        if (!(((_a2 = pageMeshData.indices) === null || _a2 === void 0 ? void 0 : _a2.length) > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2) {
          pageMeshData.vertices = new Float32Array(4 * 2 * total);
          pageMeshData.uvs = new Float32Array(4 * 2 * total);
          pageMeshData.indices = new Uint16Array(6 * total);
        } else {
          var total_1 = pageMeshData.total;
          var vertices = pageMeshData.vertices;
          for (var i_1 = total_1 * 4 * 2; i_1 < vertices.length; i_1++) {
            vertices[i_1] = 0;
          }
        }
        pageMeshData.mesh.size = 6 * total;
      }
      for (var i2 = 0; i2 < lenChars; i2++) {
        var char2 = chars2[i2];
        var offset = char2.position.x + lineAlignOffsets[char2.line] * (this._align === "justify" ? char2.prevSpaces : 1);
        if (this._roundPixels) {
          offset = Math.round(offset);
        }
        var xPos = offset * scale;
        var yPos = char2.position.y * scale;
        var texture = char2.texture;
        var pageMesh = pagesMeshData[texture.baseTexture.uid];
        var textureFrame = texture.frame;
        var textureUvs = texture._uvs;
        var index2 = pageMesh.index++;
        pageMesh.indices[index2 * 6 + 0] = 0 + index2 * 4;
        pageMesh.indices[index2 * 6 + 1] = 1 + index2 * 4;
        pageMesh.indices[index2 * 6 + 2] = 2 + index2 * 4;
        pageMesh.indices[index2 * 6 + 3] = 0 + index2 * 4;
        pageMesh.indices[index2 * 6 + 4] = 2 + index2 * 4;
        pageMesh.indices[index2 * 6 + 5] = 3 + index2 * 4;
        pageMesh.vertices[index2 * 8 + 0] = xPos;
        pageMesh.vertices[index2 * 8 + 1] = yPos;
        pageMesh.vertices[index2 * 8 + 2] = xPos + textureFrame.width * scale;
        pageMesh.vertices[index2 * 8 + 3] = yPos;
        pageMesh.vertices[index2 * 8 + 4] = xPos + textureFrame.width * scale;
        pageMesh.vertices[index2 * 8 + 5] = yPos + textureFrame.height * scale;
        pageMesh.vertices[index2 * 8 + 6] = xPos;
        pageMesh.vertices[index2 * 8 + 7] = yPos + textureFrame.height * scale;
        pageMesh.uvs[index2 * 8 + 0] = textureUvs.x0;
        pageMesh.uvs[index2 * 8 + 1] = textureUvs.y0;
        pageMesh.uvs[index2 * 8 + 2] = textureUvs.x1;
        pageMesh.uvs[index2 * 8 + 3] = textureUvs.y1;
        pageMesh.uvs[index2 * 8 + 4] = textureUvs.x2;
        pageMesh.uvs[index2 * 8 + 5] = textureUvs.y2;
        pageMesh.uvs[index2 * 8 + 6] = textureUvs.x3;
        pageMesh.uvs[index2 * 8 + 7] = textureUvs.y3;
      }
      this._textWidth = maxLineWidth * scale;
      this._textHeight = (pos.y + data2.lineHeight) * scale;
      for (var i2 in pagesMeshData) {
        var pageMeshData = pagesMeshData[i2];
        if (this.anchor.x !== 0 || this.anchor.y !== 0) {
          var vertexCount = 0;
          var anchorOffsetX = this._textWidth * this.anchor.x;
          var anchorOffsetY = this._textHeight * this.anchor.y;
          for (var i_2 = 0; i_2 < pageMeshData.total; i_2++) {
            pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
            pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
            pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
            pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
            pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
            pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
            pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
            pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          }
        }
        this._maxLineHeight = maxLineHeight * scale;
        var vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");
        var textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");
        var indexBuffer = pageMeshData.mesh.geometry.getIndex();
        vertexBuffer.data = pageMeshData.vertices;
        textureBuffer.data = pageMeshData.uvs;
        indexBuffer.data = pageMeshData.indices;
        vertexBuffer.update();
        textureBuffer.update();
        indexBuffer.update();
      }
      for (var i2 = 0; i2 < chars2.length; i2++) {
        charRenderDataPool.push(chars2[i2]);
      }
    };
    BitmapText2.prototype.updateTransform = function() {
      this.validate();
      this.containerUpdateTransform();
    };
    BitmapText2.prototype._render = function(renderer) {
      if (this._autoResolution && this._resolution !== renderer.resolution) {
        this._resolution = renderer.resolution;
        this.dirty = true;
      }
      var _a2 = BitmapFont.available[this._fontName], distanceFieldRange = _a2.distanceFieldRange, distanceFieldType = _a2.distanceFieldType, size = _a2.size;
      if (distanceFieldType !== "none") {
        var _b2 = this.worldTransform, a2 = _b2.a, b2 = _b2.b, c2 = _b2.c, d2 = _b2.d;
        var dx = Math.sqrt(a2 * a2 + b2 * b2);
        var dy = Math.sqrt(c2 * c2 + d2 * d2);
        var worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
        var fontScale = this._fontSize / size;
        for (var _i = 0, _c2 = this._activePagesMeshData; _i < _c2.length; _i++) {
          var mesh = _c2[_i];
          mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * this._resolution;
        }
      }
      _super.prototype._render.call(this, renderer);
    };
    BitmapText2.prototype.getLocalBounds = function() {
      this.validate();
      return _super.prototype.getLocalBounds.call(this);
    };
    BitmapText2.prototype.validate = function() {
      if (this.dirty) {
        this.updateText();
        this.dirty = false;
      }
    };
    Object.defineProperty(BitmapText2.prototype, "tint", {
      /**
       * The tint of the BitmapText object.
       * @default 0xffffff
       */
      get: function() {
        return this._tint;
      },
      set: function(value) {
        if (this._tint === value) {
          return;
        }
        this._tint = value;
        for (var i2 = 0; i2 < this._activePagesMeshData.length; i2++) {
          this._activePagesMeshData[i2].mesh.tint = value;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BitmapText2.prototype, "align", {
      /**
       * The alignment of the BitmapText object.
       * @member {string}
       * @default 'left'
       */
      get: function() {
        return this._align;
      },
      set: function(value) {
        if (this._align !== value) {
          this._align = value;
          this.dirty = true;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BitmapText2.prototype, "fontName", {
      /** The name of the BitmapFont. */
      get: function() {
        return this._fontName;
      },
      set: function(value) {
        if (!BitmapFont.available[value]) {
          throw new Error('Missing BitmapFont "' + value + '"');
        }
        if (this._fontName !== value) {
          this._fontName = value;
          this.dirty = true;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BitmapText2.prototype, "fontSize", {
      /** The size of the font to display. */
      get: function() {
        return this._fontSize;
      },
      set: function(value) {
        if (this._fontSize !== value) {
          this._fontSize = value;
          this.dirty = true;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BitmapText2.prototype, "anchor", {
      /**
       * The anchor sets the origin point of the text.
       *
       * The default is `(0,0)`, this means the text's origin is the top left.
       *
       * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
       *
       * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
       */
      get: function() {
        return this._anchor;
      },
      set: function(value) {
        if (typeof value === "number") {
          this._anchor.set(value);
        } else {
          this._anchor.copyFrom(value);
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BitmapText2.prototype, "text", {
      /** The text of the BitmapText object. */
      get: function() {
        return this._text;
      },
      set: function(text2) {
        text2 = String(text2 === null || text2 === void 0 ? "" : text2);
        if (this._text === text2) {
          return;
        }
        this._text = text2;
        this.dirty = true;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BitmapText2.prototype, "maxWidth", {
      /**
       * The max width of this bitmap text in pixels. If the text provided is longer than the
       * value provided, line breaks will be automatically inserted in the last whitespace.
       * Disable by setting the value to 0.
       */
      get: function() {
        return this._maxWidth;
      },
      set: function(value) {
        if (this._maxWidth === value) {
          return;
        }
        this._maxWidth = value;
        this.dirty = true;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BitmapText2.prototype, "maxLineHeight", {
      /**
       * The max line height. This is useful when trying to use the total height of the Text,
       * i.e. when trying to vertically align.
       * @readonly
       */
      get: function() {
        this.validate();
        return this._maxLineHeight;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BitmapText2.prototype, "textWidth", {
      /**
       * The width of the overall text, different from fontSize,
       * which is defined in the style object.
       * @readonly
       */
      get: function() {
        this.validate();
        return this._textWidth;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BitmapText2.prototype, "letterSpacing", {
      /** Additional space between characters. */
      get: function() {
        return this._letterSpacing;
      },
      set: function(value) {
        if (this._letterSpacing !== value) {
          this._letterSpacing = value;
          this.dirty = true;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BitmapText2.prototype, "roundPixels", {
      /**
       * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
       * Advantages can include sharper image quality (like text) and faster rendering on canvas.
       * The main disadvantage is movement of objects may appear less smooth.
       * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
       * @default PIXI.settings.ROUND_PIXELS
       */
      get: function() {
        return this._roundPixels;
      },
      set: function(value) {
        if (value !== this._roundPixels) {
          this._roundPixels = value;
          this.dirty = true;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BitmapText2.prototype, "textHeight", {
      /**
       * The height of the overall text, different from fontSize,
       * which is defined in the style object.
       * @readonly
       */
      get: function() {
        this.validate();
        return this._textHeight;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BitmapText2.prototype, "resolution", {
      /**
       * The resolution / device pixel ratio of the canvas.
       *
       * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
       * @default 1
       */
      get: function() {
        return this._resolution;
      },
      set: function(value) {
        this._autoResolution = false;
        if (this._resolution === value) {
          return;
        }
        this._resolution = value;
        this.dirty = true;
      },
      enumerable: false,
      configurable: true
    });
    BitmapText2.prototype.destroy = function(options) {
      var _textureCache = this._textureCache;
      for (var id2 in _textureCache) {
        var texture = _textureCache[id2];
        texture.destroy();
        delete _textureCache[id2];
      }
      this._textureCache = null;
      _super.prototype.destroy.call(this, options);
    };
    BitmapText2.styleDefaults = {
      align: "left",
      tint: 16777215,
      maxWidth: 0,
      letterSpacing: 0
    };
    return BitmapText2;
  }(Container$1)
);
var BitmapFontLoader = (
  /** @class */
  function() {
    function BitmapFontLoader2() {
    }
    BitmapFontLoader2.add = function() {
      LoaderResource.setExtensionXhrType("fnt", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
    };
    BitmapFontLoader2.use = function(resource, next2) {
      var format2 = autoDetectFormat(resource.data);
      if (!format2) {
        next2();
        return;
      }
      var baseUrl = BitmapFontLoader2.getBaseUrl(this, resource);
      var data2 = format2.parse(resource.data);
      var textures = {};
      var completed = function(page) {
        textures[page.metadata.pageFile] = page.texture;
        if (Object.keys(textures).length === data2.page.length) {
          resource.bitmapFont = BitmapFont.install(data2, textures, true);
          next2();
        }
      };
      for (var i2 = 0; i2 < data2.page.length; ++i2) {
        var pageFile = data2.page[i2].file;
        var url2 = baseUrl + pageFile;
        var exists = false;
        for (var name in this.resources) {
          var bitmapResource = this.resources[name];
          if (bitmapResource.url === url2) {
            bitmapResource.metadata.pageFile = pageFile;
            if (bitmapResource.texture) {
              completed(bitmapResource);
            } else {
              bitmapResource.onAfterMiddleware.add(completed);
            }
            exists = true;
            break;
          }
        }
        if (!exists) {
          var options = {
            crossOrigin: resource.crossOrigin,
            loadType: LoaderResource.LOAD_TYPE.IMAGE,
            metadata: Object.assign({ pageFile }, resource.metadata.imageMetadata),
            parentResource: resource
          };
          this.add(url2, options, completed);
        }
      }
    };
    BitmapFontLoader2.getBaseUrl = function(loader, resource) {
      var resUrl = !resource.isDataUrl ? BitmapFontLoader2.dirname(resource.url) : "";
      if (resource.isDataUrl) {
        if (resUrl === ".") {
          resUrl = "";
        }
        if (loader.baseUrl && resUrl) {
          if (loader.baseUrl.charAt(loader.baseUrl.length - 1) === "/") {
            resUrl += "/";
          }
        }
      }
      resUrl = resUrl.replace(loader.baseUrl, "");
      if (resUrl && resUrl.charAt(resUrl.length - 1) !== "/") {
        resUrl += "/";
      }
      return resUrl;
    };
    BitmapFontLoader2.dirname = function(url2) {
      var dir = url2.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
      if (dir === url2) {
        return ".";
      } else if (dir === "") {
        return "/";
      }
      return dir;
    };
    return BitmapFontLoader2;
  }()
);
/*!
 * @pixi/filter-alpha - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/filter-alpha is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$J = function(d2, b2) {
  extendStatics$J = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (b3.hasOwnProperty(p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$J(d2, b2);
};
function __extends$J(d2, b2) {
  extendStatics$J(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var fragment$z = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n";
var AlphaFilter = (
  /** @class */
  function(_super) {
    __extends$J(AlphaFilter2, _super);
    function AlphaFilter2(alpha2) {
      if (alpha2 === void 0) {
        alpha2 = 1;
      }
      var _this = _super.call(this, defaultVertex$1, fragment$z, { uAlpha: 1 }) || this;
      _this.alpha = alpha2;
      return _this;
    }
    Object.defineProperty(AlphaFilter2.prototype, "alpha", {
      /**
       * Coefficient for alpha multiplication
       * @default 1
       */
      get: function() {
        return this.uniforms.uAlpha;
      },
      set: function(value) {
        this.uniforms.uAlpha = value;
      },
      enumerable: false,
      configurable: true
    });
    return AlphaFilter2;
  }(Filter)
);
/*!
 * @pixi/filter-blur - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/filter-blur is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$I = function(d2, b2) {
  extendStatics$I = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (b3.hasOwnProperty(p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$I(d2, b2);
};
function __extends$I(d2, b2) {
  extendStatics$I(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertTemplate = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }";
function generateBlurVertSource(kernelSize, x) {
  var halfLength = Math.ceil(kernelSize / 2);
  var vertSource = vertTemplate;
  var blurLoop = "";
  var template;
  if (x) {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);";
  } else {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  }
  for (var i2 = 0; i2 < kernelSize; i2++) {
    var blur = template.replace("%index%", i2.toString());
    blur = blur.replace("%sampleIndex%", i2 - (halfLength - 1) + ".0");
    blurLoop += blur;
    blurLoop += "\n";
  }
  vertSource = vertSource.replace("%blur%", blurLoop);
  vertSource = vertSource.replace("%size%", kernelSize.toString());
  return vertSource;
}
var GAUSSIAN_VALUES = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
};
var fragTemplate = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join("\n");
function generateBlurFragSource(kernelSize) {
  var kernel = GAUSSIAN_VALUES[kernelSize];
  var halfLength = kernel.length;
  var fragSource = fragTemplate;
  var blurLoop = "";
  var template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
  var value;
  for (var i2 = 0; i2 < kernelSize; i2++) {
    var blur = template.replace("%index%", i2.toString());
    value = i2;
    if (i2 >= halfLength) {
      value = kernelSize - i2 - 1;
    }
    blur = blur.replace("%value%", kernel[value].toString());
    blurLoop += blur;
    blurLoop += "\n";
  }
  fragSource = fragSource.replace("%blur%", blurLoop);
  fragSource = fragSource.replace("%size%", kernelSize.toString());
  return fragSource;
}
/*!
 * @pixi/constants - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$1;
(function(ENV2) {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
})(ENV$1 || (ENV$1 = {}));
var RENDERER_TYPE$1;
(function(RENDERER_TYPE2) {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE$1 || (RENDERER_TYPE$1 = {}));
var BUFFER_BITS$1;
(function(BUFFER_BITS2) {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS$1 || (BUFFER_BITS$1 = {}));
var BLEND_MODES$1;
(function(BLEND_MODES2) {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
})(BLEND_MODES$1 || (BLEND_MODES$1 = {}));
var DRAW_MODES$1;
(function(DRAW_MODES2) {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$1 || (DRAW_MODES$1 = {}));
var FORMATS$1;
(function(FORMATS2) {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS$1 || (FORMATS$1 = {}));
var TARGETS$1;
(function(TARGETS2) {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$1 || (TARGETS$1 = {}));
var TYPES$1;
(function(TYPES2) {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES$1 || (TYPES$1 = {}));
var SAMPLER_TYPES$1;
(function(SAMPLER_TYPES2) {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
})(SAMPLER_TYPES$1 || (SAMPLER_TYPES$1 = {}));
var SCALE_MODES$1;
(function(SCALE_MODES2) {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES$1 || (SCALE_MODES$1 = {}));
var WRAP_MODES$1;
(function(WRAP_MODES2) {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$1 || (WRAP_MODES$1 = {}));
var MIPMAP_MODES$1;
(function(MIPMAP_MODES2) {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
})(MIPMAP_MODES$1 || (MIPMAP_MODES$1 = {}));
var ALPHA_MODES$1;
(function(ALPHA_MODES2) {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$1 || (ALPHA_MODES$1 = {}));
var CLEAR_MODES$1;
(function(CLEAR_MODES2) {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES$1 || (CLEAR_MODES$1 = {}));
var GC_MODES$1;
(function(GC_MODES2) {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
})(GC_MODES$1 || (GC_MODES$1 = {}));
var PRECISION$1;
(function(PRECISION2) {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
})(PRECISION$1 || (PRECISION$1 = {}));
var MASK_TYPES$1;
(function(MASK_TYPES2) {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
})(MASK_TYPES$1 || (MASK_TYPES$1 = {}));
var MSAA_QUALITY$1;
(function(MSAA_QUALITY2) {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY$1 || (MSAA_QUALITY$1 = {}));
var BUFFER_TYPE$1;
(function(BUFFER_TYPE2) {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$1 || (BUFFER_TYPE$1 = {}));
var BlurFilterPass = (
  /** @class */
  function(_super) {
    __extends$I(BlurFilterPass2, _super);
    function BlurFilterPass2(horizontal, strength, quality, resolution, kernelSize) {
      if (strength === void 0) {
        strength = 8;
      }
      if (quality === void 0) {
        quality = 4;
      }
      if (resolution === void 0) {
        resolution = settings$2.FILTER_RESOLUTION;
      }
      if (kernelSize === void 0) {
        kernelSize = 5;
      }
      var _this = this;
      var vertSrc = generateBlurVertSource(kernelSize, horizontal);
      var fragSrc = generateBlurFragSource(kernelSize);
      _this = _super.call(
        this,
        // vertex shader
        vertSrc,
        // fragment shader
        fragSrc
      ) || this;
      _this.horizontal = horizontal;
      _this.resolution = resolution;
      _this._quality = 0;
      _this.quality = quality;
      _this.blur = strength;
      return _this;
    }
    BlurFilterPass2.prototype.apply = function(filterManager, input, output2, clearMode) {
      if (output2) {
        if (this.horizontal) {
          this.uniforms.strength = 1 / output2.width * (output2.width / input.width);
        } else {
          this.uniforms.strength = 1 / output2.height * (output2.height / input.height);
        }
      } else {
        if (this.horizontal) {
          this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width);
        } else {
          this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height);
        }
      }
      this.uniforms.strength *= this.strength;
      this.uniforms.strength /= this.passes;
      if (this.passes === 1) {
        filterManager.applyFilter(this, input, output2, clearMode);
      } else {
        var renderTarget = filterManager.getFilterTexture();
        var renderer = filterManager.renderer;
        var flip = input;
        var flop = renderTarget;
        this.state.blend = false;
        filterManager.applyFilter(this, flip, flop, CLEAR_MODES$1.CLEAR);
        for (var i2 = 1; i2 < this.passes - 1; i2++) {
          filterManager.bindAndClear(flip, CLEAR_MODES$1.BLIT);
          this.uniforms.uSampler = flop;
          var temp2 = flop;
          flop = flip;
          flip = temp2;
          renderer.shader.bind(this);
          renderer.geometry.draw(5);
        }
        this.state.blend = true;
        filterManager.applyFilter(this, flop, output2, clearMode);
        filterManager.returnFilterTexture(renderTarget);
      }
    };
    Object.defineProperty(BlurFilterPass2.prototype, "blur", {
      /**
       * Sets the strength of both the blur.
       * @default 16
       */
      get: function() {
        return this.strength;
      },
      set: function(value) {
        this.padding = 1 + Math.abs(value) * 2;
        this.strength = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BlurFilterPass2.prototype, "quality", {
      /**
       * Sets the quality of the blur by modifying the number of passes. More passes means higher
       * quality bluring but the lower the performance.
       * @default 4
       */
      get: function() {
        return this._quality;
      },
      set: function(value) {
        this._quality = value;
        this.passes = value;
      },
      enumerable: false,
      configurable: true
    });
    return BlurFilterPass2;
  }(Filter)
);
var BlurFilter = (
  /** @class */
  function(_super) {
    __extends$I(BlurFilter2, _super);
    function BlurFilter2(strength, quality, resolution, kernelSize) {
      if (strength === void 0) {
        strength = 8;
      }
      if (quality === void 0) {
        quality = 4;
      }
      if (resolution === void 0) {
        resolution = settings$2.FILTER_RESOLUTION;
      }
      if (kernelSize === void 0) {
        kernelSize = 5;
      }
      var _this = _super.call(this) || this;
      _this.blurXFilter = new BlurFilterPass(true, strength, quality, resolution, kernelSize);
      _this.blurYFilter = new BlurFilterPass(false, strength, quality, resolution, kernelSize);
      _this.resolution = resolution;
      _this.quality = quality;
      _this.blur = strength;
      _this.repeatEdgePixels = false;
      return _this;
    }
    BlurFilter2.prototype.apply = function(filterManager, input, output2, clearMode) {
      var xStrength = Math.abs(this.blurXFilter.strength);
      var yStrength = Math.abs(this.blurYFilter.strength);
      if (xStrength && yStrength) {
        var renderTarget = filterManager.getFilterTexture();
        this.blurXFilter.apply(filterManager, input, renderTarget, CLEAR_MODES$1.CLEAR);
        this.blurYFilter.apply(filterManager, renderTarget, output2, clearMode);
        filterManager.returnFilterTexture(renderTarget);
      } else if (yStrength) {
        this.blurYFilter.apply(filterManager, input, output2, clearMode);
      } else {
        this.blurXFilter.apply(filterManager, input, output2, clearMode);
      }
    };
    BlurFilter2.prototype.updatePadding = function() {
      if (this._repeatEdgePixels) {
        this.padding = 0;
      } else {
        this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
      }
    };
    Object.defineProperty(BlurFilter2.prototype, "blur", {
      /**
       * Sets the strength of both the blurX and blurY properties simultaneously
       * @default 2
       */
      get: function() {
        return this.blurXFilter.blur;
      },
      set: function(value) {
        this.blurXFilter.blur = this.blurYFilter.blur = value;
        this.updatePadding();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BlurFilter2.prototype, "quality", {
      /**
       * Sets the number of passes for blur. More passes means higher quality bluring.
       * @default 1
       */
      get: function() {
        return this.blurXFilter.quality;
      },
      set: function(value) {
        this.blurXFilter.quality = this.blurYFilter.quality = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BlurFilter2.prototype, "blurX", {
      /**
       * Sets the strength of the blurX property
       * @default 2
       */
      get: function() {
        return this.blurXFilter.blur;
      },
      set: function(value) {
        this.blurXFilter.blur = value;
        this.updatePadding();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BlurFilter2.prototype, "blurY", {
      /**
       * Sets the strength of the blurY property
       * @default 2
       */
      get: function() {
        return this.blurYFilter.blur;
      },
      set: function(value) {
        this.blurYFilter.blur = value;
        this.updatePadding();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BlurFilter2.prototype, "blendMode", {
      /**
       * Sets the blendmode of the filter
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get: function() {
        return this.blurYFilter.blendMode;
      },
      set: function(value) {
        this.blurYFilter.blendMode = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BlurFilter2.prototype, "repeatEdgePixels", {
      /**
       * If set to true the edge of the target will be clamped
       * @default false
       */
      get: function() {
        return this._repeatEdgePixels;
      },
      set: function(value) {
        this._repeatEdgePixels = value;
        this.updatePadding();
      },
      enumerable: false,
      configurable: true
    });
    return BlurFilter2;
  }(Filter)
);
/*!
 * @pixi/filter-color-matrix - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/filter-color-matrix is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$H = function(d2, b2) {
  extendStatics$H = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (b3.hasOwnProperty(p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$H(d2, b2);
};
function __extends$H(d2, b2) {
  extendStatics$H(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var fragment$y = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n";
var ColorMatrixFilter = (
  /** @class */
  function(_super) {
    __extends$H(ColorMatrixFilter2, _super);
    function ColorMatrixFilter2() {
      var _this = this;
      var uniforms = {
        m: new Float32Array([
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ]),
        uAlpha: 1
      };
      _this = _super.call(this, defaultFilterVertex, fragment$y, uniforms) || this;
      _this.alpha = 1;
      return _this;
    }
    ColorMatrixFilter2.prototype._loadMatrix = function(matrix, multiply) {
      if (multiply === void 0) {
        multiply = false;
      }
      var newMatrix = matrix;
      if (multiply) {
        this._multiply(newMatrix, this.uniforms.m, matrix);
        newMatrix = this._colorMatrix(newMatrix);
      }
      this.uniforms.m = newMatrix;
    };
    ColorMatrixFilter2.prototype._multiply = function(out, a2, b2) {
      out[0] = a2[0] * b2[0] + a2[1] * b2[5] + a2[2] * b2[10] + a2[3] * b2[15];
      out[1] = a2[0] * b2[1] + a2[1] * b2[6] + a2[2] * b2[11] + a2[3] * b2[16];
      out[2] = a2[0] * b2[2] + a2[1] * b2[7] + a2[2] * b2[12] + a2[3] * b2[17];
      out[3] = a2[0] * b2[3] + a2[1] * b2[8] + a2[2] * b2[13] + a2[3] * b2[18];
      out[4] = a2[0] * b2[4] + a2[1] * b2[9] + a2[2] * b2[14] + a2[3] * b2[19] + a2[4];
      out[5] = a2[5] * b2[0] + a2[6] * b2[5] + a2[7] * b2[10] + a2[8] * b2[15];
      out[6] = a2[5] * b2[1] + a2[6] * b2[6] + a2[7] * b2[11] + a2[8] * b2[16];
      out[7] = a2[5] * b2[2] + a2[6] * b2[7] + a2[7] * b2[12] + a2[8] * b2[17];
      out[8] = a2[5] * b2[3] + a2[6] * b2[8] + a2[7] * b2[13] + a2[8] * b2[18];
      out[9] = a2[5] * b2[4] + a2[6] * b2[9] + a2[7] * b2[14] + a2[8] * b2[19] + a2[9];
      out[10] = a2[10] * b2[0] + a2[11] * b2[5] + a2[12] * b2[10] + a2[13] * b2[15];
      out[11] = a2[10] * b2[1] + a2[11] * b2[6] + a2[12] * b2[11] + a2[13] * b2[16];
      out[12] = a2[10] * b2[2] + a2[11] * b2[7] + a2[12] * b2[12] + a2[13] * b2[17];
      out[13] = a2[10] * b2[3] + a2[11] * b2[8] + a2[12] * b2[13] + a2[13] * b2[18];
      out[14] = a2[10] * b2[4] + a2[11] * b2[9] + a2[12] * b2[14] + a2[13] * b2[19] + a2[14];
      out[15] = a2[15] * b2[0] + a2[16] * b2[5] + a2[17] * b2[10] + a2[18] * b2[15];
      out[16] = a2[15] * b2[1] + a2[16] * b2[6] + a2[17] * b2[11] + a2[18] * b2[16];
      out[17] = a2[15] * b2[2] + a2[16] * b2[7] + a2[17] * b2[12] + a2[18] * b2[17];
      out[18] = a2[15] * b2[3] + a2[16] * b2[8] + a2[17] * b2[13] + a2[18] * b2[18];
      out[19] = a2[15] * b2[4] + a2[16] * b2[9] + a2[17] * b2[14] + a2[18] * b2[19] + a2[19];
      return out;
    };
    ColorMatrixFilter2.prototype._colorMatrix = function(matrix) {
      var m2 = new Float32Array(matrix);
      m2[4] /= 255;
      m2[9] /= 255;
      m2[14] /= 255;
      m2[19] /= 255;
      return m2;
    };
    ColorMatrixFilter2.prototype.brightness = function(b2, multiply) {
      var matrix = [
        b2,
        0,
        0,
        0,
        0,
        0,
        b2,
        0,
        0,
        0,
        0,
        0,
        b2,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    };
    ColorMatrixFilter2.prototype.tint = function(color2, multiply) {
      var r2 = color2 >> 16 & 255;
      var g2 = color2 >> 8 & 255;
      var b2 = color2 & 255;
      var matrix = [
        r2 / 255,
        0,
        0,
        0,
        0,
        0,
        g2 / 255,
        0,
        0,
        0,
        0,
        0,
        b2 / 255,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    };
    ColorMatrixFilter2.prototype.greyscale = function(scale, multiply) {
      var matrix = [
        scale,
        scale,
        scale,
        0,
        0,
        scale,
        scale,
        scale,
        0,
        0,
        scale,
        scale,
        scale,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    };
    ColorMatrixFilter2.prototype.blackAndWhite = function(multiply) {
      var matrix = [
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    };
    ColorMatrixFilter2.prototype.hue = function(rotation, multiply) {
      rotation = (rotation || 0) / 180 * Math.PI;
      var cosR = Math.cos(rotation);
      var sinR = Math.sin(rotation);
      var sqrt = Math.sqrt;
      var w2 = 1 / 3;
      var sqrW = sqrt(w2);
      var a00 = cosR + (1 - cosR) * w2;
      var a01 = w2 * (1 - cosR) - sqrW * sinR;
      var a02 = w2 * (1 - cosR) + sqrW * sinR;
      var a10 = w2 * (1 - cosR) + sqrW * sinR;
      var a11 = cosR + w2 * (1 - cosR);
      var a12 = w2 * (1 - cosR) - sqrW * sinR;
      var a20 = w2 * (1 - cosR) - sqrW * sinR;
      var a21 = w2 * (1 - cosR) + sqrW * sinR;
      var a22 = cosR + w2 * (1 - cosR);
      var matrix = [
        a00,
        a01,
        a02,
        0,
        0,
        a10,
        a11,
        a12,
        0,
        0,
        a20,
        a21,
        a22,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    };
    ColorMatrixFilter2.prototype.contrast = function(amount, multiply) {
      var v2 = (amount || 0) + 1;
      var o2 = -0.5 * (v2 - 1);
      var matrix = [
        v2,
        0,
        0,
        0,
        o2,
        0,
        v2,
        0,
        0,
        o2,
        0,
        0,
        v2,
        0,
        o2,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    };
    ColorMatrixFilter2.prototype.saturate = function(amount, multiply) {
      if (amount === void 0) {
        amount = 0;
      }
      var x = amount * 2 / 3 + 1;
      var y2 = (x - 1) * -0.5;
      var matrix = [
        x,
        y2,
        y2,
        0,
        0,
        y2,
        x,
        y2,
        0,
        0,
        y2,
        y2,
        x,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    };
    ColorMatrixFilter2.prototype.desaturate = function() {
      this.saturate(-1);
    };
    ColorMatrixFilter2.prototype.negative = function(multiply) {
      var matrix = [
        -1,
        0,
        0,
        1,
        0,
        0,
        -1,
        0,
        1,
        0,
        0,
        0,
        -1,
        1,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    };
    ColorMatrixFilter2.prototype.sepia = function(multiply) {
      var matrix = [
        0.393,
        0.7689999,
        0.18899999,
        0,
        0,
        0.349,
        0.6859999,
        0.16799999,
        0,
        0,
        0.272,
        0.5339999,
        0.13099999,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    };
    ColorMatrixFilter2.prototype.technicolor = function(multiply) {
      var matrix = [
        1.9125277891456083,
        -0.8545344976951645,
        -0.09155508482755585,
        0,
        11.793603434377337,
        -0.3087833385928097,
        1.7658908555458428,
        -0.10601743074722245,
        0,
        -70.35205161461398,
        -0.231103377548616,
        -0.7501899197440212,
        1.847597816108189,
        0,
        30.950940869491138,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    };
    ColorMatrixFilter2.prototype.polaroid = function(multiply) {
      var matrix = [
        1.438,
        -0.062,
        -0.062,
        0,
        0,
        -0.122,
        1.378,
        -0.122,
        0,
        0,
        -0.016,
        -0.016,
        1.483,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    };
    ColorMatrixFilter2.prototype.toBGR = function(multiply) {
      var matrix = [
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    };
    ColorMatrixFilter2.prototype.kodachrome = function(multiply) {
      var matrix = [
        1.1285582396593525,
        -0.3967382283601348,
        -0.03992559172921793,
        0,
        63.72958762196502,
        -0.16404339962244616,
        1.0835251566291304,
        -0.05498805115633132,
        0,
        24.732407896706203,
        -0.16786010706155763,
        -0.5603416277695248,
        1.6014850761964943,
        0,
        35.62982807460946,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    };
    ColorMatrixFilter2.prototype.browni = function(multiply) {
      var matrix = [
        0.5997023498159715,
        0.34553243048391263,
        -0.2708298674538042,
        0,
        47.43192855600873,
        -0.037703249837783157,
        0.8609577587992641,
        0.15059552388459913,
        0,
        -36.96841498319127,
        0.24113635128153335,
        -0.07441037908422492,
        0.44972182064877153,
        0,
        -7.562075277591283,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    };
    ColorMatrixFilter2.prototype.vintage = function(multiply) {
      var matrix = [
        0.6279345635605994,
        0.3202183420819367,
        -0.03965408211312453,
        0,
        9.651285835294123,
        0.02578397704808868,
        0.6441188644374771,
        0.03259127616149294,
        0,
        7.462829176470591,
        0.0466055556782719,
        -0.0851232987247891,
        0.5241648018700465,
        0,
        5.159190588235296,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    };
    ColorMatrixFilter2.prototype.colorTone = function(desaturation, toned, lightColor, darkColor, multiply) {
      desaturation = desaturation || 0.2;
      toned = toned || 0.15;
      lightColor = lightColor || 16770432;
      darkColor = darkColor || 3375104;
      var lR = (lightColor >> 16 & 255) / 255;
      var lG = (lightColor >> 8 & 255) / 255;
      var lB = (lightColor & 255) / 255;
      var dR = (darkColor >> 16 & 255) / 255;
      var dG = (darkColor >> 8 & 255) / 255;
      var dB = (darkColor & 255) / 255;
      var matrix = [
        0.3,
        0.59,
        0.11,
        0,
        0,
        lR,
        lG,
        lB,
        desaturation,
        0,
        dR,
        dG,
        dB,
        toned,
        0,
        lR - dR,
        lG - dG,
        lB - dB,
        0,
        0
      ];
      this._loadMatrix(matrix, multiply);
    };
    ColorMatrixFilter2.prototype.night = function(intensity, multiply) {
      intensity = intensity || 0.1;
      var matrix = [
        intensity * -2,
        -intensity,
        0,
        0,
        0,
        -intensity,
        0,
        intensity,
        0,
        0,
        0,
        intensity,
        intensity * 2,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    };
    ColorMatrixFilter2.prototype.predator = function(amount, multiply) {
      var matrix = [
        // row 1
        11.224130630493164 * amount,
        -4.794486999511719 * amount,
        -2.8746118545532227 * amount,
        0 * amount,
        0.40342438220977783 * amount,
        // row 2
        -3.6330697536468506 * amount,
        9.193157196044922 * amount,
        -2.951810836791992 * amount,
        0 * amount,
        -1.316135048866272 * amount,
        // row 3
        -3.2184197902679443 * amount,
        -4.2375030517578125 * amount,
        7.476448059082031 * amount,
        0 * amount,
        0.8044459223747253 * amount,
        // row 4
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    };
    ColorMatrixFilter2.prototype.lsd = function(multiply) {
      var matrix = [
        2,
        -0.4,
        0.5,
        0,
        0,
        -0.5,
        2,
        -0.4,
        0,
        0,
        -0.4,
        -0.5,
        3,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    };
    ColorMatrixFilter2.prototype.reset = function() {
      var matrix = [
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, false);
    };
    Object.defineProperty(ColorMatrixFilter2.prototype, "matrix", {
      /**
       * The matrix of the color matrix filter
       * @member {number[]}
       * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
       */
      get: function() {
        return this.uniforms.m;
      },
      set: function(value) {
        this.uniforms.m = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ColorMatrixFilter2.prototype, "alpha", {
      /**
       * The opacity value to use when mixing the original and resultant colors.
       *
       * When the value is 0, the original color is used without modification.
       * When the value is 1, the result color is used.
       * When in the range (0, 1) the color is interpolated between the original and result by this amount.
       * @default 1
       */
      get: function() {
        return this.uniforms.uAlpha;
      },
      set: function(value) {
        this.uniforms.uAlpha = value;
      },
      enumerable: false,
      configurable: true
    });
    return ColorMatrixFilter2;
  }(Filter)
);
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
/*!
 * @pixi/filter-displacement - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/filter-displacement is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$G = function(d2, b2) {
  extendStatics$G = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (b3.hasOwnProperty(p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$G(d2, b2);
};
function __extends$G(d2, b2) {
  extendStatics$G(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var fragment$x = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n";
var vertex$w = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n";
var DisplacementFilter = (
  /** @class */
  function(_super) {
    __extends$G(DisplacementFilter2, _super);
    function DisplacementFilter2(sprite, scale) {
      var _this = this;
      var maskMatrix = new Matrix();
      sprite.renderable = false;
      _this = _super.call(this, vertex$w, fragment$x, {
        mapSampler: sprite._texture,
        filterMatrix: maskMatrix,
        scale: { x: 1, y: 1 },
        rotation: new Float32Array([1, 0, 0, 1])
      }) || this;
      _this.maskSprite = sprite;
      _this.maskMatrix = maskMatrix;
      if (scale === null || scale === void 0) {
        scale = 20;
      }
      _this.scale = new Point(scale, scale);
      return _this;
    }
    DisplacementFilter2.prototype.apply = function(filterManager, input, output2, clearMode) {
      this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
      this.uniforms.scale.x = this.scale.x;
      this.uniforms.scale.y = this.scale.y;
      var wt = this.maskSprite.worldTransform;
      var lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
      var lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
      if (lenX !== 0 && lenY !== 0) {
        this.uniforms.rotation[0] = wt.a / lenX;
        this.uniforms.rotation[1] = wt.b / lenX;
        this.uniforms.rotation[2] = wt.c / lenY;
        this.uniforms.rotation[3] = wt.d / lenY;
      }
      filterManager.applyFilter(this, input, output2, clearMode);
    };
    Object.defineProperty(DisplacementFilter2.prototype, "map", {
      /** The texture used for the displacement map. Must be power of 2 sized texture. */
      get: function() {
        return this.uniforms.mapSampler;
      },
      set: function(value) {
        this.uniforms.mapSampler = value;
      },
      enumerable: false,
      configurable: true
    });
    return DisplacementFilter2;
  }(Filter)
);
/*!
 * @pixi/filter-fxaa - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/filter-fxaa is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$F = function(d2, b2) {
  extendStatics$F = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (b3.hasOwnProperty(p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$F(d2, b2);
};
function __extends$F(d2, b2) {
  extendStatics$F(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$v = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n";
var fragment$w = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
var FXAAFilter = (
  /** @class */
  function(_super) {
    __extends$F(FXAAFilter2, _super);
    function FXAAFilter2() {
      return _super.call(this, vertex$v, fragment$w) || this;
    }
    return FXAAFilter2;
  }(Filter)
);
/*!
 * @pixi/filter-noise - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/filter-noise is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$E = function(d2, b2) {
  extendStatics$E = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (b3.hasOwnProperty(p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$E(d2, b2);
};
function __extends$E(d2, b2) {
  extendStatics$E(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var fragment$v = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n";
var NoiseFilter = (
  /** @class */
  function(_super) {
    __extends$E(NoiseFilter2, _super);
    function NoiseFilter2(noise, seed) {
      if (noise === void 0) {
        noise = 0.5;
      }
      if (seed === void 0) {
        seed = Math.random();
      }
      var _this = _super.call(this, defaultFilterVertex, fragment$v, {
        uNoise: 0,
        uSeed: 0
      }) || this;
      _this.noise = noise;
      _this.seed = seed;
      return _this;
    }
    Object.defineProperty(NoiseFilter2.prototype, "noise", {
      /**
       * The amount of noise to apply, this value should be in the range (0, 1].
       * @default 0.5
       */
      get: function() {
        return this.uniforms.uNoise;
      },
      set: function(value) {
        this.uniforms.uNoise = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NoiseFilter2.prototype, "seed", {
      /** A seed value to apply to the random noise generation. `Math.random()` is a good value to use. */
      get: function() {
        return this.uniforms.uSeed;
      },
      set: function(value) {
        this.uniforms.uSeed = value;
      },
      enumerable: false,
      configurable: true
    });
    return NoiseFilter2;
  }(Filter)
);
/*!
 * @pixi/mixin-cache-as-bitmap - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*!
 * @pixi/constants - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV;
(function(ENV2) {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
})(ENV || (ENV = {}));
var RENDERER_TYPE;
(function(RENDERER_TYPE2) {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE || (RENDERER_TYPE = {}));
var BUFFER_BITS;
(function(BUFFER_BITS2) {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS || (BUFFER_BITS = {}));
var BLEND_MODES;
(function(BLEND_MODES2) {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
})(BLEND_MODES || (BLEND_MODES = {}));
var DRAW_MODES;
(function(DRAW_MODES2) {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES || (DRAW_MODES = {}));
var FORMATS;
(function(FORMATS2) {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS || (FORMATS = {}));
var TARGETS;
(function(TARGETS2) {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS || (TARGETS = {}));
var TYPES;
(function(TYPES2) {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES || (TYPES = {}));
var SAMPLER_TYPES;
(function(SAMPLER_TYPES2) {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
})(SAMPLER_TYPES || (SAMPLER_TYPES = {}));
var SCALE_MODES;
(function(SCALE_MODES2) {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES || (SCALE_MODES = {}));
var WRAP_MODES;
(function(WRAP_MODES2) {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES || (WRAP_MODES = {}));
var MIPMAP_MODES;
(function(MIPMAP_MODES2) {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
})(MIPMAP_MODES || (MIPMAP_MODES = {}));
var ALPHA_MODES;
(function(ALPHA_MODES2) {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES || (ALPHA_MODES = {}));
var CLEAR_MODES;
(function(CLEAR_MODES2) {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES || (CLEAR_MODES = {}));
var GC_MODES;
(function(GC_MODES2) {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
})(GC_MODES || (GC_MODES = {}));
var PRECISION;
(function(PRECISION2) {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
})(PRECISION || (PRECISION = {}));
var MASK_TYPES;
(function(MASK_TYPES2) {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
})(MASK_TYPES || (MASK_TYPES = {}));
var MSAA_QUALITY;
(function(MSAA_QUALITY2) {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY || (MSAA_QUALITY = {}));
var BUFFER_TYPE;
(function(BUFFER_TYPE2) {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE || (BUFFER_TYPE = {}));
var _tempMatrix = new Matrix();
DisplayObject$1.prototype._cacheAsBitmap = false;
DisplayObject$1.prototype._cacheData = null;
DisplayObject$1.prototype._cacheAsBitmapResolution = null;
DisplayObject$1.prototype._cacheAsBitmapMultisample = MSAA_QUALITY.NONE;
var CacheData = (
  /** @class */
  function() {
    function CacheData2() {
      this.textureCacheId = null;
      this.originalRender = null;
      this.originalRenderCanvas = null;
      this.originalCalculateBounds = null;
      this.originalGetLocalBounds = null;
      this.originalUpdateTransform = null;
      this.originalDestroy = null;
      this.originalMask = null;
      this.originalFilterArea = null;
      this.originalContainsPoint = null;
      this.sprite = null;
    }
    return CacheData2;
  }()
);
Object.defineProperties(DisplayObject$1.prototype, {
  /**
   * The resolution to use for cacheAsBitmap. By default this will use the renderer's resolution
   * but can be overriden for performance. Lower values will reduce memory usage at the expense
   * of render quality. A falsey value of `null` or `0` will default to the renderer's resolution.
   * If `cacheAsBitmap` is set to `true`, this will re-render with the new resolution.
   * @member {number} cacheAsBitmapResolution
   * @memberof PIXI.DisplayObject#
   * @default null
   */
  cacheAsBitmapResolution: {
    get: function() {
      return this._cacheAsBitmapResolution;
    },
    set: function(resolution) {
      if (resolution === this._cacheAsBitmapResolution) {
        return;
      }
      this._cacheAsBitmapResolution = resolution;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  /**
   * The number of samples to use for cacheAsBitmap. If set to `null`, the renderer's
   * sample count is used.
   * If `cacheAsBitmap` is set to `true`, this will re-render with the new number of samples.
   * @member {number} cacheAsBitmapMultisample
   * @memberof PIXI.DisplayObject#
   * @default PIXI.MSAA_QUALITY.NONE
   */
  cacheAsBitmapMultisample: {
    get: function() {
      return this._cacheAsBitmapMultisample;
    },
    set: function(multisample) {
      if (multisample === this._cacheAsBitmapMultisample) {
        return;
      }
      this._cacheAsBitmapMultisample = multisample;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  /**
   * Set this to true if you want this display object to be cached as a bitmap.
   * This basically takes a snap shot of the display object as it is at that moment. It can
   * provide a performance benefit for complex static displayObjects.
   * To remove simply set this property to `false`
   *
   * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true
   * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  cacheAsBitmap: {
    get: function() {
      return this._cacheAsBitmap;
    },
    set: function(value) {
      if (this._cacheAsBitmap === value) {
        return;
      }
      this._cacheAsBitmap = value;
      var data2;
      if (value) {
        if (!this._cacheData) {
          this._cacheData = new CacheData();
        }
        data2 = this._cacheData;
        data2.originalRender = this.render;
        data2.originalRenderCanvas = this.renderCanvas;
        data2.originalUpdateTransform = this.updateTransform;
        data2.originalCalculateBounds = this.calculateBounds;
        data2.originalGetLocalBounds = this.getLocalBounds;
        data2.originalDestroy = this.destroy;
        data2.originalContainsPoint = this.containsPoint;
        data2.originalMask = this._mask;
        data2.originalFilterArea = this.filterArea;
        this.render = this._renderCached;
        this.renderCanvas = this._renderCachedCanvas;
        this.destroy = this._cacheAsBitmapDestroy;
      } else {
        data2 = this._cacheData;
        if (data2.sprite) {
          this._destroyCachedDisplayObject();
        }
        this.render = data2.originalRender;
        this.renderCanvas = data2.originalRenderCanvas;
        this.calculateBounds = data2.originalCalculateBounds;
        this.getLocalBounds = data2.originalGetLocalBounds;
        this.destroy = data2.originalDestroy;
        this.updateTransform = data2.originalUpdateTransform;
        this.containsPoint = data2.originalContainsPoint;
        this._mask = data2.originalMask;
        this.filterArea = data2.originalFilterArea;
      }
    }
  }
});
DisplayObject$1.prototype._renderCached = function _renderCached(renderer) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObject(renderer);
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._render(renderer);
};
DisplayObject$1.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer) {
  var _a2;
  if (this._cacheData && this._cacheData.sprite) {
    return;
  }
  var cacheAlpha = this.alpha;
  this.alpha = 1;
  renderer.batch.flush();
  var bounds = this.getLocalBounds(null, true).clone();
  if (this.filters && this.filters.length) {
    var padding = this.filters[0].padding;
    bounds.pad(padding);
  }
  bounds.ceil(settings$2.RESOLUTION);
  var cachedRenderTexture = renderer.renderTexture.current;
  var cachedSourceFrame = renderer.renderTexture.sourceFrame.clone();
  var cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone();
  var cachedProjectionTransform = renderer.projection.transform;
  var renderTexture = RenderTexture.create({
    width: bounds.width,
    height: bounds.height,
    resolution: this.cacheAsBitmapResolution || renderer.resolution,
    multisample: (_a2 = this.cacheAsBitmapMultisample) !== null && _a2 !== void 0 ? _a2 : renderer.multisample
  });
  var textureCacheId = "cacheAsBitmap_" + uid();
  this._cacheData.textureCacheId = textureCacheId;
  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  Texture.addToCache(renderTexture, textureCacheId);
  var m2 = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
  this.render = this._cacheData.originalRender;
  renderer.render(this, { renderTexture, clear: true, transform: m2, skipUpdateTransform: false });
  renderer.framebuffer.blit();
  renderer.projection.transform = cachedProjectionTransform;
  renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);
  this.render = this._renderCached;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  var cachedSprite = new Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.enableTempParent();
    this.updateTransform();
    this.disableTempParent(null);
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
DisplayObject$1.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObjectCanvas(renderer);
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._renderCanvas(renderer);
};
DisplayObject$1.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer) {
  if (this._cacheData && this._cacheData.sprite) {
    return;
  }
  var bounds = this.getLocalBounds(null, true);
  var cacheAlpha = this.alpha;
  this.alpha = 1;
  var cachedRenderTarget = renderer.context;
  var cachedProjectionTransform = renderer._projTransform;
  bounds.ceil(settings$2.RESOLUTION);
  var renderTexture = RenderTexture.create({ width: bounds.width, height: bounds.height });
  var textureCacheId = "cacheAsBitmap_" + uid();
  this._cacheData.textureCacheId = textureCacheId;
  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  Texture.addToCache(renderTexture, textureCacheId);
  var m2 = _tempMatrix;
  this.transform.localTransform.copyTo(m2);
  m2.invert();
  m2.tx -= bounds.x;
  m2.ty -= bounds.y;
  this.renderCanvas = this._cacheData.originalRenderCanvas;
  renderer.render(this, { renderTexture, clear: true, transform: m2, skipUpdateTransform: false });
  renderer.context = cachedRenderTarget;
  renderer._projTransform = cachedProjectionTransform;
  this.renderCanvas = this._renderCachedCanvas;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  var cachedSprite = new Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.parent = renderer._tempDisplayObjectParent;
    this.updateTransform();
    this.parent = null;
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
DisplayObject$1.prototype._calculateCachedBounds = function _calculateCachedBounds() {
  this._bounds.clear();
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite._calculateBounds();
  this._bounds.updateID = this._boundsID;
};
DisplayObject$1.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {
  return this._cacheData.sprite.getLocalBounds(null);
};
DisplayObject$1.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {
  this._cacheData.sprite._texture.destroy(true);
  this._cacheData.sprite = null;
  BaseTexture.removeFromCache(this._cacheData.textureCacheId);
  Texture.removeFromCache(this._cacheData.textureCacheId);
  this._cacheData.textureCacheId = null;
};
DisplayObject$1.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) {
  this.cacheAsBitmap = false;
  this.destroy(options);
};
/*!
 * @pixi/mixin-get-child-by-name - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/mixin-get-child-by-name is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
DisplayObject$1.prototype.name = null;
Container$1.prototype.getChildByName = function getChildByName(name, deep) {
  for (var i2 = 0, j2 = this.children.length; i2 < j2; i2++) {
    if (this.children[i2].name === name) {
      return this.children[i2];
    }
  }
  if (deep) {
    for (var i2 = 0, j2 = this.children.length; i2 < j2; i2++) {
      var child = this.children[i2];
      if (!child.getChildByName) {
        continue;
      }
      var target = this.children[i2].getChildByName(name, true);
      if (target) {
        return target;
      }
    }
  }
  return null;
};
/*!
 * @pixi/mixin-get-global-position - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/mixin-get-global-position is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
DisplayObject$1.prototype.getGlobalPosition = function getGlobalPosition(point, skipUpdate) {
  if (point === void 0) {
    point = new Point();
  }
  if (skipUpdate === void 0) {
    skipUpdate = false;
  }
  if (this.parent) {
    this.parent.toGlobal(this.position, point, skipUpdate);
  } else {
    point.x = this.position.x;
    point.y = this.position.y;
  }
  return point;
};
/*!
 * @pixi/mesh-extras - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/mesh-extras is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$D = function(d2, b2) {
  extendStatics$D = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (b3.hasOwnProperty(p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$D(d2, b2);
};
function __extends$D(d2, b2) {
  extendStatics$D(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var PlaneGeometry = (
  /** @class */
  function(_super) {
    __extends$D(PlaneGeometry2, _super);
    function PlaneGeometry2(width, height, segWidth, segHeight) {
      if (width === void 0) {
        width = 100;
      }
      if (height === void 0) {
        height = 100;
      }
      if (segWidth === void 0) {
        segWidth = 10;
      }
      if (segHeight === void 0) {
        segHeight = 10;
      }
      var _this = _super.call(this) || this;
      _this.segWidth = segWidth;
      _this.segHeight = segHeight;
      _this.width = width;
      _this.height = height;
      _this.build();
      return _this;
    }
    PlaneGeometry2.prototype.build = function() {
      var total = this.segWidth * this.segHeight;
      var verts = [];
      var uvs = [];
      var indices3 = [];
      var segmentsX = this.segWidth - 1;
      var segmentsY = this.segHeight - 1;
      var sizeX = this.width / segmentsX;
      var sizeY = this.height / segmentsY;
      for (var i2 = 0; i2 < total; i2++) {
        var x = i2 % this.segWidth;
        var y2 = i2 / this.segWidth | 0;
        verts.push(x * sizeX, y2 * sizeY);
        uvs.push(x / segmentsX, y2 / segmentsY);
      }
      var totalSub = segmentsX * segmentsY;
      for (var i2 = 0; i2 < totalSub; i2++) {
        var xpos = i2 % segmentsX;
        var ypos = i2 / segmentsX | 0;
        var value = ypos * this.segWidth + xpos;
        var value2 = ypos * this.segWidth + xpos + 1;
        var value3 = (ypos + 1) * this.segWidth + xpos;
        var value4 = (ypos + 1) * this.segWidth + xpos + 1;
        indices3.push(value, value2, value3, value2, value4, value3);
      }
      this.buffers[0].data = new Float32Array(verts);
      this.buffers[1].data = new Float32Array(uvs);
      this.indexBuffer.data = new Uint16Array(indices3);
      this.buffers[0].update();
      this.buffers[1].update();
      this.indexBuffer.update();
    };
    return PlaneGeometry2;
  }(MeshGeometry)
);
var RopeGeometry = (
  /** @class */
  function(_super) {
    __extends$D(RopeGeometry2, _super);
    function RopeGeometry2(width, points, textureScale) {
      if (width === void 0) {
        width = 200;
      }
      if (textureScale === void 0) {
        textureScale = 0;
      }
      var _this = _super.call(this, new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6)) || this;
      _this.points = points;
      _this._width = width;
      _this.textureScale = textureScale;
      _this.build();
      return _this;
    }
    Object.defineProperty(RopeGeometry2.prototype, "width", {
      /**
       * The width (i.e., thickness) of the rope.
       * @readonly
       */
      get: function() {
        return this._width;
      },
      enumerable: false,
      configurable: true
    });
    RopeGeometry2.prototype.build = function() {
      var points = this.points;
      if (!points) {
        return;
      }
      var vertexBuffer = this.getBuffer("aVertexPosition");
      var uvBuffer = this.getBuffer("aTextureCoord");
      var indexBuffer = this.getIndex();
      if (points.length < 1) {
        return;
      }
      if (vertexBuffer.data.length / 4 !== points.length) {
        vertexBuffer.data = new Float32Array(points.length * 4);
        uvBuffer.data = new Float32Array(points.length * 4);
        indexBuffer.data = new Uint16Array((points.length - 1) * 6);
      }
      var uvs = uvBuffer.data;
      var indices3 = indexBuffer.data;
      uvs[0] = 0;
      uvs[1] = 0;
      uvs[2] = 0;
      uvs[3] = 1;
      var amount = 0;
      var prev2 = points[0];
      var textureWidth = this._width * this.textureScale;
      var total = points.length;
      for (var i2 = 0; i2 < total; i2++) {
        var index2 = i2 * 4;
        if (this.textureScale > 0) {
          var dx = prev2.x - points[i2].x;
          var dy = prev2.y - points[i2].y;
          var distance = Math.sqrt(dx * dx + dy * dy);
          prev2 = points[i2];
          amount += distance / textureWidth;
        } else {
          amount = i2 / (total - 1);
        }
        uvs[index2] = amount;
        uvs[index2 + 1] = 0;
        uvs[index2 + 2] = amount;
        uvs[index2 + 3] = 1;
      }
      var indexCount = 0;
      for (var i2 = 0; i2 < total - 1; i2++) {
        var index2 = i2 * 2;
        indices3[indexCount++] = index2;
        indices3[indexCount++] = index2 + 1;
        indices3[indexCount++] = index2 + 2;
        indices3[indexCount++] = index2 + 2;
        indices3[indexCount++] = index2 + 1;
        indices3[indexCount++] = index2 + 3;
      }
      uvBuffer.update();
      indexBuffer.update();
      this.updateVertices();
    };
    RopeGeometry2.prototype.updateVertices = function() {
      var points = this.points;
      if (points.length < 1) {
        return;
      }
      var lastPoint = points[0];
      var nextPoint;
      var perpX = 0;
      var perpY = 0;
      var vertices = this.buffers[0].data;
      var total = points.length;
      for (var i2 = 0; i2 < total; i2++) {
        var point = points[i2];
        var index2 = i2 * 4;
        if (i2 < points.length - 1) {
          nextPoint = points[i2 + 1];
        } else {
          nextPoint = point;
        }
        perpY = -(nextPoint.x - lastPoint.x);
        perpX = nextPoint.y - lastPoint.y;
        var perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
        var num = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
        perpX /= perpLength;
        perpY /= perpLength;
        perpX *= num;
        perpY *= num;
        vertices[index2] = point.x + perpX;
        vertices[index2 + 1] = point.y + perpY;
        vertices[index2 + 2] = point.x - perpX;
        vertices[index2 + 3] = point.y - perpY;
        lastPoint = point;
      }
      this.buffers[0].update();
    };
    RopeGeometry2.prototype.update = function() {
      if (this.textureScale > 0) {
        this.build();
      } else {
        this.updateVertices();
      }
    };
    return RopeGeometry2;
  }(MeshGeometry)
);
var SimpleRope = (
  /** @class */
  function(_super) {
    __extends$D(SimpleRope2, _super);
    function SimpleRope2(texture, points, textureScale) {
      if (textureScale === void 0) {
        textureScale = 0;
      }
      var _this = this;
      var ropeGeometry = new RopeGeometry(texture.height, points, textureScale);
      var meshMaterial = new MeshMaterial(texture);
      if (textureScale > 0) {
        texture.baseTexture.wrapMode = WRAP_MODES$4.REPEAT;
      }
      _this = _super.call(this, ropeGeometry, meshMaterial) || this;
      _this.autoUpdate = true;
      return _this;
    }
    SimpleRope2.prototype._render = function(renderer) {
      var geometry = this.geometry;
      if (this.autoUpdate || geometry._width !== this.shader.texture.height) {
        geometry._width = this.shader.texture.height;
        geometry.update();
      }
      _super.prototype._render.call(this, renderer);
    };
    return SimpleRope2;
  }(Mesh)
);
var SimplePlane = (
  /** @class */
  function(_super) {
    __extends$D(SimplePlane2, _super);
    function SimplePlane2(texture, verticesX, verticesY) {
      var _this = this;
      var planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);
      var meshMaterial = new MeshMaterial(Texture.WHITE);
      _this = _super.call(this, planeGeometry, meshMaterial) || this;
      _this.texture = texture;
      _this.autoResize = true;
      return _this;
    }
    SimplePlane2.prototype.textureUpdated = function() {
      this._textureID = this.shader.texture._updateID;
      var geometry = this.geometry;
      var _a2 = this.shader.texture, width = _a2.width, height = _a2.height;
      if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {
        geometry.width = this.shader.texture.width;
        geometry.height = this.shader.texture.height;
        geometry.build();
      }
    };
    Object.defineProperty(SimplePlane2.prototype, "texture", {
      get: function() {
        return this.shader.texture;
      },
      set: function(value) {
        if (this.shader.texture === value) {
          return;
        }
        this.shader.texture = value;
        this._textureID = -1;
        if (value.baseTexture.valid) {
          this.textureUpdated();
        } else {
          value.once("update", this.textureUpdated, this);
        }
      },
      enumerable: false,
      configurable: true
    });
    SimplePlane2.prototype._render = function(renderer) {
      if (this._textureID !== this.shader.texture._updateID) {
        this.textureUpdated();
      }
      _super.prototype._render.call(this, renderer);
    };
    SimplePlane2.prototype.destroy = function(options) {
      this.shader.texture.off("update", this.textureUpdated, this);
      _super.prototype.destroy.call(this, options);
    };
    return SimplePlane2;
  }(Mesh)
);
var SimpleMesh = (
  /** @class */
  function(_super) {
    __extends$D(SimpleMesh2, _super);
    function SimpleMesh2(texture, vertices, uvs, indices3, drawMode) {
      if (texture === void 0) {
        texture = Texture.EMPTY;
      }
      var _this = this;
      var geometry = new MeshGeometry(vertices, uvs, indices3);
      geometry.getBuffer("aVertexPosition").static = false;
      var meshMaterial = new MeshMaterial(texture);
      _this = _super.call(this, geometry, meshMaterial, null, drawMode) || this;
      _this.autoUpdate = true;
      return _this;
    }
    Object.defineProperty(SimpleMesh2.prototype, "vertices", {
      /**
       * Collection of vertices data.
       * @type {Float32Array}
       */
      get: function() {
        return this.geometry.getBuffer("aVertexPosition").data;
      },
      set: function(value) {
        this.geometry.getBuffer("aVertexPosition").data = value;
      },
      enumerable: false,
      configurable: true
    });
    SimpleMesh2.prototype._render = function(renderer) {
      if (this.autoUpdate) {
        this.geometry.getBuffer("aVertexPosition").update();
      }
      _super.prototype._render.call(this, renderer);
    };
    return SimpleMesh2;
  }(Mesh)
);
var DEFAULT_BORDER_SIZE = 10;
var NineSlicePlane = (
  /** @class */
  function(_super) {
    __extends$D(NineSlicePlane2, _super);
    function NineSlicePlane2(texture, leftWidth, topHeight, rightWidth, bottomHeight) {
      if (leftWidth === void 0) {
        leftWidth = DEFAULT_BORDER_SIZE;
      }
      if (topHeight === void 0) {
        topHeight = DEFAULT_BORDER_SIZE;
      }
      if (rightWidth === void 0) {
        rightWidth = DEFAULT_BORDER_SIZE;
      }
      if (bottomHeight === void 0) {
        bottomHeight = DEFAULT_BORDER_SIZE;
      }
      var _this = _super.call(this, Texture.WHITE, 4, 4) || this;
      _this._origWidth = texture.orig.width;
      _this._origHeight = texture.orig.height;
      _this._width = _this._origWidth;
      _this._height = _this._origHeight;
      _this._leftWidth = leftWidth;
      _this._rightWidth = rightWidth;
      _this._topHeight = topHeight;
      _this._bottomHeight = bottomHeight;
      _this.texture = texture;
      return _this;
    }
    NineSlicePlane2.prototype.textureUpdated = function() {
      this._textureID = this.shader.texture._updateID;
      this._refresh();
    };
    Object.defineProperty(NineSlicePlane2.prototype, "vertices", {
      get: function() {
        return this.geometry.getBuffer("aVertexPosition").data;
      },
      set: function(value) {
        this.geometry.getBuffer("aVertexPosition").data = value;
      },
      enumerable: false,
      configurable: true
    });
    NineSlicePlane2.prototype.updateHorizontalVertices = function() {
      var vertices = this.vertices;
      var scale = this._getMinScale();
      vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;
      vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;
      vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;
    };
    NineSlicePlane2.prototype.updateVerticalVertices = function() {
      var vertices = this.vertices;
      var scale = this._getMinScale();
      vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;
      vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;
      vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;
    };
    NineSlicePlane2.prototype._getMinScale = function() {
      var w2 = this._leftWidth + this._rightWidth;
      var scaleW = this._width > w2 ? 1 : this._width / w2;
      var h2 = this._topHeight + this._bottomHeight;
      var scaleH = this._height > h2 ? 1 : this._height / h2;
      var scale = Math.min(scaleW, scaleH);
      return scale;
    };
    Object.defineProperty(NineSlicePlane2.prototype, "width", {
      /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
      get: function() {
        return this._width;
      },
      set: function(value) {
        this._width = value;
        this._refresh();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NineSlicePlane2.prototype, "height", {
      /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
      get: function() {
        return this._height;
      },
      set: function(value) {
        this._height = value;
        this._refresh();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NineSlicePlane2.prototype, "leftWidth", {
      /** The width of the left column. */
      get: function() {
        return this._leftWidth;
      },
      set: function(value) {
        this._leftWidth = value;
        this._refresh();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NineSlicePlane2.prototype, "rightWidth", {
      /** The width of the right column. */
      get: function() {
        return this._rightWidth;
      },
      set: function(value) {
        this._rightWidth = value;
        this._refresh();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NineSlicePlane2.prototype, "topHeight", {
      /** The height of the top row. */
      get: function() {
        return this._topHeight;
      },
      set: function(value) {
        this._topHeight = value;
        this._refresh();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NineSlicePlane2.prototype, "bottomHeight", {
      /** The height of the bottom row. */
      get: function() {
        return this._bottomHeight;
      },
      set: function(value) {
        this._bottomHeight = value;
        this._refresh();
      },
      enumerable: false,
      configurable: true
    });
    NineSlicePlane2.prototype._refresh = function() {
      var texture = this.texture;
      var uvs = this.geometry.buffers[1].data;
      this._origWidth = texture.orig.width;
      this._origHeight = texture.orig.height;
      var _uvw = 1 / this._origWidth;
      var _uvh = 1 / this._origHeight;
      uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
      uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
      uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
      uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
      uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
      uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
      uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
      uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
      this.updateHorizontalVertices();
      this.updateVerticalVertices();
      this.geometry.buffers[0].update();
      this.geometry.buffers[1].update();
    };
    return NineSlicePlane2;
  }(SimplePlane)
);
/*!
 * @pixi/sprite-animated - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * @pixi/sprite-animated is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$C = function(d2, b2) {
  extendStatics$C = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (b3.hasOwnProperty(p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$C(d2, b2);
};
function __extends$C(d2, b2) {
  extendStatics$C(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var AnimatedSprite = (
  /** @class */
  function(_super) {
    __extends$C(AnimatedSprite2, _super);
    function AnimatedSprite2(textures, autoUpdate) {
      if (autoUpdate === void 0) {
        autoUpdate = true;
      }
      var _this = _super.call(this, textures[0] instanceof Texture ? textures[0] : textures[0].texture) || this;
      _this._textures = null;
      _this._durations = null;
      _this._autoUpdate = autoUpdate;
      _this._isConnectedToTicker = false;
      _this.animationSpeed = 1;
      _this.loop = true;
      _this.updateAnchor = false;
      _this.onComplete = null;
      _this.onFrameChange = null;
      _this.onLoop = null;
      _this._currentTime = 0;
      _this._playing = false;
      _this._previousFrame = null;
      _this.textures = textures;
      return _this;
    }
    AnimatedSprite2.prototype.stop = function() {
      if (!this._playing) {
        return;
      }
      this._playing = false;
      if (this._autoUpdate && this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      }
    };
    AnimatedSprite2.prototype.play = function() {
      if (this._playing) {
        return;
      }
      this._playing = true;
      if (this._autoUpdate && !this._isConnectedToTicker) {
        Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);
        this._isConnectedToTicker = true;
      }
    };
    AnimatedSprite2.prototype.gotoAndStop = function(frameNumber) {
      this.stop();
      var previousFrame = this.currentFrame;
      this._currentTime = frameNumber;
      if (previousFrame !== this.currentFrame) {
        this.updateTexture();
      }
    };
    AnimatedSprite2.prototype.gotoAndPlay = function(frameNumber) {
      var previousFrame = this.currentFrame;
      this._currentTime = frameNumber;
      if (previousFrame !== this.currentFrame) {
        this.updateTexture();
      }
      this.play();
    };
    AnimatedSprite2.prototype.update = function(deltaTime) {
      if (!this._playing) {
        return;
      }
      var elapsed = this.animationSpeed * deltaTime;
      var previousFrame = this.currentFrame;
      if (this._durations !== null) {
        var lag = this._currentTime % 1 * this._durations[this.currentFrame];
        lag += elapsed / 60 * 1e3;
        while (lag < 0) {
          this._currentTime--;
          lag += this._durations[this.currentFrame];
        }
        var sign2 = Math.sign(this.animationSpeed * deltaTime);
        this._currentTime = Math.floor(this._currentTime);
        while (lag >= this._durations[this.currentFrame]) {
          lag -= this._durations[this.currentFrame] * sign2;
          this._currentTime += sign2;
        }
        this._currentTime += lag / this._durations[this.currentFrame];
      } else {
        this._currentTime += elapsed;
      }
      if (this._currentTime < 0 && !this.loop) {
        this.gotoAndStop(0);
        if (this.onComplete) {
          this.onComplete();
        }
      } else if (this._currentTime >= this._textures.length && !this.loop) {
        this.gotoAndStop(this._textures.length - 1);
        if (this.onComplete) {
          this.onComplete();
        }
      } else if (previousFrame !== this.currentFrame) {
        if (this.loop && this.onLoop) {
          if (this.animationSpeed > 0 && this.currentFrame < previousFrame) {
            this.onLoop();
          } else if (this.animationSpeed < 0 && this.currentFrame > previousFrame) {
            this.onLoop();
          }
        }
        this.updateTexture();
      }
    };
    AnimatedSprite2.prototype.updateTexture = function() {
      var currentFrame = this.currentFrame;
      if (this._previousFrame === currentFrame) {
        return;
      }
      this._previousFrame = currentFrame;
      this._texture = this._textures[currentFrame];
      this._textureID = -1;
      this._textureTrimmedID = -1;
      this._cachedTint = 16777215;
      this.uvs = this._texture._uvs.uvsFloat32;
      if (this.updateAnchor) {
        this._anchor.copyFrom(this._texture.defaultAnchor);
      }
      if (this.onFrameChange) {
        this.onFrameChange(this.currentFrame);
      }
    };
    AnimatedSprite2.prototype.destroy = function(options) {
      this.stop();
      _super.prototype.destroy.call(this, options);
      this.onComplete = null;
      this.onFrameChange = null;
      this.onLoop = null;
    };
    AnimatedSprite2.fromFrames = function(frames) {
      var textures = [];
      for (var i2 = 0; i2 < frames.length; ++i2) {
        textures.push(Texture.from(frames[i2]));
      }
      return new AnimatedSprite2(textures);
    };
    AnimatedSprite2.fromImages = function(images) {
      var textures = [];
      for (var i2 = 0; i2 < images.length; ++i2) {
        textures.push(Texture.from(images[i2]));
      }
      return new AnimatedSprite2(textures);
    };
    Object.defineProperty(AnimatedSprite2.prototype, "totalFrames", {
      /**
       * The total number of frames in the AnimatedSprite. This is the same as number of textures
       * assigned to the AnimatedSprite.
       * @readonly
       * @default 0
       */
      get: function() {
        return this._textures.length;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(AnimatedSprite2.prototype, "textures", {
      /** The array of textures used for this AnimatedSprite. */
      get: function() {
        return this._textures;
      },
      set: function(value) {
        if (value[0] instanceof Texture) {
          this._textures = value;
          this._durations = null;
        } else {
          this._textures = [];
          this._durations = [];
          for (var i2 = 0; i2 < value.length; i2++) {
            this._textures.push(value[i2].texture);
            this._durations.push(value[i2].time);
          }
        }
        this._previousFrame = null;
        this.gotoAndStop(0);
        this.updateTexture();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(AnimatedSprite2.prototype, "currentFrame", {
      /**
       * The AnimatedSprites current frame index.
       * @readonly
       */
      get: function() {
        var currentFrame = Math.floor(this._currentTime) % this._textures.length;
        if (currentFrame < 0) {
          currentFrame += this._textures.length;
        }
        return currentFrame;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(AnimatedSprite2.prototype, "playing", {
      /**
       * Indicates if the AnimatedSprite is currently playing.
       * @readonly
       */
      get: function() {
        return this._playing;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(AnimatedSprite2.prototype, "autoUpdate", {
      /** Whether to use PIXI.Ticker.shared to auto update animation time. */
      get: function() {
        return this._autoUpdate;
      },
      set: function(value) {
        if (value !== this._autoUpdate) {
          this._autoUpdate = value;
          if (!this._autoUpdate && this._isConnectedToTicker) {
            Ticker.shared.remove(this.update, this);
            this._isConnectedToTicker = false;
          } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
            Ticker.shared.add(this.update, this);
            this._isConnectedToTicker = true;
          }
        }
      },
      enumerable: false,
      configurable: true
    });
    return AnimatedSprite2;
  }(Sprite)
);
/*!
 * pixi.js - v6.4.2
 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
Renderer.registerPlugin("accessibility", AccessibilityManager);
Renderer.registerPlugin("extract", Extract);
Renderer.registerPlugin("interaction", InteractionManager);
Renderer.registerPlugin("particle", ParticleRenderer);
Renderer.registerPlugin("prepare", Prepare);
Renderer.registerPlugin("batch", BatchRenderer);
Renderer.registerPlugin("tilingSprite", TilingSpriteRenderer);
Loader.registerPlugin(BitmapFontLoader);
Loader.registerPlugin(CompressedTextureLoader);
Loader.registerPlugin(DDSLoader);
Loader.registerPlugin(KTXLoader);
Loader.registerPlugin(SpritesheetLoader);
Application.registerPlugin(TickerPlugin);
Application.registerPlugin(AppLoaderPlugin);
var VERSION = "6.4.2";
var filters = {
  AlphaFilter,
  BlurFilter,
  BlurFilterPass,
  ColorMatrixFilter,
  DisplacementFilter,
  FXAAFilter,
  NoiseFilter
};
const PIXI$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ALPHA_MODES() {
    return ALPHA_MODES$4;
  },
  AbstractBatchRenderer,
  AbstractMultiResource,
  AbstractRenderer,
  AccessibilityManager,
  AnimatedSprite,
  AppLoaderPlugin,
  Application,
  ArrayResource,
  Attribute,
  get BLEND_MODES() {
    return BLEND_MODES$4;
  },
  get BUFFER_BITS() {
    return BUFFER_BITS$4;
  },
  get BUFFER_TYPE() {
    return BUFFER_TYPE$4;
  },
  BaseImageResource,
  BasePrepare,
  BaseRenderTexture,
  BaseTexture,
  BatchDrawCall,
  BatchGeometry,
  BatchPluginFactory,
  BatchRenderer,
  BatchShaderGenerator,
  BatchSystem,
  BatchTextureArray,
  BitmapFont,
  BitmapFontData,
  BitmapFontLoader,
  BitmapText,
  BlobResource,
  Bounds: Bounds$1,
  Buffer: Buffer$1,
  BufferResource,
  get CLEAR_MODES() {
    return CLEAR_MODES$4;
  },
  CanvasResource,
  Circle,
  CompressedTextureLoader,
  CompressedTextureResource,
  Container: Container$1,
  ContextSystem,
  CountLimiter,
  CubeResource,
  DDSLoader,
  DEG_TO_RAD,
  get DRAW_MODES() {
    return DRAW_MODES$4;
  },
  DisplayObject: DisplayObject$1,
  get ENV() {
    return ENV$4;
  },
  Ellipse,
  Extract,
  get FORMATS() {
    return FORMATS$4;
  },
  FORMATS_TO_COMPONENTS,
  FillStyle,
  Filter,
  FilterState,
  FilterSystem,
  Framebuffer,
  FramebufferSystem,
  get GC_MODES() {
    return GC_MODES$4;
  },
  GLFramebuffer,
  GLProgram,
  GLTexture,
  GRAPHICS_CURVES,
  Geometry,
  GeometrySystem,
  Graphics,
  GraphicsData,
  GraphicsGeometry,
  IGLUniformData,
  INSTALLED,
  get INTERNAL_FORMATS() {
    return INTERNAL_FORMATS;
  },
  INTERNAL_FORMAT_TO_BYTES_PER_PIXEL,
  ImageBitmapResource,
  ImageResource,
  InteractionData,
  InteractionEvent,
  InteractionManager,
  InteractionTrackingData,
  KTXLoader,
  get LINE_CAP() {
    return LINE_CAP;
  },
  get LINE_JOIN() {
    return LINE_JOIN;
  },
  LineStyle,
  Loader,
  get LoaderResource() {
    return LoaderResource;
  },
  get MASK_TYPES() {
    return MASK_TYPES$4;
  },
  get MIPMAP_MODES() {
    return MIPMAP_MODES$4;
  },
  get MSAA_QUALITY() {
    return MSAA_QUALITY$4;
  },
  MaskData,
  MaskSystem,
  Matrix,
  Mesh,
  MeshBatchUvs,
  MeshGeometry,
  MeshMaterial,
  NineSlicePlane,
  ObjectRenderer,
  ObservablePoint,
  PI_2,
  get PRECISION() {
    return PRECISION$4;
  },
  ParticleContainer,
  ParticleRenderer,
  PlaneGeometry,
  Point,
  Polygon,
  Prepare,
  Program,
  ProjectionSystem,
  Quad,
  QuadUv,
  RAD_TO_DEG,
  get RENDERER_TYPE() {
    return RENDERER_TYPE$4;
  },
  Rectangle,
  RenderTexture,
  RenderTexturePool,
  RenderTextureSystem,
  Renderer,
  Resource,
  RopeGeometry,
  RoundedRectangle,
  Runner,
  get SAMPLER_TYPES() {
    return SAMPLER_TYPES$4;
  },
  get SCALE_MODES() {
    return SCALE_MODES$4;
  },
  get SHAPES() {
    return SHAPES;
  },
  SVGResource,
  ScissorSystem,
  Shader,
  ShaderSystem,
  SimpleMesh,
  SimplePlane,
  SimpleRope,
  Sprite,
  SpriteMaskFilter,
  Spritesheet,
  SpritesheetLoader,
  State,
  StateSystem,
  StencilSystem,
  System,
  get TARGETS() {
    return TARGETS$4;
  },
  get TEXT_GRADIENT() {
    return TEXT_GRADIENT;
  },
  get TYPES() {
    return TYPES$4;
  },
  TYPES_TO_BYTES_PER_COMPONENT,
  TYPES_TO_BYTES_PER_PIXEL,
  TemporaryDisplayObject: TemporaryDisplayObject$1,
  Text,
  TextMetrics,
  TextStyle,
  Texture,
  TextureGCSystem,
  TextureLoader,
  TextureMatrix,
  TextureSystem,
  TextureUvs,
  Ticker,
  TickerPlugin,
  TilingSprite,
  TilingSpriteRenderer,
  TimeLimiter,
  Transform,
  get UPDATE_PRIORITY() {
    return UPDATE_PRIORITY;
  },
  UniformGroup,
  VERSION,
  VideoResource,
  ViewableBuffer,
  get WRAP_MODES() {
    return WRAP_MODES$4;
  },
  accessibleTarget,
  autoDetectRenderer,
  autoDetectResource,
  checkMaxIfStatementsInShader,
  createUBOElements,
  defaultFilterVertex,
  defaultVertex: defaultVertex$1,
  filters,
  generateProgram,
  generateUniformBufferSync,
  getTestContext,
  getUBOData,
  graphicsUtils,
  groupD8,
  interactiveTarget,
  isMobile: isMobile$2,
  resources,
  settings: settings$2,
  systems,
  uniformParsers,
  utils
}, Symbol.toStringTag, { value: "Module" }));
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
  randomUUID
};
function v4(options, buf, offset) {
  if (native.randomUUID && !buf && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
/*!
 * @pixi/filter-old-film - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-old-film is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$B = function(d2, b2) {
  extendStatics$B = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$B(d2, b2);
};
function __extends$B(d2, b2) {
  extendStatics$B(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$u = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$u = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nuniform float sepia;\nuniform float noise;\nuniform float noiseSize;\nuniform float scratch;\nuniform float scratchDensity;\nuniform float scratchWidth;\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\nuniform float seed;\n\nconst float SQRT_2 = 1.414213;\nconst vec3 SEPIA_RGB = vec3(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 Overlay(vec3 src, vec3 dst)\n{\n    // if (dst <= 0.5) then: 2 * src * dst\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\n    return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),\n                (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),\n                (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\n}\n\n\nvoid main()\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 color = gl_FragColor.rgb;\n\n    if (sepia > 0.0)\n    {\n        float gray = (color.x + color.y + color.z) / 3.0;\n        vec3 grayscale = vec3(gray);\n\n        color = Overlay(SEPIA_RGB, grayscale);\n\n        color = grayscale + sepia * (color - grayscale);\n    }\n\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        vec2 dir = vec2(vec2(0.5, 0.5) - coord);\n        dir.y *= dimensions.y / dimensions.x;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        color.rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    if (scratchDensity > seed && scratch != 0.0)\n    {\n        float phase = seed * 256.0;\n        float s = mod(floor(phase), 2.0);\n        float dist = 1.0 / scratchDensity;\n        float d = distance(coord, vec2(seed * dist, abs(s - seed * dist)));\n        if (d < seed * 0.6 + 0.4)\n        {\n            highp float period = scratchDensity * 10.0;\n\n            float xx = coord.x * period + phase;\n            float aa = abs(mod(xx, 0.5) * 4.0);\n            float bb = mod(floor(xx / 0.5), 2.0);\n            float yy = (1.0 - bb) * aa + bb * (2.0 - aa);\n\n            float kk = 2.0 * period;\n            float dw = scratchWidth / dimensions.x * (0.75 + seed);\n            float dh = dw * kk;\n\n            float tine = (yy - (2.0 - dh));\n\n            if (tine > 0.0) {\n                float _sign = sign(scratch);\n\n                tine = s * tine / period + scratch + 0.1;\n                tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\n\n                color.rgb *= tine;\n            }\n        }\n    }\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        // vec2 d = pixelCoord * noiseSize * vec2(1024.0 + seed * 512.0, 1024.0 - seed * 512.0);\n        // float _noise = snoise(d) * 0.5;\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        color += _noise * noise;\n    }\n\n    gl_FragColor.rgb = color;\n}\n";
var OldFilmFilter = (
  /** @class */
  function(_super) {
    __extends$B(OldFilmFilter2, _super);
    function OldFilmFilter2(options, seed) {
      if (seed === void 0) {
        seed = 0;
      }
      var _this = _super.call(this, vertex$u, fragment$u) || this;
      _this.seed = 0;
      _this.uniforms.dimensions = new Float32Array(2);
      if (typeof options === "number") {
        _this.seed = options;
        options = void 0;
      } else {
        _this.seed = seed;
      }
      Object.assign(_this, OldFilmFilter2.defaults, options);
      return _this;
    }
    OldFilmFilter2.prototype.apply = function(filterManager, input, output2, clear2) {
      var _a2, _b2;
      this.uniforms.dimensions[0] = (_a2 = input.filterFrame) === null || _a2 === void 0 ? void 0 : _a2.width;
      this.uniforms.dimensions[1] = (_b2 = input.filterFrame) === null || _b2 === void 0 ? void 0 : _b2.height;
      this.uniforms.seed = this.seed;
      filterManager.applyFilter(this, input, output2, clear2);
    };
    Object.defineProperty(OldFilmFilter2.prototype, "sepia", {
      get: function() {
        return this.uniforms.sepia;
      },
      /**
       * The amount of saturation of sepia effect,
       * a value of `1` is more saturation and closer to `0` is less,
       * and a value of `0` produces no sepia effect
       * @default 0
       */
      set: function(value) {
        this.uniforms.sepia = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(OldFilmFilter2.prototype, "noise", {
      get: function() {
        return this.uniforms.noise;
      },
      /**
       * Opacity/intensity of the noise effect between `0` and `1`
       * @default 0
       */
      set: function(value) {
        this.uniforms.noise = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(OldFilmFilter2.prototype, "noiseSize", {
      get: function() {
        return this.uniforms.noiseSize;
      },
      /**
       * The size of the noise particles
       * @default 0
       */
      set: function(value) {
        this.uniforms.noiseSize = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(OldFilmFilter2.prototype, "scratch", {
      get: function() {
        return this.uniforms.scratch;
      },
      /**
       * How often scratches appear
       * @default 0
       */
      set: function(value) {
        this.uniforms.scratch = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(OldFilmFilter2.prototype, "scratchDensity", {
      get: function() {
        return this.uniforms.scratchDensity;
      },
      /**
       * The density of the number of scratches
       * @default 0
       */
      set: function(value) {
        this.uniforms.scratchDensity = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(OldFilmFilter2.prototype, "scratchWidth", {
      get: function() {
        return this.uniforms.scratchWidth;
      },
      /**
       * The width of the scratches
       * @default 0
       */
      set: function(value) {
        this.uniforms.scratchWidth = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(OldFilmFilter2.prototype, "vignetting", {
      get: function() {
        return this.uniforms.vignetting;
      },
      /**
       * The radius of the vignette effect, smaller
       * values produces a smaller vignette
       * @default 0
       */
      set: function(value) {
        this.uniforms.vignetting = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(OldFilmFilter2.prototype, "vignettingAlpha", {
      get: function() {
        return this.uniforms.vignettingAlpha;
      },
      /**
       * Amount of opacity of vignette
       * @default 0
       */
      set: function(value) {
        this.uniforms.vignettingAlpha = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(OldFilmFilter2.prototype, "vignettingBlur", {
      get: function() {
        return this.uniforms.vignettingBlur;
      },
      /**
       * Blur intensity of the vignette
       * @default 0
       */
      set: function(value) {
        this.uniforms.vignettingBlur = value;
      },
      enumerable: false,
      configurable: true
    });
    OldFilmFilter2.defaults = {
      sepia: 0.3,
      noise: 0.3,
      noiseSize: 1,
      scratch: 0.5,
      scratchDensity: 0.3,
      scratchWidth: 1,
      vignetting: 0.3,
      vignettingAlpha: 1,
      vignettingBlur: 0.3
    };
    return OldFilmFilter2;
  }(Filter)
);
/*!
 * @pixi/filter-dot - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-dot is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$A = function(d2, b2) {
  extendStatics$A = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$A(d2, b2);
};
function __extends$A(d2, b2) {
  extendStatics$A(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$t = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$t = "precision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform vec4 filterArea;\nuniform sampler2D uSampler;\n\nuniform float angle;\nuniform float scale;\n\nfloat pattern()\n{\n   float s = sin(angle), c = cos(angle);\n   vec2 tex = vTextureCoord * filterArea.xy;\n   vec2 point = vec2(\n       c * tex.x - s * tex.y,\n       s * tex.x + c * tex.y\n   ) * scale;\n   return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvoid main()\n{\n   vec4 color = texture2D(uSampler, vTextureCoord);\n   float average = (color.r + color.g + color.b) / 3.0;\n   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\n}\n";
var DotFilter = (
  /** @class */
  function(_super) {
    __extends$A(DotFilter2, _super);
    function DotFilter2(scale, angle) {
      if (scale === void 0) {
        scale = 1;
      }
      if (angle === void 0) {
        angle = 5;
      }
      var _this = _super.call(this, vertex$t, fragment$t) || this;
      _this.scale = scale;
      _this.angle = angle;
      return _this;
    }
    Object.defineProperty(DotFilter2.prototype, "scale", {
      /**
       * The scale of the effect.
       * @default 1
       */
      get: function() {
        return this.uniforms.scale;
      },
      set: function(value) {
        this.uniforms.scale = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DotFilter2.prototype, "angle", {
      /**
       * The radius of the effect.
       * @default 5
       */
      get: function() {
        return this.uniforms.angle;
      },
      set: function(value) {
        this.uniforms.angle = value;
      },
      enumerable: false,
      configurable: true
    });
    return DotFilter2;
  }(Filter)
);
/*!
 * @pixi/filter-reflection - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-reflection is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$z = function(d2, b2) {
  extendStatics$z = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$z(d2, b2);
};
function __extends$z(d2, b2) {
  extendStatics$z(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$s = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$s = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\n\nuniform bool mirror;\nuniform float boundary;\nuniform vec2 amplitude;\nuniform vec2 waveLength;\nuniform vec2 alpha;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 coord = pixelCoord / dimensions;\n\n    if (coord.y < boundary) {\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\n        return;\n    }\n\n    float k = (coord.y - boundary) / (1. - boundary + 0.0001);\n    float areaY = boundary * dimensions.y / filterArea.y;\n    float v = areaY + areaY - vTextureCoord.y;\n    float y = mirror ? v : vTextureCoord.y;\n\n    float _amplitude = ((amplitude.y - amplitude.x) * k + amplitude.x ) / filterArea.x;\n    float _waveLength = ((waveLength.y - waveLength.x) * k + waveLength.x) / filterArea.y;\n    float _alpha = (alpha.y - alpha.x) * k + alpha.x;\n\n    float x = vTextureCoord.x + cos(v * 6.28 / _waveLength - time) * _amplitude;\n    x = clamp(x, filterClamp.x, filterClamp.z);\n\n    vec4 color = texture2D(uSampler, vec2(x, y));\n\n    gl_FragColor = color * _alpha;\n}\n";
var ReflectionFilter = (
  /** @class */
  function(_super) {
    __extends$z(ReflectionFilter2, _super);
    function ReflectionFilter2(options) {
      var _this = _super.call(this, vertex$s, fragment$s) || this;
      _this.time = 0;
      _this.uniforms.amplitude = new Float32Array(2);
      _this.uniforms.waveLength = new Float32Array(2);
      _this.uniforms.alpha = new Float32Array(2);
      _this.uniforms.dimensions = new Float32Array(2);
      Object.assign(_this, ReflectionFilter2.defaults, options);
      return _this;
    }
    ReflectionFilter2.prototype.apply = function(filterManager, input, output2, clear2) {
      var _a2, _b2;
      this.uniforms.dimensions[0] = (_a2 = input.filterFrame) === null || _a2 === void 0 ? void 0 : _a2.width;
      this.uniforms.dimensions[1] = (_b2 = input.filterFrame) === null || _b2 === void 0 ? void 0 : _b2.height;
      this.uniforms.time = this.time;
      filterManager.applyFilter(this, input, output2, clear2);
    };
    Object.defineProperty(ReflectionFilter2.prototype, "mirror", {
      get: function() {
        return this.uniforms.mirror;
      },
      /**
       * `true` to reflect the image, `false` for waves-only
       * @default true
       */
      set: function(value) {
        this.uniforms.mirror = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReflectionFilter2.prototype, "boundary", {
      get: function() {
        return this.uniforms.boundary;
      },
      /**
       * Vertical position of the reflection point, default is 50% (middle)
       * smaller numbers produce a larger reflection, larger numbers produce a smaller reflection.
       * @default 0.5
       */
      set: function(value) {
        this.uniforms.boundary = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReflectionFilter2.prototype, "amplitude", {
      get: function() {
        return this.uniforms.amplitude;
      },
      /**
       * Starting and ending amplitude of waves
       * @member {number[]}
       * @default [0, 20]
       */
      set: function(value) {
        this.uniforms.amplitude[0] = value[0];
        this.uniforms.amplitude[1] = value[1];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReflectionFilter2.prototype, "waveLength", {
      get: function() {
        return this.uniforms.waveLength;
      },
      /**
       * Starting and ending length of waves
       * @member {number[]}
       * @default [30, 100]
       */
      set: function(value) {
        this.uniforms.waveLength[0] = value[0];
        this.uniforms.waveLength[1] = value[1];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReflectionFilter2.prototype, "alpha", {
      get: function() {
        return this.uniforms.alpha;
      },
      /**
       * Starting and ending alpha values
       * @member {number[]}
       * @default [1, 1]
       */
      set: function(value) {
        this.uniforms.alpha[0] = value[0];
        this.uniforms.alpha[1] = value[1];
      },
      enumerable: false,
      configurable: true
    });
    ReflectionFilter2.defaults = {
      mirror: true,
      boundary: 0.5,
      amplitude: [0, 20],
      waveLength: [30, 100],
      alpha: [1, 1],
      time: 0
    };
    return ReflectionFilter2;
  }(Filter)
);
/*!
 * @pixi/filter-glitch - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-glitch is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$y = function(d2, b2) {
  extendStatics$y = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$y(d2, b2);
};
function __extends$y(d2, b2) {
  extendStatics$y(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$r = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$r = "// precision highp float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\nuniform float aspect;\n\nuniform sampler2D displacementMap;\nuniform float offset;\nuniform float sinDir;\nuniform float cosDir;\nuniform int fillMode;\n\nuniform float seed;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nconst int TRANSPARENT = 0;\nconst int ORIGINAL = 1;\nconst int LOOP = 2;\nconst int CLAMP = 3;\nconst int MIRROR = 4;\n\nvoid main(void)\n{\n    vec2 coord = (vTextureCoord * filterArea.xy) / dimensions;\n\n    if (coord.x > 1.0 || coord.y > 1.0) {\n        return;\n    }\n\n    float cx = coord.x - 0.5;\n    float cy = (coord.y - 0.5) * aspect;\n    float ny = (-sinDir * cx + cosDir * cy) / aspect + 0.5;\n\n    // displacementMap: repeat\n    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);\n\n    // displacementMap: mirror\n    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);\n\n    vec4 dc = texture2D(displacementMap, vec2(0.5, ny));\n\n    float displacement = (dc.r - dc.g) * (offset / filterArea.x);\n\n    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * aspect);\n\n    if (fillMode == CLAMP) {\n        coord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    } else {\n        if( coord.x > filterClamp.z ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x -= filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x = filterClamp.z * 2.0 - coord.x;\n            }\n        } else if( coord.x < filterClamp.x ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x += filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x *= -filterClamp.z;\n            }\n        }\n\n        if( coord.y > filterClamp.w ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y -= filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y = filterClamp.w * 2.0 - coord.y;\n            }\n        } else if( coord.y < filterClamp.y ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y += filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y *= -filterClamp.w;\n            }\n        }\n    }\n\n    gl_FragColor.r = texture2D(uSampler, coord + red * (1.0 - seed * 0.4) / filterArea.xy).r;\n    gl_FragColor.g = texture2D(uSampler, coord + green * (1.0 - seed * 0.3) / filterArea.xy).g;\n    gl_FragColor.b = texture2D(uSampler, coord + blue * (1.0 - seed * 0.2) / filterArea.xy).b;\n    gl_FragColor.a = texture2D(uSampler, coord).a;\n}\n";
var GlitchFilter = (
  /** @class */
  function(_super) {
    __extends$y(GlitchFilter2, _super);
    function GlitchFilter2(options) {
      var _this = _super.call(this, vertex$r, fragment$r) || this;
      _this.offset = 100;
      _this.fillMode = GlitchFilter2.TRANSPARENT;
      _this.average = false;
      _this.seed = 0;
      _this.minSize = 8;
      _this.sampleSize = 512;
      _this._slices = 0;
      _this._offsets = new Float32Array(1);
      _this._sizes = new Float32Array(1);
      _this._direction = -1;
      _this.uniforms.dimensions = new Float32Array(2);
      _this._canvas = document.createElement("canvas");
      _this._canvas.width = 4;
      _this._canvas.height = _this.sampleSize;
      _this.texture = Texture.from(_this._canvas, { scaleMode: SCALE_MODES$4.NEAREST });
      Object.assign(_this, GlitchFilter2.defaults, options);
      return _this;
    }
    GlitchFilter2.prototype.apply = function(filterManager, input, output2, clear2) {
      var _a2 = input.filterFrame, width = _a2.width, height = _a2.height;
      this.uniforms.dimensions[0] = width;
      this.uniforms.dimensions[1] = height;
      this.uniforms.aspect = height / width;
      this.uniforms.seed = this.seed;
      this.uniforms.offset = this.offset;
      this.uniforms.fillMode = this.fillMode;
      filterManager.applyFilter(this, input, output2, clear2);
    };
    GlitchFilter2.prototype._randomizeSizes = function() {
      var arr = this._sizes;
      var last = this._slices - 1;
      var size = this.sampleSize;
      var min = Math.min(this.minSize / size, 0.9 / this._slices);
      if (this.average) {
        var count = this._slices;
        var rest = 1;
        for (var i2 = 0; i2 < last; i2++) {
          var averageWidth = rest / (count - i2);
          var w2 = Math.max(averageWidth * (1 - Math.random() * 0.6), min);
          arr[i2] = w2;
          rest -= w2;
        }
        arr[last] = rest;
      } else {
        var rest = 1;
        var ratio = Math.sqrt(1 / this._slices);
        for (var i2 = 0; i2 < last; i2++) {
          var w2 = Math.max(ratio * rest * Math.random(), min);
          arr[i2] = w2;
          rest -= w2;
        }
        arr[last] = rest;
      }
      this.shuffle();
    };
    GlitchFilter2.prototype.shuffle = function() {
      var arr = this._sizes;
      var last = this._slices - 1;
      for (var i2 = last; i2 > 0; i2--) {
        var rand = Math.random() * i2 >> 0;
        var temp2 = arr[i2];
        arr[i2] = arr[rand];
        arr[rand] = temp2;
      }
    };
    GlitchFilter2.prototype._randomizeOffsets = function() {
      for (var i2 = 0; i2 < this._slices; i2++) {
        this._offsets[i2] = Math.random() * (Math.random() < 0.5 ? -1 : 1);
      }
    };
    GlitchFilter2.prototype.refresh = function() {
      this._randomizeSizes();
      this._randomizeOffsets();
      this.redraw();
    };
    GlitchFilter2.prototype.redraw = function() {
      var size = this.sampleSize;
      var texture = this.texture;
      var ctx = this._canvas.getContext("2d");
      ctx.clearRect(0, 0, 8, size);
      var offset;
      var y2 = 0;
      for (var i2 = 0; i2 < this._slices; i2++) {
        offset = Math.floor(this._offsets[i2] * 256);
        var height = this._sizes[i2] * size;
        var red2 = offset > 0 ? offset : 0;
        var green2 = offset < 0 ? -offset : 0;
        ctx.fillStyle = "rgba(" + red2 + ", " + green2 + ", 0, 1)";
        ctx.fillRect(0, y2 >> 0, size, height + 1 >> 0);
        y2 += height;
      }
      texture.baseTexture.update();
      this.uniforms.displacementMap = texture;
    };
    Object.defineProperty(GlitchFilter2.prototype, "sizes", {
      get: function() {
        return this._sizes;
      },
      /**
       * Manually custom slices size (height) of displacement bitmap
       *
       * @member {number[]|Float32Array}
       */
      set: function(sizes) {
        var len = Math.min(this._slices, sizes.length);
        for (var i2 = 0; i2 < len; i2++) {
          this._sizes[i2] = sizes[i2];
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(GlitchFilter2.prototype, "offsets", {
      get: function() {
        return this._offsets;
      },
      /**
       * Manually set custom slices offset of displacement bitmap, this is
       * a collection of values from -1 to 1. To change the max offset value
       * set `offset`.
       *
       * @member {number[]|Float32Array}
       */
      set: function(offsets) {
        var len = Math.min(this._slices, offsets.length);
        for (var i2 = 0; i2 < len; i2++) {
          this._offsets[i2] = offsets[i2];
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(GlitchFilter2.prototype, "slices", {
      /**
       * The count of slices.
       * @default 5
       */
      get: function() {
        return this._slices;
      },
      set: function(value) {
        if (this._slices === value) {
          return;
        }
        this._slices = value;
        this.uniforms.slices = value;
        this._sizes = this.uniforms.slicesWidth = new Float32Array(value);
        this._offsets = this.uniforms.slicesOffset = new Float32Array(value);
        this.refresh();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(GlitchFilter2.prototype, "direction", {
      /**
       * The angle in degree of the offset of slices.
       * @default 0
       */
      get: function() {
        return this._direction;
      },
      set: function(value) {
        if (this._direction === value) {
          return;
        }
        this._direction = value;
        var radians = value * DEG_TO_RAD;
        this.uniforms.sinDir = Math.sin(radians);
        this.uniforms.cosDir = Math.cos(radians);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(GlitchFilter2.prototype, "red", {
      /**
       * Red channel offset.
       *
       * @member {PIXI.Point|number[]}
       */
      get: function() {
        return this.uniforms.red;
      },
      set: function(value) {
        this.uniforms.red = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(GlitchFilter2.prototype, "green", {
      /**
       * Green channel offset.
       *
       * @member {PIXI.Point|number[]}
       */
      get: function() {
        return this.uniforms.green;
      },
      set: function(value) {
        this.uniforms.green = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(GlitchFilter2.prototype, "blue", {
      /**
       * Blue offset.
       *
       * @member {PIXI.Point|number[]}
       */
      get: function() {
        return this.uniforms.blue;
      },
      set: function(value) {
        this.uniforms.blue = value;
      },
      enumerable: false,
      configurable: true
    });
    GlitchFilter2.prototype.destroy = function() {
      var _a2;
      (_a2 = this.texture) === null || _a2 === void 0 ? void 0 : _a2.destroy(true);
      this.texture = this._canvas = this.red = this.green = this.blue = this._sizes = this._offsets = null;
    };
    GlitchFilter2.defaults = {
      slices: 5,
      offset: 100,
      direction: 0,
      fillMode: 0,
      average: false,
      seed: 0,
      red: [0, 0],
      green: [0, 0],
      blue: [0, 0],
      minSize: 8,
      sampleSize: 512
    };
    GlitchFilter2.TRANSPARENT = 0;
    GlitchFilter2.ORIGINAL = 1;
    GlitchFilter2.LOOP = 2;
    GlitchFilter2.CLAMP = 3;
    GlitchFilter2.MIRROR = 4;
    return GlitchFilter2;
  }(Filter)
);
/*!
 * @pixi/filter-rgb-split - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-rgb-split is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$x = function(d2, b2) {
  extendStatics$x = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$x(d2, b2);
};
function __extends$x(d2, b2) {
  extendStatics$x(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$q = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$q = "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nvoid main(void)\n{\n   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/filterArea.xy).r;\n   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/filterArea.xy).g;\n   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/filterArea.xy).b;\n   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;\n}\n";
var RGBSplitFilter = (
  /** @class */
  function(_super) {
    __extends$x(RGBSplitFilter2, _super);
    function RGBSplitFilter2(red2, green2, blue2) {
      if (red2 === void 0) {
        red2 = [-10, 0];
      }
      if (green2 === void 0) {
        green2 = [0, 10];
      }
      if (blue2 === void 0) {
        blue2 = [0, 0];
      }
      var _this = _super.call(this, vertex$q, fragment$q) || this;
      _this.red = red2;
      _this.green = green2;
      _this.blue = blue2;
      return _this;
    }
    Object.defineProperty(RGBSplitFilter2.prototype, "red", {
      /**
       * Red channel offset.
       *
       * @member {PIXI.Point | number[]}
       */
      get: function() {
        return this.uniforms.red;
      },
      set: function(value) {
        this.uniforms.red = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(RGBSplitFilter2.prototype, "green", {
      /**
       * Green channel offset.
       *
       * @member {PIXI.Point | number[]}
       */
      get: function() {
        return this.uniforms.green;
      },
      set: function(value) {
        this.uniforms.green = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(RGBSplitFilter2.prototype, "blue", {
      /**
       * Blue offset.
       *
       * @member {PIXI.Point | number[]}
       */
      get: function() {
        return this.uniforms.blue;
      },
      set: function(value) {
        this.uniforms.blue = value;
      },
      enumerable: false,
      configurable: true
    });
    return RGBSplitFilter2;
  }(Filter)
);
/*!
 * @pixi/filter-godray - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-godray is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$w = function(d2, b2) {
  extendStatics$w = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$w(d2, b2);
};
function __extends$w(d2, b2) {
  extendStatics$w(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$p = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var perlin = "vec3 mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x)\n{\n    return mod289(((x * 34.0) + 1.0) * x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec3 fade(vec3 t)\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\nfloat turb(vec3 P, vec3 rep, float lacunarity, float gain)\n{\n    float sum = 0.0;\n    float sc = 1.0;\n    float totalgain = 1.0;\n    for (float i = 0.0; i < 6.0; i++)\n    {\n        sum += totalgain * pnoise(P * sc, rep);\n        sc *= lacunarity;\n        totalgain *= gain;\n    }\n    return abs(sum);\n}\n";
var fragment$p = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nuniform vec2 light;\nuniform bool parallel;\nuniform float aspect;\n\nuniform float gain;\nuniform float lacunarity;\nuniform float time;\nuniform float alpha;\n\n${perlin}\n\nvoid main(void) {\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\n\n    float d;\n\n    if (parallel) {\n        float _cos = light.x;\n        float _sin = light.y;\n        d = (_cos * coord.x) + (_sin * coord.y * aspect);\n    } else {\n        float dx = coord.x - light.x / dimensions.x;\n        float dy = (coord.y - light.y / dimensions.y) * aspect;\n        float dis = sqrt(dx * dx + dy * dy) + 0.00001;\n        d = dy / dis;\n    }\n\n    vec3 dir = vec3(d, d, 0.0);\n\n    float noise = turb(dir + vec3(time, 0.0, 62.1 + time) * 0.05, vec3(480.0, 320.0, 480.0), lacunarity, gain);\n    noise = mix(noise, 0.0, 0.3);\n    //fade vertically.\n    vec4 mist = vec4(noise, noise, noise, 1.0) * (1.0 - coord.y);\n    mist.a = 1.0;\n    // apply user alpha\n    mist *= alpha;\n\n    gl_FragColor = texture2D(uSampler, vTextureCoord) + mist;\n\n}\n";
var GodrayFilter = (
  /** @class */
  function(_super) {
    __extends$w(GodrayFilter2, _super);
    function GodrayFilter2(options) {
      var _this = _super.call(this, vertex$p, fragment$p.replace("${perlin}", perlin)) || this;
      _this.parallel = true;
      _this.time = 0;
      _this._angle = 0;
      _this.uniforms.dimensions = new Float32Array(2);
      var opts = Object.assign(GodrayFilter2.defaults, options);
      _this._angleLight = new Point();
      _this.angle = opts.angle;
      _this.gain = opts.gain;
      _this.lacunarity = opts.lacunarity;
      _this.alpha = opts.alpha;
      _this.parallel = opts.parallel;
      _this.center = opts.center;
      _this.time = opts.time;
      return _this;
    }
    GodrayFilter2.prototype.apply = function(filterManager, input, output2, clear2) {
      var _a2 = input.filterFrame, width = _a2.width, height = _a2.height;
      this.uniforms.light = this.parallel ? this._angleLight : this.center;
      this.uniforms.parallel = this.parallel;
      this.uniforms.dimensions[0] = width;
      this.uniforms.dimensions[1] = height;
      this.uniforms.aspect = height / width;
      this.uniforms.time = this.time;
      this.uniforms.alpha = this.alpha;
      filterManager.applyFilter(this, input, output2, clear2);
    };
    Object.defineProperty(GodrayFilter2.prototype, "angle", {
      /**
       * The angle/light-source of the rays in degrees. For instance, a value of 0 is vertical rays,
       *     values of 90 or -90 produce horizontal rays.
       * @default 30
       */
      get: function() {
        return this._angle;
      },
      set: function(value) {
        this._angle = value;
        var radians = value * DEG_TO_RAD;
        this._angleLight.x = Math.cos(radians);
        this._angleLight.y = Math.sin(radians);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(GodrayFilter2.prototype, "gain", {
      /**
       * General intensity of the effect. A value closer to 1 will produce a more intense effect,
       * where a value closer to 0 will produce a subtler effect.
       * @default 0.5
       */
      get: function() {
        return this.uniforms.gain;
      },
      set: function(value) {
        this.uniforms.gain = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(GodrayFilter2.prototype, "lacunarity", {
      /**
       * The density of the fractal noise. A higher amount produces more rays and a smaller amound
       * produces fewer waves.
       * @default 2.5
       */
      get: function() {
        return this.uniforms.lacunarity;
      },
      set: function(value) {
        this.uniforms.lacunarity = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(GodrayFilter2.prototype, "alpha", {
      /**
       * The alpha (opacity) of the rays.  0 is fully transparent, 1 is fully opaque.
       * @default 1
       */
      get: function() {
        return this.uniforms.alpha;
      },
      set: function(value) {
        this.uniforms.alpha = value;
      },
      enumerable: false,
      configurable: true
    });
    GodrayFilter2.defaults = {
      angle: 30,
      gain: 0.5,
      lacunarity: 2.5,
      time: 0,
      parallel: true,
      center: [0, 0],
      alpha: 1
    };
    return GodrayFilter2;
  }(Filter)
);
/*!
 * @pixi/filter-adjustment - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-adjustment is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$v = function(d2, b2) {
  extendStatics$v = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$v(d2, b2);
};
function __extends$v(d2, b2) {
  extendStatics$v(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$o = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$o = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform float gamma;\nuniform float contrast;\nuniform float saturation;\nuniform float brightness;\nuniform float red;\nuniform float green;\nuniform float blue;\nuniform float alpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (c.a > 0.0) {\n        c.rgb /= c.a;\n\n        vec3 rgb = pow(c.rgb, vec3(1. / gamma));\n        rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, saturation), contrast);\n        rgb.r *= red;\n        rgb.g *= green;\n        rgb.b *= blue;\n        c.rgb = rgb * brightness;\n\n        c.rgb *= c.a;\n    }\n\n    gl_FragColor = c * alpha;\n}\n";
(function(_super) {
  __extends$v(AdjustmentFilter, _super);
  function AdjustmentFilter(options) {
    var _this = _super.call(this, vertex$o, fragment$o) || this;
    _this.gamma = 1;
    _this.saturation = 1;
    _this.contrast = 1;
    _this.brightness = 1;
    _this.red = 1;
    _this.green = 1;
    _this.blue = 1;
    _this.alpha = 1;
    Object.assign(_this, options);
    return _this;
  }
  AdjustmentFilter.prototype.apply = function(filterManager, input, output2, clear2) {
    this.uniforms.gamma = Math.max(this.gamma, 1e-4);
    this.uniforms.saturation = this.saturation;
    this.uniforms.contrast = this.contrast;
    this.uniforms.brightness = this.brightness;
    this.uniforms.red = this.red;
    this.uniforms.green = this.green;
    this.uniforms.blue = this.blue;
    this.uniforms.alpha = this.alpha;
    filterManager.applyFilter(this, input, output2, clear2);
  };
  return AdjustmentFilter;
})(Filter);
/*!
 * @pixi/filter-kawase-blur - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-kawase-blur is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$u = function(d2, b2) {
  extendStatics$u = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$u(d2, b2);
};
function __extends$u(d2, b2) {
  extendStatics$u(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$n = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$n = "\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}";
var fragmentClamp = "\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\nuniform vec4 filterClamp;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}\n";
var KawaseBlurFilter = (
  /** @class */
  function(_super) {
    __extends$u(KawaseBlurFilter2, _super);
    function KawaseBlurFilter2(blur, quality, clamp2) {
      if (blur === void 0) {
        blur = 4;
      }
      if (quality === void 0) {
        quality = 3;
      }
      if (clamp2 === void 0) {
        clamp2 = false;
      }
      var _this = _super.call(this, vertex$n, clamp2 ? fragmentClamp : fragment$n) || this;
      _this._kernels = [];
      _this._blur = 4;
      _this._quality = 3;
      _this.uniforms.uOffset = new Float32Array(2);
      _this._pixelSize = new Point();
      _this.pixelSize = 1;
      _this._clamp = clamp2;
      if (Array.isArray(blur)) {
        _this.kernels = blur;
      } else {
        _this._blur = blur;
        _this.quality = quality;
      }
      return _this;
    }
    KawaseBlurFilter2.prototype.apply = function(filterManager, input, output2, clear2) {
      var uvX = this._pixelSize.x / input._frame.width;
      var uvY = this._pixelSize.y / input._frame.height;
      var offset;
      if (this._quality === 1 || this._blur === 0) {
        offset = this._kernels[0] + 0.5;
        this.uniforms.uOffset[0] = offset * uvX;
        this.uniforms.uOffset[1] = offset * uvY;
        filterManager.applyFilter(this, input, output2, clear2);
      } else {
        var renderTarget = filterManager.getFilterTexture();
        var source = input;
        var target = renderTarget;
        var tmp = void 0;
        var last = this._quality - 1;
        for (var i2 = 0; i2 < last; i2++) {
          offset = this._kernels[i2] + 0.5;
          this.uniforms.uOffset[0] = offset * uvX;
          this.uniforms.uOffset[1] = offset * uvY;
          filterManager.applyFilter(this, source, target, 1);
          tmp = source;
          source = target;
          target = tmp;
        }
        offset = this._kernels[last] + 0.5;
        this.uniforms.uOffset[0] = offset * uvX;
        this.uniforms.uOffset[1] = offset * uvY;
        filterManager.applyFilter(this, source, output2, clear2);
        filterManager.returnFilterTexture(renderTarget);
      }
    };
    KawaseBlurFilter2.prototype._updatePadding = function() {
      this.padding = Math.ceil(this._kernels.reduce(function(acc, v2) {
        return acc + v2 + 0.5;
      }, 0));
    };
    KawaseBlurFilter2.prototype._generateKernels = function() {
      var blur = this._blur;
      var quality = this._quality;
      var kernels = [blur];
      if (blur > 0) {
        var k2 = blur;
        var step = blur / quality;
        for (var i2 = 1; i2 < quality; i2++) {
          k2 -= step;
          kernels.push(k2);
        }
      }
      this._kernels = kernels;
      this._updatePadding();
    };
    Object.defineProperty(KawaseBlurFilter2.prototype, "kernels", {
      /**
       * The kernel size of the blur filter, for advanced usage.
       * @default [0]
       */
      get: function() {
        return this._kernels;
      },
      set: function(value) {
        if (Array.isArray(value) && value.length > 0) {
          this._kernels = value;
          this._quality = value.length;
          this._blur = Math.max.apply(Math, value);
        } else {
          this._kernels = [0];
          this._quality = 1;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(KawaseBlurFilter2.prototype, "clamp", {
      /**
       * Get the if the filter is clampped.
       *
       * @readonly
       * @default false
       */
      get: function() {
        return this._clamp;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(KawaseBlurFilter2.prototype, "pixelSize", {
      get: function() {
        return this._pixelSize;
      },
      /**
       * Sets the pixel size of the filter. Large size is blurrier. For advanced usage.
       *
       * @member {PIXI.Point|number[]}
       * @default [1, 1]
       */
      set: function(value) {
        if (typeof value === "number") {
          this._pixelSize.x = value;
          this._pixelSize.y = value;
        } else if (Array.isArray(value)) {
          this._pixelSize.x = value[0];
          this._pixelSize.y = value[1];
        } else if (value instanceof Point) {
          this._pixelSize.x = value.x;
          this._pixelSize.y = value.y;
        } else {
          this._pixelSize.x = 1;
          this._pixelSize.y = 1;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(KawaseBlurFilter2.prototype, "quality", {
      /**
       * The quality of the filter, integer greater than `1`.
       * @default 3
       */
      get: function() {
        return this._quality;
      },
      set: function(value) {
        this._quality = Math.max(1, Math.round(value));
        this._generateKernels();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(KawaseBlurFilter2.prototype, "blur", {
      /**
       * The amount of blur, value greater than `0`.
       * @default 4
       */
      get: function() {
        return this._blur;
      },
      set: function(value) {
        this._blur = value;
        this._generateKernels();
      },
      enumerable: false,
      configurable: true
    });
    return KawaseBlurFilter2;
  }(Filter)
);
/*!
 * @pixi/filter-advanced-bloom - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-advanced-bloom is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$t = function(d2, b2) {
  extendStatics$t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$t(d2, b2);
};
function __extends$t(d2, b2) {
  extendStatics$t(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$m = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$m = "\nuniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform float threshold;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    // A simple & fast algorithm for getting brightness.\n    // It's inaccuracy , but good enought for this feature.\n    float _max = max(max(color.r, color.g), color.b);\n    float _min = min(min(color.r, color.g), color.b);\n    float brightness = (_max + _min) * 0.5;\n\n    if(brightness > threshold) {\n        gl_FragColor = color;\n    } else {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n";
var ExtractBrightnessFilter = (
  /** @class */
  function(_super) {
    __extends$t(ExtractBrightnessFilter2, _super);
    function ExtractBrightnessFilter2(threshold) {
      if (threshold === void 0) {
        threshold = 0.5;
      }
      var _this = _super.call(this, vertex$m, fragment$m) || this;
      _this.threshold = threshold;
      return _this;
    }
    Object.defineProperty(ExtractBrightnessFilter2.prototype, "threshold", {
      /**
       * Defines how bright a color needs to be extracted.
       *
       * @default 0.5
       */
      get: function() {
        return this.uniforms.threshold;
      },
      set: function(value) {
        this.uniforms.threshold = value;
      },
      enumerable: false,
      configurable: true
    });
    return ExtractBrightnessFilter2;
  }(Filter)
);
var fragment$1$1 = "uniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D bloomTexture;\nuniform float bloomScale;\nuniform float brightness;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    color.rgb *= brightness;\n    vec4 bloomColor = vec4(texture2D(bloomTexture, vTextureCoord).rgb, 0.0);\n    bloomColor.rgb *= bloomScale;\n    gl_FragColor = color + bloomColor;\n}\n";
(function(_super) {
  __extends$t(AdvancedBloomFilter, _super);
  function AdvancedBloomFilter(options) {
    var _this = _super.call(this, vertex$m, fragment$1$1) || this;
    _this.bloomScale = 1;
    _this.brightness = 1;
    _this._resolution = settings$2.FILTER_RESOLUTION;
    if (typeof options === "number") {
      options = { threshold: options };
    }
    var opt = Object.assign(AdvancedBloomFilter.defaults, options);
    _this.bloomScale = opt.bloomScale;
    _this.brightness = opt.brightness;
    var kernels = opt.kernels, blur = opt.blur, quality = opt.quality, pixelSize = opt.pixelSize, resolution = opt.resolution;
    _this._extractFilter = new ExtractBrightnessFilter(opt.threshold);
    _this._extractFilter.resolution = resolution;
    _this._blurFilter = kernels ? new KawaseBlurFilter(kernels) : new KawaseBlurFilter(blur, quality);
    _this.pixelSize = pixelSize;
    _this.resolution = resolution;
    return _this;
  }
  AdvancedBloomFilter.prototype.apply = function(filterManager, input, output2, clear2, currentState) {
    var brightTarget = filterManager.getFilterTexture();
    this._extractFilter.apply(filterManager, input, brightTarget, 1, currentState);
    var bloomTarget = filterManager.getFilterTexture();
    this._blurFilter.apply(filterManager, brightTarget, bloomTarget, 1);
    this.uniforms.bloomScale = this.bloomScale;
    this.uniforms.brightness = this.brightness;
    this.uniforms.bloomTexture = bloomTarget;
    filterManager.applyFilter(this, input, output2, clear2);
    filterManager.returnFilterTexture(bloomTarget);
    filterManager.returnFilterTexture(brightTarget);
  };
  Object.defineProperty(AdvancedBloomFilter.prototype, "resolution", {
    /**
     * The resolution of the filter.
     * @ignore
     */
    get: function() {
      return this._resolution;
    },
    set: function(value) {
      this._resolution = value;
      if (this._extractFilter) {
        this._extractFilter.resolution = value;
      }
      if (this._blurFilter) {
        this._blurFilter.resolution = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AdvancedBloomFilter.prototype, "threshold", {
    /**
     * Defines how bright a color needs to be to affect bloom.
     *
     * @default 0.5
     */
    get: function() {
      return this._extractFilter.threshold;
    },
    set: function(value) {
      this._extractFilter.threshold = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AdvancedBloomFilter.prototype, "kernels", {
    /**
     * Sets the kernels of the Blur Filter
     */
    get: function() {
      return this._blurFilter.kernels;
    },
    set: function(value) {
      this._blurFilter.kernels = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AdvancedBloomFilter.prototype, "blur", {
    /**
     * Sets the strength of the Blur properties simultaneously
     *
     * @default 2
     */
    get: function() {
      return this._blurFilter.blur;
    },
    set: function(value) {
      this._blurFilter.blur = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AdvancedBloomFilter.prototype, "quality", {
    /**
     * Sets the quality of the Blur Filter
     *
     * @default 4
     */
    get: function() {
      return this._blurFilter.quality;
    },
    set: function(value) {
      this._blurFilter.quality = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AdvancedBloomFilter.prototype, "pixelSize", {
    /**
     * Sets the pixelSize of the Kawase Blur filter
     *
     * @member {number|number[]|PIXI.Point}
     * @default 1
     */
    get: function() {
      return this._blurFilter.pixelSize;
    },
    set: function(value) {
      this._blurFilter.pixelSize = value;
    },
    enumerable: false,
    configurable: true
  });
  AdvancedBloomFilter.defaults = {
    threshold: 0.5,
    bloomScale: 1,
    brightness: 1,
    kernels: null,
    blur: 8,
    quality: 4,
    pixelSize: 1,
    resolution: settings$2.FILTER_RESOLUTION
  };
  return AdvancedBloomFilter;
})(Filter);
/*!
 * @pixi/filter-ascii - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-ascii is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$s = function(d2, b2) {
  extendStatics$s = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$s(d2, b2);
};
function __extends$s(d2, b2) {
  extendStatics$s(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$l = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$l = "varying vec2 vTextureCoord;\n\nuniform vec4 filterArea;\nuniform float pixelSize;\nuniform sampler2D uSampler;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n    return floor( coord / size ) * size;\n}\n\nvec2 getMod(vec2 coord, vec2 size)\n{\n    return mod( coord , size) / size;\n}\n\nfloat character(float n, vec2 p)\n{\n    p = floor(p*vec2(4.0, -4.0) + 2.5);\n\n    if (clamp(p.x, 0.0, 4.0) == p.x)\n    {\n        if (clamp(p.y, 0.0, 4.0) == p.y)\n        {\n            if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\n        }\n    }\n    return 0.0;\n}\n\nvoid main()\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    // get the rounded color..\n    vec2 pixCoord = pixelate(coord, vec2(pixelSize));\n    pixCoord = unmapCoord(pixCoord);\n\n    vec4 color = texture2D(uSampler, pixCoord);\n\n    // determine the character to use\n    float gray = (color.r + color.g + color.b) / 3.0;\n\n    float n =  65536.0;             // .\n    if (gray > 0.2) n = 65600.0;    // :\n    if (gray > 0.3) n = 332772.0;   // *\n    if (gray > 0.4) n = 15255086.0; // o\n    if (gray > 0.5) n = 23385164.0; // &\n    if (gray > 0.6) n = 15252014.0; // 8\n    if (gray > 0.7) n = 13199452.0; // @\n    if (gray > 0.8) n = 11512810.0; // #\n\n    // get the mod..\n    vec2 modd = getMod(coord, vec2(pixelSize));\n\n    gl_FragColor = color * character( n, vec2(-1.0) + modd * 2.0);\n\n}\n";
(function(_super) {
  __extends$s(AsciiFilter, _super);
  function AsciiFilter(size) {
    if (size === void 0) {
      size = 8;
    }
    var _this = _super.call(this, vertex$l, fragment$l) || this;
    _this.size = size;
    return _this;
  }
  Object.defineProperty(AsciiFilter.prototype, "size", {
    /**
     * The pixel size used by the filter.
     */
    get: function() {
      return this.uniforms.pixelSize;
    },
    set: function(value) {
      this.uniforms.pixelSize = value;
    },
    enumerable: false,
    configurable: true
  });
  return AsciiFilter;
})(Filter);
/*!
 * @pixi/filter-bevel - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-bevel is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$r = function(d2, b2) {
  extendStatics$r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$r(d2, b2);
};
function __extends$r(d2, b2) {
  extendStatics$r(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$k = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$k = "precision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform float transformX;\nuniform float transformY;\nuniform vec3 lightColor;\nuniform float lightAlpha;\nuniform vec3 shadowColor;\nuniform float shadowAlpha;\n\nvoid main(void) {\n    vec2 transform = vec2(1.0 / filterArea) * vec2(transformX, transformY);\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float light = texture2D(uSampler, vTextureCoord - transform).a;\n    float shadow = texture2D(uSampler, vTextureCoord + transform).a;\n\n    color.rgb = mix(color.rgb, lightColor, clamp((color.a - light) * lightAlpha, 0.0, 1.0));\n    color.rgb = mix(color.rgb, shadowColor, clamp((color.a - shadow) * shadowAlpha, 0.0, 1.0));\n    gl_FragColor = vec4(color.rgb * color.a, color.a);\n}\n";
(function(_super) {
  __extends$r(BevelFilter, _super);
  function BevelFilter(options) {
    var _this = _super.call(this, vertex$k, fragment$k) || this;
    _this._thickness = 2;
    _this._angle = 0;
    _this.uniforms.lightColor = new Float32Array(3);
    _this.uniforms.shadowColor = new Float32Array(3);
    Object.assign(_this, {
      rotation: 45,
      thickness: 2,
      lightColor: 16777215,
      lightAlpha: 0.7,
      shadowColor: 0,
      shadowAlpha: 0.7
    }, options);
    _this.padding = 1;
    return _this;
  }
  BevelFilter.prototype._updateTransform = function() {
    this.uniforms.transformX = this._thickness * Math.cos(this._angle);
    this.uniforms.transformY = this._thickness * Math.sin(this._angle);
  };
  Object.defineProperty(BevelFilter.prototype, "rotation", {
    /**
     * The angle of the light in degrees.
     * @default 45
     */
    get: function() {
      return this._angle / DEG_TO_RAD;
    },
    set: function(value) {
      this._angle = value * DEG_TO_RAD;
      this._updateTransform();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BevelFilter.prototype, "thickness", {
    /**
     * The tickness of the bevel.
     * @default 2
     */
    get: function() {
      return this._thickness;
    },
    set: function(value) {
      this._thickness = value;
      this._updateTransform();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BevelFilter.prototype, "lightColor", {
    /**
     * Color of the light.
     * @default 0xffffff
     */
    get: function() {
      return rgb2hex(this.uniforms.lightColor);
    },
    set: function(value) {
      hex2rgb(value, this.uniforms.lightColor);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BevelFilter.prototype, "lightAlpha", {
    /**
     * Alpha of the light.
     * @default 0.7
     */
    get: function() {
      return this.uniforms.lightAlpha;
    },
    set: function(value) {
      this.uniforms.lightAlpha = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BevelFilter.prototype, "shadowColor", {
    /**
     * Color of the shadow.
     * @default 0x000000
     */
    get: function() {
      return rgb2hex(this.uniforms.shadowColor);
    },
    set: function(value) {
      hex2rgb(value, this.uniforms.shadowColor);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BevelFilter.prototype, "shadowAlpha", {
    /**
     * Alpha of the shadow.
     * @default 0.7
     */
    get: function() {
      return this.uniforms.shadowAlpha;
    },
    set: function(value) {
      this.uniforms.shadowAlpha = value;
    },
    enumerable: false,
    configurable: true
  });
  return BevelFilter;
})(Filter);
/*!
 * @pixi/filter-bloom - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-bloom is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$q = function(d2, b2) {
  extendStatics$q = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$q(d2, b2);
};
function __extends$q(d2, b2) {
  extendStatics$q(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
(function(_super) {
  __extends$q(BloomFilter, _super);
  function BloomFilter(blur, quality, resolution, kernelSize) {
    if (blur === void 0) {
      blur = 2;
    }
    if (quality === void 0) {
      quality = 4;
    }
    if (resolution === void 0) {
      resolution = settings$2.FILTER_RESOLUTION;
    }
    if (kernelSize === void 0) {
      kernelSize = 5;
    }
    var _this = _super.call(this) || this;
    var blurX;
    var blurY;
    if (typeof blur === "number") {
      blurX = blur;
      blurY = blur;
    } else if (blur instanceof Point) {
      blurX = blur.x;
      blurY = blur.y;
    } else if (Array.isArray(blur)) {
      blurX = blur[0];
      blurY = blur[1];
    }
    _this.blurXFilter = new BlurFilterPass(true, blurX, quality, resolution, kernelSize);
    _this.blurYFilter = new BlurFilterPass(false, blurY, quality, resolution, kernelSize);
    _this.blurYFilter.blendMode = BLEND_MODES$4.SCREEN;
    _this.defaultFilter = new AlphaFilter();
    return _this;
  }
  BloomFilter.prototype.apply = function(filterManager, input, output2, clear2) {
    var renderTarget = filterManager.getFilterTexture();
    this.defaultFilter.apply(filterManager, input, output2, clear2);
    this.blurXFilter.apply(filterManager, input, renderTarget, 1);
    this.blurYFilter.apply(filterManager, renderTarget, output2, 0);
    filterManager.returnFilterTexture(renderTarget);
  };
  Object.defineProperty(BloomFilter.prototype, "blur", {
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     * @default 2
     */
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(value) {
      this.blurXFilter.blur = this.blurYFilter.blur = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BloomFilter.prototype, "blurX", {
    /**
     * Sets the strength of the blurX property
     * @default 2
     */
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(value) {
      this.blurXFilter.blur = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BloomFilter.prototype, "blurY", {
    /**
     * Sets the strength of the blurY property
     * @default 2
     */
    get: function() {
      return this.blurYFilter.blur;
    },
    set: function(value) {
      this.blurYFilter.blur = value;
    },
    enumerable: false,
    configurable: true
  });
  return BloomFilter;
})(Filter);
/*!
 * @pixi/filter-bulge-pinch - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-bulge-pinch is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$p = function(d2, b2) {
  extendStatics$p = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$p(d2, b2);
};
function __extends$p(d2, b2) {
  extendStatics$p(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$j = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$j = "uniform float radius;\nuniform float strength;\nuniform vec2 center;\nuniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\n\nvoid main()\n{\n    vec2 coord = vTextureCoord * filterArea.xy;\n    coord -= center * dimensions.xy;\n    float distance = length(coord);\n    if (distance < radius) {\n        float percent = distance / radius;\n        if (strength > 0.0) {\n            coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\n        } else {\n            coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\n        }\n    }\n    coord += center * dimensions.xy;\n    coord /= filterArea.xy;\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    vec4 color = texture2D(uSampler, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    gl_FragColor = color;\n}\n";
(function(_super) {
  __extends$p(BulgePinchFilter, _super);
  function BulgePinchFilter(options) {
    var _this = _super.call(this, vertex$j, fragment$j) || this;
    _this.uniforms.dimensions = new Float32Array(2);
    Object.assign(_this, BulgePinchFilter.defaults, options);
    return _this;
  }
  BulgePinchFilter.prototype.apply = function(filterManager, input, output2, clear2) {
    var _a2 = input.filterFrame, width = _a2.width, height = _a2.height;
    this.uniforms.dimensions[0] = width;
    this.uniforms.dimensions[1] = height;
    filterManager.applyFilter(this, input, output2, clear2);
  };
  Object.defineProperty(BulgePinchFilter.prototype, "radius", {
    /**
     * The radius of the circle of effect.
     */
    get: function() {
      return this.uniforms.radius;
    },
    set: function(value) {
      this.uniforms.radius = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BulgePinchFilter.prototype, "strength", {
    /**
     * The strength of the effect. -1 to 1 (-1 is strong pinch, 0 is no effect, 1 is strong bulge)
     */
    get: function() {
      return this.uniforms.strength;
    },
    set: function(value) {
      this.uniforms.strength = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BulgePinchFilter.prototype, "center", {
    /**
     * The x and y coordinates of the center of the circle of effect.
     *
     * @member {PIXI.Point | Array<number>}
     */
    get: function() {
      return this.uniforms.center;
    },
    set: function(value) {
      this.uniforms.center = value;
    },
    enumerable: false,
    configurable: true
  });
  BulgePinchFilter.defaults = {
    center: [0.5, 0.5],
    radius: 100,
    strength: 1
  };
  return BulgePinchFilter;
})(Filter);
/*!
 * @pixi/filter-color-map - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-color-map is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$o = function(d2, b2) {
  extendStatics$o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$o(d2, b2);
};
function __extends$o(d2, b2) {
  extendStatics$o(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$i = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$i = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform sampler2D colorMap;\nuniform float _mix;\nuniform float _size;\nuniform float _sliceSize;\nuniform float _slicePixelSize;\nuniform float _sliceInnerSize;\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord.xy);\n\n    vec4 adjusted;\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n        float innerWidth = _size - 1.0;\n        float zSlice0 = min(floor(color.b * innerWidth), innerWidth);\n        float zSlice1 = min(zSlice0 + 1.0, innerWidth);\n        float xOffset = _slicePixelSize * 0.5 + color.r * _sliceInnerSize;\n        float s0 = xOffset + (zSlice0 * _sliceSize);\n        float s1 = xOffset + (zSlice1 * _sliceSize);\n        float yOffset = _sliceSize * 0.5 + color.g * (1.0 - _sliceSize);\n        vec4 slice0Color = texture2D(colorMap, vec2(s0,yOffset));\n        vec4 slice1Color = texture2D(colorMap, vec2(s1,yOffset));\n        float zOffset = fract(color.b * innerWidth);\n        adjusted = mix(slice0Color, slice1Color, zOffset);\n\n        color.rgb *= color.a;\n    }\n    gl_FragColor = vec4(mix(color, adjusted, _mix).rgb, color.a);\n\n}";
(function(_super) {
  __extends$o(ColorMapFilter, _super);
  function ColorMapFilter(colorMap, nearest, mix2) {
    if (nearest === void 0) {
      nearest = false;
    }
    if (mix2 === void 0) {
      mix2 = 1;
    }
    var _this = _super.call(this, vertex$i, fragment$i) || this;
    _this.mix = 1;
    _this._size = 0;
    _this._sliceSize = 0;
    _this._slicePixelSize = 0;
    _this._sliceInnerSize = 0;
    _this._nearest = false;
    _this._scaleMode = null;
    _this._colorMap = null;
    _this._scaleMode = null;
    _this.nearest = nearest;
    _this.mix = mix2;
    _this.colorMap = colorMap;
    return _this;
  }
  ColorMapFilter.prototype.apply = function(filterManager, input, output2, clear2) {
    this.uniforms._mix = this.mix;
    filterManager.applyFilter(this, input, output2, clear2);
  };
  Object.defineProperty(ColorMapFilter.prototype, "colorSize", {
    /**
     * The size of one color slice
     * @readonly
     */
    get: function() {
      return this._size;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorMapFilter.prototype, "colorMap", {
    /**
     * the colorMap texture
     * @member {PIXI.Texture}
     */
    get: function() {
      return this._colorMap;
    },
    set: function(colorMap) {
      var _a2;
      if (!colorMap) {
        return;
      }
      if (!(colorMap instanceof Texture)) {
        colorMap = Texture.from(colorMap);
      }
      if ((_a2 = colorMap) === null || _a2 === void 0 ? void 0 : _a2.baseTexture) {
        colorMap.baseTexture.scaleMode = this._scaleMode;
        colorMap.baseTexture.mipmap = MIPMAP_MODES$4.OFF;
        this._size = colorMap.height;
        this._sliceSize = 1 / this._size;
        this._slicePixelSize = this._sliceSize / this._size;
        this._sliceInnerSize = this._slicePixelSize * (this._size - 1);
        this.uniforms._size = this._size;
        this.uniforms._sliceSize = this._sliceSize;
        this.uniforms._slicePixelSize = this._slicePixelSize;
        this.uniforms._sliceInnerSize = this._sliceInnerSize;
        this.uniforms.colorMap = colorMap;
      }
      this._colorMap = colorMap;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorMapFilter.prototype, "nearest", {
    /**
     * Whether use NEAREST for colorMap texture.
     */
    get: function() {
      return this._nearest;
    },
    set: function(nearest) {
      this._nearest = nearest;
      this._scaleMode = nearest ? SCALE_MODES$4.NEAREST : SCALE_MODES$4.LINEAR;
      var texture = this._colorMap;
      if (texture && texture.baseTexture) {
        texture.baseTexture._glTextures = {};
        texture.baseTexture.scaleMode = this._scaleMode;
        texture.baseTexture.mipmap = MIPMAP_MODES$4.OFF;
        texture._updateID++;
        texture.baseTexture.emit("update", texture.baseTexture);
      }
    },
    enumerable: false,
    configurable: true
  });
  ColorMapFilter.prototype.updateColorMap = function() {
    var texture = this._colorMap;
    if (texture && texture.baseTexture) {
      texture._updateID++;
      texture.baseTexture.emit("update", texture.baseTexture);
      this.colorMap = texture;
    }
  };
  ColorMapFilter.prototype.destroy = function(destroyBase) {
    if (destroyBase === void 0) {
      destroyBase = false;
    }
    if (this._colorMap) {
      this._colorMap.destroy(destroyBase);
    }
    _super.prototype.destroy.call(this);
  };
  return ColorMapFilter;
})(Filter);
/*!
 * @pixi/filter-color-overlay - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-color-overlay is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$n = function(d2, b2) {
  extendStatics$n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$n(d2, b2);
};
function __extends$n(d2, b2) {
  extendStatics$n(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$h = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$h = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec3 color;\nuniform float alpha;\n\nvoid main(void) {\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = vec4(mix(currentColor.rgb, color.rgb, currentColor.a * alpha), currentColor.a);\n}\n";
(function(_super) {
  __extends$n(ColorOverlayFilter, _super);
  function ColorOverlayFilter(color2, alpha2) {
    if (color2 === void 0) {
      color2 = 0;
    }
    if (alpha2 === void 0) {
      alpha2 = 1;
    }
    var _this = _super.call(this, vertex$h, fragment$h) || this;
    _this._color = 0;
    _this._alpha = 1;
    _this.uniforms.color = new Float32Array(3);
    _this.color = color2;
    _this.alpha = alpha2;
    return _this;
  }
  Object.defineProperty(ColorOverlayFilter.prototype, "color", {
    get: function() {
      return this._color;
    },
    /**
     * The resulting color, as a 3 component RGB e.g. [1.0, 0.5, 1.0]
     * @member {number|Array<number>|Float32Array}
     * @default 0x000000
     */
    set: function(value) {
      var arr = this.uniforms.color;
      if (typeof value === "number") {
        hex2rgb(value, arr);
        this._color = value;
      } else {
        arr[0] = value[0];
        arr[1] = value[1];
        arr[2] = value[2];
        this._color = rgb2hex(arr);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorOverlayFilter.prototype, "alpha", {
    get: function() {
      return this._alpha;
    },
    /**
     * The alpha value of the color
     * @default 0
     */
    set: function(value) {
      this.uniforms.alpha = value;
      this._alpha = value;
    },
    enumerable: false,
    configurable: true
  });
  return ColorOverlayFilter;
})(Filter);
/*!
 * @pixi/filter-color-replace - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-color-replace is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$m = function(d2, b2) {
  extendStatics$m = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$m(d2, b2);
};
function __extends$m(d2, b2) {
  extendStatics$m(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$g = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$g = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec3 originalColor;\nuniform vec3 newColor;\nuniform float epsilon;\nvoid main(void) {\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\n    vec3 colorDiff = originalColor - (currentColor.rgb / max(currentColor.a, 0.0000000001));\n    float colorDistance = length(colorDiff);\n    float doReplace = step(colorDistance, epsilon);\n    gl_FragColor = vec4(mix(currentColor.rgb, (newColor + colorDiff) * currentColor.a, doReplace), currentColor.a);\n}\n";
(function(_super) {
  __extends$m(ColorReplaceFilter, _super);
  function ColorReplaceFilter(originalColor, newColor, epsilon) {
    if (originalColor === void 0) {
      originalColor = 16711680;
    }
    if (newColor === void 0) {
      newColor = 0;
    }
    if (epsilon === void 0) {
      epsilon = 0.4;
    }
    var _this = _super.call(this, vertex$g, fragment$g) || this;
    _this._originalColor = 16711680;
    _this._newColor = 0;
    _this.uniforms.originalColor = new Float32Array(3);
    _this.uniforms.newColor = new Float32Array(3);
    _this.originalColor = originalColor;
    _this.newColor = newColor;
    _this.epsilon = epsilon;
    return _this;
  }
  Object.defineProperty(ColorReplaceFilter.prototype, "originalColor", {
    get: function() {
      return this._originalColor;
    },
    /**
     * The color that will be changed, as a 3 component RGB e.g. [1.0, 1.0, 1.0]
     * @member {number|Array<number>|Float32Array}
     * @default 0xFF0000
     */
    set: function(value) {
      var arr = this.uniforms.originalColor;
      if (typeof value === "number") {
        hex2rgb(value, arr);
        this._originalColor = value;
      } else {
        arr[0] = value[0];
        arr[1] = value[1];
        arr[2] = value[2];
        this._originalColor = rgb2hex(arr);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorReplaceFilter.prototype, "newColor", {
    get: function() {
      return this._newColor;
    },
    /**
     * The resulting color, as a 3 component RGB e.g. [1.0, 0.5, 1.0]
     * @member {number|Array<number>|Float32Array}
     * @default 0x000000
     */
    set: function(value) {
      var arr = this.uniforms.newColor;
      if (typeof value === "number") {
        hex2rgb(value, arr);
        this._newColor = value;
      } else {
        arr[0] = value[0];
        arr[1] = value[1];
        arr[2] = value[2];
        this._newColor = rgb2hex(arr);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorReplaceFilter.prototype, "epsilon", {
    get: function() {
      return this.uniforms.epsilon;
    },
    /**
     * Tolerance/sensitivity of the floating-point comparison between colors (lower = more exact, higher = more inclusive)
     * @default 0.4
     */
    set: function(value) {
      this.uniforms.epsilon = value;
    },
    enumerable: false,
    configurable: true
  });
  return ColorReplaceFilter;
})(Filter);
/*!
 * @pixi/filter-convolution - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-convolution is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$l = function(d2, b2) {
  extendStatics$l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$l(d2, b2);
};
function __extends$l(d2, b2) {
  extendStatics$l(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$f = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$f = "precision mediump float;\n\nvarying mediump vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec2 texelSize;\nuniform float matrix[9];\n\nvoid main(void)\n{\n   vec4 c11 = texture2D(uSampler, vTextureCoord - texelSize); // top left\n   vec4 c12 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - texelSize.y)); // top center\n   vec4 c13 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y - texelSize.y)); // top right\n\n   vec4 c21 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y)); // mid left\n   vec4 c22 = texture2D(uSampler, vTextureCoord); // mid center\n   vec4 c23 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y)); // mid right\n\n   vec4 c31 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y + texelSize.y)); // bottom left\n   vec4 c32 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + texelSize.y)); // bottom center\n   vec4 c33 = texture2D(uSampler, vTextureCoord + texelSize); // bottom right\n\n   gl_FragColor =\n       c11 * matrix[0] + c12 * matrix[1] + c13 * matrix[2] +\n       c21 * matrix[3] + c22 * matrix[4] + c23 * matrix[5] +\n       c31 * matrix[6] + c32 * matrix[7] + c33 * matrix[8];\n\n   gl_FragColor.a = c22.a;\n}\n";
(function(_super) {
  __extends$l(ConvolutionFilter, _super);
  function ConvolutionFilter(matrix, width, height) {
    if (width === void 0) {
      width = 200;
    }
    if (height === void 0) {
      height = 200;
    }
    var _this = _super.call(this, vertex$f, fragment$f) || this;
    _this.uniforms.texelSize = new Float32Array(2);
    _this.uniforms.matrix = new Float32Array(9);
    if (matrix !== void 0) {
      _this.matrix = matrix;
    }
    _this.width = width;
    _this.height = height;
    return _this;
  }
  Object.defineProperty(ConvolutionFilter.prototype, "matrix", {
    /**
     * An array of values used for matrix transformation. Specified as a 9 point Array.
     */
    get: function() {
      return this.uniforms.matrix;
    },
    set: function(matrix) {
      var _this = this;
      matrix.forEach(function(v2, i2) {
        _this.uniforms.matrix[i2] = v2;
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ConvolutionFilter.prototype, "width", {
    /**
     * Width of the object you are transforming
     */
    get: function() {
      return 1 / this.uniforms.texelSize[0];
    },
    set: function(value) {
      this.uniforms.texelSize[0] = 1 / value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ConvolutionFilter.prototype, "height", {
    /**
     * Height of the object you are transforming
     */
    get: function() {
      return 1 / this.uniforms.texelSize[1];
    },
    set: function(value) {
      this.uniforms.texelSize[1] = 1 / value;
    },
    enumerable: false,
    configurable: true
  });
  return ConvolutionFilter;
})(Filter);
/*!
 * @pixi/filter-cross-hatch - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-cross-hatch is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$k = function(d2, b2) {
  extendStatics$k = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$k(d2, b2);
};
function __extends$k(d2, b2) {
  extendStatics$k(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$e = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$e = "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);\n\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n    if (lum < 1.00)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.75)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.50)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.3)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n}\n";
(function(_super) {
  __extends$k(CrossHatchFilter, _super);
  function CrossHatchFilter() {
    return _super.call(this, vertex$e, fragment$e) || this;
  }
  return CrossHatchFilter;
})(Filter);
/*!
 * @pixi/filter-crt - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-crt is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$j = function(d2, b2) {
  extendStatics$j = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$j(d2, b2);
};
function __extends$j(d2, b2) {
  extendStatics$j(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$d = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$d = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nconst float SQRT_2 = 1.414213;\n\nconst float light = 1.0;\n\nuniform float curvature;\nuniform float lineWidth;\nuniform float lineContrast;\nuniform bool verticalLine;\nuniform float noise;\nuniform float noiseSize;\n\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\n\nuniform float seed;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 dir = vec2(vTextureCoord.xy * filterArea.xy / dimensions - vec2(0.5, 0.5));\n    \n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 rgb = gl_FragColor.rgb;\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        rgb += _noise * noise;\n    }\n\n    if (lineWidth > 0.0)\n    {\n        float _c = curvature > 0. ? curvature : 1.;\n        float k = curvature > 0. ?(length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;\n        vec2 uv = dir * k;\n\n        float v = (verticalLine ? uv.x * dimensions.x : uv.y * dimensions.y) * min(1.0, 2.0 / lineWidth ) / _c;\n        float j = 1. + cos(v * 1.2 - time) * 0.5 * lineContrast;\n        rgb *= j;\n        float segment = verticalLine ? mod((dir.x + .5) * dimensions.x, 4.) : mod((dir.y + .5) * dimensions.y, 4.);\n        rgb *= 0.99 + ceil(segment) * 0.015;\n    }\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    gl_FragColor.rgb = rgb;\n}\n";
(function(_super) {
  __extends$j(CRTFilter, _super);
  function CRTFilter(options) {
    var _this = _super.call(this, vertex$d, fragment$d) || this;
    _this.time = 0;
    _this.seed = 0;
    _this.uniforms.dimensions = new Float32Array(2);
    Object.assign(_this, CRTFilter.defaults, options);
    return _this;
  }
  CRTFilter.prototype.apply = function(filterManager, input, output2, clear2) {
    var _a2 = input.filterFrame, width = _a2.width, height = _a2.height;
    this.uniforms.dimensions[0] = width;
    this.uniforms.dimensions[1] = height;
    this.uniforms.seed = this.seed;
    this.uniforms.time = this.time;
    filterManager.applyFilter(this, input, output2, clear2);
  };
  Object.defineProperty(CRTFilter.prototype, "curvature", {
    get: function() {
      return this.uniforms.curvature;
    },
    /**
     * Bent of interlaced lines, higher value means more bend
     * @default 1
     */
    set: function(value) {
      this.uniforms.curvature = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CRTFilter.prototype, "lineWidth", {
    get: function() {
      return this.uniforms.lineWidth;
    },
    /**
     * Width of interlaced lines
     * @default 1
     */
    set: function(value) {
      this.uniforms.lineWidth = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CRTFilter.prototype, "lineContrast", {
    get: function() {
      return this.uniforms.lineContrast;
    },
    /**
     * Contrast of interlaced lines
     * @default 0.25
     */
    set: function(value) {
      this.uniforms.lineContrast = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CRTFilter.prototype, "verticalLine", {
    get: function() {
      return this.uniforms.verticalLine;
    },
    /**
     * `true` for vertical lines, `false` for horizontal lines
     * @default false
     */
    set: function(value) {
      this.uniforms.verticalLine = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CRTFilter.prototype, "noise", {
    get: function() {
      return this.uniforms.noise;
    },
    /**
     * Opacity/intensity of the noise effect between `0` and `1`
     * @default 0
     */
    set: function(value) {
      this.uniforms.noise = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CRTFilter.prototype, "noiseSize", {
    get: function() {
      return this.uniforms.noiseSize;
    },
    /**
     * The size of the noise particles
     * @default 0
     */
    set: function(value) {
      this.uniforms.noiseSize = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CRTFilter.prototype, "vignetting", {
    get: function() {
      return this.uniforms.vignetting;
    },
    /**
     * The radius of the vignette effect, smaller
     * values produces a smaller vignette
     * @default 0
     */
    set: function(value) {
      this.uniforms.vignetting = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CRTFilter.prototype, "vignettingAlpha", {
    get: function() {
      return this.uniforms.vignettingAlpha;
    },
    /**
     * Amount of opacity of vignette
     * @default 0
     */
    set: function(value) {
      this.uniforms.vignettingAlpha = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CRTFilter.prototype, "vignettingBlur", {
    get: function() {
      return this.uniforms.vignettingBlur;
    },
    /**
     * Blur intensity of the vignette
     * @default 0
     */
    set: function(value) {
      this.uniforms.vignettingBlur = value;
    },
    enumerable: false,
    configurable: true
  });
  CRTFilter.defaults = {
    curvature: 1,
    lineWidth: 1,
    lineContrast: 0.25,
    verticalLine: false,
    noise: 0,
    noiseSize: 1,
    seed: 0,
    vignetting: 0.3,
    vignettingAlpha: 1,
    vignettingBlur: 0.3,
    time: 0
  };
  return CRTFilter;
})(Filter);
/*!
 * @pixi/filter-drop-shadow - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-drop-shadow is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$i = function(d2, b2) {
  extendStatics$i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$i(d2, b2);
};
function __extends$i(d2, b2) {
  extendStatics$i(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    var arguments$1 = arguments;
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments$1[i2];
      for (var p in s2) {
        if (Object.prototype.hasOwnProperty.call(s2, p)) {
          t2[p] = s2[p];
        }
      }
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var vertex$c = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$c = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform vec3 color;\n\nuniform vec2 shift;\nuniform vec4 inputSize;\n\nvoid main(void){\n    vec4 sample = texture2D(uSampler, vTextureCoord - shift * inputSize.zw);\n\n    // Premultiply alpha\n    sample.rgb = color.rgb * sample.a;\n\n    // alpha user alpha\n    sample *= alpha;\n\n    gl_FragColor = sample;\n}";
(function(_super) {
  __extends$i(DropShadowFilter, _super);
  function DropShadowFilter(options) {
    var _this = _super.call(this) || this;
    _this.angle = 45;
    _this._distance = 5;
    _this._resolution = settings$2.FILTER_RESOLUTION;
    var opt = options ? __assign(__assign({}, DropShadowFilter.defaults), options) : DropShadowFilter.defaults;
    var kernels = opt.kernels, blur = opt.blur, quality = opt.quality, pixelSize = opt.pixelSize, resolution = opt.resolution;
    _this._tintFilter = new Filter(vertex$c, fragment$c);
    _this._tintFilter.uniforms.color = new Float32Array(4);
    _this._tintFilter.uniforms.shift = new Point();
    _this._tintFilter.resolution = resolution;
    _this._blurFilter = kernels ? new KawaseBlurFilter(kernels) : new KawaseBlurFilter(blur, quality);
    _this.pixelSize = pixelSize;
    _this.resolution = resolution;
    var shadowOnly = opt.shadowOnly, rotation = opt.rotation, distance = opt.distance, alpha2 = opt.alpha, color2 = opt.color;
    _this.shadowOnly = shadowOnly;
    _this.rotation = rotation;
    _this.distance = distance;
    _this.alpha = alpha2;
    _this.color = color2;
    _this._updatePadding();
    return _this;
  }
  DropShadowFilter.prototype.apply = function(filterManager, input, output2, clear2) {
    var target = filterManager.getFilterTexture();
    this._tintFilter.apply(filterManager, input, target, 1);
    this._blurFilter.apply(filterManager, target, output2, clear2);
    if (this.shadowOnly !== true) {
      filterManager.applyFilter(this, input, output2, 0);
    }
    filterManager.returnFilterTexture(target);
  };
  DropShadowFilter.prototype._updatePadding = function() {
    this.padding = this.distance + this.blur * 2;
  };
  DropShadowFilter.prototype._updateShift = function() {
    this._tintFilter.uniforms.shift.set(this.distance * Math.cos(this.angle), this.distance * Math.sin(this.angle));
  };
  Object.defineProperty(DropShadowFilter.prototype, "resolution", {
    /**
     * The resolution of the filter.
     * @default PIXI.settings.FILTER_RESOLUTION
     */
    get: function() {
      return this._resolution;
    },
    set: function(value) {
      this._resolution = value;
      if (this._tintFilter) {
        this._tintFilter.resolution = value;
      }
      if (this._blurFilter) {
        this._blurFilter.resolution = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DropShadowFilter.prototype, "distance", {
    /**
     * Distance offset of the shadow
     * @default 5
     */
    get: function() {
      return this._distance;
    },
    set: function(value) {
      this._distance = value;
      this._updatePadding();
      this._updateShift();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DropShadowFilter.prototype, "rotation", {
    /**
     * The angle of the shadow in degrees
     * @default 2
     */
    get: function() {
      return this.angle / DEG_TO_RAD;
    },
    set: function(value) {
      this.angle = value * DEG_TO_RAD;
      this._updateShift();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DropShadowFilter.prototype, "alpha", {
    /**
     * The alpha of the shadow
     * @default 1
     */
    get: function() {
      return this._tintFilter.uniforms.alpha;
    },
    set: function(value) {
      this._tintFilter.uniforms.alpha = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DropShadowFilter.prototype, "color", {
    /**
     * The color of the shadow.
     * @default 0x000000
     */
    get: function() {
      return rgb2hex(this._tintFilter.uniforms.color);
    },
    set: function(value) {
      hex2rgb(value, this._tintFilter.uniforms.color);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DropShadowFilter.prototype, "kernels", {
    /**
     * Sets the kernels of the Blur Filter
     */
    get: function() {
      return this._blurFilter.kernels;
    },
    set: function(value) {
      this._blurFilter.kernels = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DropShadowFilter.prototype, "blur", {
    /**
     * The blur of the shadow
     * @default 2
     */
    get: function() {
      return this._blurFilter.blur;
    },
    set: function(value) {
      this._blurFilter.blur = value;
      this._updatePadding();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DropShadowFilter.prototype, "quality", {
    /**
     * Sets the quality of the Blur Filter
     * @default 4
     */
    get: function() {
      return this._blurFilter.quality;
    },
    set: function(value) {
      this._blurFilter.quality = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DropShadowFilter.prototype, "pixelSize", {
    /**
     * Sets the pixelSize of the Kawase Blur filter
     *
     * @member {number|number[]|PIXI.Point}
     * @default 1
     */
    get: function() {
      return this._blurFilter.pixelSize;
    },
    set: function(value) {
      this._blurFilter.pixelSize = value;
    },
    enumerable: false,
    configurable: true
  });
  DropShadowFilter.defaults = {
    rotation: 45,
    distance: 5,
    color: 0,
    alpha: 0.5,
    shadowOnly: false,
    kernels: null,
    blur: 2,
    quality: 3,
    pixelSize: 1,
    resolution: settings$2.FILTER_RESOLUTION
  };
  return DropShadowFilter;
})(Filter);
/*!
 * @pixi/filter-emboss - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-emboss is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$h = function(d2, b2) {
  extendStatics$h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$h(d2, b2);
};
function __extends$h(d2, b2) {
  extendStatics$h(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$b = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$b = "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float strength;\nuniform vec4 filterArea;\n\n\nvoid main(void)\n{\n	vec2 onePixel = vec2(1.0 / filterArea);\n\n	vec4 color;\n\n	color.rgb = vec3(0.5);\n\n	color -= texture2D(uSampler, vTextureCoord - onePixel) * strength;\n	color += texture2D(uSampler, vTextureCoord + onePixel) * strength;\n\n	color.rgb = vec3((color.r + color.g + color.b) / 3.0);\n\n	float alpha = texture2D(uSampler, vTextureCoord).a;\n\n	gl_FragColor = vec4(color.rgb * alpha, alpha);\n}\n";
(function(_super) {
  __extends$h(EmbossFilter, _super);
  function EmbossFilter(strength) {
    if (strength === void 0) {
      strength = 5;
    }
    var _this = _super.call(this, vertex$b, fragment$b) || this;
    _this.strength = strength;
    return _this;
  }
  Object.defineProperty(EmbossFilter.prototype, "strength", {
    /**
     * Strength of emboss.
     */
    get: function() {
      return this.uniforms.strength;
    },
    set: function(value) {
      this.uniforms.strength = value;
    },
    enumerable: false,
    configurable: true
  });
  return EmbossFilter;
})(Filter);
/*!
 * @pixi/filter-glow - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-glow is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$g = function(d2, b2) {
  extendStatics$g = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$g(d2, b2);
};
function __extends$g(d2, b2) {
  extendStatics$g(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$a = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$a = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nuniform float outerStrength;\nuniform float innerStrength;\n\nuniform vec4 glowColor;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform bool knockout;\n\nconst float PI = 3.14159265358979323846264;\n\nconst float DIST = __DIST__;\nconst float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.0);\nconst float ANGLE_STEP_NUM = ceil(PI * 2.0 / ANGLE_STEP_SIZE);\n\nconst float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.0) / 2.0;\n\nvoid main(void) {\n    vec2 px = vec2(1.0 / filterArea.x, 1.0 / filterArea.y);\n\n    float totalAlpha = 0.0;\n\n    vec2 direction;\n    vec2 displaced;\n    vec4 curColor;\n\n    for (float angle = 0.0; angle < PI * 2.0; angle += ANGLE_STEP_SIZE) {\n       direction = vec2(cos(angle), sin(angle)) * px;\n\n       for (float curDistance = 0.0; curDistance < DIST; curDistance++) {\n           displaced = clamp(vTextureCoord + direction * \n                   (curDistance + 1.0), filterClamp.xy, filterClamp.zw);\n\n           curColor = texture2D(uSampler, displaced);\n\n           totalAlpha += (DIST - curDistance) * curColor.a;\n       }\n    }\n    \n    curColor = texture2D(uSampler, vTextureCoord);\n\n    float alphaRatio = (totalAlpha / MAX_TOTAL_ALPHA);\n\n    float innerGlowAlpha = (1.0 - alphaRatio) * innerStrength * curColor.a;\n    float innerGlowStrength = min(1.0, innerGlowAlpha);\n    \n    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);\n\n    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a);\n    float outerGlowStrength = min(1.0 - innerColor.a, outerGlowAlpha);\n\n    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;\n    \n    if (knockout) {\n      float resultAlpha = outerGlowAlpha + innerGlowAlpha;\n      gl_FragColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);\n    }\n    else {\n      gl_FragColor = innerColor + outerGlowColor;\n    }\n}\n";
(function(_super) {
  __extends$g(GlowFilter, _super);
  function GlowFilter(options) {
    var _this = this;
    var opts = Object.assign({}, GlowFilter.defaults, options);
    var outerStrength = opts.outerStrength, innerStrength = opts.innerStrength, color2 = opts.color, knockout = opts.knockout, quality = opts.quality;
    var distance = Math.round(opts.distance);
    _this = _super.call(this, vertex$a, fragment$a.replace(/__ANGLE_STEP_SIZE__/gi, "" + (1 / quality / distance).toFixed(7)).replace(/__DIST__/gi, distance.toFixed(0) + ".0")) || this;
    _this.uniforms.glowColor = new Float32Array([0, 0, 0, 1]);
    Object.assign(_this, {
      color: color2,
      outerStrength,
      innerStrength,
      padding: distance,
      knockout
    });
    return _this;
  }
  Object.defineProperty(GlowFilter.prototype, "color", {
    /**
     * The color of the glow.
     * @default 0xFFFFFF
     */
    get: function() {
      return rgb2hex(this.uniforms.glowColor);
    },
    set: function(value) {
      hex2rgb(value, this.uniforms.glowColor);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GlowFilter.prototype, "outerStrength", {
    /**
     * The strength of the glow outward from the edge of the sprite.
     * @default 4
     */
    get: function() {
      return this.uniforms.outerStrength;
    },
    set: function(value) {
      this.uniforms.outerStrength = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GlowFilter.prototype, "innerStrength", {
    /**
     * The strength of the glow inward from the edge of the sprite.
     * @default 0
     */
    get: function() {
      return this.uniforms.innerStrength;
    },
    set: function(value) {
      this.uniforms.innerStrength = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GlowFilter.prototype, "knockout", {
    /**
     * Only draw the glow, not the texture itself
     * @default false
     */
    get: function() {
      return this.uniforms.knockout;
    },
    set: function(value) {
      this.uniforms.knockout = value;
    },
    enumerable: false,
    configurable: true
  });
  GlowFilter.defaults = {
    distance: 10,
    outerStrength: 4,
    innerStrength: 0,
    color: 16777215,
    quality: 0.1,
    knockout: false
  };
  return GlowFilter;
})(Filter);
/*!
 * @pixi/filter-motion-blur - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-motion-blur is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$f = function(d2, b2) {
  extendStatics$f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$f(d2, b2);
};
function __extends$f(d2, b2) {
  extendStatics$f(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$9 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$9 = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform vec2 uVelocity;\nuniform int uKernelSize;\nuniform float uOffset;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\n// Notice:\n// the perfect way:\n//    int kernelSize = min(uKernelSize, MAX_KERNELSIZE);\n// BUT in real use-case , uKernelSize < MAX_KERNELSIZE almost always.\n// So use uKernelSize directly.\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    vec2 velocity = uVelocity / filterArea.xy;\n    float offset = -uOffset / length(uVelocity) - 0.5;\n    int k = uKernelSize - 1;\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n        vec2 bias = velocity * (float(i) / float(k) + offset);\n        color += texture2D(uSampler, vTextureCoord + bias);\n    }\n    gl_FragColor = color / float(uKernelSize);\n}\n";
(function(_super) {
  __extends$f(MotionBlurFilter, _super);
  function MotionBlurFilter(velocity, kernelSize, offset) {
    if (velocity === void 0) {
      velocity = [0, 0];
    }
    if (kernelSize === void 0) {
      kernelSize = 5;
    }
    if (offset === void 0) {
      offset = 0;
    }
    var _this = _super.call(this, vertex$9, fragment$9) || this;
    _this.kernelSize = 5;
    _this.uniforms.uVelocity = new Float32Array(2);
    _this._velocity = new ObservablePoint(_this.velocityChanged, _this);
    _this.setVelocity(velocity);
    _this.kernelSize = kernelSize;
    _this.offset = offset;
    return _this;
  }
  MotionBlurFilter.prototype.apply = function(filterManager, input, output2, clear2) {
    var _a2 = this.velocity, x = _a2.x, y2 = _a2.y;
    this.uniforms.uKernelSize = x !== 0 || y2 !== 0 ? this.kernelSize : 0;
    filterManager.applyFilter(this, input, output2, clear2);
  };
  Object.defineProperty(MotionBlurFilter.prototype, "velocity", {
    get: function() {
      return this._velocity;
    },
    /**
     * Sets the velocity of the motion for blur effect.
     *
     * @member {PIXI.ObservablePoint|PIXI.Point|number[]}
     */
    set: function(value) {
      this.setVelocity(value);
    },
    enumerable: false,
    configurable: true
  });
  MotionBlurFilter.prototype.setVelocity = function(value) {
    if (Array.isArray(value)) {
      var x = value[0], y2 = value[1];
      this._velocity.set(x, y2);
    } else {
      this._velocity.copyFrom(value);
    }
  };
  MotionBlurFilter.prototype.velocityChanged = function() {
    this.uniforms.uVelocity[0] = this._velocity.x;
    this.uniforms.uVelocity[1] = this._velocity.y;
    this.padding = (Math.max(Math.abs(this._velocity.x), Math.abs(this._velocity.y)) >> 0) + 1;
  };
  Object.defineProperty(MotionBlurFilter.prototype, "offset", {
    get: function() {
      return this.uniforms.uOffset;
    },
    /**
     * The offset of the blur filter.
     * @default 0
     */
    set: function(value) {
      this.uniforms.uOffset = value;
    },
    enumerable: false,
    configurable: true
  });
  return MotionBlurFilter;
})(Filter);
/*!
 * @pixi/filter-multi-color-replace - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-multi-color-replace is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$e = function(d2, b2) {
  extendStatics$e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$e(d2, b2);
};
function __extends$e(d2, b2) {
  extendStatics$e(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$8 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$8 = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform float epsilon;\n\nconst int MAX_COLORS = %maxColors%;\n\nuniform vec3 originalColors[MAX_COLORS];\nuniform vec3 targetColors[MAX_COLORS];\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n\n    float alpha = gl_FragColor.a;\n    if (alpha < 0.0001)\n    {\n      return;\n    }\n\n    vec3 color = gl_FragColor.rgb / alpha;\n\n    for(int i = 0; i < MAX_COLORS; i++)\n    {\n      vec3 origColor = originalColors[i];\n      if (origColor.r < 0.0)\n      {\n        break;\n      }\n      vec3 colorDiff = origColor - color;\n      if (length(colorDiff) < epsilon)\n      {\n        vec3 targetColor = targetColors[i];\n        gl_FragColor = vec4((targetColor + colorDiff) * alpha, alpha);\n        return;\n      }\n    }\n}\n";
(function(_super) {
  __extends$e(MultiColorReplaceFilter, _super);
  function MultiColorReplaceFilter(replacements, epsilon, maxColors) {
    if (epsilon === void 0) {
      epsilon = 0.05;
    }
    if (maxColors === void 0) {
      maxColors = replacements.length;
    }
    var _this = _super.call(this, vertex$8, fragment$8.replace(/%maxColors%/g, maxColors.toFixed(0))) || this;
    _this._replacements = [];
    _this._maxColors = 0;
    _this.epsilon = epsilon;
    _this._maxColors = maxColors;
    _this.uniforms.originalColors = new Float32Array(maxColors * 3);
    _this.uniforms.targetColors = new Float32Array(maxColors * 3);
    _this.replacements = replacements;
    return _this;
  }
  Object.defineProperty(MultiColorReplaceFilter.prototype, "replacements", {
    get: function() {
      return this._replacements;
    },
    /**
     * The source and target colors for replacement. See constructor for information on the format.
     *
     * @member {Array<Array>}
     */
    set: function(replacements) {
      var originals = this.uniforms.originalColors;
      var targets = this.uniforms.targetColors;
      var colorCount = replacements.length;
      if (colorCount > this._maxColors) {
        throw new Error("Length of replacements (" + colorCount + ") exceeds the maximum colors length (" + this._maxColors + ")");
      }
      originals[colorCount * 3] = -1;
      for (var i2 = 0; i2 < colorCount; i2++) {
        var pair = replacements[i2];
        var color2 = pair[0];
        if (typeof color2 === "number") {
          color2 = hex2rgb(color2);
        } else {
          pair[0] = rgb2hex(color2);
        }
        originals[i2 * 3] = color2[0];
        originals[i2 * 3 + 1] = color2[1];
        originals[i2 * 3 + 2] = color2[2];
        var targetColor = pair[1];
        if (typeof targetColor === "number") {
          targetColor = hex2rgb(targetColor);
        } else {
          pair[1] = rgb2hex(targetColor);
        }
        targets[i2 * 3] = targetColor[0];
        targets[i2 * 3 + 1] = targetColor[1];
        targets[i2 * 3 + 2] = targetColor[2];
      }
      this._replacements = replacements;
    },
    enumerable: false,
    configurable: true
  });
  MultiColorReplaceFilter.prototype.refresh = function() {
    this.replacements = this._replacements;
  };
  Object.defineProperty(MultiColorReplaceFilter.prototype, "maxColors", {
    /**
     * The maximum number of color replacements supported by this filter. Can be changed
     * _only_ during construction.
     * @readonly
     */
    get: function() {
      return this._maxColors;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MultiColorReplaceFilter.prototype, "epsilon", {
    get: function() {
      return this.uniforms.epsilon;
    },
    /**
     * Tolerance of the floating-point comparison between colors (lower = more exact, higher = more inclusive)
     * @default 0.05
     */
    set: function(value) {
      this.uniforms.epsilon = value;
    },
    enumerable: false,
    configurable: true
  });
  return MultiColorReplaceFilter;
})(Filter);
/*!
 * @pixi/filter-outline - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-outline is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$d = function(d2, b2) {
  extendStatics$d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$d(d2, b2);
};
function __extends$d(d2, b2) {
  extendStatics$d(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$7 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$7 = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 thickness;\nuniform vec4 outlineColor;\nuniform vec4 filterClamp;\n\nconst float DOUBLE_PI = 3.14159265358979323846264 * 2.;\n\nvoid main(void) {\n    vec4 ownColor = texture2D(uSampler, vTextureCoord);\n    vec4 curColor;\n    float maxAlpha = 0.;\n    vec2 displaced;\n    for (float angle = 0.; angle <= DOUBLE_PI; angle += ${angleStep}) {\n        displaced.x = vTextureCoord.x + thickness.x * cos(angle);\n        displaced.y = vTextureCoord.y + thickness.y * sin(angle);\n        curColor = texture2D(uSampler, clamp(displaced, filterClamp.xy, filterClamp.zw));\n        maxAlpha = max(maxAlpha, curColor.a);\n    }\n    float resultAlpha = max(maxAlpha, ownColor.a);\n    gl_FragColor = vec4((ownColor.rgb + outlineColor.rgb * (1. - ownColor.a)) * resultAlpha, resultAlpha);\n}\n";
(function(_super) {
  __extends$d(OutlineFilter, _super);
  function OutlineFilter(thickness, color2, quality) {
    if (thickness === void 0) {
      thickness = 1;
    }
    if (color2 === void 0) {
      color2 = 0;
    }
    if (quality === void 0) {
      quality = 0.1;
    }
    var _this = _super.call(this, vertex$7, fragment$7.replace(/\$\{angleStep\}/, OutlineFilter.getAngleStep(quality))) || this;
    _this._thickness = 1;
    _this.uniforms.thickness = new Float32Array([0, 0]);
    _this.uniforms.outlineColor = new Float32Array([0, 0, 0, 1]);
    Object.assign(_this, { thickness, color: color2, quality });
    return _this;
  }
  OutlineFilter.getAngleStep = function(quality) {
    var samples = Math.max(quality * OutlineFilter.MAX_SAMPLES, OutlineFilter.MIN_SAMPLES);
    return (Math.PI * 2 / samples).toFixed(7);
  };
  OutlineFilter.prototype.apply = function(filterManager, input, output2, clear2) {
    this.uniforms.thickness[0] = this._thickness / input._frame.width;
    this.uniforms.thickness[1] = this._thickness / input._frame.height;
    filterManager.applyFilter(this, input, output2, clear2);
  };
  Object.defineProperty(OutlineFilter.prototype, "color", {
    /**
     * The color of the glow.
     * @default 0x000000
     */
    get: function() {
      return rgb2hex(this.uniforms.outlineColor);
    },
    set: function(value) {
      hex2rgb(value, this.uniforms.outlineColor);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(OutlineFilter.prototype, "thickness", {
    /**
     * The thickness of the outline.
     * @default 1
     */
    get: function() {
      return this._thickness;
    },
    set: function(value) {
      this._thickness = value;
      this.padding = value;
    },
    enumerable: false,
    configurable: true
  });
  OutlineFilter.MIN_SAMPLES = 1;
  OutlineFilter.MAX_SAMPLES = 100;
  return OutlineFilter;
})(Filter);
/*!
 * @pixi/filter-pixelate - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-pixelate is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$c = function(d2, b2) {
  extendStatics$c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$c(d2, b2);
};
function __extends$c(d2, b2) {
  extendStatics$c(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$6 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$6 = "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform vec2 size;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n	return floor( coord / size ) * size;\n}\n\nvoid main(void)\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    coord = pixelate(coord, size);\n\n    coord = unmapCoord(coord);\n\n    gl_FragColor = texture2D(uSampler, coord);\n}\n";
(function(_super) {
  __extends$c(PixelateFilter, _super);
  function PixelateFilter(size) {
    if (size === void 0) {
      size = 10;
    }
    var _this = _super.call(this, vertex$6, fragment$6) || this;
    _this.size = size;
    return _this;
  }
  Object.defineProperty(PixelateFilter.prototype, "size", {
    /**
     * This a point that describes the size of the blocks.
     * x is the width of the block and y is the height.
     *
     * @member {PIXI.Point|Array<number>|number}
     * @default 10
     */
    get: function() {
      return this.uniforms.size;
    },
    set: function(value) {
      if (typeof value === "number") {
        value = [value, value];
      }
      this.uniforms.size = value;
    },
    enumerable: false,
    configurable: true
  });
  return PixelateFilter;
})(Filter);
/*!
 * @pixi/filter-radial-blur - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-radial-blur is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$b = function(d2, b2) {
  extendStatics$b = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$b(d2, b2);
};
function __extends$b(d2, b2) {
  extendStatics$b(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$5 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$5 = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform float uRadian;\nuniform vec2 uCenter;\nuniform float uRadius;\nuniform int uKernelSize;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    float aspect = filterArea.y / filterArea.x;\n    vec2 center = uCenter.xy / filterArea.xy;\n    float gradient = uRadius / filterArea.x * 0.3;\n    float radius = uRadius / filterArea.x - gradient * 0.5;\n    int k = uKernelSize - 1;\n\n    vec2 coord = vTextureCoord;\n    vec2 dir = vec2(center - coord);\n    float dist = length(vec2(dir.x, dir.y * aspect));\n\n    float radianStep = uRadian;\n    if (radius >= 0.0 && dist > radius) {\n        float delta = dist - radius;\n        float gap = gradient;\n        float scale = 1.0 - abs(delta / gap);\n        if (scale <= 0.0) {\n            gl_FragColor = color;\n            return;\n        }\n        radianStep *= scale;\n    }\n    radianStep /= float(k);\n\n    float s = sin(radianStep);\n    float c = cos(radianStep);\n    mat2 rotationMatrix = mat2(vec2(c, -s), vec2(s, c));\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n\n        coord -= center;\n        coord.y *= aspect;\n        coord = rotationMatrix * coord;\n        coord.y /= aspect;\n        coord += center;\n\n        vec4 sample = texture2D(uSampler, coord);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample;\n    }\n\n    gl_FragColor = color / float(uKernelSize);\n}\n";
(function(_super) {
  __extends$b(RadialBlurFilter, _super);
  function RadialBlurFilter(angle, center, kernelSize, radius) {
    if (angle === void 0) {
      angle = 0;
    }
    if (center === void 0) {
      center = [0, 0];
    }
    if (kernelSize === void 0) {
      kernelSize = 5;
    }
    if (radius === void 0) {
      radius = -1;
    }
    var _this = _super.call(this, vertex$5, fragment$5) || this;
    _this._angle = 0;
    _this.angle = angle;
    _this.center = center;
    _this.kernelSize = kernelSize;
    _this.radius = radius;
    return _this;
  }
  RadialBlurFilter.prototype.apply = function(filterManager, input, output2, clear2) {
    this.uniforms.uKernelSize = this._angle !== 0 ? this.kernelSize : 0;
    filterManager.applyFilter(this, input, output2, clear2);
  };
  Object.defineProperty(RadialBlurFilter.prototype, "angle", {
    get: function() {
      return this._angle;
    },
    /**
     * Sets the angle in degrees of the motion for blur effect.
     * @default 0
     */
    set: function(value) {
      this._angle = value;
      this.uniforms.uRadian = value * Math.PI / 180;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RadialBlurFilter.prototype, "center", {
    /**
     * Center of the effect.
     *
     * @member {PIXI.Point|number[]}
     * @default [0, 0]
     */
    get: function() {
      return this.uniforms.uCenter;
    },
    set: function(value) {
      this.uniforms.uCenter = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RadialBlurFilter.prototype, "radius", {
    /**
     * Outer radius of the effect. The default value of `-1` is infinite.
     * @default -1
     */
    get: function() {
      return this.uniforms.uRadius;
    },
    set: function(value) {
      if (value < 0 || value === Infinity) {
        value = -1;
      }
      this.uniforms.uRadius = value;
    },
    enumerable: false,
    configurable: true
  });
  return RadialBlurFilter;
})(Filter);
/*!
 * @pixi/filter-shockwave - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-shockwave is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$a = function(d2, b2) {
  extendStatics$a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$a(d2, b2);
};
function __extends$a(d2, b2) {
  extendStatics$a(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$4 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$4 = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\n\nuniform vec2 center;\n\nuniform float amplitude;\nuniform float wavelength;\n// uniform float power;\nuniform float brightness;\nuniform float speed;\nuniform float radius;\n\nuniform float time;\n\nconst float PI = 3.14159;\n\nvoid main()\n{\n    float halfWavelength = wavelength * 0.5 / filterArea.x;\n    float maxRadius = radius / filterArea.x;\n    float currentRadius = time * speed / filterArea.x;\n\n    float fade = 1.0;\n\n    if (maxRadius > 0.0) {\n        if (currentRadius > maxRadius) {\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\n            return;\n        }\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\n    }\n\n    vec2 dir = vec2(vTextureCoord - center / filterArea.xy);\n    dir.y *= filterArea.y / filterArea.x;\n    float dist = length(dir);\n\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\n        return;\n    }\n\n    vec2 diffUV = normalize(dir);\n\n    float diff = (dist - currentRadius) / halfWavelength;\n\n    float p = 1.0 - pow(abs(diff), 2.0);\n\n    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );\n    float powDiff = 1.25 * sin(diff * PI) * p * ( amplitude * fade );\n\n    vec2 offset = diffUV * powDiff / filterArea.xy;\n\n    // Do clamp :\n    vec2 coord = vTextureCoord + offset;\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    vec4 color = texture2D(uSampler, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    // No clamp :\n    // gl_FragColor = texture2D(uSampler, vTextureCoord + offset);\n\n    color.rgb *= 1.0 + (brightness - 1.0) * p * fade;\n\n    gl_FragColor = color;\n}\n";
var ShockwaveFilter = (
  /** @class */
  function(_super) {
    __extends$a(ShockwaveFilter2, _super);
    function ShockwaveFilter2(center, options, time) {
      if (center === void 0) {
        center = [0, 0];
      }
      if (time === void 0) {
        time = 0;
      }
      var _this = _super.call(this, vertex$4, fragment$4) || this;
      _this.center = center;
      Object.assign(_this, ShockwaveFilter2.defaults, options);
      _this.time = time;
      return _this;
    }
    ShockwaveFilter2.prototype.apply = function(filterManager, input, output2, clear2) {
      this.uniforms.time = this.time;
      filterManager.applyFilter(this, input, output2, clear2);
    };
    Object.defineProperty(ShockwaveFilter2.prototype, "center", {
      /**
       * Sets the center of the shockwave in normalized screen coords. That is
       * (0,0) is the top-left and (1,1) is the bottom right.
       *
       * @member {PIXI.Point|number[]}
       */
      get: function() {
        return this.uniforms.center;
      },
      set: function(value) {
        this.uniforms.center = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ShockwaveFilter2.prototype, "amplitude", {
      /**
       * The amplitude of the shockwave.
       */
      get: function() {
        return this.uniforms.amplitude;
      },
      set: function(value) {
        this.uniforms.amplitude = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ShockwaveFilter2.prototype, "wavelength", {
      /**
       * The wavelength of the shockwave.
       */
      get: function() {
        return this.uniforms.wavelength;
      },
      set: function(value) {
        this.uniforms.wavelength = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ShockwaveFilter2.prototype, "brightness", {
      /**
       * The brightness of the shockwave.
       */
      get: function() {
        return this.uniforms.brightness;
      },
      set: function(value) {
        this.uniforms.brightness = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ShockwaveFilter2.prototype, "speed", {
      /**
       * The speed about the shockwave ripples out.
       * The unit is `pixel/second`
       */
      get: function() {
        return this.uniforms.speed;
      },
      set: function(value) {
        this.uniforms.speed = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ShockwaveFilter2.prototype, "radius", {
      /**
       * The maximum radius of shockwave.
       * `< 0.0` means it's infinity.
       */
      get: function() {
        return this.uniforms.radius;
      },
      set: function(value) {
        this.uniforms.radius = value;
      },
      enumerable: false,
      configurable: true
    });
    ShockwaveFilter2.defaults = {
      amplitude: 30,
      wavelength: 160,
      brightness: 1,
      speed: 500,
      radius: -1
    };
    return ShockwaveFilter2;
  }(Filter)
);
/*!
 * @pixi/filter-simple-lightmap - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-simple-lightmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$9 = function(d2, b2) {
  extendStatics$9 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$9(d2, b2);
};
function __extends$9(d2, b2) {
  extendStatics$9(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$3 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$3 = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform sampler2D uLightmap;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\nuniform vec4 ambientColor;\nvoid main() {\n    vec4 diffuseColor = texture2D(uSampler, vTextureCoord);\n    vec2 lightCoord = (vTextureCoord * filterArea.xy) / dimensions;\n    vec4 light = texture2D(uLightmap, lightCoord);\n    vec3 ambient = ambientColor.rgb * ambientColor.a;\n    vec3 intensity = ambient + light.rgb;\n    vec3 finalColor = diffuseColor.rgb * intensity;\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\n}\n";
(function(_super) {
  __extends$9(SimpleLightmapFilter, _super);
  function SimpleLightmapFilter(texture, color2, alpha2) {
    if (color2 === void 0) {
      color2 = 0;
    }
    if (alpha2 === void 0) {
      alpha2 = 1;
    }
    var _this = _super.call(this, vertex$3, fragment$3) || this;
    _this._color = 0;
    _this.uniforms.dimensions = new Float32Array(2);
    _this.uniforms.ambientColor = new Float32Array([0, 0, 0, alpha2]);
    _this.texture = texture;
    _this.color = color2;
    return _this;
  }
  SimpleLightmapFilter.prototype.apply = function(filterManager, input, output2, clear2) {
    var _a2, _b2;
    this.uniforms.dimensions[0] = (_a2 = input.filterFrame) === null || _a2 === void 0 ? void 0 : _a2.width;
    this.uniforms.dimensions[1] = (_b2 = input.filterFrame) === null || _b2 === void 0 ? void 0 : _b2.height;
    filterManager.applyFilter(this, input, output2, clear2);
  };
  Object.defineProperty(SimpleLightmapFilter.prototype, "texture", {
    /**
     * a texture where your lightmap is rendered
     * @member {PIXI.Texture}
     */
    get: function() {
      return this.uniforms.uLightmap;
    },
    set: function(value) {
      this.uniforms.uLightmap = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SimpleLightmapFilter.prototype, "color", {
    get: function() {
      return this._color;
    },
    /**
     * An RGBA array of the ambient color or a hex color without alpha
     * @member {Array<number>|number}
     */
    set: function(value) {
      var arr = this.uniforms.ambientColor;
      if (typeof value === "number") {
        hex2rgb(value, arr);
        this._color = value;
      } else {
        arr[0] = value[0];
        arr[1] = value[1];
        arr[2] = value[2];
        arr[3] = value[3];
        this._color = rgb2hex(arr);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SimpleLightmapFilter.prototype, "alpha", {
    /**
     * When setting `color` as hex, this can be used to set alpha independently.
     */
    get: function() {
      return this.uniforms.ambientColor[3];
    },
    set: function(value) {
      this.uniforms.ambientColor[3] = value;
    },
    enumerable: false,
    configurable: true
  });
  return SimpleLightmapFilter;
})(Filter);
/*!
 * @pixi/filter-tilt-shift - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-tilt-shift is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$8 = function(d2, b2) {
  extendStatics$8 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$8(d2, b2);
};
function __extends$8(d2, b2) {
  extendStatics$8(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$2 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$2 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float blur;\nuniform float gradientBlur;\nuniform vec2 start;\nuniform vec2 end;\nuniform vec2 delta;\nuniform vec2 texSize;\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n    vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * texSize - start, normal)) / gradientBlur) * blur;\n\n    for (float t = -30.0; t <= 30.0; t++)\n    {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta / texSize * percent * radius);\n        sample.rgb *= sample.a;\n        color += sample * weight;\n        total += weight;\n    }\n\n    color /= total;\n    color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n";
var TiltShiftAxisFilter = (
  /** @class */
  function(_super) {
    __extends$8(TiltShiftAxisFilter2, _super);
    function TiltShiftAxisFilter2(blur, gradientBlur, start, end2) {
      if (blur === void 0) {
        blur = 100;
      }
      if (gradientBlur === void 0) {
        gradientBlur = 600;
      }
      var _this = _super.call(this, vertex$2, fragment$2) || this;
      _this.uniforms.blur = blur;
      _this.uniforms.gradientBlur = gradientBlur;
      _this.uniforms.start = start || new Point(0, window.innerHeight / 2);
      _this.uniforms.end = end2 || new Point(600, window.innerHeight / 2);
      _this.uniforms.delta = new Point(30, 30);
      _this.uniforms.texSize = new Point(window.innerWidth, window.innerHeight);
      _this.updateDelta();
      return _this;
    }
    TiltShiftAxisFilter2.prototype.updateDelta = function() {
      this.uniforms.delta.x = 0;
      this.uniforms.delta.y = 0;
    };
    Object.defineProperty(TiltShiftAxisFilter2.prototype, "blur", {
      /**
       * The strength of the blur.
       *
       * @memberof PIXI.filters.TiltShiftAxisFilter#
       */
      get: function() {
        return this.uniforms.blur;
      },
      set: function(value) {
        this.uniforms.blur = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TiltShiftAxisFilter2.prototype, "gradientBlur", {
      /**
       * The strength of the gradient blur.
       *
       * @memberof PIXI.filters.TiltShiftAxisFilter#
       */
      get: function() {
        return this.uniforms.gradientBlur;
      },
      set: function(value) {
        this.uniforms.gradientBlur = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TiltShiftAxisFilter2.prototype, "start", {
      /**
       * The X value to start the effect at.
       *
       * @member {PIXI.Point}
       * @memberof PIXI.filters.TiltShiftAxisFilter#
       */
      get: function() {
        return this.uniforms.start;
      },
      set: function(value) {
        this.uniforms.start = value;
        this.updateDelta();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TiltShiftAxisFilter2.prototype, "end", {
      /**
       * The X value to end the effect at.
       *
       * @member {PIXI.Point}
       * @memberof PIXI.filters.TiltShiftAxisFilter#
       */
      get: function() {
        return this.uniforms.end;
      },
      set: function(value) {
        this.uniforms.end = value;
        this.updateDelta();
      },
      enumerable: false,
      configurable: true
    });
    return TiltShiftAxisFilter2;
  }(Filter)
);
var TiltShiftXFilter = (
  /** @class */
  function(_super) {
    __extends$8(TiltShiftXFilter2, _super);
    function TiltShiftXFilter2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TiltShiftXFilter2.prototype.updateDelta = function() {
      var dx = this.uniforms.end.x - this.uniforms.start.x;
      var dy = this.uniforms.end.y - this.uniforms.start.y;
      var d2 = Math.sqrt(dx * dx + dy * dy);
      this.uniforms.delta.x = dx / d2;
      this.uniforms.delta.y = dy / d2;
    };
    return TiltShiftXFilter2;
  }(TiltShiftAxisFilter)
);
var TiltShiftYFilter = (
  /** @class */
  function(_super) {
    __extends$8(TiltShiftYFilter2, _super);
    function TiltShiftYFilter2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TiltShiftYFilter2.prototype.updateDelta = function() {
      var dx = this.uniforms.end.x - this.uniforms.start.x;
      var dy = this.uniforms.end.y - this.uniforms.start.y;
      var d2 = Math.sqrt(dx * dx + dy * dy);
      this.uniforms.delta.x = -dy / d2;
      this.uniforms.delta.y = dx / d2;
    };
    return TiltShiftYFilter2;
  }(TiltShiftAxisFilter)
);
(function(_super) {
  __extends$8(TiltShiftFilter, _super);
  function TiltShiftFilter(blur, gradientBlur, start, end2) {
    if (blur === void 0) {
      blur = 100;
    }
    if (gradientBlur === void 0) {
      gradientBlur = 600;
    }
    var _this = _super.call(this) || this;
    _this.tiltShiftXFilter = new TiltShiftXFilter(blur, gradientBlur, start, end2);
    _this.tiltShiftYFilter = new TiltShiftYFilter(blur, gradientBlur, start, end2);
    return _this;
  }
  TiltShiftFilter.prototype.apply = function(filterManager, input, output2, clearMode) {
    var renderTarget = filterManager.getFilterTexture();
    this.tiltShiftXFilter.apply(filterManager, input, renderTarget, 1);
    this.tiltShiftYFilter.apply(filterManager, renderTarget, output2, clearMode);
    filterManager.returnFilterTexture(renderTarget);
  };
  Object.defineProperty(TiltShiftFilter.prototype, "blur", {
    /**
     * The strength of the blur.
     */
    get: function() {
      return this.tiltShiftXFilter.blur;
    },
    set: function(value) {
      this.tiltShiftXFilter.blur = this.tiltShiftYFilter.blur = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TiltShiftFilter.prototype, "gradientBlur", {
    /**
     * The strength of the gradient blur.
     */
    get: function() {
      return this.tiltShiftXFilter.gradientBlur;
    },
    set: function(value) {
      this.tiltShiftXFilter.gradientBlur = this.tiltShiftYFilter.gradientBlur = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TiltShiftFilter.prototype, "start", {
    /**
     * The Y value to start the effect at.
     *
     * @member {PIXI.Point}
     */
    get: function() {
      return this.tiltShiftXFilter.start;
    },
    set: function(value) {
      this.tiltShiftXFilter.start = this.tiltShiftYFilter.start = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TiltShiftFilter.prototype, "end", {
    /**
     * The Y value to end the effect at.
     *
     * @member {PIXI.Point}
     */
    get: function() {
      return this.tiltShiftXFilter.end;
    },
    set: function(value) {
      this.tiltShiftXFilter.end = this.tiltShiftYFilter.end = value;
    },
    enumerable: false,
    configurable: true
  });
  return TiltShiftFilter;
})(Filter);
/*!
 * @pixi/filter-twist - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-twist is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$7 = function(d2, b2) {
  extendStatics$7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$7(d2, b2);
};
function __extends$7(d2, b2) {
  extendStatics$7(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex$1 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment$1 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform vec4 filterArea;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 twist(vec2 coord)\n{\n    coord -= offset;\n\n    float dist = length(coord);\n\n    if (dist < radius)\n    {\n        float ratioDist = (radius - dist) / radius;\n        float angleMod = ratioDist * ratioDist * angle;\n        float s = sin(angleMod);\n        float c = cos(angleMod);\n        coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\n    }\n\n    coord += offset;\n\n    return coord;\n}\n\nvoid main(void)\n{\n\n    vec2 coord = mapCoord(vTextureCoord);\n\n    coord = twist(coord);\n\n    coord = unmapCoord(coord);\n\n    gl_FragColor = texture2D(uSampler, coord );\n\n}\n";
(function(_super) {
  __extends$7(TwistFilter, _super);
  function TwistFilter(options) {
    var _this = _super.call(this, vertex$1, fragment$1) || this;
    Object.assign(_this, TwistFilter.defaults, options);
    return _this;
  }
  Object.defineProperty(TwistFilter.prototype, "offset", {
    /**
     * This point describes the the offset of the twist.
     *
     * @member {PIXI.Point}
     */
    get: function() {
      return this.uniforms.offset;
    },
    set: function(value) {
      this.uniforms.offset = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TwistFilter.prototype, "radius", {
    /**
     * The radius of the twist.
     */
    get: function() {
      return this.uniforms.radius;
    },
    set: function(value) {
      this.uniforms.radius = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TwistFilter.prototype, "angle", {
    /**
     * The angle of the twist.
     */
    get: function() {
      return this.uniforms.angle;
    },
    set: function(value) {
      this.uniforms.angle = value;
    },
    enumerable: false,
    configurable: true
  });
  TwistFilter.defaults = {
    radius: 200,
    angle: 4,
    padding: 20,
    offset: new Point()
  };
  return TwistFilter;
})(Filter);
/*!
 * @pixi/filter-zoom-blur - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:53:35 UTC
 *
 * @pixi/filter-zoom-blur is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$6 = function(d2, b2) {
  extendStatics$6 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics$6(d2, b2);
};
function __extends$6(d2, b2) {
  extendStatics$6(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __rest(s2, e2) {
  var t2 = {};
  for (var p in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) {
      t2[p] = s2[p];
    }
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") {
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
      if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) {
        t2[p[i2]] = s2[p[i2]];
      }
    }
  }
  return t2;
}
var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform vec2 uCenter;\nuniform float uStrength;\nuniform float uInnerRadius;\nuniform float uRadius;\n\nconst float MAX_KERNEL_SIZE = ${maxKernelSize};\n\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand(vec2 co, float seed) {\n    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n    highp float dt = dot(co + seed, vec2(a, b)), sn = mod(dt, 3.14159);\n    return fract(sin(sn) * c + seed);\n}\n\nvoid main() {\n\n    float minGradient = uInnerRadius * 0.3;\n    float innerRadius = (uInnerRadius + minGradient * 0.5) / filterArea.x;\n\n    float gradient = uRadius * 0.3;\n    float radius = (uRadius - gradient * 0.5) / filterArea.x;\n\n    float countLimit = MAX_KERNEL_SIZE;\n\n    vec2 dir = vec2(uCenter.xy / filterArea.xy - vTextureCoord);\n    float dist = length(vec2(dir.x, dir.y * filterArea.y / filterArea.x));\n\n    float strength = uStrength;\n\n    float delta = 0.0;\n    float gap;\n    if (dist < innerRadius) {\n        delta = innerRadius - dist;\n        gap = minGradient;\n    } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\n        delta = dist - radius;\n        gap = gradient;\n    }\n\n    if (delta > 0.0) {\n        float normalCount = gap / filterArea.x;\n        delta = (normalCount - delta) / normalCount;\n        countLimit *= delta;\n        strength *= delta;\n        if (countLimit < 1.0)\n        {\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\n            return;\n        }\n    }\n\n    // randomize the lookup values to hide the fixed number of samples\n    float offset = rand(vTextureCoord, 0.0);\n\n    float total = 0.0;\n    vec4 color = vec4(0.0);\n\n    dir *= strength;\n\n    for (float t = 0.0; t < MAX_KERNEL_SIZE; t++) {\n        float percent = (t + offset) / MAX_KERNEL_SIZE;\n        float weight = 4.0 * (percent - percent * percent);\n        vec2 p = vTextureCoord + dir * percent;\n        vec4 sample = texture2D(uSampler, p);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample * weight;\n        total += weight;\n\n        if (t > countLimit){\n            break;\n        }\n    }\n\n    color /= total;\n    // switch back from pre-multiplied alpha\n    // color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n";
(function(_super) {
  __extends$6(ZoomBlurFilter, _super);
  function ZoomBlurFilter(options) {
    var _this = this;
    var _a2 = Object.assign(ZoomBlurFilter.defaults, options), maxKernelSize = _a2.maxKernelSize, rest = __rest(_a2, ["maxKernelSize"]);
    _this = _super.call(this, vertex, fragment.replace("${maxKernelSize}", maxKernelSize.toFixed(1))) || this;
    Object.assign(_this, rest);
    return _this;
  }
  Object.defineProperty(ZoomBlurFilter.prototype, "center", {
    /**
     * Center of the effect.
     *
     * @member {PIXI.Point|number[]}
     * @default [0, 0]
     */
    get: function() {
      return this.uniforms.uCenter;
    },
    set: function(value) {
      this.uniforms.uCenter = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ZoomBlurFilter.prototype, "strength", {
    /**
     * Intensity of the zoom effect.
     * @default 0.1
     */
    get: function() {
      return this.uniforms.uStrength;
    },
    set: function(value) {
      this.uniforms.uStrength = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ZoomBlurFilter.prototype, "innerRadius", {
    /**
     * Radius of the inner region not effected by blur.
     * @default 0
     */
    get: function() {
      return this.uniforms.uInnerRadius;
    },
    set: function(value) {
      this.uniforms.uInnerRadius = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ZoomBlurFilter.prototype, "radius", {
    /**
     * Outer radius of the effect. The default value is `-1`.
     * `< 0.0` means it's infinity.
     * @default -1
     */
    get: function() {
      return this.uniforms.uRadius;
    },
    set: function(value) {
      if (value < 0 || value === Infinity) {
        value = -1;
      }
      this.uniforms.uRadius = value;
    },
    enumerable: false,
    configurable: true
  });
  ZoomBlurFilter.defaults = {
    strength: 0.1,
    center: [0, 0],
    innerRadius: 0,
    radius: -1,
    maxKernelSize: 32
  };
  return ZoomBlurFilter;
})(Filter);
const FILTER_NAME$1 = "shockwaveFilter";
function getOrCreateShockwaveFilterImpl(container2, createMode) {
  const shockwaveFilterFromMap = container2.containerFilters.get(FILTER_NAME$1);
  if (shockwaveFilterFromMap) {
    return shockwaveFilterFromMap;
  } else {
    if (createMode) {
      const shockwaveFilter = new ShockwaveFilter([1280, 720]);
      shockwaveFilter.time = 0;
      container2.addFilter(shockwaveFilter);
      container2.containerFilters.set(FILTER_NAME$1, shockwaveFilter);
      return shockwaveFilter;
    }
  }
}
function getShockwaveFilter(container2) {
  if (container2.getOrCreateShockwaveFilter(false)) {
    const shockwaveFilter = container2.getOrCreateShockwaveFilter();
    return shockwaveFilter.time;
  }
  return 0;
}
function setShockwaveFilter(container2, value) {
  if (value === 0) {
    container2.removeFilter(FILTER_NAME$1);
  } else {
    const shockwaveFilter = container2.getOrCreateShockwaveFilter();
    if (shockwaveFilter)
      shockwaveFilter.time = value;
  }
}
const INIT_RAD = 0;
const FILTER_NAME = "radiusAlphaFilter";
class RadiusAlphaFilter extends Filter {
  constructor(center, radius) {
    const fragmentShader = `
// fragment shader
precision mediump float;

uniform sampler2D uSampler;  // 
varying vec2 vTextureCoord;  // 
uniform vec2 center;         // 
uniform float radius;        // 

void main(void) {
    vec4 color = texture2D(uSampler, vTextureCoord);

    // 
    float aspect = 16.0 / 9.0;

    // 
    vec2 aspectCorrectCoord = vTextureCoord;
    aspectCorrectCoord.x *= aspect;

    // 
    float dist = distance(aspectCorrectCoord, center * vec2(aspect, 1.0));

    // smoothstepalpha,
    float alpha = smoothstep(radius, radius + 0.05, dist);

    // 
    gl_FragColor = color * (1.0 - alpha);
}
    `;
    super(null, fragmentShader);
    this.uniforms.center = [center.x, center.y];
    this.uniforms.radius = radius;
  }
  set center(value) {
    this.uniforms.center = [value.x, value.y];
  }
  get center() {
    return new Point(this.uniforms.center[0], this.uniforms.center[1]);
  }
  set radius(value) {
    this.uniforms.radius = value;
  }
  get radius() {
    return this.uniforms.radius;
  }
}
function getOrCreateRadiusAlphaFilterImpl(container2, createMode) {
  const shockwaveFilterFromMap = container2.containerFilters.get(FILTER_NAME);
  if (shockwaveFilterFromMap) {
    return shockwaveFilterFromMap;
  } else {
    if (createMode) {
      const shockwaveFilter = new RadiusAlphaFilter(new Point(0.5, 0.5), INIT_RAD);
      shockwaveFilter.radius = INIT_RAD;
      container2.addFilter(shockwaveFilter);
      container2.containerFilters.set(FILTER_NAME, shockwaveFilter);
      return shockwaveFilter;
    }
  }
}
function getRadiusAlphaFilter(container2) {
  if (container2.getOrCreateShockwaveFilter(false)) {
    const shockwaveFilter = container2.getOrCreateRadiusAlphaFilter();
    return shockwaveFilter.radius;
  }
  return INIT_RAD;
}
function setRadiusAlphaFilter(container2, value) {
  if (value === 0) {
    container2.removeFilter(FILTER_NAME);
  } else {
    const shockwaveFilter = container2.getOrCreateRadiusAlphaFilter();
    if (shockwaveFilter)
      shockwaveFilter.radius = value;
  }
}
class WebGALPixiContainer extends Container$1 {
  constructor() {
    super();
    __publicField(this, "containerFilters", /* @__PURE__ */ new Map());
    __publicField(this, "baseX", 0);
    __publicField(this, "baseY", 0);
  }
  addFilter(filter2) {
    if (this.filters) {
      this.filters.push(filter2);
    } else {
      this.filters = [filter2];
    }
  }
  removeFilter(name) {
    const filter2 = this.containerFilters.get(name);
    if (filter2) {
      const index2 = ((this == null ? void 0 : this.filters) ?? []).findIndex((e2) => e2 === filter2);
      if (this.filters) {
        this.filters.splice(index2, 1);
        this.containerFilters.delete(name);
      }
    }
  }
  get blur() {
    return this.getOrCreateBlurFilter().blur;
  }
  set blur(value) {
    this.getOrCreateBlurFilter().blur = value;
  }
  get x() {
    var _a2;
    const rX = ((_a2 = super.position) == null ? void 0 : _a2.x) ?? 0;
    return rX - this.baseX;
  }
  set x(value) {
    if (!super.position) {
      return;
    }
    super.position.x = value + this.baseX;
  }
  get y() {
    var _a2;
    const rY = ((_a2 = super.position) == null ? void 0 : _a2.y) ?? 0;
    return rY - this.baseY;
  }
  set y(value) {
    if (!super.position) {
      return;
    }
    super.position.y = value + this.baseY;
  }
  setBaseX(x) {
    const originalX = this.x;
    this.baseX = x;
    this.x = originalX;
  }
  setBaseY(y2) {
    const originalY = this.y;
    this.baseY = y2;
    this.y = originalY;
  }
  getOrCreateBlurFilter() {
    const blurFilterFromMap = this.containerFilters.get("blur");
    if (blurFilterFromMap) {
      return blurFilterFromMap;
    } else {
      const blurFilter = new filters.BlurFilter();
      blurFilter.blur = 0;
      this.addFilter(blurFilter);
      this.containerFilters.set("blur", blurFilter);
      return blurFilter;
    }
  }
  /**
   * old film filter
   * @public
   */
  getOrCreateOldFilmFilter(createMode = true) {
    const blurFilterFromMap = this.containerFilters.get("oldFilm");
    if (blurFilterFromMap) {
      return blurFilterFromMap;
    } else {
      if (createMode) {
        const oldFilm = new OldFilmFilter();
        this.addFilter(oldFilm);
        this.containerFilters.set("oldFilm", oldFilm);
        return oldFilm;
      } else
        return null;
    }
  }
  get oldFilm() {
    if (this.getOrCreateOldFilmFilter(false))
      return 1;
    return 0;
  }
  set oldFilm(value) {
    if (value === 0) {
      this.removeFilter("oldFilm");
    } else
      this.getOrCreateOldFilmFilter();
  }
  /**
   * dot film filter
   * @public
   */
  getOrCreateDotFilter(createMode = true) {
    const blurFilterFromMap = this.containerFilters.get("dotFilm");
    if (blurFilterFromMap) {
      return blurFilterFromMap;
    } else {
      if (createMode) {
        const dotFilm = new DotFilter();
        this.addFilter(dotFilm);
        this.containerFilters.set("dotFilm", dotFilm);
        return dotFilm;
      } else
        return null;
    }
  }
  get dotFilm() {
    if (this.getOrCreateDotFilter(false))
      return 1;
    return 0;
  }
  set dotFilm(value) {
    if (value === 0) {
      this.removeFilter("dotFilm");
    } else
      this.getOrCreateDotFilter();
  }
  /**
   * reflection film filter
   * @public
   */
  getOrCreateReflectionFilter(createMode = true) {
    const blurFilterFromMap = this.containerFilters.get("reflectionFilm");
    if (blurFilterFromMap) {
      return blurFilterFromMap;
    } else {
      if (createMode) {
        const reflectionFilm = new ReflectionFilter();
        this.addFilter(reflectionFilm);
        this.containerFilters.set("reflectionFilm", reflectionFilm);
        return reflectionFilm;
      } else
        return null;
    }
  }
  get reflectionFilm() {
    if (this.getOrCreateReflectionFilter(false))
      return 1;
    return 0;
  }
  set reflectionFilm(value) {
    if (value === 0) {
      this.removeFilter("reflectionFilm");
    } else
      this.getOrCreateReflectionFilter();
  }
  /**
   * glitchFilter film filter
   * @public
   */
  getOrCreateGlitchFilter(createMode = true) {
    const blurFilterFromMap = this.containerFilters.get("glitchFilm");
    if (blurFilterFromMap) {
      return blurFilterFromMap;
    } else {
      if (createMode) {
        const glitchFilm = new GlitchFilter();
        this.addFilter(glitchFilm);
        this.containerFilters.set("glitchFilm", glitchFilm);
        return glitchFilm;
      } else
        return null;
    }
  }
  get glitchFilm() {
    if (this.getOrCreateGlitchFilter(false))
      return 1;
    return 0;
  }
  set glitchFilm(value) {
    if (value === 0) {
      this.removeFilter("glitchFilm");
    } else
      this.getOrCreateGlitchFilter();
  }
  /**
   * rgbSplitFilter film filter
   * @public
   */
  getOrCreateRGBSplitFilter(createMode = true) {
    const blurFilterFromMap = this.containerFilters.get("rgbFilm");
    if (blurFilterFromMap) {
      return blurFilterFromMap;
    } else {
      if (createMode) {
        const rgbFilm = new RGBSplitFilter();
        this.addFilter(rgbFilm);
        this.containerFilters.set("rgbFilm", rgbFilm);
        return rgbFilm;
      }
    }
  }
  get rgbFilm() {
    if (this.getOrCreateRGBSplitFilter(false))
      return 1;
    return 0;
  }
  set rgbFilm(value) {
    if (value === 0) {
      this.removeFilter("rgbFilm");
    } else
      this.getOrCreateRGBSplitFilter();
  }
  /**
   * godrayFilter film filter
   * @public
   */
  getOrCreateGodrayFilter(createMode = true) {
    const blurFilterFromMap = this.containerFilters.get("godrayFilm");
    if (blurFilterFromMap) {
      return blurFilterFromMap;
    } else {
      if (createMode) {
        const godrayFilm = new GodrayFilter();
        this.addFilter(godrayFilm);
        this.containerFilters.set("godrayFilm", godrayFilm);
        return godrayFilm;
      }
    }
  }
  get godrayFilm() {
    if (this.getOrCreateGodrayFilter(false))
      return 1;
    return 0;
  }
  set godrayFilm(value) {
    if (value === 0) {
      this.removeFilter("godrayFilm");
    } else
      this.getOrCreateGodrayFilter();
  }
  /**
   * ShockwaveFilter
   */
  getOrCreateShockwaveFilter(createMode = true) {
    return getOrCreateShockwaveFilterImpl(this, createMode);
  }
  get shockwaveFilter() {
    return getShockwaveFilter(this);
  }
  set shockwaveFilter(value) {
    setShockwaveFilter(this, value);
  }
  /**
   * RadiusAlphaFilter
   */
  getOrCreateRadiusAlphaFilter(createMode = true) {
    return getOrCreateRadiusAlphaFilterImpl(this, createMode);
  }
  get radiusAlphaFilter() {
    return getRadiusAlphaFilter(this);
  }
  set radiusAlphaFilter(value) {
    setRadiusAlphaFilter(this, value);
  }
}
var AttachmentType;
(function(AttachmentType2) {
  AttachmentType2[AttachmentType2["Region"] = 0] = "Region";
  AttachmentType2[AttachmentType2["BoundingBox"] = 1] = "BoundingBox";
  AttachmentType2[AttachmentType2["Mesh"] = 2] = "Mesh";
  AttachmentType2[AttachmentType2["LinkedMesh"] = 3] = "LinkedMesh";
  AttachmentType2[AttachmentType2["Path"] = 4] = "Path";
  AttachmentType2[AttachmentType2["Point"] = 5] = "Point";
  AttachmentType2[AttachmentType2["Clipping"] = 6] = "Clipping";
})(AttachmentType || (AttachmentType = {}));
var BinaryInput = (
  /** @class */
  function() {
    function BinaryInput2(data2, strings2, index2, buffer) {
      if (strings2 === void 0) {
        strings2 = new Array();
      }
      if (index2 === void 0) {
        index2 = 0;
      }
      if (buffer === void 0) {
        buffer = new DataView(data2.buffer);
      }
      this.strings = strings2;
      this.index = index2;
      this.buffer = buffer;
    }
    BinaryInput2.prototype.readByte = function() {
      return this.buffer.getInt8(this.index++);
    };
    BinaryInput2.prototype.readUnsignedByte = function() {
      return this.buffer.getUint8(this.index++);
    };
    BinaryInput2.prototype.readShort = function() {
      var value = this.buffer.getInt16(this.index);
      this.index += 2;
      return value;
    };
    BinaryInput2.prototype.readInt32 = function() {
      var value = this.buffer.getInt32(this.index);
      this.index += 4;
      return value;
    };
    BinaryInput2.prototype.readInt = function(optimizePositive) {
      var b2 = this.readByte();
      var result = b2 & 127;
      if ((b2 & 128) != 0) {
        b2 = this.readByte();
        result |= (b2 & 127) << 7;
        if ((b2 & 128) != 0) {
          b2 = this.readByte();
          result |= (b2 & 127) << 14;
          if ((b2 & 128) != 0) {
            b2 = this.readByte();
            result |= (b2 & 127) << 21;
            if ((b2 & 128) != 0) {
              b2 = this.readByte();
              result |= (b2 & 127) << 28;
            }
          }
        }
      }
      return optimizePositive ? result : result >>> 1 ^ -(result & 1);
    };
    BinaryInput2.prototype.readStringRef = function() {
      var index2 = this.readInt(true);
      return index2 == 0 ? null : this.strings[index2 - 1];
    };
    BinaryInput2.prototype.readString = function() {
      var byteCount = this.readInt(true);
      switch (byteCount) {
        case 0:
          return null;
        case 1:
          return "";
      }
      byteCount--;
      var chars2 = "";
      for (var i2 = 0; i2 < byteCount; ) {
        var b2 = this.readUnsignedByte();
        switch (b2 >> 4) {
          case 12:
          case 13:
            chars2 += String.fromCharCode((b2 & 31) << 6 | this.readByte() & 63);
            i2 += 2;
            break;
          case 14:
            chars2 += String.fromCharCode((b2 & 15) << 12 | (this.readByte() & 63) << 6 | this.readByte() & 63);
            i2 += 3;
            break;
          default:
            chars2 += String.fromCharCode(b2);
            i2++;
        }
      }
      return chars2;
    };
    BinaryInput2.prototype.readFloat = function() {
      var value = this.buffer.getFloat32(this.index);
      this.index += 4;
      return value;
    };
    BinaryInput2.prototype.readBoolean = function() {
      return this.readByte() != 0;
    };
    return BinaryInput2;
  }()
);
var MixBlend;
(function(MixBlend2) {
  MixBlend2[MixBlend2["setup"] = 0] = "setup";
  MixBlend2[MixBlend2["first"] = 1] = "first";
  MixBlend2[MixBlend2["replace"] = 2] = "replace";
  MixBlend2[MixBlend2["add"] = 3] = "add";
})(MixBlend || (MixBlend = {}));
var MixDirection;
(function(MixDirection2) {
  MixDirection2[MixDirection2["mixIn"] = 0] = "mixIn";
  MixDirection2[MixDirection2["mixOut"] = 1] = "mixOut";
})(MixDirection || (MixDirection = {}));
var PositionMode;
(function(PositionMode2) {
  PositionMode2[PositionMode2["Fixed"] = 0] = "Fixed";
  PositionMode2[PositionMode2["Percent"] = 1] = "Percent";
})(PositionMode || (PositionMode = {}));
var RotateMode;
(function(RotateMode2) {
  RotateMode2[RotateMode2["Tangent"] = 0] = "Tangent";
  RotateMode2[RotateMode2["Chain"] = 1] = "Chain";
  RotateMode2[RotateMode2["ChainScale"] = 2] = "ChainScale";
})(RotateMode || (RotateMode = {}));
var TransformMode;
(function(TransformMode2) {
  TransformMode2[TransformMode2["Normal"] = 0] = "Normal";
  TransformMode2[TransformMode2["OnlyTranslation"] = 1] = "OnlyTranslation";
  TransformMode2[TransformMode2["NoRotationOrReflection"] = 2] = "NoRotationOrReflection";
  TransformMode2[TransformMode2["NoScale"] = 3] = "NoScale";
  TransformMode2[TransformMode2["NoScaleOrReflection"] = 4] = "NoScaleOrReflection";
})(TransformMode || (TransformMode = {}));
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$5 = function(d2, b2) {
  extendStatics$5 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p))
        d3[p] = b3[p];
  };
  return extendStatics$5(d2, b2);
};
function __extends$5(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics$5(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function filterFromString(text2) {
  switch (text2.toLowerCase()) {
    case "nearest":
      return TextureFilter.Nearest;
    case "linear":
      return TextureFilter.Linear;
    case "mipmap":
      return TextureFilter.MipMap;
    case "mipmapnearestnearest":
      return TextureFilter.MipMapNearestNearest;
    case "mipmaplinearnearest":
      return TextureFilter.MipMapLinearNearest;
    case "mipmapnearestlinear":
      return TextureFilter.MipMapNearestLinear;
    case "mipmaplinearlinear":
      return TextureFilter.MipMapLinearLinear;
    default:
      throw new Error("Unknown texture filter " + text2);
  }
}
var TextureFilter;
(function(TextureFilter2) {
  TextureFilter2[TextureFilter2["Nearest"] = 9728] = "Nearest";
  TextureFilter2[TextureFilter2["Linear"] = 9729] = "Linear";
  TextureFilter2[TextureFilter2["MipMap"] = 9987] = "MipMap";
  TextureFilter2[TextureFilter2["MipMapNearestNearest"] = 9984] = "MipMapNearestNearest";
  TextureFilter2[TextureFilter2["MipMapLinearNearest"] = 9985] = "MipMapLinearNearest";
  TextureFilter2[TextureFilter2["MipMapNearestLinear"] = 9986] = "MipMapNearestLinear";
  TextureFilter2[TextureFilter2["MipMapLinearLinear"] = 9987] = "MipMapLinearLinear";
})(TextureFilter || (TextureFilter = {}));
var TextureWrap;
(function(TextureWrap2) {
  TextureWrap2[TextureWrap2["MirroredRepeat"] = 33648] = "MirroredRepeat";
  TextureWrap2[TextureWrap2["ClampToEdge"] = 33071] = "ClampToEdge";
  TextureWrap2[TextureWrap2["Repeat"] = 10497] = "Repeat";
})(TextureWrap || (TextureWrap = {}));
var TextureRegion = (
  /** @class */
  function() {
    function TextureRegion2() {
      this.size = null;
      this.names = null;
      this.values = null;
      this.renderObject = null;
    }
    Object.defineProperty(TextureRegion2.prototype, "width", {
      get: function() {
        var tex = this.texture;
        if (tex.trim) {
          return tex.trim.width;
        }
        return tex.orig.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "height", {
      get: function() {
        var tex = this.texture;
        if (tex.trim) {
          return tex.trim.height;
        }
        return tex.orig.height;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "u", {
      get: function() {
        return this.texture._uvs.x0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "v", {
      get: function() {
        return this.texture._uvs.y0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "u2", {
      get: function() {
        return this.texture._uvs.x2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "v2", {
      get: function() {
        return this.texture._uvs.y2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "offsetX", {
      get: function() {
        var tex = this.texture;
        return tex.trim ? tex.trim.x : 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "offsetY", {
      get: function() {
        return this.spineOffsetY;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "pixiOffsetY", {
      get: function() {
        var tex = this.texture;
        return tex.trim ? tex.trim.y : 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "spineOffsetY", {
      get: function() {
        var tex = this.texture;
        return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "originalWidth", {
      get: function() {
        return this.texture.orig.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "originalHeight", {
      get: function() {
        return this.texture.orig.height;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "x", {
      get: function() {
        return this.texture.frame.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "y", {
      get: function() {
        return this.texture.frame.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "rotate", {
      get: function() {
        return this.texture.rotate !== 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextureRegion2.prototype, "degrees", {
      get: function() {
        return (360 - this.texture.rotate * 45) % 360;
      },
      enumerable: false,
      configurable: true
    });
    return TextureRegion2;
  }()
);
var RegionFields = (
  /** @class */
  function() {
    function RegionFields2() {
      this.x = 0;
      this.y = 0;
      this.width = 0;
      this.height = 0;
      this.offsetX = 0;
      this.offsetY = 0;
      this.originalWidth = 0;
      this.originalHeight = 0;
      this.rotate = 0;
      this.index = 0;
    }
    return RegionFields2;
  }()
);
var TextureAtlas = (
  /** @class */
  function() {
    function TextureAtlas2(atlasText, textureLoader, callback) {
      this.pages = new Array();
      this.regions = new Array();
      if (atlasText) {
        this.addSpineAtlas(atlasText, textureLoader, callback);
      }
    }
    TextureAtlas2.prototype.addTexture = function(name, texture) {
      var pages = this.pages;
      var page = null;
      for (var i2 = 0; i2 < pages.length; i2++) {
        if (pages[i2].baseTexture === texture.baseTexture) {
          page = pages[i2];
          break;
        }
      }
      if (page === null) {
        page = new TextureAtlasPage();
        page.name = "texturePage";
        var baseTexture = texture.baseTexture;
        page.width = baseTexture.realWidth;
        page.height = baseTexture.realHeight;
        page.baseTexture = baseTexture;
        page.minFilter = page.magFilter = TextureFilter.Nearest;
        page.uWrap = TextureWrap.ClampToEdge;
        page.vWrap = TextureWrap.ClampToEdge;
        pages.push(page);
      }
      var region = new TextureAtlasRegion();
      region.name = name;
      region.page = page;
      region.texture = texture;
      region.index = -1;
      this.regions.push(region);
      return region;
    };
    TextureAtlas2.prototype.addTextureHash = function(textures, stripExtension) {
      for (var key in textures) {
        if (textures.hasOwnProperty(key)) {
          this.addTexture(stripExtension && key.indexOf(".") !== -1 ? key.substr(0, key.lastIndexOf(".")) : key, textures[key]);
        }
      }
    };
    TextureAtlas2.prototype.addSpineAtlas = function(atlasText, textureLoader, callback) {
      return this.load(atlasText, textureLoader, callback);
    };
    TextureAtlas2.prototype.load = function(atlasText, textureLoader, callback) {
      var _this = this;
      if (textureLoader == null)
        throw new Error("textureLoader cannot be null.");
      var reader = new TextureAtlasReader(atlasText);
      var entry = new Array(4);
      var page = null;
      var pageFields = {};
      var region = null;
      pageFields["size"] = function() {
        page.width = parseInt(entry[1]);
        page.height = parseInt(entry[2]);
      };
      pageFields["format"] = function() {
      };
      pageFields["filter"] = function() {
        page.minFilter = filterFromString(entry[1]);
        page.magFilter = filterFromString(entry[2]);
      };
      pageFields["repeat"] = function() {
        if (entry[1].indexOf("x") != -1)
          page.uWrap = TextureWrap.Repeat;
        if (entry[1].indexOf("y") != -1)
          page.vWrap = TextureWrap.Repeat;
      };
      pageFields["pma"] = function() {
        page.pma = entry[1] == "true";
      };
      var regionFields = {};
      regionFields["xy"] = function() {
        region.x = parseInt(entry[1]);
        region.y = parseInt(entry[2]);
      };
      regionFields["size"] = function() {
        region.width = parseInt(entry[1]);
        region.height = parseInt(entry[2]);
      };
      regionFields["bounds"] = function() {
        region.x = parseInt(entry[1]);
        region.y = parseInt(entry[2]);
        region.width = parseInt(entry[3]);
        region.height = parseInt(entry[4]);
      };
      regionFields["offset"] = function() {
        region.offsetX = parseInt(entry[1]);
        region.offsetY = parseInt(entry[2]);
      };
      regionFields["orig"] = function() {
        region.originalWidth = parseInt(entry[1]);
        region.originalHeight = parseInt(entry[2]);
      };
      regionFields["offsets"] = function() {
        region.offsetX = parseInt(entry[1]);
        region.offsetY = parseInt(entry[2]);
        region.originalWidth = parseInt(entry[3]);
        region.originalHeight = parseInt(entry[4]);
      };
      regionFields["rotate"] = function() {
        var rotateValue = entry[1];
        var rotate = 0;
        if (rotateValue.toLocaleLowerCase() == "true") {
          rotate = 6;
        } else if (rotateValue.toLocaleLowerCase() == "false") {
          rotate = 0;
        } else {
          rotate = (720 - parseFloat(rotateValue)) % 360 / 45;
        }
        region.rotate = rotate;
      };
      regionFields["index"] = function() {
        region.index = parseInt(entry[1]);
      };
      var line2 = reader.readLine();
      while (line2 != null && line2.trim().length == 0)
        line2 = reader.readLine();
      while (true) {
        if (line2 == null || line2.trim().length == 0)
          break;
        if (reader.readEntry(entry, line2) == 0)
          break;
        line2 = reader.readLine();
      }
      var iterateParser = function() {
        while (true) {
          if (line2 == null) {
            return callback && callback(_this);
          }
          if (line2.trim().length == 0) {
            page = null;
            line2 = reader.readLine();
          } else if (page === null) {
            page = new TextureAtlasPage();
            page.name = line2.trim();
            while (true) {
              if (reader.readEntry(entry, line2 = reader.readLine()) == 0)
                break;
              var field = pageFields[entry[0]];
              if (field)
                field();
            }
            _this.pages.push(page);
            textureLoader(page.name, function(texture) {
              if (texture === null) {
                _this.pages.splice(_this.pages.indexOf(page), 1);
                return callback && callback(null);
              }
              page.baseTexture = texture;
              if (page.pma) {
                texture.alphaMode = ALPHA_MODES$4.PMA;
              }
              if (!texture.valid) {
                texture.setSize(page.width, page.height);
              }
              page.setFilters();
              if (!page.width || !page.height) {
                page.width = texture.realWidth;
                page.height = texture.realHeight;
                if (!page.width || !page.height) {
                  console.log("ERROR spine atlas page " + page.name + ": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)");
                }
              }
              iterateParser();
            });
            break;
          } else {
            region = new RegionFields();
            var atlasRegion = new TextureAtlasRegion();
            atlasRegion.name = line2;
            atlasRegion.page = page;
            var names = null;
            var values = null;
            while (true) {
              var count = reader.readEntry(entry, line2 = reader.readLine());
              if (count == 0)
                break;
              var field = regionFields[entry[0]];
              if (field)
                field();
              else {
                if (names == null) {
                  names = [];
                  values = [];
                }
                names.push(entry[0]);
                var entryValues = [];
                for (var i2 = 0; i2 < count; i2++)
                  entryValues.push(parseInt(entry[i2 + 1]));
                values.push(entryValues);
              }
            }
            if (region.originalWidth == 0 && region.originalHeight == 0) {
              region.originalWidth = region.width;
              region.originalHeight = region.height;
            }
            var resolution = page.baseTexture.resolution;
            region.x /= resolution;
            region.y /= resolution;
            region.width /= resolution;
            region.height /= resolution;
            region.originalWidth /= resolution;
            region.originalHeight /= resolution;
            region.offsetX /= resolution;
            region.offsetY /= resolution;
            var swapWH = region.rotate % 4 !== 0;
            var frame2 = new Rectangle(region.x, region.y, swapWH ? region.height : region.width, swapWH ? region.width : region.height);
            var orig = new Rectangle(0, 0, region.originalWidth, region.originalHeight);
            var trim2 = new Rectangle(region.offsetX, region.originalHeight - region.height - region.offsetY, region.width, region.height);
            atlasRegion.texture = new Texture(atlasRegion.page.baseTexture, frame2, orig, trim2, region.rotate);
            atlasRegion.index = region.index;
            atlasRegion.texture.updateUvs();
            _this.regions.push(atlasRegion);
          }
        }
      };
      iterateParser();
    };
    TextureAtlas2.prototype.findRegion = function(name) {
      for (var i2 = 0; i2 < this.regions.length; i2++) {
        if (this.regions[i2].name == name) {
          return this.regions[i2];
        }
      }
      return null;
    };
    TextureAtlas2.prototype.dispose = function() {
      for (var i2 = 0; i2 < this.pages.length; i2++) {
        this.pages[i2].baseTexture.dispose();
      }
    };
    return TextureAtlas2;
  }()
);
var TextureAtlasReader = (
  /** @class */
  function() {
    function TextureAtlasReader2(text2) {
      this.index = 0;
      this.lines = text2.split(/\r\n|\r|\n/);
    }
    TextureAtlasReader2.prototype.readLine = function() {
      if (this.index >= this.lines.length)
        return null;
      return this.lines[this.index++];
    };
    TextureAtlasReader2.prototype.readEntry = function(entry, line2) {
      if (line2 == null)
        return 0;
      line2 = line2.trim();
      if (line2.length == 0)
        return 0;
      var colon = line2.indexOf(":");
      if (colon == -1)
        return 0;
      entry[0] = line2.substr(0, colon).trim();
      for (var i2 = 1, lastMatch = colon + 1; ; i2++) {
        var comma = line2.indexOf(",", lastMatch);
        if (comma == -1) {
          entry[i2] = line2.substr(lastMatch).trim();
          return i2;
        }
        entry[i2] = line2.substr(lastMatch, comma - lastMatch).trim();
        lastMatch = comma + 1;
        if (i2 == 4)
          return 4;
      }
    };
    return TextureAtlasReader2;
  }()
);
var TextureAtlasPage = (
  /** @class */
  function() {
    function TextureAtlasPage2() {
      this.minFilter = TextureFilter.Nearest;
      this.magFilter = TextureFilter.Nearest;
      this.uWrap = TextureWrap.ClampToEdge;
      this.vWrap = TextureWrap.ClampToEdge;
    }
    TextureAtlasPage2.prototype.setFilters = function() {
      var tex = this.baseTexture;
      var filter2 = this.minFilter;
      if (filter2 == TextureFilter.Linear) {
        tex.scaleMode = SCALE_MODES$4.LINEAR;
      } else if (this.minFilter == TextureFilter.Nearest) {
        tex.scaleMode = SCALE_MODES$4.NEAREST;
      } else {
        tex.mipmap = MIPMAP_MODES$4.POW2;
        if (filter2 == TextureFilter.MipMapNearestNearest) {
          tex.scaleMode = SCALE_MODES$4.NEAREST;
        } else {
          tex.scaleMode = SCALE_MODES$4.LINEAR;
        }
      }
    };
    return TextureAtlasPage2;
  }()
);
var TextureAtlasRegion = (
  /** @class */
  function(_super) {
    __extends$5(TextureAtlasRegion2, _super);
    function TextureAtlasRegion2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return TextureAtlasRegion2;
  }(TextureRegion)
);
var fround_polyfill = function(array) {
  return function(x) {
    return array[0] = x, array[0];
  };
}(new Float32Array(1));
var fround = Math.fround || fround_polyfill;
var IntSet = (
  /** @class */
  function() {
    function IntSet2() {
      this.array = new Array();
    }
    IntSet2.prototype.add = function(value) {
      var contains = this.contains(value);
      this.array[value | 0] = value | 0;
      return !contains;
    };
    IntSet2.prototype.contains = function(value) {
      return this.array[value | 0] != void 0;
    };
    IntSet2.prototype.remove = function(value) {
      this.array[value | 0] = void 0;
    };
    IntSet2.prototype.clear = function() {
      this.array.length = 0;
    };
    return IntSet2;
  }()
);
var StringSet = (
  /** @class */
  function() {
    function StringSet2() {
      this.entries = {};
      this.size = 0;
    }
    StringSet2.prototype.add = function(value) {
      var contains = this.entries[value];
      this.entries[value] = true;
      if (!contains) {
        this.size++;
        return true;
      }
      return false;
    };
    StringSet2.prototype.addAll = function(values) {
      var oldSize = this.size;
      for (var i2 = 0, n2 = values.length; i2 < n2; i2++)
        this.add(values[i2]);
      return oldSize != this.size;
    };
    StringSet2.prototype.contains = function(value) {
      return this.entries[value];
    };
    StringSet2.prototype.clear = function() {
      this.entries = {};
      this.size = 0;
    };
    return StringSet2;
  }()
);
var Color = (
  /** @class */
  function() {
    function Color2(r2, g2, b2, a2) {
      if (r2 === void 0) {
        r2 = 0;
      }
      if (g2 === void 0) {
        g2 = 0;
      }
      if (b2 === void 0) {
        b2 = 0;
      }
      if (a2 === void 0) {
        a2 = 0;
      }
      this.r = r2;
      this.g = g2;
      this.b = b2;
      this.a = a2;
    }
    Color2.prototype.set = function(r2, g2, b2, a2) {
      this.r = r2;
      this.g = g2;
      this.b = b2;
      this.a = a2;
      return this.clamp();
    };
    Color2.prototype.setFromColor = function(c2) {
      this.r = c2.r;
      this.g = c2.g;
      this.b = c2.b;
      this.a = c2.a;
      return this;
    };
    Color2.prototype.setFromString = function(hex2) {
      hex2 = hex2.charAt(0) == "#" ? hex2.substr(1) : hex2;
      this.r = parseInt(hex2.substr(0, 2), 16) / 255;
      this.g = parseInt(hex2.substr(2, 2), 16) / 255;
      this.b = parseInt(hex2.substr(4, 2), 16) / 255;
      this.a = hex2.length != 8 ? 1 : parseInt(hex2.substr(6, 2), 16) / 255;
      return this;
    };
    Color2.prototype.add = function(r2, g2, b2, a2) {
      this.r += r2;
      this.g += g2;
      this.b += b2;
      this.a += a2;
      return this.clamp();
    };
    Color2.prototype.clamp = function() {
      if (this.r < 0)
        this.r = 0;
      else if (this.r > 1)
        this.r = 1;
      if (this.g < 0)
        this.g = 0;
      else if (this.g > 1)
        this.g = 1;
      if (this.b < 0)
        this.b = 0;
      else if (this.b > 1)
        this.b = 1;
      if (this.a < 0)
        this.a = 0;
      else if (this.a > 1)
        this.a = 1;
      return this;
    };
    Color2.rgba8888ToColor = function(color2, value) {
      color2.r = ((value & 4278190080) >>> 24) / 255;
      color2.g = ((value & 16711680) >>> 16) / 255;
      color2.b = ((value & 65280) >>> 8) / 255;
      color2.a = (value & 255) / 255;
    };
    Color2.rgb888ToColor = function(color2, value) {
      color2.r = ((value & 16711680) >>> 16) / 255;
      color2.g = ((value & 65280) >>> 8) / 255;
      color2.b = (value & 255) / 255;
    };
    Color2.fromString = function(hex2) {
      return new Color2().setFromString(hex2);
    };
    Color2.WHITE = new Color2(1, 1, 1, 1);
    Color2.RED = new Color2(1, 0, 0, 1);
    Color2.GREEN = new Color2(0, 1, 0, 1);
    Color2.BLUE = new Color2(0, 0, 1, 1);
    Color2.MAGENTA = new Color2(1, 0, 1, 1);
    return Color2;
  }()
);
var MathUtils = (
  /** @class */
  function() {
    function MathUtils2() {
    }
    MathUtils2.clamp = function(value, min, max2) {
      if (value < min)
        return min;
      if (value > max2)
        return max2;
      return value;
    };
    MathUtils2.cosDeg = function(degrees) {
      return Math.cos(degrees * MathUtils2.degRad);
    };
    MathUtils2.sinDeg = function(degrees) {
      return Math.sin(degrees * MathUtils2.degRad);
    };
    MathUtils2.signum = function(value) {
      return value > 0 ? 1 : value < 0 ? -1 : 0;
    };
    MathUtils2.toInt = function(x) {
      return x > 0 ? Math.floor(x) : Math.ceil(x);
    };
    MathUtils2.cbrt = function(x) {
      var y2 = Math.pow(Math.abs(x), 1 / 3);
      return x < 0 ? -y2 : y2;
    };
    MathUtils2.randomTriangular = function(min, max2) {
      return MathUtils2.randomTriangularWith(min, max2, (min + max2) * 0.5);
    };
    MathUtils2.randomTriangularWith = function(min, max2, mode) {
      var u2 = Math.random();
      var d2 = max2 - min;
      if (u2 <= (mode - min) / d2)
        return min + Math.sqrt(u2 * d2 * (mode - min));
      return max2 - Math.sqrt((1 - u2) * d2 * (max2 - mode));
    };
    MathUtils2.isPowerOfTwo = function(value) {
      return value && (value & value - 1) === 0;
    };
    MathUtils2.PI = 3.1415927;
    MathUtils2.PI2 = MathUtils2.PI * 2;
    MathUtils2.radiansToDegrees = 180 / MathUtils2.PI;
    MathUtils2.radDeg = MathUtils2.radiansToDegrees;
    MathUtils2.degreesToRadians = MathUtils2.PI / 180;
    MathUtils2.degRad = MathUtils2.degreesToRadians;
    return MathUtils2;
  }()
);
var Interpolation = (
  /** @class */
  function() {
    function Interpolation2() {
    }
    Interpolation2.prototype.apply = function(start, end2, a2) {
      return start + (end2 - start) * this.applyInternal(a2);
    };
    return Interpolation2;
  }()
);
var Pow = (
  /** @class */
  function(_super) {
    __extends$5(Pow2, _super);
    function Pow2(power) {
      var _this = _super.call(this) || this;
      _this.power = 2;
      _this.power = power;
      return _this;
    }
    Pow2.prototype.applyInternal = function(a2) {
      if (a2 <= 0.5)
        return Math.pow(a2 * 2, this.power) / 2;
      return Math.pow((a2 - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;
    };
    return Pow2;
  }(Interpolation)
);
var PowOut = (
  /** @class */
  function(_super) {
    __extends$5(PowOut2, _super);
    function PowOut2(power) {
      return _super.call(this, power) || this;
    }
    PowOut2.prototype.applyInternal = function(a2) {
      return Math.pow(a2 - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;
    };
    return PowOut2;
  }(Pow)
);
var Utils = (
  /** @class */
  function() {
    function Utils2() {
    }
    Utils2.arrayCopy = function(source, sourceStart, dest, destStart, numElements) {
      for (var i2 = sourceStart, j2 = destStart; i2 < sourceStart + numElements; i2++, j2++) {
        dest[j2] = source[i2];
      }
    };
    Utils2.arrayFill = function(array, fromIndex, toIndex, value) {
      for (var i2 = fromIndex; i2 < toIndex; i2++)
        array[i2] = value;
    };
    Utils2.setArraySize = function(array, size, value) {
      if (value === void 0) {
        value = 0;
      }
      var oldSize = array.length;
      if (oldSize == size)
        return array;
      array.length = size;
      if (oldSize < size) {
        for (var i2 = oldSize; i2 < size; i2++)
          array[i2] = value;
      }
      return array;
    };
    Utils2.ensureArrayCapacity = function(array, size, value) {
      if (value === void 0) {
        value = 0;
      }
      if (array.length >= size)
        return array;
      return Utils2.setArraySize(array, size, value);
    };
    Utils2.newArray = function(size, defaultValue2) {
      var array = new Array(size);
      for (var i2 = 0; i2 < size; i2++)
        array[i2] = defaultValue2;
      return array;
    };
    Utils2.newFloatArray = function(size) {
      if (Utils2.SUPPORTS_TYPED_ARRAYS)
        return new Float32Array(size);
      else {
        var array = new Array(size);
        for (var i2 = 0; i2 < array.length; i2++)
          array[i2] = 0;
        return array;
      }
    };
    Utils2.newShortArray = function(size) {
      if (Utils2.SUPPORTS_TYPED_ARRAYS)
        return new Int16Array(size);
      else {
        var array = new Array(size);
        for (var i2 = 0; i2 < array.length; i2++)
          array[i2] = 0;
        return array;
      }
    };
    Utils2.toFloatArray = function(array) {
      return Utils2.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;
    };
    Utils2.toSinglePrecision = function(value) {
      return Utils2.SUPPORTS_TYPED_ARRAYS ? fround(value) : value;
    };
    Utils2.webkit602BugfixHelper = function(alpha2, blend) {
    };
    Utils2.contains = function(array, element, identity2) {
      for (var i2 = 0; i2 < array.length; i2++)
        if (array[i2] == element)
          return true;
      return false;
    };
    Utils2.enumValue = function(type2, name) {
      return type2[name[0].toUpperCase() + name.slice(1)];
    };
    Utils2.SUPPORTS_TYPED_ARRAYS = typeof Float32Array !== "undefined";
    return Utils2;
  }()
);
var Pool = (
  /** @class */
  function() {
    function Pool2(instantiator) {
      this.items = new Array();
      this.instantiator = instantiator;
    }
    Pool2.prototype.obtain = function() {
      return this.items.length > 0 ? this.items.pop() : this.instantiator();
    };
    Pool2.prototype.free = function(item) {
      if (item.reset)
        item.reset();
      this.items.push(item);
    };
    Pool2.prototype.freeAll = function(items) {
      for (var i2 = 0; i2 < items.length; i2++)
        this.free(items[i2]);
    };
    Pool2.prototype.clear = function() {
      this.items.length = 0;
    };
    return Pool2;
  }()
);
var Vector2 = (
  /** @class */
  function() {
    function Vector22(x, y2) {
      if (x === void 0) {
        x = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      this.x = x;
      this.y = y2;
    }
    Vector22.prototype.set = function(x, y2) {
      this.x = x;
      this.y = y2;
      return this;
    };
    Vector22.prototype.length = function() {
      var x = this.x;
      var y2 = this.y;
      return Math.sqrt(x * x + y2 * y2);
    };
    Vector22.prototype.normalize = function() {
      var len = this.length();
      if (len != 0) {
        this.x /= len;
        this.y /= len;
      }
      return this;
    };
    return Vector22;
  }()
);
var SkeletonBoundsBase = (
  /** @class */
  function() {
    function SkeletonBoundsBase2() {
      this.minX = 0;
      this.minY = 0;
      this.maxX = 0;
      this.maxY = 0;
      this.boundingBoxes = new Array();
      this.polygons = new Array();
      this.polygonPool = new Pool(function() {
        return Utils.newFloatArray(16);
      });
    }
    SkeletonBoundsBase2.prototype.update = function(skeleton, updateAabb) {
      if (!skeleton)
        throw new Error("skeleton cannot be null.");
      var boundingBoxes = this.boundingBoxes;
      var polygons = this.polygons;
      var polygonPool = this.polygonPool;
      var slots = skeleton.slots;
      var slotCount = slots.length;
      boundingBoxes.length = 0;
      polygonPool.freeAll(polygons);
      polygons.length = 0;
      for (var i2 = 0; i2 < slotCount; i2++) {
        var slot = slots[i2];
        if (!slot.bone.active)
          continue;
        var attachment = slot.getAttachment();
        if (attachment != null && attachment.type === AttachmentType.BoundingBox) {
          var boundingBox = attachment;
          boundingBoxes.push(boundingBox);
          var polygon = polygonPool.obtain();
          if (polygon.length != boundingBox.worldVerticesLength) {
            polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);
          }
          polygons.push(polygon);
          boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);
        }
      }
      if (updateAabb) {
        this.aabbCompute();
      } else {
        this.minX = Number.POSITIVE_INFINITY;
        this.minY = Number.POSITIVE_INFINITY;
        this.maxX = Number.NEGATIVE_INFINITY;
        this.maxY = Number.NEGATIVE_INFINITY;
      }
    };
    SkeletonBoundsBase2.prototype.aabbCompute = function() {
      var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
      var polygons = this.polygons;
      for (var i2 = 0, n2 = polygons.length; i2 < n2; i2++) {
        var polygon = polygons[i2];
        var vertices = polygon;
        for (var ii2 = 0, nn2 = polygon.length; ii2 < nn2; ii2 += 2) {
          var x = vertices[ii2];
          var y2 = vertices[ii2 + 1];
          minX = Math.min(minX, x);
          minY = Math.min(minY, y2);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y2);
        }
      }
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    };
    SkeletonBoundsBase2.prototype.aabbContainsPoint = function(x, y2) {
      return x >= this.minX && x <= this.maxX && y2 >= this.minY && y2 <= this.maxY;
    };
    SkeletonBoundsBase2.prototype.aabbIntersectsSegment = function(x1, y1, x2, y2) {
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY)
        return false;
      var m2 = (y2 - y1) / (x2 - x1);
      var y3 = m2 * (minX - x1) + y1;
      if (y3 > minY && y3 < maxY)
        return true;
      y3 = m2 * (maxX - x1) + y1;
      if (y3 > minY && y3 < maxY)
        return true;
      var x = (minY - y1) / m2 + x1;
      if (x > minX && x < maxX)
        return true;
      x = (maxY - y1) / m2 + x1;
      if (x > minX && x < maxX)
        return true;
      return false;
    };
    SkeletonBoundsBase2.prototype.aabbIntersectsSkeleton = function(bounds) {
      return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
    };
    SkeletonBoundsBase2.prototype.containsPoint = function(x, y2) {
      var polygons = this.polygons;
      for (var i2 = 0, n2 = polygons.length; i2 < n2; i2++)
        if (this.containsPointPolygon(polygons[i2], x, y2))
          return this.boundingBoxes[i2];
      return null;
    };
    SkeletonBoundsBase2.prototype.containsPointPolygon = function(polygon, x, y2) {
      var vertices = polygon;
      var nn2 = polygon.length;
      var prevIndex = nn2 - 2;
      var inside = false;
      for (var ii2 = 0; ii2 < nn2; ii2 += 2) {
        var vertexY = vertices[ii2 + 1];
        var prevY = vertices[prevIndex + 1];
        if (vertexY < y2 && prevY >= y2 || prevY < y2 && vertexY >= y2) {
          var vertexX = vertices[ii2];
          if (vertexX + (y2 - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x)
            inside = !inside;
        }
        prevIndex = ii2;
      }
      return inside;
    };
    SkeletonBoundsBase2.prototype.intersectsSegment = function(x1, y1, x2, y2) {
      var polygons = this.polygons;
      for (var i2 = 0, n2 = polygons.length; i2 < n2; i2++)
        if (this.intersectsSegmentPolygon(polygons[i2], x1, y1, x2, y2))
          return this.boundingBoxes[i2];
      return null;
    };
    SkeletonBoundsBase2.prototype.intersectsSegmentPolygon = function(polygon, x1, y1, x2, y2) {
      var vertices = polygon;
      var nn2 = polygon.length;
      var width12 = x1 - x2, height12 = y1 - y2;
      var det1 = x1 * y2 - y1 * x2;
      var x3 = vertices[nn2 - 2], y3 = vertices[nn2 - 1];
      for (var ii2 = 0; ii2 < nn2; ii2 += 2) {
        var x4 = vertices[ii2], y4 = vertices[ii2 + 1];
        var det2 = x3 * y4 - y3 * x4;
        var width34 = x3 - x4, height34 = y3 - y4;
        var det3 = width12 * height34 - height12 * width34;
        var x = (det1 * width34 - width12 * det2) / det3;
        if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {
          var y5 = (det1 * height34 - height12 * det2) / det3;
          if ((y5 >= y3 && y5 <= y4 || y5 >= y4 && y5 <= y3) && (y5 >= y1 && y5 <= y2 || y5 >= y2 && y5 <= y1))
            return true;
        }
        x3 = x4;
        y3 = y4;
      }
      return false;
    };
    SkeletonBoundsBase2.prototype.getPolygon = function(boundingBox) {
      if (!boundingBox)
        throw new Error("boundingBox cannot be null.");
      var index2 = this.boundingBoxes.indexOf(boundingBox);
      return index2 == -1 ? null : this.polygons[index2];
    };
    SkeletonBoundsBase2.prototype.getWidth = function() {
      return this.maxX - this.minX;
    };
    SkeletonBoundsBase2.prototype.getHeight = function() {
      return this.maxY - this.minY;
    };
    return SkeletonBoundsBase2;
  }()
);
var settings = {
  yDown: true,
  /**
   * pixi-spine gives option to not fail at certain parsing errors
   * spine-ts fails here
   */
  FAIL_ON_NON_EXISTING_SKIN: false,
  /**
   * past Spine.globalAutoUpdate
   */
  GLOBAL_AUTO_UPDATE: true,
  /**
   * past Spine.globalDelayLimit
   */
  GLOBAL_DELAY_LIMIT: 0
};
var tempRgb = [0, 0, 0];
var SpineSprite = (
  /** @class */
  function(_super) {
    __extends$5(SpineSprite2, _super);
    function SpineSprite2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.region = null;
      _this.attachment = null;
      return _this;
    }
    return SpineSprite2;
  }(Sprite)
);
var SpineMesh = (
  /** @class */
  function(_super) {
    __extends$5(SpineMesh2, _super);
    function SpineMesh2(texture, vertices, uvs, indices3, drawMode) {
      var _this = _super.call(this, texture, vertices, uvs, indices3, drawMode) || this;
      _this.region = null;
      _this.attachment = null;
      return _this;
    }
    return SpineMesh2;
  }(SimpleMesh)
);
var SpineBase = (
  /** @class */
  function(_super) {
    __extends$5(SpineBase2, _super);
    function SpineBase2(spineData) {
      var _this = _super.call(this) || this;
      if (!spineData) {
        throw new Error("The spineData param is required.");
      }
      if (typeof spineData === "string") {
        throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');
      }
      _this.spineData = spineData;
      _this.createSkeleton(spineData);
      _this.slotContainers = [];
      _this.tempClipContainers = [];
      for (var i2 = 0, n2 = _this.skeleton.slots.length; i2 < n2; i2++) {
        var slot = _this.skeleton.slots[i2];
        var attachment = slot.getAttachment();
        var slotContainer = _this.newContainer();
        _this.slotContainers.push(slotContainer);
        _this.addChild(slotContainer);
        _this.tempClipContainers.push(null);
        if (!attachment) {
          continue;
        }
        if (attachment.type === AttachmentType.Region) {
          var spriteName = attachment.name;
          var sprite = _this.createSprite(slot, attachment, spriteName);
          slot.currentSprite = sprite;
          slot.currentSpriteName = spriteName;
          slotContainer.addChild(sprite);
        } else if (attachment.type === AttachmentType.Mesh) {
          var mesh = _this.createMesh(slot, attachment);
          slot.currentMesh = mesh;
          slot.currentMeshId = attachment.id;
          slot.currentMeshName = attachment.name;
          slotContainer.addChild(mesh);
        } else if (attachment.type === AttachmentType.Clipping) {
          _this.createGraphics(slot, attachment);
          slotContainer.addChild(slot.clippingContainer);
          slotContainer.addChild(slot.currentGraphics);
        }
      }
      _this.tintRgb = new Float32Array([1, 1, 1]);
      _this.autoUpdate = true;
      _this.visible = true;
      return _this;
    }
    Object.defineProperty(SpineBase2.prototype, "debug", {
      get: function() {
        return this._debug;
      },
      set: function(value) {
        var _a2;
        if (value == this._debug) {
          return;
        }
        (_a2 = this._debug) === null || _a2 === void 0 ? void 0 : _a2.unregisterSpine(this);
        value === null || value === void 0 ? void 0 : value.registerSpine(this);
        this._debug = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SpineBase2.prototype, "autoUpdate", {
      /**
       * If this flag is set to true, the spine animation will be automatically updated every
       * time the object id drawn. The down side of this approach is that the delta time is
       * automatically calculated and you could miss out on cool effects like slow motion,
       * pause, skip ahead and the sorts. Most of these effects can be achieved even with
       * autoUpdate enabled but are harder to achieve.
       *
       * @member {boolean}
       * @memberof spine.Spine#
       * @default true
       */
      get: function() {
        return this._autoUpdate;
      },
      set: function(value) {
        if (value !== this._autoUpdate) {
          this._autoUpdate = value;
          this.updateTransform = value ? SpineBase2.prototype.autoUpdateTransform : Container$1.prototype.updateTransform;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SpineBase2.prototype, "tint", {
      /**
       * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
       *
       * @member {number}
       * @memberof spine.Spine#
       * @default 0xFFFFFF
       */
      get: function() {
        return rgb2hex(this.tintRgb);
      },
      set: function(value) {
        this.tintRgb = hex2rgb(value, this.tintRgb);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SpineBase2.prototype, "delayLimit", {
      /**
       * Limit value for the update dt with Spine.globalDelayLimit
       * that can be overridden with localDelayLimit
       * @return {number} - Maximum processed dt value for the update
       */
      get: function() {
        var limit = typeof this.localDelayLimit !== "undefined" ? this.localDelayLimit : settings.GLOBAL_DELAY_LIMIT;
        return limit || Number.MAX_VALUE;
      },
      enumerable: false,
      configurable: true
    });
    SpineBase2.prototype.update = function(dt) {
      var _a2;
      var delayLimit = this.delayLimit;
      if (dt > delayLimit)
        dt = delayLimit;
      this.state.update(dt);
      this.state.apply(this.skeleton);
      if (!this.skeleton)
        return;
      this.skeleton.updateWorldTransform();
      var slots = this.skeleton.slots;
      var globalClr = this.color;
      var light = null, dark = null;
      if (globalClr) {
        light = globalClr.light;
        dark = globalClr.dark;
      } else {
        light = this.tintRgb;
      }
      for (var i2 = 0, n2 = slots.length; i2 < n2; i2++) {
        var slot = slots[i2];
        var attachment = slot.getAttachment();
        var slotContainer = this.slotContainers[i2];
        if (!attachment) {
          slotContainer.visible = false;
          continue;
        }
        var spriteColor = null;
        if (attachment.sequence) {
          attachment.sequence.apply(slot, attachment);
        }
        var region = attachment.region;
        var attColor = attachment.color;
        switch (attachment != null && attachment.type) {
          case AttachmentType.Region:
            var transform = slotContainer.transform;
            transform.setFromMatrix(slot.bone.matrix);
            region = attachment.region;
            if (slot.currentMesh) {
              slot.currentMesh.visible = false;
              slot.currentMesh = null;
              slot.currentMeshId = void 0;
              slot.currentMeshName = void 0;
            }
            if (!region) {
              if (slot.currentSprite) {
                slot.currentSprite.renderable = false;
              }
              break;
            }
            if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.name) {
              var spriteName = attachment.name;
              if (slot.currentSprite) {
                slot.currentSprite.visible = false;
              }
              slot.sprites = slot.sprites || {};
              if (slot.sprites[spriteName] !== void 0) {
                slot.sprites[spriteName].visible = true;
              } else {
                var sprite = this.createSprite(slot, attachment, spriteName);
                slotContainer.addChild(sprite);
              }
              slot.currentSprite = slot.sprites[spriteName];
              slot.currentSpriteName = spriteName;
            }
            slot.currentSprite.renderable = true;
            if (!slot.hackRegion) {
              this.setSpriteRegion(attachment, slot.currentSprite, region);
            }
            if (slot.currentSprite.color) {
              spriteColor = slot.currentSprite.color;
            } else {
              tempRgb[0] = light[0] * slot.color.r * attColor.r;
              tempRgb[1] = light[1] * slot.color.g * attColor.g;
              tempRgb[2] = light[2] * slot.color.b * attColor.b;
              slot.currentSprite.tint = rgb2hex(tempRgb);
            }
            slot.currentSprite.blendMode = slot.blendMode;
            break;
          case AttachmentType.Mesh:
            if (slot.currentSprite) {
              slot.currentSprite.visible = false;
              slot.currentSprite = null;
              slot.currentSpriteName = void 0;
              var transform_1 = new Transform();
              transform_1._parentID = -1;
              transform_1._worldID = slotContainer.transform._worldID;
              slotContainer.transform = transform_1;
            }
            if (!region) {
              if (slot.currentMesh) {
                slot.currentMesh.renderable = false;
              }
              break;
            }
            var id2 = attachment.id;
            if (slot.currentMeshId === void 0 || slot.currentMeshId !== id2) {
              var meshId = id2;
              if (slot.currentMesh) {
                slot.currentMesh.visible = false;
              }
              slot.meshes = slot.meshes || {};
              if (slot.meshes[meshId] !== void 0) {
                slot.meshes[meshId].visible = true;
              } else {
                var mesh = this.createMesh(slot, attachment);
                slotContainer.addChild(mesh);
              }
              slot.currentMesh = slot.meshes[meshId];
              slot.currentMeshName = attachment.name;
              slot.currentMeshId = meshId;
            }
            slot.currentMesh.renderable = true;
            attachment.computeWorldVerticesOld(slot, slot.currentMesh.vertices);
            if (slot.currentMesh.color) {
              spriteColor = slot.currentMesh.color;
            } else {
              tempRgb[0] = light[0] * slot.color.r * attColor.r;
              tempRgb[1] = light[1] * slot.color.g * attColor.g;
              tempRgb[2] = light[2] * slot.color.b * attColor.b;
              slot.currentMesh.tint = rgb2hex(tempRgb);
            }
            slot.currentMesh.blendMode = slot.blendMode;
            if (!slot.hackRegion) {
              this.setMeshRegion(attachment, slot.currentMesh, region);
            }
            break;
          case AttachmentType.Clipping:
            if (!slot.currentGraphics) {
              this.createGraphics(slot, attachment);
              slotContainer.addChild(slot.clippingContainer);
              slotContainer.addChild(slot.currentGraphics);
            }
            this.updateGraphics(slot, attachment);
            slotContainer.alpha = 1;
            slotContainer.visible = true;
            continue;
          default:
            slotContainer.visible = false;
            continue;
        }
        slotContainer.visible = true;
        if (spriteColor) {
          var r0 = slot.color.r * attColor.r;
          var g0 = slot.color.g * attColor.g;
          var b0 = slot.color.b * attColor.b;
          spriteColor.setLight(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));
          if (slot.darkColor) {
            r0 = slot.darkColor.r;
            g0 = slot.darkColor.g;
            b0 = slot.darkColor.b;
          } else {
            r0 = 0;
            g0 = 0;
            b0 = 0;
          }
          spriteColor.setDark(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));
        }
        slotContainer.alpha = slot.color.a;
      }
      var drawOrder = this.skeleton.drawOrder;
      var clippingAttachment = null;
      var clippingContainer = null;
      for (var i2 = 0, n2 = drawOrder.length; i2 < n2; i2++) {
        var slot = slots[drawOrder[i2].data.index];
        var slotContainer = this.slotContainers[drawOrder[i2].data.index];
        if (!clippingContainer) {
          if (slotContainer.parent !== null && slotContainer.parent !== this) {
            slotContainer.parent.removeChild(slotContainer);
            slotContainer.parent = this;
          }
        }
        if (slot.currentGraphics && slot.getAttachment()) {
          clippingContainer = slot.clippingContainer;
          clippingAttachment = slot.getAttachment();
          clippingContainer.children.length = 0;
          this.children[i2] = slotContainer;
          if (clippingAttachment.endSlot === slot.data) {
            clippingAttachment.endSlot = null;
          }
        } else {
          if (clippingContainer) {
            var c2 = this.tempClipContainers[i2];
            if (!c2) {
              c2 = this.tempClipContainers[i2] = this.newContainer();
              c2.visible = false;
            }
            this.children[i2] = c2;
            slotContainer.parent = null;
            clippingContainer.addChild(slotContainer);
            if (clippingAttachment.endSlot == slot.data) {
              clippingContainer.renderable = true;
              clippingContainer = null;
              clippingAttachment = null;
            }
          } else {
            this.children[i2] = slotContainer;
          }
        }
      }
      (_a2 = this._debug) === null || _a2 === void 0 ? void 0 : _a2.renderDebug(this);
    };
    SpineBase2.prototype.setSpriteRegion = function(attachment, sprite, region) {
      if (sprite.attachment === attachment && sprite.region === region) {
        return;
      }
      sprite.region = region;
      sprite.attachment = attachment;
      sprite.texture = region.texture;
      sprite.rotation = attachment.rotation * MathUtils.degRad;
      sprite.position.x = attachment.x;
      sprite.position.y = attachment.y;
      sprite.alpha = attachment.color.a;
      if (!region.size) {
        sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;
        sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;
      } else {
        sprite.scale.x = region.size.width / region.originalWidth;
        sprite.scale.y = -region.size.height / region.originalHeight;
      }
    };
    SpineBase2.prototype.setMeshRegion = function(attachment, mesh, region) {
      if (mesh.attachment === attachment && mesh.region === region) {
        return;
      }
      mesh.region = region;
      mesh.attachment = attachment;
      mesh.texture = region.texture;
      region.texture.updateUvs();
      mesh.uvBuffer.update(attachment.regionUVs);
    };
    SpineBase2.prototype.autoUpdateTransform = function() {
      {
        this.lastTime = this.lastTime || Date.now();
        var timeDelta = (Date.now() - this.lastTime) * 1e-3;
        this.lastTime = Date.now();
        this.update(timeDelta);
      }
      Container$1.prototype.updateTransform.call(this);
    };
    SpineBase2.prototype.createSprite = function(slot, attachment, defName) {
      var region = attachment.region;
      if (slot.hackAttachment === attachment) {
        region = slot.hackRegion;
      }
      var texture = region ? region.texture : null;
      var sprite = this.newSprite(texture);
      sprite.anchor.set(0.5);
      if (region) {
        this.setSpriteRegion(attachment, sprite, attachment.region);
      }
      slot.sprites = slot.sprites || {};
      slot.sprites[defName] = sprite;
      return sprite;
    };
    SpineBase2.prototype.createMesh = function(slot, attachment) {
      var region = attachment.region;
      if (slot.hackAttachment === attachment) {
        region = slot.hackRegion;
        slot.hackAttachment = null;
        slot.hackRegion = null;
      }
      var strip = this.newMesh(region ? region.texture : null, new Float32Array(attachment.regionUVs.length), attachment.regionUVs, new Uint16Array(attachment.triangles), DRAW_MODES$4.TRIANGLES);
      if (typeof strip._canvasPadding !== "undefined") {
        strip._canvasPadding = 1.5;
      }
      strip.alpha = attachment.color.a;
      strip.region = attachment.region;
      if (region) {
        this.setMeshRegion(attachment, strip, region);
      }
      slot.meshes = slot.meshes || {};
      slot.meshes[attachment.id] = strip;
      return strip;
    };
    SpineBase2.prototype.createGraphics = function(slot, clip) {
      var graphics = this.newGraphics();
      var poly = new Polygon([]);
      graphics.clear();
      graphics.beginFill(16777215, 1);
      graphics.drawPolygon(poly);
      graphics.renderable = false;
      slot.currentGraphics = graphics;
      slot.clippingContainer = this.newContainer();
      slot.clippingContainer.mask = slot.currentGraphics;
      return graphics;
    };
    SpineBase2.prototype.updateGraphics = function(slot, clip) {
      var geom = slot.currentGraphics.geometry;
      var vertices = geom.graphicsData[0].shape.points;
      var n2 = clip.worldVerticesLength;
      vertices.length = n2;
      clip.computeWorldVertices(slot, 0, n2, vertices, 0, 2);
      geom.invalidate();
    };
    SpineBase2.prototype.hackTextureBySlotIndex = function(slotIndex, texture, size) {
      if (texture === void 0) {
        texture = null;
      }
      if (size === void 0) {
        size = null;
      }
      var slot = this.skeleton.slots[slotIndex];
      if (!slot) {
        return false;
      }
      var attachment = slot.getAttachment();
      var region = attachment.region;
      if (texture) {
        region = new TextureRegion();
        region.texture = texture;
        region.size = size;
        slot.hackRegion = region;
        slot.hackAttachment = attachment;
      } else {
        slot.hackRegion = null;
        slot.hackAttachment = null;
      }
      if (slot.currentSprite) {
        this.setSpriteRegion(attachment, slot.currentSprite, region);
      } else if (slot.currentMesh) {
        this.setMeshRegion(attachment, slot.currentMesh, region);
      }
      return true;
    };
    SpineBase2.prototype.hackTextureBySlotName = function(slotName, texture, size) {
      if (texture === void 0) {
        texture = null;
      }
      if (size === void 0) {
        size = null;
      }
      var index2 = this.skeleton.findSlotIndex(slotName);
      if (index2 == -1) {
        return false;
      }
      return this.hackTextureBySlotIndex(index2, texture, size);
    };
    SpineBase2.prototype.hackTextureAttachment = function(slotName, attachmentName, texture, size) {
      if (size === void 0) {
        size = null;
      }
      var slotIndex = this.skeleton.findSlotIndex(slotName);
      var attachment = this.skeleton.getAttachmentByName(slotName, attachmentName);
      attachment.region.texture = texture;
      var slot = this.skeleton.slots[slotIndex];
      if (!slot) {
        return false;
      }
      var currentAttachment = slot.getAttachment();
      if (attachmentName === currentAttachment.name) {
        var region = attachment.region;
        if (texture) {
          region = new TextureRegion();
          region.texture = texture;
          region.size = size;
          slot.hackRegion = region;
          slot.hackAttachment = currentAttachment;
        } else {
          slot.hackRegion = null;
          slot.hackAttachment = null;
        }
        if (slot.currentSprite && slot.currentSprite.region != region) {
          this.setSpriteRegion(currentAttachment, slot.currentSprite, region);
          slot.currentSprite.region = region;
        } else if (slot.currentMesh && slot.currentMesh.region != region) {
          this.setMeshRegion(currentAttachment, slot.currentMesh, region);
        }
        return true;
      }
      return false;
    };
    SpineBase2.prototype.newContainer = function() {
      return new Container$1();
    };
    SpineBase2.prototype.newSprite = function(tex) {
      return new SpineSprite(tex);
    };
    SpineBase2.prototype.newGraphics = function() {
      return new Graphics();
    };
    SpineBase2.prototype.newMesh = function(texture, vertices, uvs, indices3, drawMode) {
      return new SpineMesh(texture, vertices, uvs, indices3, drawMode);
    };
    SpineBase2.prototype.transformHack = function() {
      return 1;
    };
    SpineBase2.prototype.hackAttachmentGroups = function(nameSuffix, group, outGroup) {
      if (!nameSuffix) {
        return void 0;
      }
      var list_d = [], list_n = [];
      for (var i2 = 0, len = this.skeleton.slots.length; i2 < len; i2++) {
        var slot = this.skeleton.slots[i2];
        var name_1 = slot.currentSpriteName || slot.currentMeshName || "";
        var target = slot.currentSprite || slot.currentMesh;
        if (name_1.endsWith(nameSuffix)) {
          target.parentGroup = group;
          list_n.push(target);
        } else if (outGroup && target) {
          target.parentGroup = outGroup;
          list_d.push(target);
        }
      }
      return [list_d, list_n];
    };
    SpineBase2.prototype.destroy = function(options) {
      this.debug = null;
      for (var i2 = 0, n2 = this.skeleton.slots.length; i2 < n2; i2++) {
        var slot = this.skeleton.slots[i2];
        for (var name_2 in slot.meshes) {
          slot.meshes[name_2].destroy(options);
        }
        slot.meshes = null;
        for (var name_3 in slot.sprites) {
          slot.sprites[name_3].destroy(options);
        }
        slot.sprites = null;
      }
      for (var i2 = 0, n2 = this.slotContainers.length; i2 < n2; i2++) {
        this.slotContainers[i2].destroy(options);
      }
      this.spineData = null;
      this.skeleton = null;
      this.slotContainers = null;
      this.stateData = null;
      this.state = null;
      this.tempClipContainers = null;
      _super.prototype.destroy.call(this, options);
    };
    SpineBase2.clippingPolygon = [];
    return SpineBase2;
  }(Container$1)
);
Object.defineProperty(SpineBase.prototype, "visible", {
  get: function() {
    return this._visible;
  },
  set: function(value) {
    if (value !== this._visible) {
      this._visible = value;
      if (value) {
        this.lastTime = 0;
      }
    }
  }
});
function isJson(resource) {
  return resource.type === LoaderResource.TYPE.JSON;
}
function isBuffer2(resource) {
  return resource.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BUFFER;
}
LoaderResource.setExtensionXhrType("skel", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
var AbstractSpineParser = (
  /** @class */
  function() {
    function AbstractSpineParser2() {
    }
    AbstractSpineParser2.prototype.genMiddleware = function() {
      var self2 = this;
      return {
        use: function(resource, next2) {
          if (!resource.data) {
            return next2();
          }
          var isJsonSpineModel = isJson(resource) && resource.data.bones;
          var isBinarySpineModel = isBuffer2(resource) && (resource.extension === "skel" || resource.metadata && resource.metadata.spineMetadata);
          if (!isJsonSpineModel && !isBinarySpineModel) {
            return next2();
          }
          var parser = null;
          var dataToParse = resource.data;
          if (isJsonSpineModel) {
            parser = self2.createJsonParser();
          } else {
            parser = self2.createBinaryParser();
            if (resource.data instanceof ArrayBuffer) {
              dataToParse = new Uint8Array(resource.data);
            }
          }
          var metadata = resource.metadata || {};
          var metadataSkeletonScale = metadata ? metadata.spineSkeletonScale : null;
          if (metadataSkeletonScale) {
            parser.scale = metadataSkeletonScale;
          }
          var metadataAtlas = metadata.spineAtlas;
          if (metadataAtlas === false) {
            return next2();
          }
          if (metadataAtlas && metadataAtlas.pages) {
            self2.parseData(resource, parser, metadataAtlas, dataToParse);
            return next2();
          }
          var metadataAtlasSuffix = metadata.spineAtlasSuffix || ".atlas";
          var atlasPath = resource.url;
          var queryStringPos = atlasPath.indexOf("?");
          if (queryStringPos > 0) {
            atlasPath = atlasPath.substr(0, queryStringPos);
          }
          atlasPath = atlasPath.substr(0, atlasPath.lastIndexOf(".")) + metadataAtlasSuffix;
          if (metadata.spineAtlasFile) {
            atlasPath = metadata.spineAtlasFile;
          }
          atlasPath = atlasPath.replace(this.baseUrl, "");
          var atlasOptions = {
            crossOrigin: resource.crossOrigin,
            xhrType: LoaderResource.XHR_RESPONSE_TYPE.TEXT,
            metadata: metadata.spineMetadata || null,
            parentResource: resource
          };
          var imageOptions = {
            crossOrigin: resource.crossOrigin,
            metadata: metadata.imageMetadata || null,
            parentResource: resource
          };
          var baseUrl = resource.url.substr(0, resource.url.lastIndexOf("/") + 1);
          baseUrl = baseUrl.replace(this.baseUrl, "");
          var namePrefix = metadata.imageNamePrefix || resource.name + "_atlas_page_";
          var adapter = metadata.images ? staticImageLoader(metadata.images) : metadata.image ? staticImageLoader({ "default": metadata.image }) : metadata.imageLoader ? metadata.imageLoader(this, namePrefix, baseUrl, imageOptions) : imageLoaderAdapter(this, namePrefix, baseUrl, imageOptions);
          function createSkeletonWithRawAtlas(rawData) {
            new TextureAtlas(rawData, adapter, function(spineAtlas) {
              if (spineAtlas) {
                self2.parseData(resource, parser, spineAtlas, dataToParse);
              }
              next2();
            });
          }
          if (metadata.atlasRawData) {
            createSkeletonWithRawAtlas(metadata.atlasRawData);
          } else {
            this.add(resource.name + "_atlas", atlasPath, atlasOptions, function(atlasResource) {
              if (!atlasResource.error) {
                createSkeletonWithRawAtlas(atlasResource.data);
              } else {
                next2();
              }
            });
          }
        }
      };
    };
    return AbstractSpineParser2;
  }()
);
function imageLoaderAdapter(loader, namePrefix, baseUrl, imageOptions) {
  if (baseUrl && baseUrl.lastIndexOf("/") !== baseUrl.length - 1) {
    baseUrl += "/";
  }
  return function(line2, callback) {
    var name = namePrefix + line2;
    var url2 = baseUrl + line2;
    var cachedResource = loader.resources[name];
    if (cachedResource) {
      var done = function() {
        callback(cachedResource.texture.baseTexture);
      };
      if (cachedResource.texture) {
        done();
      } else {
        cachedResource.onAfterMiddleware.add(done);
      }
    } else {
      loader.add(name, url2, imageOptions, function(resource) {
        if (!resource.error) {
          if (line2.indexOf("-pma.") >= 0) {
            resource.texture.baseTexture.alphaMode = ALPHA_MODES$4.PMA;
          }
          callback(resource.texture.baseTexture);
        } else {
          callback(null);
        }
      });
    }
  };
}
function staticImageLoader(pages) {
  return function(line2, callback) {
    var page = pages[line2] || pages["default"];
    if (page && page.baseTexture)
      callback(page.baseTexture);
    else
      callback(page);
  };
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$4 = function(d2, b2) {
  extendStatics$4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p))
        d3[p] = b3[p];
  };
  return extendStatics$4(d2, b2);
};
function __extends$4(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics$4(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var Attachment$2 = (
  /** @class */
  function() {
    function Attachment2(name) {
      if (name == null)
        throw new Error("name cannot be null.");
      this.name = name;
    }
    return Attachment2;
  }()
);
var VertexAttachment$2 = (
  /** @class */
  function(_super) {
    __extends$4(VertexAttachment2, _super);
    function VertexAttachment2(name) {
      var _this = _super.call(this, name) || this;
      _this.id = (VertexAttachment2.nextID++ & 65535) << 11;
      _this.worldVerticesLength = 0;
      _this.deformAttachment = _this;
      return _this;
    }
    VertexAttachment2.prototype.computeWorldVerticesOld = function(slot, worldVertices) {
      this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);
    };
    VertexAttachment2.prototype.computeWorldVertices = function(slot, start, count, worldVertices, offset, stride) {
      count = offset + (count >> 1) * stride;
      var skeleton = slot.bone.skeleton;
      var deformArray = slot.deform;
      var vertices = this.vertices;
      var bones = this.bones;
      if (bones == null) {
        if (deformArray.length > 0)
          vertices = deformArray;
        var mat = slot.bone.matrix;
        var x = mat.tx;
        var y2 = mat.ty;
        var a2 = mat.a, b2 = mat.c, c2 = mat.b, d2 = mat.d;
        for (var v_1 = start, w2 = offset; w2 < count; v_1 += 2, w2 += stride) {
          var vx2 = vertices[v_1], vy2 = vertices[v_1 + 1];
          worldVertices[w2] = vx2 * a2 + vy2 * b2 + x;
          worldVertices[w2 + 1] = vx2 * c2 + vy2 * d2 + y2;
        }
        return;
      }
      var v2 = 0, skip = 0;
      for (var i2 = 0; i2 < start; i2 += 2) {
        var n2 = bones[v2];
        v2 += n2 + 1;
        skip += n2;
      }
      var skeletonBones = skeleton.bones;
      if (deformArray.length == 0) {
        for (var w2 = offset, b2 = skip * 3; w2 < count; w2 += stride) {
          var wx = 0, wy = 0;
          var n2 = bones[v2++];
          n2 += v2;
          for (; v2 < n2; v2++, b2 += 3) {
            var mat = skeletonBones[bones[v2]].matrix;
            var vx2 = vertices[b2], vy2 = vertices[b2 + 1], weight = vertices[b2 + 2];
            wx += (vx2 * mat.a + vy2 * mat.c + mat.tx) * weight;
            wy += (vx2 * mat.b + vy2 * mat.d + mat.ty) * weight;
          }
          worldVertices[w2] = wx;
          worldVertices[w2 + 1] = wy;
        }
      } else {
        var deform = deformArray;
        for (var w2 = offset, b2 = skip * 3, f2 = skip << 1; w2 < count; w2 += stride) {
          var wx = 0, wy = 0;
          var n2 = bones[v2++];
          n2 += v2;
          for (; v2 < n2; v2++, b2 += 3, f2 += 2) {
            var mat = skeletonBones[bones[v2]].matrix;
            var vx2 = vertices[b2] + deform[f2], vy2 = vertices[b2 + 1] + deform[f2 + 1], weight = vertices[b2 + 2];
            wx += (vx2 * mat.a + vy2 * mat.c + mat.tx) * weight;
            wy += (vx2 * mat.b + vy2 * mat.d + mat.ty) * weight;
          }
          worldVertices[w2] = wx;
          worldVertices[w2 + 1] = wy;
        }
      }
    };
    VertexAttachment2.prototype.copyTo = function(attachment) {
      if (this.bones != null) {
        attachment.bones = new Array(this.bones.length);
        Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);
      } else
        attachment.bones = null;
      if (this.vertices != null) {
        attachment.vertices = Utils.newFloatArray(this.vertices.length);
        Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);
      } else
        attachment.vertices = null;
      attachment.worldVerticesLength = this.worldVerticesLength;
      attachment.deformAttachment = this.deformAttachment;
    };
    VertexAttachment2.nextID = 0;
    return VertexAttachment2;
  }(Attachment$2)
);
var BoundingBoxAttachment$2 = (
  /** @class */
  function(_super) {
    __extends$4(BoundingBoxAttachment2, _super);
    function BoundingBoxAttachment2(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.BoundingBox;
      _this.color = new Color(1, 1, 1, 1);
      return _this;
    }
    BoundingBoxAttachment2.prototype.copy = function() {
      var copy2 = new BoundingBoxAttachment2(this.name);
      this.copyTo(copy2);
      copy2.color.setFromColor(this.color);
      return copy2;
    };
    return BoundingBoxAttachment2;
  }(VertexAttachment$2)
);
var ClippingAttachment$2 = (
  /** @class */
  function(_super) {
    __extends$4(ClippingAttachment2, _super);
    function ClippingAttachment2(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Clipping;
      _this.color = new Color(0.2275, 0.2275, 0.8078, 1);
      return _this;
    }
    ClippingAttachment2.prototype.copy = function() {
      var copy2 = new ClippingAttachment2(this.name);
      this.copyTo(copy2);
      copy2.endSlot = this.endSlot;
      copy2.color.setFromColor(this.color);
      return copy2;
    };
    return ClippingAttachment2;
  }(VertexAttachment$2)
);
var MeshAttachment$2 = (
  /** @class */
  function(_super) {
    __extends$4(MeshAttachment2, _super);
    function MeshAttachment2(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Mesh;
      _this.color = new Color(1, 1, 1, 1);
      _this.tempColor = new Color(0, 0, 0, 0);
      return _this;
    }
    MeshAttachment2.prototype.getParentMesh = function() {
      return this.parentMesh;
    };
    MeshAttachment2.prototype.setParentMesh = function(parentMesh) {
      this.parentMesh = parentMesh;
      if (parentMesh != null) {
        this.bones = parentMesh.bones;
        this.vertices = parentMesh.vertices;
        this.worldVerticesLength = parentMesh.worldVerticesLength;
        this.regionUVs = parentMesh.regionUVs;
        this.triangles = parentMesh.triangles;
        this.hullLength = parentMesh.hullLength;
        this.worldVerticesLength = parentMesh.worldVerticesLength;
      }
    };
    MeshAttachment2.prototype.copy = function() {
      if (this.parentMesh != null)
        return this.newLinkedMesh();
      var copy2 = new MeshAttachment2(this.name);
      copy2.region = this.region;
      copy2.path = this.path;
      copy2.color.setFromColor(this.color);
      this.copyTo(copy2);
      copy2.regionUVs = new Float32Array(this.regionUVs.length);
      Utils.arrayCopy(this.regionUVs, 0, copy2.regionUVs, 0, this.regionUVs.length);
      copy2.triangles = new Array(this.triangles.length);
      Utils.arrayCopy(this.triangles, 0, copy2.triangles, 0, this.triangles.length);
      copy2.hullLength = this.hullLength;
      if (this.edges != null) {
        copy2.edges = new Array(this.edges.length);
        Utils.arrayCopy(this.edges, 0, copy2.edges, 0, this.edges.length);
      }
      copy2.width = this.width;
      copy2.height = this.height;
      return copy2;
    };
    MeshAttachment2.prototype.newLinkedMesh = function() {
      var copy2 = new MeshAttachment2(this.name);
      copy2.region = this.region;
      copy2.path = this.path;
      copy2.color.setFromColor(this.color);
      copy2.deformAttachment = this.deformAttachment;
      copy2.setParentMesh(this.parentMesh != null ? this.parentMesh : this);
      return copy2;
    };
    return MeshAttachment2;
  }(VertexAttachment$2)
);
var PathAttachment$2 = (
  /** @class */
  function(_super) {
    __extends$4(PathAttachment2, _super);
    function PathAttachment2(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Path;
      _this.closed = false;
      _this.constantSpeed = false;
      _this.color = new Color(1, 1, 1, 1);
      return _this;
    }
    PathAttachment2.prototype.copy = function() {
      var copy2 = new PathAttachment2(this.name);
      this.copyTo(copy2);
      copy2.lengths = new Array(this.lengths.length);
      Utils.arrayCopy(this.lengths, 0, copy2.lengths, 0, this.lengths.length);
      copy2.closed = closed;
      copy2.constantSpeed = this.constantSpeed;
      copy2.color.setFromColor(this.color);
      return copy2;
    };
    return PathAttachment2;
  }(VertexAttachment$2)
);
var PointAttachment$2 = (
  /** @class */
  function(_super) {
    __extends$4(PointAttachment2, _super);
    function PointAttachment2(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Point;
      _this.color = new Color(0.38, 0.94, 0, 1);
      return _this;
    }
    PointAttachment2.prototype.computeWorldPosition = function(bone, point) {
      var mat = bone.matrix;
      point.x = this.x * mat.a + this.y * mat.c + bone.worldX;
      point.y = this.x * mat.b + this.y * mat.d + bone.worldY;
      return point;
    };
    PointAttachment2.prototype.computeWorldRotation = function(bone) {
      var mat = bone.matrix;
      var cos = MathUtils.cosDeg(this.rotation), sin = MathUtils.sinDeg(this.rotation);
      var x = cos * mat.a + sin * mat.c;
      var y2 = cos * mat.b + sin * mat.d;
      return Math.atan2(y2, x) * MathUtils.radDeg;
    };
    PointAttachment2.prototype.copy = function() {
      var copy2 = new PointAttachment2(this.name);
      copy2.x = this.x;
      copy2.y = this.y;
      copy2.rotation = this.rotation;
      copy2.color.setFromColor(this.color);
      return copy2;
    };
    return PointAttachment2;
  }(VertexAttachment$2)
);
var Slot$2 = (
  /** @class */
  function() {
    function Slot2(data2, bone) {
      this.deform = new Array();
      if (data2 == null)
        throw new Error("data cannot be null.");
      if (bone == null)
        throw new Error("bone cannot be null.");
      this.data = data2;
      this.bone = bone;
      this.color = new Color();
      this.darkColor = data2.darkColor == null ? null : new Color();
      this.setToSetupPose();
      this.blendMode = this.data.blendMode;
    }
    Slot2.prototype.getAttachment = function() {
      return this.attachment;
    };
    Slot2.prototype.setAttachment = function(attachment) {
      if (this.attachment == attachment)
        return;
      this.attachment = attachment;
      this.attachmentTime = this.bone.skeleton.time;
      this.deform.length = 0;
    };
    Slot2.prototype.setAttachmentTime = function(time) {
      this.attachmentTime = this.bone.skeleton.time - time;
    };
    Slot2.prototype.getAttachmentTime = function() {
      return this.bone.skeleton.time - this.attachmentTime;
    };
    Slot2.prototype.setToSetupPose = function() {
      this.color.setFromColor(this.data.color);
      if (this.darkColor != null)
        this.darkColor.setFromColor(this.data.darkColor);
      if (this.data.attachmentName == null)
        this.attachment = null;
      else {
        this.attachment = null;
        this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
      }
    };
    return Slot2;
  }()
);
var RegionAttachment$2 = (
  /** @class */
  function(_super) {
    __extends$4(RegionAttachment2, _super);
    function RegionAttachment2(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Region;
      _this.x = 0;
      _this.y = 0;
      _this.scaleX = 1;
      _this.scaleY = 1;
      _this.rotation = 0;
      _this.width = 0;
      _this.height = 0;
      _this.color = new Color(1, 1, 1, 1);
      _this.offset = Utils.newFloatArray(8);
      _this.uvs = Utils.newFloatArray(8);
      _this.tempColor = new Color(1, 1, 1, 1);
      return _this;
    }
    RegionAttachment2.prototype.updateOffset = function() {
      var regionScaleX = this.width / this.region.originalWidth * this.scaleX;
      var regionScaleY = this.height / this.region.originalHeight * this.scaleY;
      var localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
      var localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
      var localX2 = localX + this.region.width * regionScaleX;
      var localY2 = localY + this.region.height * regionScaleY;
      var radians = this.rotation * Math.PI / 180;
      var cos = Math.cos(radians);
      var sin = Math.sin(radians);
      var localXCos = localX * cos + this.x;
      var localXSin = localX * sin;
      var localYCos = localY * cos + this.y;
      var localYSin = localY * sin;
      var localX2Cos = localX2 * cos + this.x;
      var localX2Sin = localX2 * sin;
      var localY2Cos = localY2 * cos + this.y;
      var localY2Sin = localY2 * sin;
      var offset = this.offset;
      offset[RegionAttachment2.OX1] = localXCos - localYSin;
      offset[RegionAttachment2.OY1] = localYCos + localXSin;
      offset[RegionAttachment2.OX2] = localXCos - localY2Sin;
      offset[RegionAttachment2.OY2] = localY2Cos + localXSin;
      offset[RegionAttachment2.OX3] = localX2Cos - localY2Sin;
      offset[RegionAttachment2.OY3] = localY2Cos + localX2Sin;
      offset[RegionAttachment2.OX4] = localX2Cos - localYSin;
      offset[RegionAttachment2.OY4] = localYCos + localX2Sin;
    };
    RegionAttachment2.prototype.setRegion = function(region) {
      this.region = region;
      var uvs = this.uvs;
      if (region.rotate) {
        uvs[2] = region.u;
        uvs[3] = region.v2;
        uvs[4] = region.u;
        uvs[5] = region.v;
        uvs[6] = region.u2;
        uvs[7] = region.v;
        uvs[0] = region.u2;
        uvs[1] = region.v2;
      } else {
        uvs[0] = region.u;
        uvs[1] = region.v2;
        uvs[2] = region.u;
        uvs[3] = region.v;
        uvs[4] = region.u2;
        uvs[5] = region.v;
        uvs[6] = region.u2;
        uvs[7] = region.v2;
      }
    };
    RegionAttachment2.prototype.computeWorldVertices = function(bone, worldVertices, offset, stride) {
      var vertexOffset = this.offset;
      var mat = bone instanceof Slot$2 ? bone.bone.matrix : bone.matrix;
      var x = mat.tx, y2 = mat.ty;
      var a2 = mat.a, b2 = mat.c, c2 = mat.b, d2 = mat.d;
      var offsetX = 0, offsetY = 0;
      offsetX = vertexOffset[RegionAttachment2.OX1];
      offsetY = vertexOffset[RegionAttachment2.OY1];
      worldVertices[offset] = offsetX * a2 + offsetY * b2 + x;
      worldVertices[offset + 1] = offsetX * c2 + offsetY * d2 + y2;
      offset += stride;
      offsetX = vertexOffset[RegionAttachment2.OX2];
      offsetY = vertexOffset[RegionAttachment2.OY2];
      worldVertices[offset] = offsetX * a2 + offsetY * b2 + x;
      worldVertices[offset + 1] = offsetX * c2 + offsetY * d2 + y2;
      offset += stride;
      offsetX = vertexOffset[RegionAttachment2.OX3];
      offsetY = vertexOffset[RegionAttachment2.OY3];
      worldVertices[offset] = offsetX * a2 + offsetY * b2 + x;
      worldVertices[offset + 1] = offsetX * c2 + offsetY * d2 + y2;
      offset += stride;
      offsetX = vertexOffset[RegionAttachment2.OX4];
      offsetY = vertexOffset[RegionAttachment2.OY4];
      worldVertices[offset] = offsetX * a2 + offsetY * b2 + x;
      worldVertices[offset + 1] = offsetX * c2 + offsetY * d2 + y2;
    };
    RegionAttachment2.prototype.copy = function() {
      var copy2 = new RegionAttachment2(this.name);
      copy2.region = this.region;
      copy2.rendererObject = this.rendererObject;
      copy2.path = this.path;
      copy2.x = this.x;
      copy2.y = this.y;
      copy2.scaleX = this.scaleX;
      copy2.scaleY = this.scaleY;
      copy2.rotation = this.rotation;
      copy2.width = this.width;
      copy2.height = this.height;
      Utils.arrayCopy(this.uvs, 0, copy2.uvs, 0, 8);
      Utils.arrayCopy(this.offset, 0, copy2.offset, 0, 8);
      copy2.color.setFromColor(this.color);
      return copy2;
    };
    RegionAttachment2.OX1 = 0;
    RegionAttachment2.OY1 = 1;
    RegionAttachment2.OX2 = 2;
    RegionAttachment2.OY2 = 3;
    RegionAttachment2.OX3 = 4;
    RegionAttachment2.OY3 = 5;
    RegionAttachment2.OX4 = 6;
    RegionAttachment2.OY4 = 7;
    RegionAttachment2.X1 = 0;
    RegionAttachment2.Y1 = 1;
    RegionAttachment2.C1R = 2;
    RegionAttachment2.C1G = 3;
    RegionAttachment2.C1B = 4;
    RegionAttachment2.C1A = 5;
    RegionAttachment2.U1 = 6;
    RegionAttachment2.V1 = 7;
    RegionAttachment2.X2 = 8;
    RegionAttachment2.Y2 = 9;
    RegionAttachment2.C2R = 10;
    RegionAttachment2.C2G = 11;
    RegionAttachment2.C2B = 12;
    RegionAttachment2.C2A = 13;
    RegionAttachment2.U2 = 14;
    RegionAttachment2.V2 = 15;
    RegionAttachment2.X3 = 16;
    RegionAttachment2.Y3 = 17;
    RegionAttachment2.C3R = 18;
    RegionAttachment2.C3G = 19;
    RegionAttachment2.C3B = 20;
    RegionAttachment2.C3A = 21;
    RegionAttachment2.U3 = 22;
    RegionAttachment2.V3 = 23;
    RegionAttachment2.X4 = 24;
    RegionAttachment2.Y4 = 25;
    RegionAttachment2.C4R = 26;
    RegionAttachment2.C4G = 27;
    RegionAttachment2.C4B = 28;
    RegionAttachment2.C4A = 29;
    RegionAttachment2.U4 = 30;
    RegionAttachment2.V4 = 31;
    return RegionAttachment2;
  }(Attachment$2)
);
var JitterEffect$1 = (
  /** @class */
  function() {
    function JitterEffect2(jitterX, jitterY) {
      this.jitterX = 0;
      this.jitterY = 0;
      this.jitterX = jitterX;
      this.jitterY = jitterY;
    }
    JitterEffect2.prototype.begin = function(skeleton) {
    };
    JitterEffect2.prototype.transform = function(position2, uv, light, dark) {
      position2.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);
      position2.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);
    };
    JitterEffect2.prototype.end = function() {
    };
    return JitterEffect2;
  }()
);
var SwirlEffect$1 = (
  /** @class */
  function() {
    function SwirlEffect2(radius) {
      this.centerX = 0;
      this.centerY = 0;
      this.radius = 0;
      this.angle = 0;
      this.worldX = 0;
      this.worldY = 0;
      this.radius = radius;
    }
    SwirlEffect2.prototype.begin = function(skeleton) {
      this.worldX = skeleton.x + this.centerX;
      this.worldY = skeleton.y + this.centerY;
    };
    SwirlEffect2.prototype.transform = function(position2, uv, light, dark) {
      var radAngle = this.angle * MathUtils.degreesToRadians;
      var x = position2.x - this.worldX;
      var y2 = position2.y - this.worldY;
      var dist = Math.sqrt(x * x + y2 * y2);
      if (dist < this.radius) {
        var theta = SwirlEffect2.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);
        var cos = Math.cos(theta);
        var sin = Math.sin(theta);
        position2.x = cos * x - sin * y2 + this.worldX;
        position2.y = sin * x + cos * y2 + this.worldY;
      }
    };
    SwirlEffect2.prototype.end = function() {
    };
    SwirlEffect2.interpolation = new PowOut(2);
    return SwirlEffect2;
  }()
);
var Animation$2 = (
  /** @class */
  function() {
    function Animation2(name, timelines, duration) {
      if (name == null)
        throw new Error("name cannot be null.");
      if (timelines == null)
        throw new Error("timelines cannot be null.");
      this.name = name;
      this.timelines = timelines;
      this.timelineIds = [];
      for (var i2 = 0; i2 < timelines.length; i2++)
        this.timelineIds[timelines[i2].getPropertyId()] = true;
      this.duration = duration;
    }
    Animation2.prototype.hasTimeline = function(id2) {
      return this.timelineIds[id2] == true;
    };
    Animation2.prototype.apply = function(skeleton, lastTime2, time, loop, events, alpha2, blend, direction) {
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      if (loop && this.duration != 0) {
        time %= this.duration;
        if (lastTime2 > 0)
          lastTime2 %= this.duration;
      }
      var timelines = this.timelines;
      for (var i2 = 0, n2 = timelines.length; i2 < n2; i2++)
        timelines[i2].apply(skeleton, lastTime2, time, events, alpha2, blend, direction);
    };
    Animation2.binarySearch = function(values, target, step) {
      if (step === void 0) {
        step = 1;
      }
      var low = 0;
      var high = values.length / step - 2;
      if (high == 0)
        return step;
      var current = high >>> 1;
      while (true) {
        if (values[(current + 1) * step] <= target)
          low = current + 1;
        else
          high = current;
        if (low == high)
          return (low + 1) * step;
        current = low + high >>> 1;
      }
    };
    Animation2.linearSearch = function(values, target, step) {
      for (var i2 = 0, last = values.length - step; i2 <= last; i2 += step)
        if (values[i2] > target)
          return i2;
      return -1;
    };
    return Animation2;
  }()
);
var TimelineType$1;
(function(TimelineType2) {
  TimelineType2[TimelineType2["rotate"] = 0] = "rotate";
  TimelineType2[TimelineType2["translate"] = 1] = "translate";
  TimelineType2[TimelineType2["scale"] = 2] = "scale";
  TimelineType2[TimelineType2["shear"] = 3] = "shear";
  TimelineType2[TimelineType2["attachment"] = 4] = "attachment";
  TimelineType2[TimelineType2["color"] = 5] = "color";
  TimelineType2[TimelineType2["deform"] = 6] = "deform";
  TimelineType2[TimelineType2["event"] = 7] = "event";
  TimelineType2[TimelineType2["drawOrder"] = 8] = "drawOrder";
  TimelineType2[TimelineType2["ikConstraint"] = 9] = "ikConstraint";
  TimelineType2[TimelineType2["transformConstraint"] = 10] = "transformConstraint";
  TimelineType2[TimelineType2["pathConstraintPosition"] = 11] = "pathConstraintPosition";
  TimelineType2[TimelineType2["pathConstraintSpacing"] = 12] = "pathConstraintSpacing";
  TimelineType2[TimelineType2["pathConstraintMix"] = 13] = "pathConstraintMix";
  TimelineType2[TimelineType2["twoColor"] = 14] = "twoColor";
})(TimelineType$1 || (TimelineType$1 = {}));
var CurveTimeline$2 = (
  /** @class */
  function() {
    function CurveTimeline3(frameCount) {
      if (frameCount <= 0)
        throw new Error("frameCount must be > 0: " + frameCount);
      this.curves = Utils.newFloatArray((frameCount - 1) * CurveTimeline3.BEZIER_SIZE);
    }
    CurveTimeline3.prototype.getFrameCount = function() {
      return this.curves.length / CurveTimeline3.BEZIER_SIZE + 1;
    };
    CurveTimeline3.prototype.setLinear = function(frameIndex) {
      this.curves[frameIndex * CurveTimeline3.BEZIER_SIZE] = CurveTimeline3.LINEAR;
    };
    CurveTimeline3.prototype.setStepped = function(frameIndex) {
      this.curves[frameIndex * CurveTimeline3.BEZIER_SIZE] = CurveTimeline3.STEPPED;
    };
    CurveTimeline3.prototype.getCurveType = function(frameIndex) {
      var index2 = frameIndex * CurveTimeline3.BEZIER_SIZE;
      if (index2 == this.curves.length)
        return CurveTimeline3.LINEAR;
      var type2 = this.curves[index2];
      if (type2 == CurveTimeline3.LINEAR)
        return CurveTimeline3.LINEAR;
      if (type2 == CurveTimeline3.STEPPED)
        return CurveTimeline3.STEPPED;
      return CurveTimeline3.BEZIER;
    };
    CurveTimeline3.prototype.setCurve = function(frameIndex, cx1, cy1, cx2, cy2) {
      var tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;
      var dddfx = ((cx1 - cx2) * 3 + 1) * 6e-3, dddfy = ((cy1 - cy2) * 3 + 1) * 6e-3;
      var ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;
      var dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;
      var i2 = frameIndex * CurveTimeline3.BEZIER_SIZE;
      var curves = this.curves;
      curves[i2++] = CurveTimeline3.BEZIER;
      var x = dfx, y2 = dfy;
      for (var n2 = i2 + CurveTimeline3.BEZIER_SIZE - 1; i2 < n2; i2 += 2) {
        curves[i2] = x;
        curves[i2 + 1] = y2;
        dfx += ddfx;
        dfy += ddfy;
        ddfx += dddfx;
        ddfy += dddfy;
        x += dfx;
        y2 += dfy;
      }
    };
    CurveTimeline3.prototype.getCurvePercent = function(frameIndex, percent2) {
      percent2 = MathUtils.clamp(percent2, 0, 1);
      var curves = this.curves;
      var i2 = frameIndex * CurveTimeline3.BEZIER_SIZE;
      var type2 = curves[i2];
      if (type2 == CurveTimeline3.LINEAR)
        return percent2;
      if (type2 == CurveTimeline3.STEPPED)
        return 0;
      i2++;
      var x = 0;
      for (var start = i2, n2 = i2 + CurveTimeline3.BEZIER_SIZE - 1; i2 < n2; i2 += 2) {
        x = curves[i2];
        if (x >= percent2) {
          var prevX = void 0, prevY = void 0;
          if (i2 == start) {
            prevX = 0;
            prevY = 0;
          } else {
            prevX = curves[i2 - 2];
            prevY = curves[i2 - 1];
          }
          return prevY + (curves[i2 + 1] - prevY) * (percent2 - prevX) / (x - prevX);
        }
      }
      var y2 = curves[i2 - 1];
      return y2 + (1 - y2) * (percent2 - x) / (1 - x);
    };
    CurveTimeline3.LINEAR = 0;
    CurveTimeline3.STEPPED = 1;
    CurveTimeline3.BEZIER = 2;
    CurveTimeline3.BEZIER_SIZE = 10 * 2 - 1;
    return CurveTimeline3;
  }()
);
var RotateTimeline$2 = (
  /** @class */
  function(_super) {
    __extends$4(RotateTimeline2, _super);
    function RotateTimeline2(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount << 1);
      return _this;
    }
    RotateTimeline2.prototype.getPropertyId = function() {
      return (TimelineType$1.rotate << 24) + this.boneIndex;
    };
    RotateTimeline2.prototype.setFrame = function(frameIndex, time, degrees) {
      frameIndex <<= 1;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + RotateTimeline2.ROTATION] = degrees;
    };
    RotateTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var frames = this.frames;
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.rotation = bone.data.rotation;
            return;
          case MixBlend.first:
            var r_1 = bone.data.rotation - bone.rotation;
            bone.rotation += (r_1 - (16384 - (16384.499999999996 - r_1 / 360 | 0)) * 360) * alpha2;
        }
        return;
      }
      if (time >= frames[frames.length - RotateTimeline2.ENTRIES]) {
        var r_2 = frames[frames.length + RotateTimeline2.PREV_ROTATION];
        switch (blend) {
          case MixBlend.setup:
            bone.rotation = bone.data.rotation + r_2 * alpha2;
            break;
          case MixBlend.first:
          case MixBlend.replace:
            r_2 += bone.data.rotation - bone.rotation;
            r_2 -= (16384 - (16384.499999999996 - r_2 / 360 | 0)) * 360;
          case MixBlend.add:
            bone.rotation += r_2 * alpha2;
        }
        return;
      }
      var frame2 = Animation$2.binarySearch(frames, time, RotateTimeline2.ENTRIES);
      var prevRotation = frames[frame2 + RotateTimeline2.PREV_ROTATION];
      var frameTime = frames[frame2];
      var percent2 = this.getCurvePercent((frame2 >> 1) - 1, 1 - (time - frameTime) / (frames[frame2 + RotateTimeline2.PREV_TIME] - frameTime));
      var r2 = frames[frame2 + RotateTimeline2.ROTATION] - prevRotation;
      r2 = prevRotation + (r2 - (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360) * percent2;
      switch (blend) {
        case MixBlend.setup:
          bone.rotation = bone.data.rotation + (r2 - (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360) * alpha2;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          r2 += bone.data.rotation - bone.rotation;
        case MixBlend.add:
          bone.rotation += (r2 - (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360) * alpha2;
      }
    };
    RotateTimeline2.ENTRIES = 2;
    RotateTimeline2.PREV_TIME = -2;
    RotateTimeline2.PREV_ROTATION = -1;
    RotateTimeline2.ROTATION = 1;
    return RotateTimeline2;
  }(CurveTimeline$2)
);
var TranslateTimeline$2 = (
  /** @class */
  function(_super) {
    __extends$4(TranslateTimeline2, _super);
    function TranslateTimeline2(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * TranslateTimeline2.ENTRIES);
      return _this;
    }
    TranslateTimeline2.prototype.getPropertyId = function() {
      return (TimelineType$1.translate << 24) + this.boneIndex;
    };
    TranslateTimeline2.prototype.setFrame = function(frameIndex, time, x, y2) {
      frameIndex *= TranslateTimeline2.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + TranslateTimeline2.X] = x;
      this.frames[frameIndex + TranslateTimeline2.Y] = y2;
    };
    TranslateTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var frames = this.frames;
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.x = bone.data.x;
            bone.y = bone.data.y;
            return;
          case MixBlend.first:
            bone.x += (bone.data.x - bone.x) * alpha2;
            bone.y += (bone.data.y - bone.y) * alpha2;
        }
        return;
      }
      var x = 0, y2 = 0;
      if (time >= frames[frames.length - TranslateTimeline2.ENTRIES]) {
        x = frames[frames.length + TranslateTimeline2.PREV_X];
        y2 = frames[frames.length + TranslateTimeline2.PREV_Y];
      } else {
        var frame2 = Animation$2.binarySearch(frames, time, TranslateTimeline2.ENTRIES);
        x = frames[frame2 + TranslateTimeline2.PREV_X];
        y2 = frames[frame2 + TranslateTimeline2.PREV_Y];
        var frameTime = frames[frame2];
        var percent2 = this.getCurvePercent(frame2 / TranslateTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame2 + TranslateTimeline2.PREV_TIME] - frameTime));
        x += (frames[frame2 + TranslateTimeline2.X] - x) * percent2;
        y2 += (frames[frame2 + TranslateTimeline2.Y] - y2) * percent2;
      }
      switch (blend) {
        case MixBlend.setup:
          bone.x = bone.data.x + x * alpha2;
          bone.y = bone.data.y + y2 * alpha2;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.x += (bone.data.x + x - bone.x) * alpha2;
          bone.y += (bone.data.y + y2 - bone.y) * alpha2;
          break;
        case MixBlend.add:
          bone.x += x * alpha2;
          bone.y += y2 * alpha2;
      }
    };
    TranslateTimeline2.ENTRIES = 3;
    TranslateTimeline2.PREV_TIME = -3;
    TranslateTimeline2.PREV_X = -2;
    TranslateTimeline2.PREV_Y = -1;
    TranslateTimeline2.X = 1;
    TranslateTimeline2.Y = 2;
    return TranslateTimeline2;
  }(CurveTimeline$2)
);
var ScaleTimeline$2 = (
  /** @class */
  function(_super) {
    __extends$4(ScaleTimeline2, _super);
    function ScaleTimeline2(frameCount) {
      return _super.call(this, frameCount) || this;
    }
    ScaleTimeline2.prototype.getPropertyId = function() {
      return (TimelineType$1.scale << 24) + this.boneIndex;
    };
    ScaleTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var frames = this.frames;
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.scaleX = bone.data.scaleX;
            bone.scaleY = bone.data.scaleY;
            return;
          case MixBlend.first:
            bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha2;
            bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha2;
        }
        return;
      }
      var x = 0, y2 = 0;
      if (time >= frames[frames.length - ScaleTimeline2.ENTRIES]) {
        x = frames[frames.length + ScaleTimeline2.PREV_X] * bone.data.scaleX;
        y2 = frames[frames.length + ScaleTimeline2.PREV_Y] * bone.data.scaleY;
      } else {
        var frame2 = Animation$2.binarySearch(frames, time, ScaleTimeline2.ENTRIES);
        x = frames[frame2 + ScaleTimeline2.PREV_X];
        y2 = frames[frame2 + ScaleTimeline2.PREV_Y];
        var frameTime = frames[frame2];
        var percent2 = this.getCurvePercent(frame2 / ScaleTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame2 + ScaleTimeline2.PREV_TIME] - frameTime));
        x = (x + (frames[frame2 + ScaleTimeline2.X] - x) * percent2) * bone.data.scaleX;
        y2 = (y2 + (frames[frame2 + ScaleTimeline2.Y] - y2) * percent2) * bone.data.scaleY;
      }
      if (alpha2 == 1) {
        if (blend == MixBlend.add) {
          bone.scaleX += x - bone.data.scaleX;
          bone.scaleY += y2 - bone.data.scaleY;
        } else {
          bone.scaleX = x;
          bone.scaleY = y2;
        }
      } else {
        var bx = 0, by = 0;
        if (direction == MixDirection.mixOut) {
          switch (blend) {
            case MixBlend.setup:
              bx = bone.data.scaleX;
              by = bone.data.scaleY;
              bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha2;
              bone.scaleY = by + (Math.abs(y2) * MathUtils.signum(by) - by) * alpha2;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              bx = bone.scaleX;
              by = bone.scaleY;
              bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha2;
              bone.scaleY = by + (Math.abs(y2) * MathUtils.signum(by) - by) * alpha2;
              break;
            case MixBlend.add:
              bx = bone.scaleX;
              by = bone.scaleY;
              bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha2;
              bone.scaleY = by + (Math.abs(y2) * MathUtils.signum(by) - bone.data.scaleY) * alpha2;
          }
        } else {
          switch (blend) {
            case MixBlend.setup:
              bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);
              by = Math.abs(bone.data.scaleY) * MathUtils.signum(y2);
              bone.scaleX = bx + (x - bx) * alpha2;
              bone.scaleY = by + (y2 - by) * alpha2;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              bx = Math.abs(bone.scaleX) * MathUtils.signum(x);
              by = Math.abs(bone.scaleY) * MathUtils.signum(y2);
              bone.scaleX = bx + (x - bx) * alpha2;
              bone.scaleY = by + (y2 - by) * alpha2;
              break;
            case MixBlend.add:
              bx = MathUtils.signum(x);
              by = MathUtils.signum(y2);
              bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha2;
              bone.scaleY = Math.abs(bone.scaleY) * by + (y2 - Math.abs(bone.data.scaleY) * by) * alpha2;
          }
        }
      }
    };
    return ScaleTimeline2;
  }(TranslateTimeline$2)
);
var ShearTimeline$2 = (
  /** @class */
  function(_super) {
    __extends$4(ShearTimeline2, _super);
    function ShearTimeline2(frameCount) {
      return _super.call(this, frameCount) || this;
    }
    ShearTimeline2.prototype.getPropertyId = function() {
      return (TimelineType$1.shear << 24) + this.boneIndex;
    };
    ShearTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var frames = this.frames;
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.shearX = bone.data.shearX;
            bone.shearY = bone.data.shearY;
            return;
          case MixBlend.first:
            bone.shearX += (bone.data.shearX - bone.shearX) * alpha2;
            bone.shearY += (bone.data.shearY - bone.shearY) * alpha2;
        }
        return;
      }
      var x = 0, y2 = 0;
      if (time >= frames[frames.length - ShearTimeline2.ENTRIES]) {
        x = frames[frames.length + ShearTimeline2.PREV_X];
        y2 = frames[frames.length + ShearTimeline2.PREV_Y];
      } else {
        var frame2 = Animation$2.binarySearch(frames, time, ShearTimeline2.ENTRIES);
        x = frames[frame2 + ShearTimeline2.PREV_X];
        y2 = frames[frame2 + ShearTimeline2.PREV_Y];
        var frameTime = frames[frame2];
        var percent2 = this.getCurvePercent(frame2 / ShearTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame2 + ShearTimeline2.PREV_TIME] - frameTime));
        x = x + (frames[frame2 + ShearTimeline2.X] - x) * percent2;
        y2 = y2 + (frames[frame2 + ShearTimeline2.Y] - y2) * percent2;
      }
      switch (blend) {
        case MixBlend.setup:
          bone.shearX = bone.data.shearX + x * alpha2;
          bone.shearY = bone.data.shearY + y2 * alpha2;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha2;
          bone.shearY += (bone.data.shearY + y2 - bone.shearY) * alpha2;
          break;
        case MixBlend.add:
          bone.shearX += x * alpha2;
          bone.shearY += y2 * alpha2;
      }
    };
    return ShearTimeline2;
  }(TranslateTimeline$2)
);
var ColorTimeline$1 = (
  /** @class */
  function(_super) {
    __extends$4(ColorTimeline2, _super);
    function ColorTimeline2(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * ColorTimeline2.ENTRIES);
      return _this;
    }
    ColorTimeline2.prototype.getPropertyId = function() {
      return (TimelineType$1.color << 24) + this.slotIndex;
    };
    ColorTimeline2.prototype.setFrame = function(frameIndex, time, r2, g2, b2, a2) {
      frameIndex *= ColorTimeline2.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + ColorTimeline2.R] = r2;
      this.frames[frameIndex + ColorTimeline2.G] = g2;
      this.frames[frameIndex + ColorTimeline2.B] = b2;
      this.frames[frameIndex + ColorTimeline2.A] = a2;
    };
    ColorTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            slot.color.setFromColor(slot.data.color);
            return;
          case MixBlend.first:
            var color2 = slot.color, setup = slot.data.color;
            color2.add((setup.r - color2.r) * alpha2, (setup.g - color2.g) * alpha2, (setup.b - color2.b) * alpha2, (setup.a - color2.a) * alpha2);
        }
        return;
      }
      var r2 = 0, g2 = 0, b2 = 0, a2 = 0;
      if (time >= frames[frames.length - ColorTimeline2.ENTRIES]) {
        var i2 = frames.length;
        r2 = frames[i2 + ColorTimeline2.PREV_R];
        g2 = frames[i2 + ColorTimeline2.PREV_G];
        b2 = frames[i2 + ColorTimeline2.PREV_B];
        a2 = frames[i2 + ColorTimeline2.PREV_A];
      } else {
        var frame2 = Animation$2.binarySearch(frames, time, ColorTimeline2.ENTRIES);
        r2 = frames[frame2 + ColorTimeline2.PREV_R];
        g2 = frames[frame2 + ColorTimeline2.PREV_G];
        b2 = frames[frame2 + ColorTimeline2.PREV_B];
        a2 = frames[frame2 + ColorTimeline2.PREV_A];
        var frameTime = frames[frame2];
        var percent2 = this.getCurvePercent(frame2 / ColorTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame2 + ColorTimeline2.PREV_TIME] - frameTime));
        r2 += (frames[frame2 + ColorTimeline2.R] - r2) * percent2;
        g2 += (frames[frame2 + ColorTimeline2.G] - g2) * percent2;
        b2 += (frames[frame2 + ColorTimeline2.B] - b2) * percent2;
        a2 += (frames[frame2 + ColorTimeline2.A] - a2) * percent2;
      }
      if (alpha2 == 1)
        slot.color.set(r2, g2, b2, a2);
      else {
        var color2 = slot.color;
        if (blend == MixBlend.setup)
          color2.setFromColor(slot.data.color);
        color2.add((r2 - color2.r) * alpha2, (g2 - color2.g) * alpha2, (b2 - color2.b) * alpha2, (a2 - color2.a) * alpha2);
      }
    };
    ColorTimeline2.ENTRIES = 5;
    ColorTimeline2.PREV_TIME = -5;
    ColorTimeline2.PREV_R = -4;
    ColorTimeline2.PREV_G = -3;
    ColorTimeline2.PREV_B = -2;
    ColorTimeline2.PREV_A = -1;
    ColorTimeline2.R = 1;
    ColorTimeline2.G = 2;
    ColorTimeline2.B = 3;
    ColorTimeline2.A = 4;
    return ColorTimeline2;
  }(CurveTimeline$2)
);
var TwoColorTimeline$1 = (
  /** @class */
  function(_super) {
    __extends$4(TwoColorTimeline2, _super);
    function TwoColorTimeline2(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * TwoColorTimeline2.ENTRIES);
      return _this;
    }
    TwoColorTimeline2.prototype.getPropertyId = function() {
      return (TimelineType$1.twoColor << 24) + this.slotIndex;
    };
    TwoColorTimeline2.prototype.setFrame = function(frameIndex, time, r2, g2, b2, a2, r22, g22, b22) {
      frameIndex *= TwoColorTimeline2.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + TwoColorTimeline2.R] = r2;
      this.frames[frameIndex + TwoColorTimeline2.G] = g2;
      this.frames[frameIndex + TwoColorTimeline2.B] = b2;
      this.frames[frameIndex + TwoColorTimeline2.A] = a2;
      this.frames[frameIndex + TwoColorTimeline2.R2] = r22;
      this.frames[frameIndex + TwoColorTimeline2.G2] = g22;
      this.frames[frameIndex + TwoColorTimeline2.B2] = b22;
    };
    TwoColorTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            slot.color.setFromColor(slot.data.color);
            slot.darkColor.setFromColor(slot.data.darkColor);
            return;
          case MixBlend.first:
            var light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;
            light.add((setupLight.r - light.r) * alpha2, (setupLight.g - light.g) * alpha2, (setupLight.b - light.b) * alpha2, (setupLight.a - light.a) * alpha2);
            dark.add((setupDark.r - dark.r) * alpha2, (setupDark.g - dark.g) * alpha2, (setupDark.b - dark.b) * alpha2, 0);
        }
        return;
      }
      var r2 = 0, g2 = 0, b2 = 0, a2 = 0, r22 = 0, g22 = 0, b22 = 0;
      if (time >= frames[frames.length - TwoColorTimeline2.ENTRIES]) {
        var i2 = frames.length;
        r2 = frames[i2 + TwoColorTimeline2.PREV_R];
        g2 = frames[i2 + TwoColorTimeline2.PREV_G];
        b2 = frames[i2 + TwoColorTimeline2.PREV_B];
        a2 = frames[i2 + TwoColorTimeline2.PREV_A];
        r22 = frames[i2 + TwoColorTimeline2.PREV_R2];
        g22 = frames[i2 + TwoColorTimeline2.PREV_G2];
        b22 = frames[i2 + TwoColorTimeline2.PREV_B2];
      } else {
        var frame2 = Animation$2.binarySearch(frames, time, TwoColorTimeline2.ENTRIES);
        r2 = frames[frame2 + TwoColorTimeline2.PREV_R];
        g2 = frames[frame2 + TwoColorTimeline2.PREV_G];
        b2 = frames[frame2 + TwoColorTimeline2.PREV_B];
        a2 = frames[frame2 + TwoColorTimeline2.PREV_A];
        r22 = frames[frame2 + TwoColorTimeline2.PREV_R2];
        g22 = frames[frame2 + TwoColorTimeline2.PREV_G2];
        b22 = frames[frame2 + TwoColorTimeline2.PREV_B2];
        var frameTime = frames[frame2];
        var percent2 = this.getCurvePercent(frame2 / TwoColorTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame2 + TwoColorTimeline2.PREV_TIME] - frameTime));
        r2 += (frames[frame2 + TwoColorTimeline2.R] - r2) * percent2;
        g2 += (frames[frame2 + TwoColorTimeline2.G] - g2) * percent2;
        b2 += (frames[frame2 + TwoColorTimeline2.B] - b2) * percent2;
        a2 += (frames[frame2 + TwoColorTimeline2.A] - a2) * percent2;
        r22 += (frames[frame2 + TwoColorTimeline2.R2] - r22) * percent2;
        g22 += (frames[frame2 + TwoColorTimeline2.G2] - g22) * percent2;
        b22 += (frames[frame2 + TwoColorTimeline2.B2] - b22) * percent2;
      }
      if (alpha2 == 1) {
        slot.color.set(r2, g2, b2, a2);
        slot.darkColor.set(r22, g22, b22, 1);
      } else {
        var light = slot.color, dark = slot.darkColor;
        if (blend == MixBlend.setup) {
          light.setFromColor(slot.data.color);
          dark.setFromColor(slot.data.darkColor);
        }
        light.add((r2 - light.r) * alpha2, (g2 - light.g) * alpha2, (b2 - light.b) * alpha2, (a2 - light.a) * alpha2);
        dark.add((r22 - dark.r) * alpha2, (g22 - dark.g) * alpha2, (b22 - dark.b) * alpha2, 0);
      }
    };
    TwoColorTimeline2.ENTRIES = 8;
    TwoColorTimeline2.PREV_TIME = -8;
    TwoColorTimeline2.PREV_R = -7;
    TwoColorTimeline2.PREV_G = -6;
    TwoColorTimeline2.PREV_B = -5;
    TwoColorTimeline2.PREV_A = -4;
    TwoColorTimeline2.PREV_R2 = -3;
    TwoColorTimeline2.PREV_G2 = -2;
    TwoColorTimeline2.PREV_B2 = -1;
    TwoColorTimeline2.R = 1;
    TwoColorTimeline2.G = 2;
    TwoColorTimeline2.B = 3;
    TwoColorTimeline2.A = 4;
    TwoColorTimeline2.R2 = 5;
    TwoColorTimeline2.G2 = 6;
    TwoColorTimeline2.B2 = 7;
    return TwoColorTimeline2;
  }(CurveTimeline$2)
);
var AttachmentTimeline$2 = (
  /** @class */
  function() {
    function AttachmentTimeline2(frameCount) {
      this.frames = Utils.newFloatArray(frameCount);
      this.attachmentNames = new Array(frameCount);
    }
    AttachmentTimeline2.prototype.getPropertyId = function() {
      return (TimelineType$1.attachment << 24) + this.slotIndex;
    };
    AttachmentTimeline2.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    AttachmentTimeline2.prototype.setFrame = function(frameIndex, time, attachmentName) {
      this.frames[frameIndex] = time;
      this.attachmentNames[frameIndex] = attachmentName;
    };
    AttachmentTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      if (direction == MixDirection.mixOut) {
        if (blend == MixBlend.setup)
          this.setAttachment(skeleton, slot, slot.data.attachmentName);
        return;
      }
      var frames = this.frames;
      if (time < frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first)
          this.setAttachment(skeleton, slot, slot.data.attachmentName);
        return;
      }
      var frameIndex = 0;
      if (time >= frames[frames.length - 1])
        frameIndex = frames.length - 1;
      else
        frameIndex = Animation$2.binarySearch(frames, time, 1) - 1;
      var attachmentName = this.attachmentNames[frameIndex];
      skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
    };
    AttachmentTimeline2.prototype.setAttachment = function(skeleton, slot, attachmentName) {
      slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
    };
    return AttachmentTimeline2;
  }()
);
var zeros$1 = null;
var DeformTimeline$2 = (
  /** @class */
  function(_super) {
    __extends$4(DeformTimeline2, _super);
    function DeformTimeline2(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount);
      _this.frameVertices = new Array(frameCount);
      if (zeros$1 == null)
        zeros$1 = Utils.newFloatArray(64);
      return _this;
    }
    DeformTimeline2.prototype.getPropertyId = function() {
      return (TimelineType$1.deform << 27) + +this.attachment.id + this.slotIndex;
    };
    DeformTimeline2.prototype.setFrame = function(frameIndex, time, vertices) {
      this.frames[frameIndex] = time;
      this.frameVertices[frameIndex] = vertices;
    };
    DeformTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      var slotAttachment = slot.getAttachment();
      if (!(slotAttachment instanceof VertexAttachment$2) || !(slotAttachment.deformAttachment == this.attachment))
        return;
      var deformArray = slot.deform;
      if (deformArray.length == 0)
        blend = MixBlend.setup;
      var frameVertices = this.frameVertices;
      var vertexCount = frameVertices[0].length;
      var frames = this.frames;
      if (time < frames[0]) {
        var vertexAttachment = slotAttachment;
        switch (blend) {
          case MixBlend.setup:
            deformArray.length = 0;
            return;
          case MixBlend.first:
            if (alpha2 == 1) {
              deformArray.length = 0;
              break;
            }
            var deform_1 = Utils.setArraySize(deformArray, vertexCount);
            if (vertexAttachment.bones == null) {
              var setupVertices = vertexAttachment.vertices;
              for (var i2 = 0; i2 < vertexCount; i2++)
                deform_1[i2] += (setupVertices[i2] - deform_1[i2]) * alpha2;
            } else {
              alpha2 = 1 - alpha2;
              for (var i2 = 0; i2 < vertexCount; i2++)
                deform_1[i2] *= alpha2;
            }
        }
        return;
      }
      var deform = Utils.setArraySize(deformArray, vertexCount);
      if (time >= frames[frames.length - 1]) {
        var lastVertices = frameVertices[frames.length - 1];
        if (alpha2 == 1) {
          if (blend == MixBlend.add) {
            var vertexAttachment = slotAttachment;
            if (vertexAttachment.bones == null) {
              var setupVertices = vertexAttachment.vertices;
              for (var i_1 = 0; i_1 < vertexCount; i_1++) {
                deform[i_1] += lastVertices[i_1] - setupVertices[i_1];
              }
            } else {
              for (var i_2 = 0; i_2 < vertexCount; i_2++)
                deform[i_2] += lastVertices[i_2];
            }
          } else {
            Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);
          }
        } else {
          switch (blend) {
            case MixBlend.setup: {
              var vertexAttachment_1 = slotAttachment;
              if (vertexAttachment_1.bones == null) {
                var setupVertices = vertexAttachment_1.vertices;
                for (var i_3 = 0; i_3 < vertexCount; i_3++) {
                  var setup = setupVertices[i_3];
                  deform[i_3] = setup + (lastVertices[i_3] - setup) * alpha2;
                }
              } else {
                for (var i_4 = 0; i_4 < vertexCount; i_4++)
                  deform[i_4] = lastVertices[i_4] * alpha2;
              }
              break;
            }
            case MixBlend.first:
            case MixBlend.replace:
              for (var i_5 = 0; i_5 < vertexCount; i_5++)
                deform[i_5] += (lastVertices[i_5] - deform[i_5]) * alpha2;
              break;
            case MixBlend.add:
              var vertexAttachment = slotAttachment;
              if (vertexAttachment.bones == null) {
                var setupVertices = vertexAttachment.vertices;
                for (var i_6 = 0; i_6 < vertexCount; i_6++) {
                  deform[i_6] += (lastVertices[i_6] - setupVertices[i_6]) * alpha2;
                }
              } else {
                for (var i_7 = 0; i_7 < vertexCount; i_7++)
                  deform[i_7] += lastVertices[i_7] * alpha2;
              }
          }
        }
        return;
      }
      var frame2 = Animation$2.binarySearch(frames, time);
      var prevVertices = frameVertices[frame2 - 1];
      var nextVertices = frameVertices[frame2];
      var frameTime = frames[frame2];
      var percent2 = this.getCurvePercent(frame2 - 1, 1 - (time - frameTime) / (frames[frame2 - 1] - frameTime));
      if (alpha2 == 1) {
        if (blend == MixBlend.add) {
          var vertexAttachment = slotAttachment;
          if (vertexAttachment.bones == null) {
            var setupVertices = vertexAttachment.vertices;
            for (var i_8 = 0; i_8 < vertexCount; i_8++) {
              var prev2 = prevVertices[i_8];
              deform[i_8] += prev2 + (nextVertices[i_8] - prev2) * percent2 - setupVertices[i_8];
            }
          } else {
            for (var i_9 = 0; i_9 < vertexCount; i_9++) {
              var prev2 = prevVertices[i_9];
              deform[i_9] += prev2 + (nextVertices[i_9] - prev2) * percent2;
            }
          }
        } else {
          for (var i_10 = 0; i_10 < vertexCount; i_10++) {
            var prev2 = prevVertices[i_10];
            deform[i_10] = prev2 + (nextVertices[i_10] - prev2) * percent2;
          }
        }
      } else {
        switch (blend) {
          case MixBlend.setup: {
            var vertexAttachment_2 = slotAttachment;
            if (vertexAttachment_2.bones == null) {
              var setupVertices = vertexAttachment_2.vertices;
              for (var i_11 = 0; i_11 < vertexCount; i_11++) {
                var prev2 = prevVertices[i_11], setup = setupVertices[i_11];
                deform[i_11] = setup + (prev2 + (nextVertices[i_11] - prev2) * percent2 - setup) * alpha2;
              }
            } else {
              for (var i_12 = 0; i_12 < vertexCount; i_12++) {
                var prev2 = prevVertices[i_12];
                deform[i_12] = (prev2 + (nextVertices[i_12] - prev2) * percent2) * alpha2;
              }
            }
            break;
          }
          case MixBlend.first:
          case MixBlend.replace:
            for (var i_13 = 0; i_13 < vertexCount; i_13++) {
              var prev2 = prevVertices[i_13];
              deform[i_13] += (prev2 + (nextVertices[i_13] - prev2) * percent2 - deform[i_13]) * alpha2;
            }
            break;
          case MixBlend.add:
            var vertexAttachment = slotAttachment;
            if (vertexAttachment.bones == null) {
              var setupVertices = vertexAttachment.vertices;
              for (var i_14 = 0; i_14 < vertexCount; i_14++) {
                var prev2 = prevVertices[i_14];
                deform[i_14] += (prev2 + (nextVertices[i_14] - prev2) * percent2 - setupVertices[i_14]) * alpha2;
              }
            } else {
              for (var i_15 = 0; i_15 < vertexCount; i_15++) {
                var prev2 = prevVertices[i_15];
                deform[i_15] += (prev2 + (nextVertices[i_15] - prev2) * percent2) * alpha2;
              }
            }
        }
      }
    };
    return DeformTimeline2;
  }(CurveTimeline$2)
);
var EventTimeline$2 = (
  /** @class */
  function() {
    function EventTimeline2(frameCount) {
      this.frames = Utils.newFloatArray(frameCount);
      this.events = new Array(frameCount);
    }
    EventTimeline2.prototype.getPropertyId = function() {
      return TimelineType$1.event << 24;
    };
    EventTimeline2.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    EventTimeline2.prototype.setFrame = function(frameIndex, event) {
      this.frames[frameIndex] = event.time;
      this.events[frameIndex] = event;
    };
    EventTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      if (firedEvents == null)
        return;
      var frames = this.frames;
      var frameCount = this.frames.length;
      if (lastTime2 > time) {
        this.apply(skeleton, lastTime2, Number.MAX_VALUE, firedEvents, alpha2, blend, direction);
        lastTime2 = -1;
      } else if (lastTime2 >= frames[frameCount - 1])
        return;
      if (time < frames[0])
        return;
      var frame2 = 0;
      if (lastTime2 < frames[0])
        frame2 = 0;
      else {
        frame2 = Animation$2.binarySearch(frames, lastTime2);
        var frameTime = frames[frame2];
        while (frame2 > 0) {
          if (frames[frame2 - 1] != frameTime)
            break;
          frame2--;
        }
      }
      for (; frame2 < frameCount && time >= frames[frame2]; frame2++)
        firedEvents.push(this.events[frame2]);
    };
    return EventTimeline2;
  }()
);
var DrawOrderTimeline$2 = (
  /** @class */
  function() {
    function DrawOrderTimeline2(frameCount) {
      this.frames = Utils.newFloatArray(frameCount);
      this.drawOrders = new Array(frameCount);
    }
    DrawOrderTimeline2.prototype.getPropertyId = function() {
      return TimelineType$1.drawOrder << 24;
    };
    DrawOrderTimeline2.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    DrawOrderTimeline2.prototype.setFrame = function(frameIndex, time, drawOrder) {
      this.frames[frameIndex] = time;
      this.drawOrders[frameIndex] = drawOrder;
    };
    DrawOrderTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      var drawOrder = skeleton.drawOrder;
      var slots = skeleton.slots;
      if (direction == MixDirection.mixOut && blend == MixBlend.setup) {
        Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
        return;
      }
      var frames = this.frames;
      if (time < frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first)
          Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
        return;
      }
      var frame2 = 0;
      if (time >= frames[frames.length - 1])
        frame2 = frames.length - 1;
      else
        frame2 = Animation$2.binarySearch(frames, time) - 1;
      var drawOrderToSetupIndex = this.drawOrders[frame2];
      if (drawOrderToSetupIndex == null)
        Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);
      else {
        for (var i2 = 0, n2 = drawOrderToSetupIndex.length; i2 < n2; i2++)
          drawOrder[i2] = slots[drawOrderToSetupIndex[i2]];
      }
    };
    return DrawOrderTimeline2;
  }()
);
var IkConstraintTimeline$2 = (
  /** @class */
  function(_super) {
    __extends$4(IkConstraintTimeline2, _super);
    function IkConstraintTimeline2(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * IkConstraintTimeline2.ENTRIES);
      return _this;
    }
    IkConstraintTimeline2.prototype.getPropertyId = function() {
      return (TimelineType$1.ikConstraint << 24) + this.ikConstraintIndex;
    };
    IkConstraintTimeline2.prototype.setFrame = function(frameIndex, time, mix2, softness, bendDirection, compress, stretch) {
      frameIndex *= IkConstraintTimeline2.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + IkConstraintTimeline2.MIX] = mix2;
      this.frames[frameIndex + IkConstraintTimeline2.SOFTNESS] = softness;
      this.frames[frameIndex + IkConstraintTimeline2.BEND_DIRECTION] = bendDirection;
      this.frames[frameIndex + IkConstraintTimeline2.COMPRESS] = compress ? 1 : 0;
      this.frames[frameIndex + IkConstraintTimeline2.STRETCH] = stretch ? 1 : 0;
    };
    IkConstraintTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      var frames = this.frames;
      var constraint = skeleton.ikConstraints[this.ikConstraintIndex];
      if (!constraint.active)
        return;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.mix = constraint.data.mix;
            constraint.softness = constraint.data.softness;
            constraint.bendDirection = constraint.data.bendDirection;
            constraint.compress = constraint.data.compress;
            constraint.stretch = constraint.data.stretch;
            return;
          case MixBlend.first:
            constraint.mix += (constraint.data.mix - constraint.mix) * alpha2;
            constraint.softness += (constraint.data.softness - constraint.softness) * alpha2;
            constraint.bendDirection = constraint.data.bendDirection;
            constraint.compress = constraint.data.compress;
            constraint.stretch = constraint.data.stretch;
        }
        return;
      }
      if (time >= frames[frames.length - IkConstraintTimeline2.ENTRIES]) {
        if (blend == MixBlend.setup) {
          constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline2.PREV_MIX] - constraint.data.mix) * alpha2;
          constraint.softness = constraint.data.softness + (frames[frames.length + IkConstraintTimeline2.PREV_SOFTNESS] - constraint.data.softness) * alpha2;
          if (direction == MixDirection.mixOut) {
            constraint.bendDirection = constraint.data.bendDirection;
            constraint.compress = constraint.data.compress;
            constraint.stretch = constraint.data.stretch;
          } else {
            constraint.bendDirection = frames[frames.length + IkConstraintTimeline2.PREV_BEND_DIRECTION];
            constraint.compress = frames[frames.length + IkConstraintTimeline2.PREV_COMPRESS] != 0;
            constraint.stretch = frames[frames.length + IkConstraintTimeline2.PREV_STRETCH] != 0;
          }
        } else {
          constraint.mix += (frames[frames.length + IkConstraintTimeline2.PREV_MIX] - constraint.mix) * alpha2;
          constraint.softness += (frames[frames.length + IkConstraintTimeline2.PREV_SOFTNESS] - constraint.softness) * alpha2;
          if (direction == MixDirection.mixIn) {
            constraint.bendDirection = frames[frames.length + IkConstraintTimeline2.PREV_BEND_DIRECTION];
            constraint.compress = frames[frames.length + IkConstraintTimeline2.PREV_COMPRESS] != 0;
            constraint.stretch = frames[frames.length + IkConstraintTimeline2.PREV_STRETCH] != 0;
          }
        }
        return;
      }
      var frame2 = Animation$2.binarySearch(frames, time, IkConstraintTimeline2.ENTRIES);
      var mix2 = frames[frame2 + IkConstraintTimeline2.PREV_MIX];
      var softness = frames[frame2 + IkConstraintTimeline2.PREV_SOFTNESS];
      var frameTime = frames[frame2];
      var percent2 = this.getCurvePercent(frame2 / IkConstraintTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame2 + IkConstraintTimeline2.PREV_TIME] - frameTime));
      if (blend == MixBlend.setup) {
        constraint.mix = constraint.data.mix + (mix2 + (frames[frame2 + IkConstraintTimeline2.MIX] - mix2) * percent2 - constraint.data.mix) * alpha2;
        constraint.softness = constraint.data.softness + (softness + (frames[frame2 + IkConstraintTimeline2.SOFTNESS] - softness) * percent2 - constraint.data.softness) * alpha2;
        if (direction == MixDirection.mixOut) {
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
        } else {
          constraint.bendDirection = frames[frame2 + IkConstraintTimeline2.PREV_BEND_DIRECTION];
          constraint.compress = frames[frame2 + IkConstraintTimeline2.PREV_COMPRESS] != 0;
          constraint.stretch = frames[frame2 + IkConstraintTimeline2.PREV_STRETCH] != 0;
        }
      } else {
        constraint.mix += (mix2 + (frames[frame2 + IkConstraintTimeline2.MIX] - mix2) * percent2 - constraint.mix) * alpha2;
        constraint.softness += (softness + (frames[frame2 + IkConstraintTimeline2.SOFTNESS] - softness) * percent2 - constraint.softness) * alpha2;
        if (direction == MixDirection.mixIn) {
          constraint.bendDirection = frames[frame2 + IkConstraintTimeline2.PREV_BEND_DIRECTION];
          constraint.compress = frames[frame2 + IkConstraintTimeline2.PREV_COMPRESS] != 0;
          constraint.stretch = frames[frame2 + IkConstraintTimeline2.PREV_STRETCH] != 0;
        }
      }
    };
    IkConstraintTimeline2.ENTRIES = 6;
    IkConstraintTimeline2.PREV_TIME = -6;
    IkConstraintTimeline2.PREV_MIX = -5;
    IkConstraintTimeline2.PREV_SOFTNESS = -4;
    IkConstraintTimeline2.PREV_BEND_DIRECTION = -3;
    IkConstraintTimeline2.PREV_COMPRESS = -2;
    IkConstraintTimeline2.PREV_STRETCH = -1;
    IkConstraintTimeline2.MIX = 1;
    IkConstraintTimeline2.SOFTNESS = 2;
    IkConstraintTimeline2.BEND_DIRECTION = 3;
    IkConstraintTimeline2.COMPRESS = 4;
    IkConstraintTimeline2.STRETCH = 5;
    return IkConstraintTimeline2;
  }(CurveTimeline$2)
);
var TransformConstraintTimeline$2 = (
  /** @class */
  function(_super) {
    __extends$4(TransformConstraintTimeline2, _super);
    function TransformConstraintTimeline2(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * TransformConstraintTimeline2.ENTRIES);
      return _this;
    }
    TransformConstraintTimeline2.prototype.getPropertyId = function() {
      return (TimelineType$1.transformConstraint << 24) + this.transformConstraintIndex;
    };
    TransformConstraintTimeline2.prototype.setFrame = function(frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {
      frameIndex *= TransformConstraintTimeline2.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + TransformConstraintTimeline2.ROTATE] = rotateMix;
      this.frames[frameIndex + TransformConstraintTimeline2.TRANSLATE] = translateMix;
      this.frames[frameIndex + TransformConstraintTimeline2.SCALE] = scaleMix;
      this.frames[frameIndex + TransformConstraintTimeline2.SHEAR] = shearMix;
    };
    TransformConstraintTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      var frames = this.frames;
      var constraint = skeleton.transformConstraints[this.transformConstraintIndex];
      if (!constraint.active)
        return;
      if (time < frames[0]) {
        var data2 = constraint.data;
        switch (blend) {
          case MixBlend.setup:
            constraint.rotateMix = data2.rotateMix;
            constraint.translateMix = data2.translateMix;
            constraint.scaleMix = data2.scaleMix;
            constraint.shearMix = data2.shearMix;
            return;
          case MixBlend.first:
            constraint.rotateMix += (data2.rotateMix - constraint.rotateMix) * alpha2;
            constraint.translateMix += (data2.translateMix - constraint.translateMix) * alpha2;
            constraint.scaleMix += (data2.scaleMix - constraint.scaleMix) * alpha2;
            constraint.shearMix += (data2.shearMix - constraint.shearMix) * alpha2;
        }
        return;
      }
      var rotate = 0, translate = 0, scale = 0, shear = 0;
      if (time >= frames[frames.length - TransformConstraintTimeline2.ENTRIES]) {
        var i2 = frames.length;
        rotate = frames[i2 + TransformConstraintTimeline2.PREV_ROTATE];
        translate = frames[i2 + TransformConstraintTimeline2.PREV_TRANSLATE];
        scale = frames[i2 + TransformConstraintTimeline2.PREV_SCALE];
        shear = frames[i2 + TransformConstraintTimeline2.PREV_SHEAR];
      } else {
        var frame2 = Animation$2.binarySearch(frames, time, TransformConstraintTimeline2.ENTRIES);
        rotate = frames[frame2 + TransformConstraintTimeline2.PREV_ROTATE];
        translate = frames[frame2 + TransformConstraintTimeline2.PREV_TRANSLATE];
        scale = frames[frame2 + TransformConstraintTimeline2.PREV_SCALE];
        shear = frames[frame2 + TransformConstraintTimeline2.PREV_SHEAR];
        var frameTime = frames[frame2];
        var percent2 = this.getCurvePercent(frame2 / TransformConstraintTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame2 + TransformConstraintTimeline2.PREV_TIME] - frameTime));
        rotate += (frames[frame2 + TransformConstraintTimeline2.ROTATE] - rotate) * percent2;
        translate += (frames[frame2 + TransformConstraintTimeline2.TRANSLATE] - translate) * percent2;
        scale += (frames[frame2 + TransformConstraintTimeline2.SCALE] - scale) * percent2;
        shear += (frames[frame2 + TransformConstraintTimeline2.SHEAR] - shear) * percent2;
      }
      if (blend == MixBlend.setup) {
        var data2 = constraint.data;
        constraint.rotateMix = data2.rotateMix + (rotate - data2.rotateMix) * alpha2;
        constraint.translateMix = data2.translateMix + (translate - data2.translateMix) * alpha2;
        constraint.scaleMix = data2.scaleMix + (scale - data2.scaleMix) * alpha2;
        constraint.shearMix = data2.shearMix + (shear - data2.shearMix) * alpha2;
      } else {
        constraint.rotateMix += (rotate - constraint.rotateMix) * alpha2;
        constraint.translateMix += (translate - constraint.translateMix) * alpha2;
        constraint.scaleMix += (scale - constraint.scaleMix) * alpha2;
        constraint.shearMix += (shear - constraint.shearMix) * alpha2;
      }
    };
    TransformConstraintTimeline2.ENTRIES = 5;
    TransformConstraintTimeline2.PREV_TIME = -5;
    TransformConstraintTimeline2.PREV_ROTATE = -4;
    TransformConstraintTimeline2.PREV_TRANSLATE = -3;
    TransformConstraintTimeline2.PREV_SCALE = -2;
    TransformConstraintTimeline2.PREV_SHEAR = -1;
    TransformConstraintTimeline2.ROTATE = 1;
    TransformConstraintTimeline2.TRANSLATE = 2;
    TransformConstraintTimeline2.SCALE = 3;
    TransformConstraintTimeline2.SHEAR = 4;
    return TransformConstraintTimeline2;
  }(CurveTimeline$2)
);
var PathConstraintPositionTimeline$2 = (
  /** @class */
  function(_super) {
    __extends$4(PathConstraintPositionTimeline2, _super);
    function PathConstraintPositionTimeline2(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * PathConstraintPositionTimeline2.ENTRIES);
      return _this;
    }
    PathConstraintPositionTimeline2.prototype.getPropertyId = function() {
      return (TimelineType$1.pathConstraintPosition << 24) + this.pathConstraintIndex;
    };
    PathConstraintPositionTimeline2.prototype.setFrame = function(frameIndex, time, value) {
      frameIndex *= PathConstraintPositionTimeline2.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + PathConstraintPositionTimeline2.VALUE] = value;
    };
    PathConstraintPositionTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      var frames = this.frames;
      var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
      if (!constraint.active)
        return;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.position = constraint.data.position;
            return;
          case MixBlend.first:
            constraint.position += (constraint.data.position - constraint.position) * alpha2;
        }
        return;
      }
      var position2 = 0;
      if (time >= frames[frames.length - PathConstraintPositionTimeline2.ENTRIES])
        position2 = frames[frames.length + PathConstraintPositionTimeline2.PREV_VALUE];
      else {
        var frame2 = Animation$2.binarySearch(frames, time, PathConstraintPositionTimeline2.ENTRIES);
        position2 = frames[frame2 + PathConstraintPositionTimeline2.PREV_VALUE];
        var frameTime = frames[frame2];
        var percent2 = this.getCurvePercent(frame2 / PathConstraintPositionTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame2 + PathConstraintPositionTimeline2.PREV_TIME] - frameTime));
        position2 += (frames[frame2 + PathConstraintPositionTimeline2.VALUE] - position2) * percent2;
      }
      if (blend == MixBlend.setup)
        constraint.position = constraint.data.position + (position2 - constraint.data.position) * alpha2;
      else
        constraint.position += (position2 - constraint.position) * alpha2;
    };
    PathConstraintPositionTimeline2.ENTRIES = 2;
    PathConstraintPositionTimeline2.PREV_TIME = -2;
    PathConstraintPositionTimeline2.PREV_VALUE = -1;
    PathConstraintPositionTimeline2.VALUE = 1;
    return PathConstraintPositionTimeline2;
  }(CurveTimeline$2)
);
var PathConstraintSpacingTimeline$2 = (
  /** @class */
  function(_super) {
    __extends$4(PathConstraintSpacingTimeline2, _super);
    function PathConstraintSpacingTimeline2(frameCount) {
      return _super.call(this, frameCount) || this;
    }
    PathConstraintSpacingTimeline2.prototype.getPropertyId = function() {
      return (TimelineType$1.pathConstraintSpacing << 24) + this.pathConstraintIndex;
    };
    PathConstraintSpacingTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      var frames = this.frames;
      var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
      if (!constraint.active)
        return;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.spacing = constraint.data.spacing;
            return;
          case MixBlend.first:
            constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha2;
        }
        return;
      }
      var spacing = 0;
      if (time >= frames[frames.length - PathConstraintSpacingTimeline2.ENTRIES])
        spacing = frames[frames.length + PathConstraintSpacingTimeline2.PREV_VALUE];
      else {
        var frame2 = Animation$2.binarySearch(frames, time, PathConstraintSpacingTimeline2.ENTRIES);
        spacing = frames[frame2 + PathConstraintSpacingTimeline2.PREV_VALUE];
        var frameTime = frames[frame2];
        var percent2 = this.getCurvePercent(frame2 / PathConstraintSpacingTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame2 + PathConstraintSpacingTimeline2.PREV_TIME] - frameTime));
        spacing += (frames[frame2 + PathConstraintSpacingTimeline2.VALUE] - spacing) * percent2;
      }
      if (blend == MixBlend.setup)
        constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha2;
      else
        constraint.spacing += (spacing - constraint.spacing) * alpha2;
    };
    return PathConstraintSpacingTimeline2;
  }(PathConstraintPositionTimeline$2)
);
var PathConstraintMixTimeline$2 = (
  /** @class */
  function(_super) {
    __extends$4(PathConstraintMixTimeline2, _super);
    function PathConstraintMixTimeline2(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * PathConstraintMixTimeline2.ENTRIES);
      return _this;
    }
    PathConstraintMixTimeline2.prototype.getPropertyId = function() {
      return (TimelineType$1.pathConstraintMix << 24) + this.pathConstraintIndex;
    };
    PathConstraintMixTimeline2.prototype.setFrame = function(frameIndex, time, rotateMix, translateMix) {
      frameIndex *= PathConstraintMixTimeline2.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + PathConstraintMixTimeline2.ROTATE] = rotateMix;
      this.frames[frameIndex + PathConstraintMixTimeline2.TRANSLATE] = translateMix;
    };
    PathConstraintMixTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      var frames = this.frames;
      var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
      if (!constraint.active)
        return;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.rotateMix = constraint.data.rotateMix;
            constraint.translateMix = constraint.data.translateMix;
            return;
          case MixBlend.first:
            constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha2;
            constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha2;
        }
        return;
      }
      var rotate = 0, translate = 0;
      if (time >= frames[frames.length - PathConstraintMixTimeline2.ENTRIES]) {
        rotate = frames[frames.length + PathConstraintMixTimeline2.PREV_ROTATE];
        translate = frames[frames.length + PathConstraintMixTimeline2.PREV_TRANSLATE];
      } else {
        var frame2 = Animation$2.binarySearch(frames, time, PathConstraintMixTimeline2.ENTRIES);
        rotate = frames[frame2 + PathConstraintMixTimeline2.PREV_ROTATE];
        translate = frames[frame2 + PathConstraintMixTimeline2.PREV_TRANSLATE];
        var frameTime = frames[frame2];
        var percent2 = this.getCurvePercent(frame2 / PathConstraintMixTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame2 + PathConstraintMixTimeline2.PREV_TIME] - frameTime));
        rotate += (frames[frame2 + PathConstraintMixTimeline2.ROTATE] - rotate) * percent2;
        translate += (frames[frame2 + PathConstraintMixTimeline2.TRANSLATE] - translate) * percent2;
      }
      if (blend == MixBlend.setup) {
        constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha2;
        constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha2;
      } else {
        constraint.rotateMix += (rotate - constraint.rotateMix) * alpha2;
        constraint.translateMix += (translate - constraint.translateMix) * alpha2;
      }
    };
    PathConstraintMixTimeline2.ENTRIES = 3;
    PathConstraintMixTimeline2.PREV_TIME = -3;
    PathConstraintMixTimeline2.PREV_ROTATE = -2;
    PathConstraintMixTimeline2.PREV_TRANSLATE = -1;
    PathConstraintMixTimeline2.ROTATE = 1;
    PathConstraintMixTimeline2.TRANSLATE = 2;
    return PathConstraintMixTimeline2;
  }(CurveTimeline$2)
);
var AnimationState$2 = (
  /** @class */
  function() {
    function AnimationState2(data2) {
      this.tracks = new Array();
      this.timeScale = 1;
      this.unkeyedState = 0;
      this.events = new Array();
      this.listeners = new Array();
      this.queue = new EventQueue$2(this);
      this.propertyIDs = new IntSet();
      this.animationsChanged = false;
      this.trackEntryPool = new Pool(function() {
        return new TrackEntry$2();
      });
      this.data = data2;
    }
    AnimationState2.prototype.update = function(delta) {
      delta *= this.timeScale;
      var tracks = this.tracks;
      for (var i2 = 0, n2 = tracks.length; i2 < n2; i2++) {
        var current = tracks[i2];
        if (current == null)
          continue;
        current.animationLast = current.nextAnimationLast;
        current.trackLast = current.nextTrackLast;
        var currentDelta = delta * current.timeScale;
        if (current.delay > 0) {
          current.delay -= currentDelta;
          if (current.delay > 0)
            continue;
          currentDelta = -current.delay;
          current.delay = 0;
        }
        var next2 = current.next;
        if (next2 != null) {
          var nextTime = current.trackLast - next2.delay;
          if (nextTime >= 0) {
            next2.delay = 0;
            next2.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next2.timeScale;
            current.trackTime += currentDelta;
            this.setCurrent(i2, next2, true);
            while (next2.mixingFrom != null) {
              next2.mixTime += delta;
              next2 = next2.mixingFrom;
            }
            continue;
          }
        } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {
          tracks[i2] = null;
          this.queue.end(current);
          this.disposeNext(current);
          continue;
        }
        if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {
          var from2 = current.mixingFrom;
          current.mixingFrom = null;
          if (from2 != null)
            from2.mixingTo = null;
          while (from2 != null) {
            this.queue.end(from2);
            from2 = from2.mixingFrom;
          }
        }
        current.trackTime += currentDelta;
      }
      this.queue.drain();
    };
    AnimationState2.prototype.updateMixingFrom = function(to, delta) {
      var from2 = to.mixingFrom;
      if (from2 == null)
        return true;
      var finished = this.updateMixingFrom(from2, delta);
      from2.animationLast = from2.nextAnimationLast;
      from2.trackLast = from2.nextTrackLast;
      if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {
        if (from2.totalAlpha == 0 || to.mixDuration == 0) {
          to.mixingFrom = from2.mixingFrom;
          if (from2.mixingFrom != null)
            from2.mixingFrom.mixingTo = to;
          to.interruptAlpha = from2.interruptAlpha;
          this.queue.end(from2);
        }
        return finished;
      }
      from2.trackTime += delta * from2.timeScale;
      to.mixTime += delta;
      return false;
    };
    AnimationState2.prototype.apply = function(skeleton) {
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      if (this.animationsChanged)
        this._animationsChanged();
      var events = this.events;
      var tracks = this.tracks;
      var applied = false;
      for (var i_1 = 0, n_1 = tracks.length; i_1 < n_1; i_1++) {
        var current = tracks[i_1];
        if (current == null || current.delay > 0)
          continue;
        applied = true;
        var blend = i_1 == 0 ? MixBlend.first : current.mixBlend;
        var mix2 = current.alpha;
        if (current.mixingFrom != null)
          mix2 *= this.applyMixingFrom(current, skeleton, blend);
        else if (current.trackTime >= current.trackEnd && current.next == null)
          mix2 = 0;
        var animationLast = current.animationLast, animationTime = current.getAnimationTime();
        var timelineCount = current.animation.timelines.length;
        var timelines = current.animation.timelines;
        if (i_1 == 0 && mix2 == 1 || blend == MixBlend.add) {
          for (var ii2 = 0; ii2 < timelineCount; ii2++) {
            Utils.webkit602BugfixHelper(mix2, blend);
            var timeline = timelines[ii2];
            if (timeline instanceof AttachmentTimeline$2)
              this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);
            else
              timeline.apply(skeleton, animationLast, animationTime, events, mix2, blend, MixDirection.mixIn);
          }
        } else {
          var timelineMode = current.timelineMode;
          var firstFrame = current.timelinesRotation.length == 0;
          if (firstFrame)
            Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);
          var timelinesRotation = current.timelinesRotation;
          for (var ii2 = 0; ii2 < timelineCount; ii2++) {
            var timeline_1 = timelines[ii2];
            var timelineBlend = timelineMode[ii2] == AnimationState2.SUBSEQUENT ? blend : MixBlend.setup;
            if (timeline_1 instanceof RotateTimeline$2) {
              this.applyRotateTimeline(timeline_1, skeleton, animationTime, mix2, timelineBlend, timelinesRotation, ii2 << 1, firstFrame);
            } else if (timeline_1 instanceof AttachmentTimeline$2) {
              this.applyAttachmentTimeline(timeline_1, skeleton, animationTime, blend, true);
            } else {
              Utils.webkit602BugfixHelper(mix2, blend);
              timeline_1.apply(skeleton, animationLast, animationTime, events, mix2, timelineBlend, MixDirection.mixIn);
            }
          }
        }
        this.queueEvents(current, animationTime);
        events.length = 0;
        current.nextAnimationLast = animationTime;
        current.nextTrackLast = current.trackTime;
      }
      var setupState = this.unkeyedState + AnimationState2.SETUP;
      var slots = skeleton.slots;
      for (var i2 = 0, n2 = skeleton.slots.length; i2 < n2; i2++) {
        var slot = slots[i2];
        if (slot.attachmentState == setupState) {
          var attachmentName = slot.data.attachmentName;
          slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));
        }
      }
      this.unkeyedState += 2;
      this.queue.drain();
      return applied;
    };
    AnimationState2.prototype.applyMixingFrom = function(to, skeleton, blend) {
      var from2 = to.mixingFrom;
      if (from2.mixingFrom != null)
        this.applyMixingFrom(from2, skeleton, blend);
      var mix2 = 0;
      if (to.mixDuration == 0) {
        mix2 = 1;
        if (blend == MixBlend.first)
          blend = MixBlend.setup;
      } else {
        mix2 = to.mixTime / to.mixDuration;
        if (mix2 > 1)
          mix2 = 1;
        if (blend != MixBlend.first)
          blend = from2.mixBlend;
      }
      var events = mix2 < from2.eventThreshold ? this.events : null;
      var attachments = mix2 < from2.attachmentThreshold, drawOrder = mix2 < from2.drawOrderThreshold;
      var animationLast = from2.animationLast, animationTime = from2.getAnimationTime();
      var timelineCount = from2.animation.timelines.length;
      var timelines = from2.animation.timelines;
      var alphaHold = from2.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix2);
      if (blend == MixBlend.add) {
        for (var i2 = 0; i2 < timelineCount; i2++)
          timelines[i2].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, MixDirection.mixOut);
      } else {
        var timelineMode = from2.timelineMode;
        var timelineHoldMix = from2.timelineHoldMix;
        var firstFrame = from2.timelinesRotation.length == 0;
        if (firstFrame)
          Utils.setArraySize(from2.timelinesRotation, timelineCount << 1, null);
        var timelinesRotation = from2.timelinesRotation;
        from2.totalAlpha = 0;
        for (var i2 = 0; i2 < timelineCount; i2++) {
          var timeline = timelines[i2];
          var direction = MixDirection.mixOut;
          var timelineBlend = void 0;
          var alpha2 = 0;
          switch (timelineMode[i2]) {
            case AnimationState2.SUBSEQUENT:
              if (!drawOrder && timeline instanceof DrawOrderTimeline$2)
                continue;
              timelineBlend = blend;
              alpha2 = alphaMix;
              break;
            case AnimationState2.FIRST:
              timelineBlend = MixBlend.setup;
              alpha2 = alphaMix;
              break;
            case AnimationState2.HOLD_SUBSEQUENT:
              timelineBlend = blend;
              alpha2 = alphaHold;
              break;
            case AnimationState2.HOLD_FIRST:
              timelineBlend = MixBlend.setup;
              alpha2 = alphaHold;
              break;
            default:
              timelineBlend = MixBlend.setup;
              var holdMix = timelineHoldMix[i2];
              alpha2 = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
              break;
          }
          from2.totalAlpha += alpha2;
          if (timeline instanceof RotateTimeline$2)
            this.applyRotateTimeline(timeline, skeleton, animationTime, alpha2, timelineBlend, timelinesRotation, i2 << 1, firstFrame);
          else if (timeline instanceof AttachmentTimeline$2)
            this.applyAttachmentTimeline(timeline, skeleton, animationTime, timelineBlend, attachments);
          else {
            Utils.webkit602BugfixHelper(alpha2, blend);
            if (drawOrder && timeline instanceof DrawOrderTimeline$2 && timelineBlend == MixBlend.setup)
              direction = MixDirection.mixIn;
            timeline.apply(skeleton, animationLast, animationTime, events, alpha2, timelineBlend, direction);
          }
        }
      }
      if (to.mixDuration > 0)
        this.queueEvents(from2, animationTime);
      this.events.length = 0;
      from2.nextAnimationLast = animationTime;
      from2.nextTrackLast = from2.trackTime;
      return mix2;
    };
    AnimationState2.prototype.applyAttachmentTimeline = function(timeline, skeleton, time, blend, attachments) {
      var slot = skeleton.slots[timeline.slotIndex];
      if (!slot.bone.active)
        return;
      var frames = timeline.frames;
      if (time < frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first)
          this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);
      } else {
        var frameIndex;
        if (time >= frames[frames.length - 1])
          frameIndex = frames.length - 1;
        else
          frameIndex = Animation$2.binarySearch(frames, time) - 1;
        this.setAttachment(skeleton, slot, timeline.attachmentNames[frameIndex], attachments);
      }
      if (slot.attachmentState <= this.unkeyedState)
        slot.attachmentState = this.unkeyedState + AnimationState2.SETUP;
    };
    AnimationState2.prototype.setAttachment = function(skeleton, slot, attachmentName, attachments) {
      slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));
      if (attachments)
        slot.attachmentState = this.unkeyedState + AnimationState2.CURRENT;
    };
    AnimationState2.prototype.applyRotateTimeline = function(timeline, skeleton, time, alpha2, blend, timelinesRotation, i2, firstFrame) {
      if (firstFrame)
        timelinesRotation[i2] = 0;
      if (alpha2 == 1) {
        timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);
        return;
      }
      var rotateTimeline = timeline;
      var frames = rotateTimeline.frames;
      var bone = skeleton.bones[rotateTimeline.boneIndex];
      if (!bone.active)
        return;
      var r1 = 0, r2 = 0;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.rotation = bone.data.rotation;
          default:
            return;
          case MixBlend.first:
            r1 = bone.rotation;
            r2 = bone.data.rotation;
        }
      } else {
        r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;
        if (time >= frames[frames.length - RotateTimeline$2.ENTRIES])
          r2 = bone.data.rotation + frames[frames.length + RotateTimeline$2.PREV_ROTATION];
        else {
          var frame2 = Animation$2.binarySearch(frames, time, RotateTimeline$2.ENTRIES);
          var prevRotation = frames[frame2 + RotateTimeline$2.PREV_ROTATION];
          var frameTime = frames[frame2];
          var percent2 = rotateTimeline.getCurvePercent((frame2 >> 1) - 1, 1 - (time - frameTime) / (frames[frame2 + RotateTimeline$2.PREV_TIME] - frameTime));
          r2 = frames[frame2 + RotateTimeline$2.ROTATION] - prevRotation;
          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
          r2 = prevRotation + r2 * percent2 + bone.data.rotation;
          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
        }
      }
      var total = 0, diff = r2 - r1;
      diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;
      if (diff == 0) {
        total = timelinesRotation[i2];
      } else {
        var lastTotal = 0, lastDiff = 0;
        if (firstFrame) {
          lastTotal = 0;
          lastDiff = diff;
        } else {
          lastTotal = timelinesRotation[i2];
          lastDiff = timelinesRotation[i2 + 1];
        }
        var current = diff > 0, dir = lastTotal >= 0;
        if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
          if (Math.abs(lastTotal) > 180)
            lastTotal += 360 * MathUtils.signum(lastTotal);
          dir = current;
        }
        total = diff + lastTotal - lastTotal % 360;
        if (dir != current)
          total += 360 * MathUtils.signum(lastTotal);
        timelinesRotation[i2] = total;
      }
      timelinesRotation[i2 + 1] = diff;
      r1 += total * alpha2;
      bone.rotation = r1 - (16384 - (16384.499999999996 - r1 / 360 | 0)) * 360;
    };
    AnimationState2.prototype.queueEvents = function(entry, animationTime) {
      var animationStart = entry.animationStart, animationEnd = entry.animationEnd;
      var duration = animationEnd - animationStart;
      var trackLastWrapped = entry.trackLast % duration;
      var events = this.events;
      var i2 = 0, n2 = events.length;
      for (; i2 < n2; i2++) {
        var event_1 = events[i2];
        if (event_1.time < trackLastWrapped)
          break;
        if (event_1.time > animationEnd)
          continue;
        this.queue.event(entry, event_1);
      }
      var complete = false;
      if (entry.loop)
        complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;
      else
        complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
      if (complete)
        this.queue.complete(entry);
      for (; i2 < n2; i2++) {
        var event_2 = events[i2];
        if (event_2.time < animationStart)
          continue;
        this.queue.event(entry, events[i2]);
      }
    };
    AnimationState2.prototype.clearTracks = function() {
      var oldDrainDisabled = this.queue.drainDisabled;
      this.queue.drainDisabled = true;
      for (var i2 = 0, n2 = this.tracks.length; i2 < n2; i2++)
        this.clearTrack(i2);
      this.tracks.length = 0;
      this.queue.drainDisabled = oldDrainDisabled;
      this.queue.drain();
    };
    AnimationState2.prototype.clearTrack = function(trackIndex) {
      if (trackIndex >= this.tracks.length)
        return;
      var current = this.tracks[trackIndex];
      if (current == null)
        return;
      this.queue.end(current);
      this.disposeNext(current);
      var entry = current;
      while (true) {
        var from2 = entry.mixingFrom;
        if (from2 == null)
          break;
        this.queue.end(from2);
        entry.mixingFrom = null;
        entry.mixingTo = null;
        entry = from2;
      }
      this.tracks[current.trackIndex] = null;
      this.queue.drain();
    };
    AnimationState2.prototype.setCurrent = function(index2, current, interrupt) {
      var from2 = this.expandToIndex(index2);
      this.tracks[index2] = current;
      if (from2 != null) {
        if (interrupt)
          this.queue.interrupt(from2);
        current.mixingFrom = from2;
        from2.mixingTo = current;
        current.mixTime = 0;
        if (from2.mixingFrom != null && from2.mixDuration > 0)
          current.interruptAlpha *= Math.min(1, from2.mixTime / from2.mixDuration);
        from2.timelinesRotation.length = 0;
      }
      this.queue.start(current);
    };
    AnimationState2.prototype.setAnimation = function(trackIndex, animationName, loop) {
      var animation2 = this.data.skeletonData.findAnimation(animationName);
      if (animation2 == null)
        throw new Error("Animation not found: " + animationName);
      return this.setAnimationWith(trackIndex, animation2, loop);
    };
    AnimationState2.prototype.setAnimationWith = function(trackIndex, animation2, loop) {
      if (animation2 == null)
        throw new Error("animation cannot be null.");
      var interrupt = true;
      var current = this.expandToIndex(trackIndex);
      if (current != null) {
        if (current.nextTrackLast == -1) {
          this.tracks[trackIndex] = current.mixingFrom;
          this.queue.interrupt(current);
          this.queue.end(current);
          this.disposeNext(current);
          current = current.mixingFrom;
          interrupt = false;
        } else
          this.disposeNext(current);
      }
      var entry = this.trackEntry(trackIndex, animation2, loop, current);
      this.setCurrent(trackIndex, entry, interrupt);
      this.queue.drain();
      return entry;
    };
    AnimationState2.prototype.addAnimation = function(trackIndex, animationName, loop, delay) {
      var animation2 = this.data.skeletonData.findAnimation(animationName);
      if (animation2 == null)
        throw new Error("Animation not found: " + animationName);
      return this.addAnimationWith(trackIndex, animation2, loop, delay);
    };
    AnimationState2.prototype.addAnimationWith = function(trackIndex, animation2, loop, delay) {
      if (animation2 == null)
        throw new Error("animation cannot be null.");
      var last = this.expandToIndex(trackIndex);
      if (last != null) {
        while (last.next != null)
          last = last.next;
      }
      var entry = this.trackEntry(trackIndex, animation2, loop, last);
      if (last == null) {
        this.setCurrent(trackIndex, entry, true);
        this.queue.drain();
      } else {
        last.next = entry;
        if (delay <= 0) {
          var duration = last.animationEnd - last.animationStart;
          if (duration != 0) {
            if (last.loop)
              delay += duration * (1 + (last.trackTime / duration | 0));
            else
              delay += Math.max(duration, last.trackTime);
            delay -= this.data.getMix(last.animation, animation2);
          } else
            delay = last.trackTime;
        }
      }
      entry.delay = delay;
      return entry;
    };
    AnimationState2.prototype.setEmptyAnimation = function(trackIndex, mixDuration) {
      var entry = this.setAnimationWith(trackIndex, AnimationState2.emptyAnimation, false);
      entry.mixDuration = mixDuration;
      entry.trackEnd = mixDuration;
      return entry;
    };
    AnimationState2.prototype.addEmptyAnimation = function(trackIndex, mixDuration, delay) {
      if (delay <= 0)
        delay -= mixDuration;
      var entry = this.addAnimationWith(trackIndex, AnimationState2.emptyAnimation, false, delay);
      entry.mixDuration = mixDuration;
      entry.trackEnd = mixDuration;
      return entry;
    };
    AnimationState2.prototype.setEmptyAnimations = function(mixDuration) {
      var oldDrainDisabled = this.queue.drainDisabled;
      this.queue.drainDisabled = true;
      for (var i2 = 0, n2 = this.tracks.length; i2 < n2; i2++) {
        var current = this.tracks[i2];
        if (current != null)
          this.setEmptyAnimation(current.trackIndex, mixDuration);
      }
      this.queue.drainDisabled = oldDrainDisabled;
      this.queue.drain();
    };
    AnimationState2.prototype.expandToIndex = function(index2) {
      if (index2 < this.tracks.length)
        return this.tracks[index2];
      Utils.ensureArrayCapacity(this.tracks, index2 + 1, null);
      this.tracks.length = index2 + 1;
      return null;
    };
    AnimationState2.prototype.trackEntry = function(trackIndex, animation2, loop, last) {
      var entry = this.trackEntryPool.obtain();
      entry.trackIndex = trackIndex;
      entry.animation = animation2;
      entry.loop = loop;
      entry.holdPrevious = false;
      entry.eventThreshold = 0;
      entry.attachmentThreshold = 0;
      entry.drawOrderThreshold = 0;
      entry.animationStart = 0;
      entry.animationEnd = animation2.duration;
      entry.animationLast = -1;
      entry.nextAnimationLast = -1;
      entry.delay = 0;
      entry.trackTime = 0;
      entry.trackLast = -1;
      entry.nextTrackLast = -1;
      entry.trackEnd = Number.MAX_VALUE;
      entry.timeScale = 1;
      entry.alpha = 1;
      entry.interruptAlpha = 1;
      entry.mixTime = 0;
      entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation2);
      entry.mixBlend = MixBlend.replace;
      return entry;
    };
    AnimationState2.prototype.disposeNext = function(entry) {
      var next2 = entry.next;
      while (next2 != null) {
        this.queue.dispose(next2);
        next2 = next2.next;
      }
      entry.next = null;
    };
    AnimationState2.prototype._animationsChanged = function() {
      this.animationsChanged = false;
      this.propertyIDs.clear();
      for (var i2 = 0, n2 = this.tracks.length; i2 < n2; i2++) {
        var entry = this.tracks[i2];
        if (entry == null)
          continue;
        while (entry.mixingFrom != null)
          entry = entry.mixingFrom;
        do {
          if (entry.mixingFrom == null || entry.mixBlend != MixBlend.add)
            this.computeHold(entry);
          entry = entry.mixingTo;
        } while (entry != null);
      }
    };
    AnimationState2.prototype.computeHold = function(entry) {
      var to = entry.mixingTo;
      var timelines = entry.animation.timelines;
      var timelinesCount = entry.animation.timelines.length;
      var timelineMode = Utils.setArraySize(entry.timelineMode, timelinesCount);
      entry.timelineHoldMix.length = 0;
      var timelineDipMix = Utils.setArraySize(entry.timelineHoldMix, timelinesCount);
      var propertyIDs = this.propertyIDs;
      if (to != null && to.holdPrevious) {
        for (var i2 = 0; i2 < timelinesCount; i2++) {
          timelineMode[i2] = propertyIDs.add(timelines[i2].getPropertyId()) ? AnimationState2.HOLD_FIRST : AnimationState2.HOLD_SUBSEQUENT;
        }
        return;
      }
      outer:
        for (var i2 = 0; i2 < timelinesCount; i2++) {
          var timeline = timelines[i2];
          var id2 = timeline.getPropertyId();
          if (!propertyIDs.add(id2))
            timelineMode[i2] = AnimationState2.SUBSEQUENT;
          else if (to == null || timeline instanceof AttachmentTimeline$2 || timeline instanceof DrawOrderTimeline$2 || timeline instanceof EventTimeline$2 || !to.animation.hasTimeline(id2)) {
            timelineMode[i2] = AnimationState2.FIRST;
          } else {
            for (var next2 = to.mixingTo; next2 != null; next2 = next2.mixingTo) {
              if (next2.animation.hasTimeline(id2))
                continue;
              if (entry.mixDuration > 0) {
                timelineMode[i2] = AnimationState2.HOLD_MIX;
                timelineDipMix[i2] = next2;
                continue outer;
              }
              break;
            }
            timelineMode[i2] = AnimationState2.HOLD_FIRST;
          }
        }
    };
    AnimationState2.prototype.getCurrent = function(trackIndex) {
      if (trackIndex >= this.tracks.length)
        return null;
      return this.tracks[trackIndex];
    };
    AnimationState2.prototype.addListener = function(listener) {
      if (listener == null)
        throw new Error("listener cannot be null.");
      this.listeners.push(listener);
    };
    AnimationState2.prototype.removeListener = function(listener) {
      var index2 = this.listeners.indexOf(listener);
      if (index2 >= 0)
        this.listeners.splice(index2, 1);
    };
    AnimationState2.prototype.clearListeners = function() {
      this.listeners.length = 0;
    };
    AnimationState2.prototype.clearListenerNotifications = function() {
      this.queue.clear();
    };
    AnimationState2.prototype.setAnimationByName = function(trackIndex, animationName, loop) {
      if (!AnimationState2.deprecatedWarning1) {
        AnimationState2.deprecatedWarning1 = true;
        console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.");
      }
      this.setAnimation(trackIndex, animationName, loop);
    };
    AnimationState2.prototype.addAnimationByName = function(trackIndex, animationName, loop, delay) {
      if (!AnimationState2.deprecatedWarning2) {
        AnimationState2.deprecatedWarning2 = true;
        console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.");
      }
      this.addAnimation(trackIndex, animationName, loop, delay);
    };
    AnimationState2.prototype.hasAnimation = function(animationName) {
      var animation2 = this.data.skeletonData.findAnimation(animationName);
      return animation2 !== null;
    };
    AnimationState2.prototype.hasAnimationByName = function(animationName) {
      if (!AnimationState2.deprecatedWarning3) {
        AnimationState2.deprecatedWarning3 = true;
        console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.");
      }
      return this.hasAnimation(animationName);
    };
    AnimationState2.emptyAnimation = new Animation$2("<empty>", [], 0);
    AnimationState2.SUBSEQUENT = 0;
    AnimationState2.FIRST = 1;
    AnimationState2.HOLD_SUBSEQUENT = 2;
    AnimationState2.HOLD_FIRST = 3;
    AnimationState2.HOLD_MIX = 4;
    AnimationState2.SETUP = 1;
    AnimationState2.CURRENT = 2;
    AnimationState2.deprecatedWarning1 = false;
    AnimationState2.deprecatedWarning2 = false;
    AnimationState2.deprecatedWarning3 = false;
    return AnimationState2;
  }()
);
var TrackEntry$2 = (
  /** @class */
  function() {
    function TrackEntry2() {
      this.mixBlend = MixBlend.replace;
      this.timelineMode = new Array();
      this.timelineHoldMix = new Array();
      this.timelinesRotation = new Array();
    }
    TrackEntry2.prototype.reset = function() {
      this.next = null;
      this.mixingFrom = null;
      this.mixingTo = null;
      this.animation = null;
      this.listener = null;
      this.timelineMode.length = 0;
      this.timelineHoldMix.length = 0;
      this.timelinesRotation.length = 0;
    };
    TrackEntry2.prototype.getAnimationTime = function() {
      if (this.loop) {
        var duration = this.animationEnd - this.animationStart;
        if (duration == 0)
          return this.animationStart;
        return this.trackTime % duration + this.animationStart;
      }
      return Math.min(this.trackTime + this.animationStart, this.animationEnd);
    };
    TrackEntry2.prototype.setAnimationLast = function(animationLast) {
      this.animationLast = animationLast;
      this.nextAnimationLast = animationLast;
    };
    TrackEntry2.prototype.isComplete = function() {
      return this.trackTime >= this.animationEnd - this.animationStart;
    };
    TrackEntry2.prototype.resetRotationDirections = function() {
      this.timelinesRotation.length = 0;
    };
    Object.defineProperty(TrackEntry2.prototype, "time", {
      get: function() {
        if (!TrackEntry2.deprecatedWarning1) {
          TrackEntry2.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
        }
        return this.trackTime;
      },
      set: function(value) {
        if (!TrackEntry2.deprecatedWarning1) {
          TrackEntry2.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
        }
        this.trackTime = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TrackEntry2.prototype, "endTime", {
      get: function() {
        if (!TrackEntry2.deprecatedWarning2) {
          TrackEntry2.deprecatedWarning2 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
        }
        return this.trackTime;
      },
      set: function(value) {
        if (!TrackEntry2.deprecatedWarning2) {
          TrackEntry2.deprecatedWarning2 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
        }
        this.trackTime = value;
      },
      enumerable: false,
      configurable: true
    });
    TrackEntry2.prototype.loopsCount = function() {
      return Math.floor(this.trackTime / this.trackEnd);
    };
    TrackEntry2.deprecatedWarning1 = false;
    TrackEntry2.deprecatedWarning2 = false;
    return TrackEntry2;
  }()
);
var EventQueue$2 = (
  /** @class */
  function() {
    function EventQueue2(animState) {
      this.objects = [];
      this.drainDisabled = false;
      this.animState = animState;
    }
    EventQueue2.prototype.start = function(entry) {
      this.objects.push(EventType$2.start);
      this.objects.push(entry);
      this.animState.animationsChanged = true;
    };
    EventQueue2.prototype.interrupt = function(entry) {
      this.objects.push(EventType$2.interrupt);
      this.objects.push(entry);
    };
    EventQueue2.prototype.end = function(entry) {
      this.objects.push(EventType$2.end);
      this.objects.push(entry);
      this.animState.animationsChanged = true;
    };
    EventQueue2.prototype.dispose = function(entry) {
      this.objects.push(EventType$2.dispose);
      this.objects.push(entry);
    };
    EventQueue2.prototype.complete = function(entry) {
      this.objects.push(EventType$2.complete);
      this.objects.push(entry);
    };
    EventQueue2.prototype.event = function(entry, event) {
      this.objects.push(EventType$2.event);
      this.objects.push(entry);
      this.objects.push(event);
    };
    EventQueue2.prototype.deprecateStuff = function() {
      if (!EventQueue2.deprecatedWarning1) {
        EventQueue2.deprecatedWarning1 = true;
        console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'");
      }
      return true;
    };
    EventQueue2.prototype.drain = function() {
      if (this.drainDisabled)
        return;
      this.drainDisabled = true;
      var objects = this.objects;
      var listeners = this.animState.listeners;
      for (var i2 = 0; i2 < objects.length; i2 += 2) {
        var type2 = objects[i2];
        var entry = objects[i2 + 1];
        switch (type2) {
          case EventType$2.start:
            if (entry.listener != null && entry.listener.start)
              entry.listener.start(entry);
            for (var ii2 = 0; ii2 < listeners.length; ii2++)
              if (listeners[ii2].start)
                listeners[ii2].start(entry);
            entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);
            this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);
            break;
          case EventType$2.interrupt:
            if (entry.listener != null && entry.listener.interrupt)
              entry.listener.interrupt(entry);
            for (var ii2 = 0; ii2 < listeners.length; ii2++)
              if (listeners[ii2].interrupt)
                listeners[ii2].interrupt(entry);
            break;
          case EventType$2.end:
            if (entry.listener != null && entry.listener.end)
              entry.listener.end(entry);
            for (var ii2 = 0; ii2 < listeners.length; ii2++)
              if (listeners[ii2].end)
                listeners[ii2].end(entry);
            entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);
            this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);
          case EventType$2.dispose:
            if (entry.listener != null && entry.listener.dispose)
              entry.listener.dispose(entry);
            for (var ii2 = 0; ii2 < listeners.length; ii2++)
              if (listeners[ii2].dispose)
                listeners[ii2].dispose(entry);
            this.animState.trackEntryPool.free(entry);
            break;
          case EventType$2.complete:
            if (entry.listener != null && entry.listener.complete)
              entry.listener.complete(entry);
            for (var ii2 = 0; ii2 < listeners.length; ii2++)
              if (listeners[ii2].complete)
                listeners[ii2].complete(entry);
            var count = MathUtils.toInt(entry.loopsCount());
            entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);
            this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);
            break;
          case EventType$2.event:
            var event_3 = objects[i2++ + 2];
            if (entry.listener != null && entry.listener.event)
              entry.listener.event(entry, event_3);
            for (var ii2 = 0; ii2 < listeners.length; ii2++)
              if (listeners[ii2].event)
                listeners[ii2].event(entry, event_3);
            entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event_3);
            this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event_3);
            break;
        }
      }
      this.clear();
      this.drainDisabled = false;
    };
    EventQueue2.prototype.clear = function() {
      this.objects.length = 0;
    };
    EventQueue2.deprecatedWarning1 = false;
    return EventQueue2;
  }()
);
var EventType$2;
(function(EventType2) {
  EventType2[EventType2["start"] = 0] = "start";
  EventType2[EventType2["interrupt"] = 1] = "interrupt";
  EventType2[EventType2["end"] = 2] = "end";
  EventType2[EventType2["dispose"] = 3] = "dispose";
  EventType2[EventType2["complete"] = 4] = "complete";
  EventType2[EventType2["event"] = 5] = "event";
})(EventType$2 || (EventType$2 = {}));
var AnimationStateAdapter$1 = (
  /** @class */
  function() {
    function AnimationStateAdapter3() {
    }
    AnimationStateAdapter3.prototype.start = function(entry) {
    };
    AnimationStateAdapter3.prototype.interrupt = function(entry) {
    };
    AnimationStateAdapter3.prototype.end = function(entry) {
    };
    AnimationStateAdapter3.prototype.dispose = function(entry) {
    };
    AnimationStateAdapter3.prototype.complete = function(entry) {
    };
    AnimationStateAdapter3.prototype.event = function(entry, event) {
    };
    return AnimationStateAdapter3;
  }()
);
var AnimationStateData$2 = (
  /** @class */
  function() {
    function AnimationStateData2(skeletonData) {
      this.animationToMixTime = {};
      this.defaultMix = 0;
      if (skeletonData == null)
        throw new Error("skeletonData cannot be null.");
      this.skeletonData = skeletonData;
    }
    AnimationStateData2.prototype.setMix = function(fromName, toName, duration) {
      var from2 = this.skeletonData.findAnimation(fromName);
      if (from2 == null)
        throw new Error("Animation not found: " + fromName);
      var to = this.skeletonData.findAnimation(toName);
      if (to == null)
        throw new Error("Animation not found: " + toName);
      this.setMixWith(from2, to, duration);
    };
    AnimationStateData2.prototype.setMixByName = function(fromName, toName, duration) {
      if (!AnimationStateData2.deprecatedWarning1) {
        AnimationStateData2.deprecatedWarning1 = true;
        console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.");
      }
      this.setMix(fromName, toName, duration);
    };
    AnimationStateData2.prototype.setMixWith = function(from2, to, duration) {
      if (from2 == null)
        throw new Error("from cannot be null.");
      if (to == null)
        throw new Error("to cannot be null.");
      var key = from2.name + "." + to.name;
      this.animationToMixTime[key] = duration;
    };
    AnimationStateData2.prototype.getMix = function(from2, to) {
      var key = from2.name + "." + to.name;
      var value = this.animationToMixTime[key];
      return value === void 0 ? this.defaultMix : value;
    };
    AnimationStateData2.deprecatedWarning1 = false;
    return AnimationStateData2;
  }()
);
var AtlasAttachmentLoader$2 = (
  /** @class */
  function() {
    function AtlasAttachmentLoader2(atlas) {
      this.atlas = atlas;
    }
    AtlasAttachmentLoader2.prototype.newRegionAttachment = function(skin, name, path) {
      var region = this.atlas.findRegion(path);
      if (region == null)
        throw new Error("Region not found in atlas: " + path + " (region attachment: " + name + ")");
      var attachment = new RegionAttachment$2(name);
      attachment.region = region;
      return attachment;
    };
    AtlasAttachmentLoader2.prototype.newMeshAttachment = function(skin, name, path) {
      var region = this.atlas.findRegion(path);
      if (region == null)
        throw new Error("Region not found in atlas: " + path + " (mesh attachment: " + name + ")");
      var attachment = new MeshAttachment$2(name);
      attachment.region = region;
      return attachment;
    };
    AtlasAttachmentLoader2.prototype.newBoundingBoxAttachment = function(skin, name) {
      return new BoundingBoxAttachment$2(name);
    };
    AtlasAttachmentLoader2.prototype.newPathAttachment = function(skin, name) {
      return new PathAttachment$2(name);
    };
    AtlasAttachmentLoader2.prototype.newPointAttachment = function(skin, name) {
      return new PointAttachment$2(name);
    };
    AtlasAttachmentLoader2.prototype.newClippingAttachment = function(skin, name) {
      return new ClippingAttachment$2(name);
    };
    return AtlasAttachmentLoader2;
  }()
);
var Bone$2 = (
  /** @class */
  function() {
    function Bone2(data2, skeleton, parent) {
      this.matrix = new Matrix();
      this.children = new Array();
      this.x = 0;
      this.y = 0;
      this.rotation = 0;
      this.scaleX = 0;
      this.scaleY = 0;
      this.shearX = 0;
      this.shearY = 0;
      this.ax = 0;
      this.ay = 0;
      this.arotation = 0;
      this.ascaleX = 0;
      this.ascaleY = 0;
      this.ashearX = 0;
      this.ashearY = 0;
      this.appliedValid = false;
      this.sorted = false;
      this.active = false;
      if (data2 == null)
        throw new Error("data cannot be null.");
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      this.data = data2;
      this.skeleton = skeleton;
      this.parent = parent;
      this.setToSetupPose();
    }
    Object.defineProperty(Bone2.prototype, "worldX", {
      get: function() {
        return this.matrix.tx;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bone2.prototype, "worldY", {
      get: function() {
        return this.matrix.ty;
      },
      enumerable: false,
      configurable: true
    });
    Bone2.prototype.isActive = function() {
      return this.active;
    };
    Bone2.prototype.update = function() {
      this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
    };
    Bone2.prototype.updateWorldTransform = function() {
      this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
    };
    Bone2.prototype.updateWorldTransformWith = function(x, y2, rotation, scaleX, scaleY, shearX, shearY) {
      this.ax = x;
      this.ay = y2;
      this.arotation = rotation;
      this.ascaleX = scaleX;
      this.ascaleY = scaleY;
      this.ashearX = shearX;
      this.ashearY = shearY;
      this.appliedValid = true;
      var parent = this.parent;
      var m2 = this.matrix;
      var sx = this.skeleton.scaleX;
      var sy = -this.skeleton.scaleY;
      if (parent == null) {
        var skeleton = this.skeleton;
        var rotationY = rotation + 90 + shearY;
        m2.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;
        m2.c = MathUtils.cosDeg(rotationY) * scaleY * sx;
        m2.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;
        m2.d = MathUtils.sinDeg(rotationY) * scaleY * sy;
        m2.tx = x * sx + skeleton.x;
        m2.ty = y2 * sy + skeleton.y;
        return;
      }
      var pa2 = parent.matrix.a, pb2 = parent.matrix.c, pc2 = parent.matrix.b, pd2 = parent.matrix.d;
      m2.tx = pa2 * x + pb2 * y2 + parent.matrix.tx;
      m2.ty = pc2 * x + pd2 * y2 + parent.matrix.ty;
      switch (this.data.transformMode) {
        case TransformMode.Normal: {
          var rotationY = rotation + 90 + shearY;
          var la2 = MathUtils.cosDeg(rotation + shearX) * scaleX;
          var lb2 = MathUtils.cosDeg(rotationY) * scaleY;
          var lc2 = MathUtils.sinDeg(rotation + shearX) * scaleX;
          var ld2 = MathUtils.sinDeg(rotationY) * scaleY;
          m2.a = pa2 * la2 + pb2 * lc2;
          m2.c = pa2 * lb2 + pb2 * ld2;
          m2.b = pc2 * la2 + pd2 * lc2;
          m2.d = pc2 * lb2 + pd2 * ld2;
          return;
        }
        case TransformMode.OnlyTranslation: {
          var rotationY = rotation + 90 + shearY;
          m2.a = MathUtils.cosDeg(rotation + shearX) * scaleX;
          m2.c = MathUtils.cosDeg(rotationY) * scaleY;
          m2.b = MathUtils.sinDeg(rotation + shearX) * scaleX;
          m2.d = MathUtils.sinDeg(rotationY) * scaleY;
          break;
        }
        case TransformMode.NoRotationOrReflection: {
          var s2 = pa2 * pa2 + pc2 * pc2;
          var prx = 0;
          if (s2 > 1e-4) {
            s2 = Math.abs(pa2 * pd2 - pb2 * pc2) / s2;
            pa2 /= this.skeleton.scaleX;
            pc2 /= this.skeleton.scaleY;
            pb2 = pc2 * s2;
            pd2 = pa2 * s2;
            prx = Math.atan2(pc2, pa2) * MathUtils.radDeg;
          } else {
            pa2 = 0;
            pc2 = 0;
            prx = 90 - Math.atan2(pd2, pb2) * MathUtils.radDeg;
          }
          var rx = rotation + shearX - prx;
          var ry = rotation + shearY - prx + 90;
          var la2 = MathUtils.cosDeg(rx) * scaleX;
          var lb2 = MathUtils.cosDeg(ry) * scaleY;
          var lc2 = MathUtils.sinDeg(rx) * scaleX;
          var ld2 = MathUtils.sinDeg(ry) * scaleY;
          m2.a = pa2 * la2 - pb2 * lc2;
          m2.c = pa2 * lb2 - pb2 * ld2;
          m2.b = pc2 * la2 + pd2 * lc2;
          m2.d = pc2 * lb2 + pd2 * ld2;
          break;
        }
        case TransformMode.NoScale:
        case TransformMode.NoScaleOrReflection: {
          var cos = MathUtils.cosDeg(rotation);
          var sin = MathUtils.sinDeg(rotation);
          var za2 = (pa2 * cos + pb2 * sin) / sx;
          var zc2 = (pc2 * cos + pd2 * sin) / sy;
          var s2 = Math.sqrt(za2 * za2 + zc2 * zc2);
          if (s2 > 1e-5)
            s2 = 1 / s2;
          za2 *= s2;
          zc2 *= s2;
          s2 = Math.sqrt(za2 * za2 + zc2 * zc2);
          if (this.data.transformMode == TransformMode.NoScale && pa2 * pd2 - pb2 * pc2 < 0 != (this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0))
            s2 = -s2;
          var r2 = Math.PI / 2 + Math.atan2(zc2, za2);
          var zb2 = Math.cos(r2) * s2;
          var zd2 = Math.sin(r2) * s2;
          var la2 = MathUtils.cosDeg(shearX) * scaleX;
          var lb2 = MathUtils.cosDeg(90 + shearY) * scaleY;
          var lc2 = MathUtils.sinDeg(shearX) * scaleX;
          var ld2 = MathUtils.sinDeg(90 + shearY) * scaleY;
          m2.a = za2 * la2 + zb2 * lc2;
          m2.c = za2 * lb2 + zb2 * ld2;
          m2.b = zc2 * la2 + zd2 * lc2;
          m2.d = zc2 * lb2 + zd2 * ld2;
          break;
        }
      }
      m2.a *= sx;
      m2.c *= sx;
      m2.b *= sy;
      m2.d *= sy;
    };
    Bone2.prototype.setToSetupPose = function() {
      var data2 = this.data;
      this.x = data2.x;
      this.y = data2.y;
      this.rotation = data2.rotation;
      this.scaleX = data2.scaleX;
      this.scaleY = data2.scaleY;
      this.shearX = data2.shearX;
      this.shearY = data2.shearY;
    };
    Bone2.prototype.getWorldRotationX = function() {
      return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;
    };
    Bone2.prototype.getWorldRotationY = function() {
      return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;
    };
    Bone2.prototype.getWorldScaleX = function() {
      var m2 = this.matrix;
      return Math.sqrt(m2.a * m2.a + m2.c * m2.c);
    };
    Bone2.prototype.getWorldScaleY = function() {
      var m2 = this.matrix;
      return Math.sqrt(m2.b * m2.b + m2.d * m2.d);
    };
    Bone2.prototype.updateAppliedTransform = function() {
      this.appliedValid = true;
      var parent = this.parent;
      var m2 = this.matrix;
      if (parent == null) {
        this.ax = m2.tx;
        this.ay = m2.ty;
        this.arotation = Math.atan2(m2.b, m2.a) * MathUtils.radDeg;
        this.ascaleX = Math.sqrt(m2.a * m2.a + m2.b * m2.b);
        this.ascaleY = Math.sqrt(m2.c * m2.c + m2.d * m2.d);
        this.ashearX = 0;
        this.ashearY = Math.atan2(m2.a * m2.c + m2.b * m2.d, m2.a * m2.d - m2.b * m2.c) * MathUtils.radDeg;
        return;
      }
      var pm = parent.matrix;
      var pid = 1 / (pm.a * pm.d - pm.b * pm.c);
      var dx = m2.tx - pm.tx, dy = m2.ty - pm.ty;
      this.ax = dx * pm.d * pid - dy * pm.c * pid;
      this.ay = dy * pm.a * pid - dx * pm.b * pid;
      var ia2 = pid * pm.d;
      var id2 = pid * pm.a;
      var ib2 = pid * pm.c;
      var ic2 = pid * pm.b;
      var ra2 = ia2 * m2.a - ib2 * m2.b;
      var rb2 = ia2 * m2.c - ib2 * m2.d;
      var rc2 = id2 * m2.b - ic2 * m2.a;
      var rd2 = id2 * m2.d - ic2 * m2.c;
      this.ashearX = 0;
      this.ascaleX = Math.sqrt(ra2 * ra2 + rc2 * rc2);
      if (this.ascaleX > 1e-4) {
        var det = ra2 * rd2 - rb2 * rc2;
        this.ascaleY = det / this.ascaleX;
        this.ashearY = Math.atan2(ra2 * rb2 + rc2 * rd2, det) * MathUtils.radDeg;
        this.arotation = Math.atan2(rc2, ra2) * MathUtils.radDeg;
      } else {
        this.ascaleX = 0;
        this.ascaleY = Math.sqrt(rb2 * rb2 + rd2 * rd2);
        this.ashearY = 0;
        this.arotation = 90 - Math.atan2(rd2, rb2) * MathUtils.radDeg;
      }
    };
    Bone2.prototype.worldToLocal = function(world) {
      var m2 = this.matrix;
      var a2 = m2.a, b2 = m2.c, c2 = m2.b, d2 = m2.d;
      var invDet = 1 / (a2 * d2 - b2 * c2);
      var x = world.x - m2.tx, y2 = world.y - m2.ty;
      world.x = x * d2 * invDet - y2 * b2 * invDet;
      world.y = y2 * a2 * invDet - x * c2 * invDet;
      return world;
    };
    Bone2.prototype.localToWorld = function(local) {
      var m2 = this.matrix;
      var x = local.x, y2 = local.y;
      local.x = x * m2.a + y2 * m2.c + m2.tx;
      local.y = x * m2.b + y2 * m2.d + m2.ty;
      return local;
    };
    Bone2.prototype.worldToLocalRotation = function(worldRotation) {
      var sin = MathUtils.sinDeg(worldRotation), cos = MathUtils.cosDeg(worldRotation);
      var mat = this.matrix;
      return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;
    };
    Bone2.prototype.localToWorldRotation = function(localRotation) {
      var sin = MathUtils.sinDeg(localRotation), cos = MathUtils.cosDeg(localRotation);
      var mat = this.matrix;
      return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;
    };
    Bone2.prototype.rotateWorld = function(degrees) {
      var mat = this.matrix;
      var a2 = mat.a, b2 = mat.c, c2 = mat.b, d2 = mat.d;
      var cos = MathUtils.cosDeg(degrees), sin = MathUtils.sinDeg(degrees);
      mat.a = cos * a2 - sin * c2;
      mat.c = cos * b2 - sin * d2;
      mat.b = sin * a2 + cos * c2;
      mat.d = sin * b2 + cos * d2;
      this.appliedValid = false;
    };
    return Bone2;
  }()
);
var BoneData$2 = (
  /** @class */
  function() {
    function BoneData2(index2, name, parent) {
      this.x = 0;
      this.y = 0;
      this.rotation = 0;
      this.scaleX = 1;
      this.scaleY = 1;
      this.shearX = 0;
      this.shearY = 0;
      this.transformMode = TransformMode.Normal;
      this.skinRequired = false;
      this.color = new Color();
      if (index2 < 0)
        throw new Error("index must be >= 0.");
      if (name == null)
        throw new Error("name cannot be null.");
      this.index = index2;
      this.name = name;
      this.parent = parent;
    }
    return BoneData2;
  }()
);
var ConstraintData$1 = (
  /** @class */
  function() {
    function ConstraintData2(name, order, skinRequired) {
      this.name = name;
      this.order = order;
      this.skinRequired = skinRequired;
    }
    return ConstraintData2;
  }()
);
var Event$3 = (
  /** @class */
  function() {
    function Event2(time, data2) {
      if (data2 == null)
        throw new Error("data cannot be null.");
      this.time = time;
      this.data = data2;
    }
    return Event2;
  }()
);
var EventData$2 = (
  /** @class */
  function() {
    function EventData2(name) {
      this.name = name;
    }
    return EventData2;
  }()
);
var IkConstraint$2 = (
  /** @class */
  function() {
    function IkConstraint2(data2, skeleton) {
      this.bendDirection = 0;
      this.compress = false;
      this.stretch = false;
      this.mix = 1;
      this.softness = 0;
      this.active = false;
      if (data2 == null)
        throw new Error("data cannot be null.");
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      this.data = data2;
      this.mix = data2.mix;
      this.softness = data2.softness;
      this.bendDirection = data2.bendDirection;
      this.compress = data2.compress;
      this.stretch = data2.stretch;
      this.bones = new Array();
      for (var i2 = 0; i2 < data2.bones.length; i2++)
        this.bones.push(skeleton.findBone(data2.bones[i2].name));
      this.target = skeleton.findBone(data2.target.name);
    }
    IkConstraint2.prototype.isActive = function() {
      return this.active;
    };
    IkConstraint2.prototype.apply = function() {
      this.update();
    };
    IkConstraint2.prototype.update = function() {
      var target = this.target;
      var bones = this.bones;
      switch (bones.length) {
        case 1:
          this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
          break;
        case 2:
          this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);
          break;
      }
    };
    IkConstraint2.prototype.apply1 = function(bone, targetX, targetY, compress, stretch, uniform, alpha2) {
      if (!bone.appliedValid)
        bone.updateAppliedTransform();
      var p = bone.parent.matrix;
      var pa2 = p.a, pb2 = p.c, pc2 = p.b, pd2 = p.d;
      var rotationIK = -bone.ashearX - bone.arotation, tx = 0, ty = 0;
      switch (bone.data.transformMode) {
        case TransformMode.OnlyTranslation:
          tx = targetX - bone.worldX;
          ty = targetY - bone.worldY;
          break;
        case TransformMode.NoRotationOrReflection:
          var s2 = Math.abs(pa2 * pd2 - pb2 * pc2) / (pa2 * pa2 + pc2 * pc2);
          var sa2 = pa2 / bone.skeleton.scaleX;
          var sc2 = pc2 / bone.skeleton.scaleY;
          pb2 = -sc2 * s2 * bone.skeleton.scaleX;
          pd2 = sa2 * s2 * bone.skeleton.scaleY;
          rotationIK += Math.atan2(sc2, sa2) * MathUtils.radDeg;
        default:
          var x = targetX - p.tx, y2 = targetY - p.ty;
          var d2 = pa2 * pd2 - pb2 * pc2;
          tx = (x * pd2 - y2 * pb2) / d2 - bone.ax;
          ty = (y2 * pa2 - x * pc2) / d2 - bone.ay;
      }
      rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;
      if (bone.ascaleX < 0)
        rotationIK += 180;
      if (rotationIK > 180)
        rotationIK -= 360;
      else if (rotationIK < -180)
        rotationIK += 360;
      var sx = bone.ascaleX, sy = bone.ascaleY;
      if (compress || stretch) {
        switch (bone.data.transformMode) {
          case TransformMode.NoScale:
          case TransformMode.NoScaleOrReflection:
            tx = targetX - bone.worldX;
            ty = targetY - bone.worldY;
        }
        var b2 = bone.data.length * sx, dd2 = Math.sqrt(tx * tx + ty * ty);
        if (compress && dd2 < b2 || stretch && dd2 > b2 && b2 > 1e-4) {
          var s2 = (dd2 / b2 - 1) * alpha2 + 1;
          sx *= s2;
          if (uniform)
            sy *= s2;
        }
      }
      bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha2, sx, sy, bone.ashearX, bone.ashearY);
    };
    IkConstraint2.prototype.apply2 = function(parent, child, targetX, targetY, bendDir, stretch, softness, alpha2) {
      if (alpha2 == 0) {
        child.updateWorldTransform();
        return;
      }
      if (!parent.appliedValid)
        parent.updateAppliedTransform();
      if (!child.appliedValid)
        child.updateAppliedTransform();
      var px = parent.ax, py = parent.ay, psx = parent.ascaleX, sx = psx, psy = parent.ascaleY, csx = child.ascaleX;
      var pmat = parent.matrix;
      var os1 = 0, os2 = 0, s2 = 0;
      if (psx < 0) {
        psx = -psx;
        os1 = 180;
        s2 = -1;
      } else {
        os1 = 0;
        s2 = 1;
      }
      if (psy < 0) {
        psy = -psy;
        s2 = -s2;
      }
      if (csx < 0) {
        csx = -csx;
        os2 = 180;
      } else
        os2 = 0;
      var cx = child.ax, cy = 0, cwx = 0, cwy = 0, a2 = pmat.a, b2 = pmat.c, c2 = pmat.b, d2 = pmat.d;
      var u2 = Math.abs(psx - psy) <= 1e-4;
      if (!u2) {
        cy = 0;
        cwx = a2 * cx + pmat.tx;
        cwy = c2 * cx + pmat.ty;
      } else {
        cy = child.ay;
        cwx = a2 * cx + b2 * cy + pmat.tx;
        cwy = c2 * cx + d2 * cy + pmat.ty;
      }
      var pp = parent.parent.matrix;
      a2 = pp.a;
      b2 = pp.c;
      c2 = pp.b;
      d2 = pp.d;
      var id2 = 1 / (a2 * d2 - b2 * c2), x = cwx - pp.tx, y2 = cwy - pp.ty;
      var dx = (x * d2 - y2 * b2) * id2 - px, dy = (y2 * a2 - x * c2) * id2 - py;
      var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a22;
      if (l1 < 1e-4) {
        this.apply1(parent, targetX, targetY, false, stretch, false, alpha2);
        child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
        return;
      }
      x = targetX - pp.tx;
      y2 = targetY - pp.ty;
      var tx = (x * d2 - y2 * b2) * id2 - px, ty = (y2 * a2 - x * c2) * id2 - py;
      var dd2 = tx * tx + ty * ty;
      if (softness != 0) {
        softness *= psx * (csx + 1) / 2;
        var td2 = Math.sqrt(dd2), sd2 = td2 - l1 - l2 * psx + softness;
        if (sd2 > 0) {
          var p = Math.min(1, sd2 / (softness * 2)) - 1;
          p = (sd2 - softness * (1 - p * p)) / td2;
          tx -= p * tx;
          ty -= p * ty;
          dd2 = tx * tx + ty * ty;
        }
      }
      outer:
        if (u2) {
          l2 *= psx;
          var cos = (dd2 - l1 * l1 - l2 * l2) / (2 * l1 * l2);
          if (cos < -1)
            cos = -1;
          else if (cos > 1) {
            cos = 1;
            if (stretch)
              sx *= (Math.sqrt(dd2) / (l1 + l2) - 1) * alpha2 + 1;
          }
          a22 = Math.acos(cos) * bendDir;
          a2 = l1 + l2 * cos;
          b2 = l2 * Math.sin(a22);
          a1 = Math.atan2(ty * a2 - tx * b2, tx * a2 + ty * b2);
        } else {
          a2 = psx * l2;
          b2 = psy * l2;
          var aa2 = a2 * a2, bb2 = b2 * b2, ta2 = Math.atan2(ty, tx);
          c2 = bb2 * l1 * l1 + aa2 * dd2 - aa2 * bb2;
          var c1 = -2 * bb2 * l1, c22 = bb2 - aa2;
          d2 = c1 * c1 - 4 * c22 * c2;
          if (d2 >= 0) {
            var q2 = Math.sqrt(d2);
            if (c1 < 0)
              q2 = -q2;
            q2 = -(c1 + q2) / 2;
            var r0 = q2 / c22, r1 = c2 / q2;
            var r2 = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
            if (r2 * r2 <= dd2) {
              y2 = Math.sqrt(dd2 - r2 * r2) * bendDir;
              a1 = ta2 - Math.atan2(y2, r2);
              a22 = Math.atan2(y2 / psy, (r2 - l1) / psx);
              break outer;
            }
          }
          var minAngle = MathUtils.PI, minX = l1 - a2, minDist = minX * minX, minY = 0;
          var maxAngle = 0, maxX = l1 + a2, maxDist = maxX * maxX, maxY = 0;
          c2 = -a2 * l1 / (aa2 - bb2);
          if (c2 >= -1 && c2 <= 1) {
            c2 = Math.acos(c2);
            x = a2 * Math.cos(c2) + l1;
            y2 = b2 * Math.sin(c2);
            d2 = x * x + y2 * y2;
            if (d2 < minDist) {
              minAngle = c2;
              minDist = d2;
              minX = x;
              minY = y2;
            }
            if (d2 > maxDist) {
              maxAngle = c2;
              maxDist = d2;
              maxX = x;
              maxY = y2;
            }
          }
          if (dd2 <= (minDist + maxDist) / 2) {
            a1 = ta2 - Math.atan2(minY * bendDir, minX);
            a22 = minAngle * bendDir;
          } else {
            a1 = ta2 - Math.atan2(maxY * bendDir, maxX);
            a22 = maxAngle * bendDir;
          }
        }
      var os = Math.atan2(cy, cx) * s2;
      var rotation = parent.arotation;
      a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;
      if (a1 > 180)
        a1 -= 360;
      else if (a1 < -180)
        a1 += 360;
      parent.updateWorldTransformWith(px, py, rotation + a1 * alpha2, sx, parent.ascaleY, 0, 0);
      rotation = child.arotation;
      a22 = ((a22 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
      if (a22 > 180)
        a22 -= 360;
      else if (a22 < -180)
        a22 += 360;
      child.updateWorldTransformWith(cx, cy, rotation + a22 * alpha2, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
    };
    return IkConstraint2;
  }()
);
var IkConstraintData$2 = (
  /** @class */
  function(_super) {
    __extends$4(IkConstraintData2, _super);
    function IkConstraintData2(name) {
      var _this = _super.call(this, name, 0, false) || this;
      _this.bones = new Array();
      _this.bendDirection = 1;
      _this.compress = false;
      _this.stretch = false;
      _this.uniform = false;
      _this.mix = 1;
      _this.softness = 0;
      return _this;
    }
    return IkConstraintData2;
  }(ConstraintData$1)
);
var PathConstraintData$2 = (
  /** @class */
  function(_super) {
    __extends$4(PathConstraintData2, _super);
    function PathConstraintData2(name) {
      var _this = _super.call(this, name, 0, false) || this;
      _this.bones = new Array();
      return _this;
    }
    return PathConstraintData2;
  }(ConstraintData$1)
);
var SpacingMode$2;
(function(SpacingMode2) {
  SpacingMode2[SpacingMode2["Length"] = 0] = "Length";
  SpacingMode2[SpacingMode2["Fixed"] = 1] = "Fixed";
  SpacingMode2[SpacingMode2["Percent"] = 2] = "Percent";
})(SpacingMode$2 || (SpacingMode$2 = {}));
var PathConstraint$2 = (
  /** @class */
  function() {
    function PathConstraint2(data2, skeleton) {
      this.position = 0;
      this.spacing = 0;
      this.rotateMix = 0;
      this.translateMix = 0;
      this.spaces = new Array();
      this.positions = new Array();
      this.world = new Array();
      this.curves = new Array();
      this.lengths = new Array();
      this.segments = new Array();
      this.active = false;
      if (data2 == null)
        throw new Error("data cannot be null.");
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      this.data = data2;
      this.bones = new Array();
      for (var i2 = 0, n2 = data2.bones.length; i2 < n2; i2++)
        this.bones.push(skeleton.findBone(data2.bones[i2].name));
      this.target = skeleton.findSlot(data2.target.name);
      this.position = data2.position;
      this.spacing = data2.spacing;
      this.rotateMix = data2.rotateMix;
      this.translateMix = data2.translateMix;
    }
    PathConstraint2.prototype.isActive = function() {
      return this.active;
    };
    PathConstraint2.prototype.apply = function() {
      this.update();
    };
    PathConstraint2.prototype.update = function() {
      var attachment = this.target.getAttachment();
      if (!(attachment instanceof PathAttachment$2))
        return;
      var rotateMix = this.rotateMix, translateMix = this.translateMix;
      var translate = translateMix > 0, rotate = rotateMix > 0;
      if (!translate && !rotate)
        return;
      var data2 = this.data;
      var spacingMode = data2.spacingMode;
      var lengthSpacing = spacingMode == SpacingMode$2.Length;
      var rotateMode = data2.rotateMode;
      var tangents = rotateMode == RotateMode.Tangent, scale = rotateMode == RotateMode.ChainScale;
      var boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;
      var bones = this.bones;
      var spaces = Utils.setArraySize(this.spaces, spacesCount), lengths = null;
      var spacing = this.spacing;
      if (scale || lengthSpacing) {
        if (scale)
          lengths = Utils.setArraySize(this.lengths, boneCount);
        for (var i2 = 0, n2 = spacesCount - 1; i2 < n2; ) {
          var bone = bones[i2];
          var setupLength = bone.data.length;
          if (setupLength < PathConstraint2.epsilon) {
            if (scale)
              lengths[i2] = 0;
            spaces[++i2] = 0;
          } else {
            var x = setupLength * bone.matrix.a, y2 = setupLength * bone.matrix.b;
            var length_1 = Math.sqrt(x * x + y2 * y2);
            if (scale)
              lengths[i2] = length_1;
            spaces[++i2] = (lengthSpacing ? setupLength + spacing : spacing) * length_1 / setupLength;
          }
        }
      } else {
        for (var i2 = 1; i2 < spacesCount; i2++)
          spaces[i2] = spacing;
      }
      var positions = this.computeWorldPositions(attachment, spacesCount, tangents, data2.positionMode == PositionMode.Percent, spacingMode == SpacingMode$2.Percent);
      var boneX = positions[0], boneY = positions[1], offsetRotation = data2.offsetRotation;
      var tip = false;
      if (offsetRotation == 0)
        tip = rotateMode == RotateMode.Chain;
      else {
        tip = false;
        var p = this.target.bone.matrix;
        offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;
      }
      for (var i2 = 0, p = 3; i2 < boneCount; i2++, p += 3) {
        var bone = bones[i2];
        var mat = bone.matrix;
        mat.tx += (boneX - mat.tx) * translateMix;
        mat.ty += (boneY - mat.ty) * translateMix;
        var x = positions[p], y2 = positions[p + 1], dx = x - boneX, dy = y2 - boneY;
        if (scale) {
          var length_2 = lengths[i2];
          if (length_2 != 0) {
            var s2 = (Math.sqrt(dx * dx + dy * dy) / length_2 - 1) * rotateMix + 1;
            mat.a *= s2;
            mat.b *= s2;
          }
        }
        boneX = x;
        boneY = y2;
        if (rotate) {
          var a2 = mat.a, b2 = mat.c, c2 = mat.b, d2 = mat.d, r2 = 0, cos = 0, sin = 0;
          if (tangents)
            r2 = positions[p - 1];
          else if (spaces[i2 + 1] == 0)
            r2 = positions[p + 2];
          else
            r2 = Math.atan2(dy, dx);
          r2 -= Math.atan2(c2, a2);
          if (tip) {
            cos = Math.cos(r2);
            sin = Math.sin(r2);
            var length_3 = bone.data.length;
            boneX += (length_3 * (cos * a2 - sin * c2) - dx) * rotateMix;
            boneY += (length_3 * (sin * a2 + cos * c2) - dy) * rotateMix;
          } else {
            r2 += offsetRotation;
          }
          if (r2 > MathUtils.PI)
            r2 -= MathUtils.PI2;
          else if (r2 < -MathUtils.PI)
            r2 += MathUtils.PI2;
          r2 *= rotateMix;
          cos = Math.cos(r2);
          sin = Math.sin(r2);
          mat.a = cos * a2 - sin * c2;
          mat.c = cos * b2 - sin * d2;
          mat.b = sin * a2 + cos * c2;
          mat.d = sin * b2 + cos * d2;
        }
        bone.appliedValid = false;
      }
    };
    PathConstraint2.prototype.computeWorldPositions = function(path, spacesCount, tangents, percentPosition, percentSpacing) {
      var target = this.target;
      var position2 = this.position;
      var spaces = this.spaces, out = Utils.setArraySize(this.positions, spacesCount * 3 + 2), world = null;
      var closed2 = path.closed;
      var verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint2.NONE;
      if (!path.constantSpeed) {
        var lengths = path.lengths;
        curveCount -= closed2 ? 1 : 2;
        var pathLength_1 = lengths[curveCount];
        if (percentPosition)
          position2 *= pathLength_1;
        if (percentSpacing) {
          for (var i2 = 0; i2 < spacesCount; i2++)
            spaces[i2] *= pathLength_1;
        }
        world = Utils.setArraySize(this.world, 8);
        for (var i2 = 0, o2 = 0, curve = 0; i2 < spacesCount; i2++, o2 += 3) {
          var space = spaces[i2];
          position2 += space;
          var p = position2;
          if (closed2) {
            p %= pathLength_1;
            if (p < 0)
              p += pathLength_1;
            curve = 0;
          } else if (p < 0) {
            if (prevCurve != PathConstraint2.BEFORE) {
              prevCurve = PathConstraint2.BEFORE;
              path.computeWorldVertices(target, 2, 4, world, 0, 2);
            }
            this.addBeforePosition(p, world, 0, out, o2);
            continue;
          } else if (p > pathLength_1) {
            if (prevCurve != PathConstraint2.AFTER) {
              prevCurve = PathConstraint2.AFTER;
              path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);
            }
            this.addAfterPosition(p - pathLength_1, world, 0, out, o2);
            continue;
          }
          for (; ; curve++) {
            var length_4 = lengths[curve];
            if (p > length_4)
              continue;
            if (curve == 0)
              p /= length_4;
            else {
              var prev2 = lengths[curve - 1];
              p = (p - prev2) / (length_4 - prev2);
            }
            break;
          }
          if (curve != prevCurve) {
            prevCurve = curve;
            if (closed2 && curve == curveCount) {
              path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
              path.computeWorldVertices(target, 0, 4, world, 4, 2);
            } else
              path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);
          }
          this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o2, tangents || i2 > 0 && space == 0);
        }
        return out;
      }
      if (closed2) {
        verticesLength += 2;
        world = Utils.setArraySize(this.world, verticesLength);
        path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
        path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
        world[verticesLength - 2] = world[0];
        world[verticesLength - 1] = world[1];
      } else {
        curveCount--;
        verticesLength -= 4;
        world = Utils.setArraySize(this.world, verticesLength);
        path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);
      }
      var curves = Utils.setArraySize(this.curves, curveCount);
      var pathLength = 0;
      var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;
      var tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;
      for (var i2 = 0, w2 = 2; i2 < curveCount; i2++, w2 += 6) {
        cx1 = world[w2];
        cy1 = world[w2 + 1];
        cx2 = world[w2 + 2];
        cy2 = world[w2 + 3];
        x2 = world[w2 + 4];
        y2 = world[w2 + 5];
        tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
        tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
        ddfx = tmpx * 2 + dddfx;
        ddfy = tmpy * 2 + dddfy;
        dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
        dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        dfx += ddfx;
        dfy += ddfy;
        ddfx += dddfx;
        ddfy += dddfy;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        dfx += ddfx;
        dfy += ddfy;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        dfx += ddfx + dddfx;
        dfy += ddfy + dddfy;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        curves[i2] = pathLength;
        x1 = x2;
        y1 = y2;
      }
      if (percentPosition)
        position2 *= pathLength;
      if (percentSpacing) {
        for (var i2 = 0; i2 < spacesCount; i2++)
          spaces[i2] *= pathLength;
      }
      var segments = this.segments;
      var curveLength = 0;
      for (var i2 = 0, o2 = 0, curve = 0, segment = 0; i2 < spacesCount; i2++, o2 += 3) {
        var space = spaces[i2];
        position2 += space;
        var p = position2;
        if (closed2) {
          p %= pathLength;
          if (p < 0)
            p += pathLength;
          curve = 0;
        } else if (p < 0) {
          this.addBeforePosition(p, world, 0, out, o2);
          continue;
        } else if (p > pathLength) {
          this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o2);
          continue;
        }
        for (; ; curve++) {
          var length_5 = curves[curve];
          if (p > length_5)
            continue;
          if (curve == 0)
            p /= length_5;
          else {
            var prev2 = curves[curve - 1];
            p = (p - prev2) / (length_5 - prev2);
          }
          break;
        }
        if (curve != prevCurve) {
          prevCurve = curve;
          var ii2 = curve * 6;
          x1 = world[ii2];
          y1 = world[ii2 + 1];
          cx1 = world[ii2 + 2];
          cy1 = world[ii2 + 3];
          cx2 = world[ii2 + 4];
          cy2 = world[ii2 + 5];
          x2 = world[ii2 + 6];
          y2 = world[ii2 + 7];
          tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
          tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
          dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;
          dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;
          ddfx = tmpx * 2 + dddfx;
          ddfy = tmpy * 2 + dddfy;
          dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
          dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
          curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
          segments[0] = curveLength;
          for (ii2 = 1; ii2 < 8; ii2++) {
            dfx += ddfx;
            dfy += ddfy;
            ddfx += dddfx;
            ddfy += dddfy;
            curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
            segments[ii2] = curveLength;
          }
          dfx += ddfx;
          dfy += ddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[8] = curveLength;
          dfx += ddfx + dddfx;
          dfy += ddfy + dddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[9] = curveLength;
          segment = 0;
        }
        p *= curveLength;
        for (; ; segment++) {
          var length_6 = segments[segment];
          if (p > length_6)
            continue;
          if (segment == 0)
            p /= length_6;
          else {
            var prev2 = segments[segment - 1];
            p = segment + (p - prev2) / (length_6 - prev2);
          }
          break;
        }
        this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o2, tangents || i2 > 0 && space == 0);
      }
      return out;
    };
    PathConstraint2.prototype.addBeforePosition = function(p, temp2, i2, out, o2) {
      var x1 = temp2[i2], y1 = temp2[i2 + 1], dx = temp2[i2 + 2] - x1, dy = temp2[i2 + 3] - y1, r2 = Math.atan2(dy, dx);
      out[o2] = x1 + p * Math.cos(r2);
      out[o2 + 1] = y1 + p * Math.sin(r2);
      out[o2 + 2] = r2;
    };
    PathConstraint2.prototype.addAfterPosition = function(p, temp2, i2, out, o2) {
      var x1 = temp2[i2 + 2], y1 = temp2[i2 + 3], dx = x1 - temp2[i2], dy = y1 - temp2[i2 + 1], r2 = Math.atan2(dy, dx);
      out[o2] = x1 + p * Math.cos(r2);
      out[o2 + 1] = y1 + p * Math.sin(r2);
      out[o2 + 2] = r2;
    };
    PathConstraint2.prototype.addCurvePosition = function(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o2, tangents) {
      if (p == 0 || isNaN(p))
        p = 1e-4;
      var tt = p * p, ttt = tt * p, u2 = 1 - p, uu = u2 * u2, uuu = uu * u2;
      var ut = u2 * p, ut3 = ut * 3, uut3 = u2 * ut3, utt3 = ut3 * p;
      var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y3 = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
      out[o2] = x;
      out[o2 + 1] = y3;
      if (tangents)
        out[o2 + 2] = Math.atan2(y3 - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
    };
    PathConstraint2.NONE = -1;
    PathConstraint2.BEFORE = -2;
    PathConstraint2.AFTER = -3;
    PathConstraint2.epsilon = 1e-5;
    return PathConstraint2;
  }()
);
var TransformConstraint$2 = (
  /** @class */
  function() {
    function TransformConstraint2(data2, skeleton) {
      this.rotateMix = 0;
      this.translateMix = 0;
      this.scaleMix = 0;
      this.shearMix = 0;
      this.temp = new Vector2();
      this.active = false;
      if (data2 == null)
        throw new Error("data cannot be null.");
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      this.data = data2;
      this.rotateMix = data2.rotateMix;
      this.translateMix = data2.translateMix;
      this.scaleMix = data2.scaleMix;
      this.shearMix = data2.shearMix;
      this.bones = new Array();
      for (var i2 = 0; i2 < data2.bones.length; i2++)
        this.bones.push(skeleton.findBone(data2.bones[i2].name));
      this.target = skeleton.findBone(data2.target.name);
    }
    TransformConstraint2.prototype.isActive = function() {
      return this.active;
    };
    TransformConstraint2.prototype.apply = function() {
      this.update();
    };
    TransformConstraint2.prototype.update = function() {
      if (this.data.local) {
        if (this.data.relative)
          this.applyRelativeLocal();
        else
          this.applyAbsoluteLocal();
      } else {
        if (this.data.relative)
          this.applyRelativeWorld();
        else
          this.applyAbsoluteWorld();
      }
    };
    TransformConstraint2.prototype.applyAbsoluteWorld = function() {
      var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
      var target = this.target;
      var targetMat = target.matrix;
      var ta2 = targetMat.a, tb2 = targetMat.c, tc2 = targetMat.b, td2 = targetMat.d;
      var degRadReflect = ta2 * td2 - tb2 * tc2 > 0 ? MathUtils.degRad : -MathUtils.degRad;
      var offsetRotation = this.data.offsetRotation * degRadReflect;
      var offsetShearY = this.data.offsetShearY * degRadReflect;
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        var modified = false;
        var mat = bone.matrix;
        if (rotateMix != 0) {
          var a2 = mat.a, b2 = mat.c, c2 = mat.b, d2 = mat.d;
          var r2 = Math.atan2(tc2, ta2) - Math.atan2(c2, a2) + offsetRotation;
          if (r2 > MathUtils.PI)
            r2 -= MathUtils.PI2;
          else if (r2 < -MathUtils.PI)
            r2 += MathUtils.PI2;
          r2 *= rotateMix;
          var cos = Math.cos(r2), sin = Math.sin(r2);
          mat.a = cos * a2 - sin * c2;
          mat.c = cos * b2 - sin * d2;
          mat.b = sin * a2 + cos * c2;
          mat.d = sin * b2 + cos * d2;
          modified = true;
        }
        if (translateMix != 0) {
          var temp2 = this.temp;
          target.localToWorld(temp2.set(this.data.offsetX, this.data.offsetY));
          mat.tx += (temp2.x - mat.tx) * translateMix;
          mat.ty += (temp2.y - mat.ty) * translateMix;
          modified = true;
        }
        if (scaleMix > 0) {
          var s2 = Math.sqrt(mat.a * mat.a + mat.b * mat.b);
          var ts = Math.sqrt(ta2 * ta2 + tc2 * tc2);
          if (s2 > 1e-5)
            s2 = (s2 + (ts - s2 + this.data.offsetScaleX) * scaleMix) / s2;
          mat.a *= s2;
          mat.b *= s2;
          s2 = Math.sqrt(mat.c * mat.c + mat.d * mat.d);
          ts = Math.sqrt(tb2 * tb2 + td2 * td2);
          if (s2 > 1e-5)
            s2 = (s2 + (ts - s2 + this.data.offsetScaleY) * scaleMix) / s2;
          mat.c *= s2;
          mat.d *= s2;
          modified = true;
        }
        if (shearMix > 0) {
          var b2 = mat.c, d2 = mat.d;
          var by = Math.atan2(d2, b2);
          var r2 = Math.atan2(td2, tb2) - Math.atan2(tc2, ta2) - (by - Math.atan2(mat.b, mat.a));
          if (r2 > MathUtils.PI)
            r2 -= MathUtils.PI2;
          else if (r2 < -MathUtils.PI)
            r2 += MathUtils.PI2;
          r2 = by + (r2 + offsetShearY) * shearMix;
          var s2 = Math.sqrt(b2 * b2 + d2 * d2);
          mat.c = Math.cos(r2) * s2;
          mat.d = Math.sin(r2) * s2;
          modified = true;
        }
        if (modified)
          bone.appliedValid = false;
      }
    };
    TransformConstraint2.prototype.applyRelativeWorld = function() {
      var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
      var target = this.target;
      var targetMat = target.matrix;
      var ta2 = targetMat.a, tb2 = targetMat.c, tc2 = targetMat.b, td2 = targetMat.d;
      var degRadReflect = ta2 * td2 - tb2 * tc2 > 0 ? MathUtils.degRad : -MathUtils.degRad;
      var offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        var modified = false;
        var mat = bone.matrix;
        if (rotateMix != 0) {
          var a2 = mat.a, b2 = mat.c, c2 = mat.b, d2 = mat.d;
          var r2 = Math.atan2(tc2, ta2) + offsetRotation;
          if (r2 > MathUtils.PI)
            r2 -= MathUtils.PI2;
          else if (r2 < -MathUtils.PI)
            r2 += MathUtils.PI2;
          r2 *= rotateMix;
          var cos = Math.cos(r2), sin = Math.sin(r2);
          mat.a = cos * a2 - sin * c2;
          mat.c = cos * b2 - sin * d2;
          mat.b = sin * a2 + cos * c2;
          mat.d = sin * b2 + cos * d2;
          modified = true;
        }
        if (translateMix != 0) {
          var temp2 = this.temp;
          target.localToWorld(temp2.set(this.data.offsetX, this.data.offsetY));
          mat.tx += temp2.x * translateMix;
          mat.ty += temp2.y * translateMix;
          modified = true;
        }
        if (scaleMix > 0) {
          var s2 = (Math.sqrt(ta2 * ta2 + tc2 * tc2) - 1 + this.data.offsetScaleX) * scaleMix + 1;
          mat.a *= s2;
          mat.b *= s2;
          s2 = (Math.sqrt(tb2 * tb2 + td2 * td2) - 1 + this.data.offsetScaleY) * scaleMix + 1;
          mat.c *= s2;
          mat.d *= s2;
          modified = true;
        }
        if (shearMix > 0) {
          var r2 = Math.atan2(td2, tb2) - Math.atan2(tc2, ta2);
          if (r2 > MathUtils.PI)
            r2 -= MathUtils.PI2;
          else if (r2 < -MathUtils.PI)
            r2 += MathUtils.PI2;
          var b2 = mat.c, d2 = mat.d;
          r2 = Math.atan2(d2, b2) + (r2 - MathUtils.PI / 2 + offsetShearY) * shearMix;
          var s2 = Math.sqrt(b2 * b2 + d2 * d2);
          mat.c = Math.cos(r2) * s2;
          mat.d = Math.sin(r2) * s2;
          modified = true;
        }
        if (modified)
          bone.appliedValid = false;
      }
    };
    TransformConstraint2.prototype.applyAbsoluteLocal = function() {
      var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
      var target = this.target;
      if (!target.appliedValid)
        target.updateAppliedTransform();
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        if (!bone.appliedValid)
          bone.updateAppliedTransform();
        var rotation = bone.arotation;
        if (rotateMix != 0) {
          var r2 = target.arotation - rotation + this.data.offsetRotation;
          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
          rotation += r2 * rotateMix;
        }
        var x = bone.ax, y2 = bone.ay;
        if (translateMix != 0) {
          x += (target.ax - x + this.data.offsetX) * translateMix;
          y2 += (target.ay - y2 + this.data.offsetY) * translateMix;
        }
        var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
        if (scaleMix > 0) {
          if (scaleX > 1e-5)
            scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;
          if (scaleY > 1e-5)
            scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;
        }
        var shearY = bone.ashearY;
        if (shearMix > 0) {
          var r2 = target.ashearY - shearY + this.data.offsetShearY;
          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
          bone.shearY += r2 * shearMix;
        }
        bone.updateWorldTransformWith(x, y2, rotation, scaleX, scaleY, bone.ashearX, shearY);
      }
    };
    TransformConstraint2.prototype.applyRelativeLocal = function() {
      var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
      var target = this.target;
      if (!target.appliedValid)
        target.updateAppliedTransform();
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        if (!bone.appliedValid)
          bone.updateAppliedTransform();
        var rotation = bone.arotation;
        if (rotateMix != 0)
          rotation += (target.arotation + this.data.offsetRotation) * rotateMix;
        var x = bone.ax, y2 = bone.ay;
        if (translateMix != 0) {
          x += (target.ax + this.data.offsetX) * translateMix;
          y2 += (target.ay + this.data.offsetY) * translateMix;
        }
        var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
        if (scaleMix > 0) {
          if (scaleX > 1e-5)
            scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;
          if (scaleY > 1e-5)
            scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;
        }
        var shearY = bone.ashearY;
        if (shearMix > 0)
          shearY += (target.ashearY + this.data.offsetShearY) * shearMix;
        bone.updateWorldTransformWith(x, y2, rotation, scaleX, scaleY, bone.ashearX, shearY);
      }
    };
    return TransformConstraint2;
  }()
);
var Skeleton$2 = (
  /** @class */
  function() {
    function Skeleton2(data2) {
      this._updateCache = new Array();
      this.updateCacheReset = new Array();
      this.time = 0;
      this.scaleX = 1;
      this.scaleY = 1;
      this.x = 0;
      this.y = 0;
      if (data2 == null)
        throw new Error("data cannot be null.");
      this.data = data2;
      this.bones = new Array();
      for (var i2 = 0; i2 < data2.bones.length; i2++) {
        var boneData = data2.bones[i2];
        var bone = void 0;
        if (boneData.parent == null)
          bone = new Bone$2(boneData, this, null);
        else {
          var parent_1 = this.bones[boneData.parent.index];
          bone = new Bone$2(boneData, this, parent_1);
          parent_1.children.push(bone);
        }
        this.bones.push(bone);
      }
      this.slots = new Array();
      this.drawOrder = new Array();
      for (var i2 = 0; i2 < data2.slots.length; i2++) {
        var slotData = data2.slots[i2];
        var bone = this.bones[slotData.boneData.index];
        var slot = new Slot$2(slotData, bone);
        this.slots.push(slot);
        this.drawOrder.push(slot);
      }
      this.ikConstraints = new Array();
      for (var i2 = 0; i2 < data2.ikConstraints.length; i2++) {
        var ikConstraintData = data2.ikConstraints[i2];
        this.ikConstraints.push(new IkConstraint$2(ikConstraintData, this));
      }
      this.transformConstraints = new Array();
      for (var i2 = 0; i2 < data2.transformConstraints.length; i2++) {
        var transformConstraintData = data2.transformConstraints[i2];
        this.transformConstraints.push(new TransformConstraint$2(transformConstraintData, this));
      }
      this.pathConstraints = new Array();
      for (var i2 = 0; i2 < data2.pathConstraints.length; i2++) {
        var pathConstraintData = data2.pathConstraints[i2];
        this.pathConstraints.push(new PathConstraint$2(pathConstraintData, this));
      }
      this.color = new Color(1, 1, 1, 1);
      this.updateCache();
    }
    Skeleton2.prototype.updateCache = function() {
      var updateCache = this._updateCache;
      updateCache.length = 0;
      this.updateCacheReset.length = 0;
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        bone.sorted = bone.data.skinRequired;
        bone.active = !bone.sorted;
      }
      if (this.skin != null) {
        var skinBones = this.skin.bones;
        for (var i2 = 0, n2 = this.skin.bones.length; i2 < n2; i2++) {
          var bone = this.bones[skinBones[i2].index];
          do {
            bone.sorted = false;
            bone.active = true;
            bone = bone.parent;
          } while (bone != null);
        }
      }
      var ikConstraints = this.ikConstraints;
      var transformConstraints = this.transformConstraints;
      var pathConstraints = this.pathConstraints;
      var ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;
      var constraintCount = ikCount + transformCount + pathCount;
      outer:
        for (var i2 = 0; i2 < constraintCount; i2++) {
          for (var ii2 = 0; ii2 < ikCount; ii2++) {
            var constraint = ikConstraints[ii2];
            if (constraint.data.order == i2) {
              this.sortIkConstraint(constraint);
              continue outer;
            }
          }
          for (var ii2 = 0; ii2 < transformCount; ii2++) {
            var constraint = transformConstraints[ii2];
            if (constraint.data.order == i2) {
              this.sortTransformConstraint(constraint);
              continue outer;
            }
          }
          for (var ii2 = 0; ii2 < pathCount; ii2++) {
            var constraint = pathConstraints[ii2];
            if (constraint.data.order == i2) {
              this.sortPathConstraint(constraint);
              continue outer;
            }
          }
        }
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++)
        this.sortBone(bones[i2]);
    };
    Skeleton2.prototype.sortIkConstraint = function(constraint) {
      constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true));
      if (!constraint.active)
        return;
      var target = constraint.target;
      this.sortBone(target);
      var constrained = constraint.bones;
      var parent = constrained[0];
      this.sortBone(parent);
      if (constrained.length > 1) {
        var child = constrained[constrained.length - 1];
        if (!(this._updateCache.indexOf(child) > -1))
          this.updateCacheReset.push(child);
      }
      this._updateCache.push(constraint);
      this.sortReset(parent.children);
      constrained[constrained.length - 1].sorted = true;
    };
    Skeleton2.prototype.sortPathConstraint = function(constraint) {
      constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true));
      if (!constraint.active)
        return;
      var slot = constraint.target;
      var slotIndex = slot.data.index;
      var slotBone = slot.bone;
      if (this.skin != null)
        this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
      if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)
        this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
      for (var i2 = 0, n2 = this.data.skins.length; i2 < n2; i2++)
        this.sortPathConstraintAttachment(this.data.skins[i2], slotIndex, slotBone);
      var attachment = slot.getAttachment();
      if (attachment instanceof PathAttachment$2)
        this.sortPathConstraintAttachmentWith(attachment, slotBone);
      var constrained = constraint.bones;
      var boneCount = constrained.length;
      for (var i2 = 0; i2 < boneCount; i2++)
        this.sortBone(constrained[i2]);
      this._updateCache.push(constraint);
      for (var i2 = 0; i2 < boneCount; i2++)
        this.sortReset(constrained[i2].children);
      for (var i2 = 0; i2 < boneCount; i2++)
        constrained[i2].sorted = true;
    };
    Skeleton2.prototype.sortTransformConstraint = function(constraint) {
      constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true));
      if (!constraint.active)
        return;
      this.sortBone(constraint.target);
      var constrained = constraint.bones;
      var boneCount = constrained.length;
      if (constraint.data.local) {
        for (var i2 = 0; i2 < boneCount; i2++) {
          var child = constrained[i2];
          this.sortBone(child.parent);
          if (!(this._updateCache.indexOf(child) > -1))
            this.updateCacheReset.push(child);
        }
      } else {
        for (var i2 = 0; i2 < boneCount; i2++) {
          this.sortBone(constrained[i2]);
        }
      }
      this._updateCache.push(constraint);
      for (var ii2 = 0; ii2 < boneCount; ii2++)
        this.sortReset(constrained[ii2].children);
      for (var ii2 = 0; ii2 < boneCount; ii2++)
        constrained[ii2].sorted = true;
    };
    Skeleton2.prototype.sortPathConstraintAttachment = function(skin, slotIndex, slotBone) {
      var attachments = skin.attachments[slotIndex];
      if (!attachments)
        return;
      for (var key in attachments) {
        this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
      }
    };
    Skeleton2.prototype.sortPathConstraintAttachmentWith = function(attachment, slotBone) {
      if (!(attachment instanceof PathAttachment$2))
        return;
      var pathBones = attachment.bones;
      if (pathBones == null)
        this.sortBone(slotBone);
      else {
        var bones = this.bones;
        var i2 = 0;
        while (i2 < pathBones.length) {
          var boneCount = pathBones[i2++];
          for (var n2 = i2 + boneCount; i2 < n2; i2++) {
            var boneIndex = pathBones[i2];
            this.sortBone(bones[boneIndex]);
          }
        }
      }
    };
    Skeleton2.prototype.sortBone = function(bone) {
      if (bone.sorted)
        return;
      var parent = bone.parent;
      if (parent != null)
        this.sortBone(parent);
      bone.sorted = true;
      this._updateCache.push(bone);
    };
    Skeleton2.prototype.sortReset = function(bones) {
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        if (!bone.active)
          continue;
        if (bone.sorted)
          this.sortReset(bone.children);
        bone.sorted = false;
      }
    };
    Skeleton2.prototype.updateWorldTransform = function() {
      var updateCacheReset = this.updateCacheReset;
      for (var i2 = 0, n2 = updateCacheReset.length; i2 < n2; i2++) {
        var bone = updateCacheReset[i2];
        bone.ax = bone.x;
        bone.ay = bone.y;
        bone.arotation = bone.rotation;
        bone.ascaleX = bone.scaleX;
        bone.ascaleY = bone.scaleY;
        bone.ashearX = bone.shearX;
        bone.ashearY = bone.shearY;
        bone.appliedValid = true;
      }
      var updateCache = this._updateCache;
      for (var i2 = 0, n2 = updateCache.length; i2 < n2; i2++)
        updateCache[i2].update();
    };
    Skeleton2.prototype.setToSetupPose = function() {
      this.setBonesToSetupPose();
      this.setSlotsToSetupPose();
    };
    Skeleton2.prototype.setBonesToSetupPose = function() {
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++)
        bones[i2].setToSetupPose();
      var ikConstraints = this.ikConstraints;
      for (var i2 = 0, n2 = ikConstraints.length; i2 < n2; i2++) {
        var constraint = ikConstraints[i2];
        constraint.mix = constraint.data.mix;
        constraint.softness = constraint.data.softness;
        constraint.bendDirection = constraint.data.bendDirection;
        constraint.compress = constraint.data.compress;
        constraint.stretch = constraint.data.stretch;
      }
      var transformConstraints = this.transformConstraints;
      for (var i2 = 0, n2 = transformConstraints.length; i2 < n2; i2++) {
        var constraint = transformConstraints[i2];
        var data2 = constraint.data;
        constraint.rotateMix = data2.rotateMix;
        constraint.translateMix = data2.translateMix;
        constraint.scaleMix = data2.scaleMix;
        constraint.shearMix = data2.shearMix;
      }
      var pathConstraints = this.pathConstraints;
      for (var i2 = 0, n2 = pathConstraints.length; i2 < n2; i2++) {
        var constraint = pathConstraints[i2];
        var data2 = constraint.data;
        constraint.position = data2.position;
        constraint.spacing = data2.spacing;
        constraint.rotateMix = data2.rotateMix;
        constraint.translateMix = data2.translateMix;
      }
    };
    Skeleton2.prototype.setSlotsToSetupPose = function() {
      var slots = this.slots;
      Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
      for (var i2 = 0, n2 = slots.length; i2 < n2; i2++)
        slots[i2].setToSetupPose();
    };
    Skeleton2.prototype.getRootBone = function() {
      if (this.bones.length == 0)
        return null;
      return this.bones[0];
    };
    Skeleton2.prototype.findBone = function(boneName) {
      if (boneName == null)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        if (bone.data.name == boneName)
          return bone;
      }
      return null;
    };
    Skeleton2.prototype.findBoneIndex = function(boneName) {
      if (boneName == null)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++)
        if (bones[i2].data.name == boneName)
          return i2;
      return -1;
    };
    Skeleton2.prototype.findSlot = function(slotName) {
      if (slotName == null)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i2 = 0, n2 = slots.length; i2 < n2; i2++) {
        var slot = slots[i2];
        if (slot.data.name == slotName)
          return slot;
      }
      return null;
    };
    Skeleton2.prototype.findSlotIndex = function(slotName) {
      if (slotName == null)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i2 = 0, n2 = slots.length; i2 < n2; i2++)
        if (slots[i2].data.name == slotName)
          return i2;
      return -1;
    };
    Skeleton2.prototype.setSkinByName = function(skinName) {
      var skin = this.data.findSkin(skinName);
      if (skin == null)
        throw new Error("Skin not found: " + skinName);
      this.setSkin(skin);
    };
    Skeleton2.prototype.setSkin = function(newSkin) {
      if (newSkin == this.skin)
        return;
      if (newSkin != null) {
        if (this.skin != null)
          newSkin.attachAll(this, this.skin);
        else {
          var slots = this.slots;
          for (var i2 = 0, n2 = slots.length; i2 < n2; i2++) {
            var slot = slots[i2];
            var name_1 = slot.data.attachmentName;
            if (name_1 != null) {
              var attachment = newSkin.getAttachment(i2, name_1);
              if (attachment != null)
                slot.setAttachment(attachment);
            }
          }
        }
      }
      this.skin = newSkin;
      this.updateCache();
    };
    Skeleton2.prototype.getAttachmentByName = function(slotName, attachmentName) {
      return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);
    };
    Skeleton2.prototype.getAttachment = function(slotIndex, attachmentName) {
      if (attachmentName == null)
        throw new Error("attachmentName cannot be null.");
      if (this.skin != null) {
        var attachment = this.skin.getAttachment(slotIndex, attachmentName);
        if (attachment != null)
          return attachment;
      }
      if (this.data.defaultSkin != null)
        return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
      return null;
    };
    Skeleton2.prototype.setAttachment = function(slotName, attachmentName) {
      if (slotName == null)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i2 = 0, n2 = slots.length; i2 < n2; i2++) {
        var slot = slots[i2];
        if (slot.data.name == slotName) {
          var attachment = null;
          if (attachmentName != null) {
            attachment = this.getAttachment(i2, attachmentName);
            if (attachment == null)
              throw new Error("Attachment not found: " + attachmentName + ", for slot: " + slotName);
          }
          slot.setAttachment(attachment);
          return;
        }
      }
      throw new Error("Slot not found: " + slotName);
    };
    Skeleton2.prototype.findIkConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var ikConstraints = this.ikConstraints;
      for (var i2 = 0, n2 = ikConstraints.length; i2 < n2; i2++) {
        var ikConstraint = ikConstraints[i2];
        if (ikConstraint.data.name == constraintName)
          return ikConstraint;
      }
      return null;
    };
    Skeleton2.prototype.findTransformConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var transformConstraints = this.transformConstraints;
      for (var i2 = 0, n2 = transformConstraints.length; i2 < n2; i2++) {
        var constraint = transformConstraints[i2];
        if (constraint.data.name == constraintName)
          return constraint;
      }
      return null;
    };
    Skeleton2.prototype.findPathConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var pathConstraints = this.pathConstraints;
      for (var i2 = 0, n2 = pathConstraints.length; i2 < n2; i2++) {
        var constraint = pathConstraints[i2];
        if (constraint.data.name == constraintName)
          return constraint;
      }
      return null;
    };
    Skeleton2.prototype.getBounds = function(offset, size, temp2) {
      if (temp2 === void 0) {
        temp2 = new Array(2);
      }
      if (offset == null)
        throw new Error("offset cannot be null.");
      if (size == null)
        throw new Error("size cannot be null.");
      var drawOrder = this.drawOrder;
      var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
      for (var i2 = 0, n2 = drawOrder.length; i2 < n2; i2++) {
        var slot = drawOrder[i2];
        if (!slot.bone.active)
          continue;
        var verticesLength = 0;
        var vertices = null;
        var attachment = slot.getAttachment();
        if (attachment instanceof RegionAttachment$2) {
          verticesLength = 8;
          vertices = Utils.setArraySize(temp2, verticesLength, 0);
          attachment.computeWorldVertices(slot.bone, vertices, 0, 2);
        } else if (attachment instanceof MeshAttachment$2) {
          var mesh = attachment;
          verticesLength = mesh.worldVerticesLength;
          vertices = Utils.setArraySize(temp2, verticesLength, 0);
          mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
        }
        if (vertices != null) {
          for (var ii2 = 0, nn2 = vertices.length; ii2 < nn2; ii2 += 2) {
            var x = vertices[ii2], y2 = vertices[ii2 + 1];
            minX = Math.min(minX, x);
            minY = Math.min(minY, y2);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y2);
          }
        }
      }
      offset.set(minX, minY);
      size.set(maxX - minX, maxY - minY);
    };
    Skeleton2.prototype.update = function(delta) {
      this.time += delta;
    };
    Object.defineProperty(Skeleton2.prototype, "flipX", {
      get: function() {
        return this.scaleX == -1;
      },
      set: function(value) {
        if (!Skeleton2.deprecatedWarning1) {
          Skeleton2.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
        }
        this.scaleX = value ? 1 : -1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Skeleton2.prototype, "flipY", {
      get: function() {
        return this.scaleY == -1;
      },
      set: function(value) {
        if (!Skeleton2.deprecatedWarning1) {
          Skeleton2.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
        }
        this.scaleY = value ? 1 : -1;
      },
      enumerable: false,
      configurable: true
    });
    Skeleton2.deprecatedWarning1 = false;
    return Skeleton2;
  }()
);
var SkeletonData$2 = (
  /** @class */
  function() {
    function SkeletonData2() {
      this.bones = new Array();
      this.slots = new Array();
      this.skins = new Array();
      this.events = new Array();
      this.animations = new Array();
      this.ikConstraints = new Array();
      this.transformConstraints = new Array();
      this.pathConstraints = new Array();
      this.fps = 0;
    }
    SkeletonData2.prototype.findBone = function(boneName) {
      if (boneName == null)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        if (bone.name == boneName)
          return bone;
      }
      return null;
    };
    SkeletonData2.prototype.findBoneIndex = function(boneName) {
      if (boneName == null)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++)
        if (bones[i2].name == boneName)
          return i2;
      return -1;
    };
    SkeletonData2.prototype.findSlot = function(slotName) {
      if (slotName == null)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i2 = 0, n2 = slots.length; i2 < n2; i2++) {
        var slot = slots[i2];
        if (slot.name == slotName)
          return slot;
      }
      return null;
    };
    SkeletonData2.prototype.findSlotIndex = function(slotName) {
      if (slotName == null)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i2 = 0, n2 = slots.length; i2 < n2; i2++)
        if (slots[i2].name == slotName)
          return i2;
      return -1;
    };
    SkeletonData2.prototype.findSkin = function(skinName) {
      if (skinName == null)
        throw new Error("skinName cannot be null.");
      var skins = this.skins;
      for (var i2 = 0, n2 = skins.length; i2 < n2; i2++) {
        var skin = skins[i2];
        if (skin.name == skinName)
          return skin;
      }
      return null;
    };
    SkeletonData2.prototype.findEvent = function(eventDataName) {
      if (eventDataName == null)
        throw new Error("eventDataName cannot be null.");
      var events = this.events;
      for (var i2 = 0, n2 = events.length; i2 < n2; i2++) {
        var event_1 = events[i2];
        if (event_1.name == eventDataName)
          return event_1;
      }
      return null;
    };
    SkeletonData2.prototype.findAnimation = function(animationName) {
      if (animationName == null)
        throw new Error("animationName cannot be null.");
      var animations = this.animations;
      for (var i2 = 0, n2 = animations.length; i2 < n2; i2++) {
        var animation2 = animations[i2];
        if (animation2.name == animationName)
          return animation2;
      }
      return null;
    };
    SkeletonData2.prototype.findIkConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var ikConstraints = this.ikConstraints;
      for (var i2 = 0, n2 = ikConstraints.length; i2 < n2; i2++) {
        var constraint = ikConstraints[i2];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    };
    SkeletonData2.prototype.findTransformConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var transformConstraints = this.transformConstraints;
      for (var i2 = 0, n2 = transformConstraints.length; i2 < n2; i2++) {
        var constraint = transformConstraints[i2];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    };
    SkeletonData2.prototype.findPathConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var pathConstraints = this.pathConstraints;
      for (var i2 = 0, n2 = pathConstraints.length; i2 < n2; i2++) {
        var constraint = pathConstraints[i2];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    };
    SkeletonData2.prototype.findPathConstraintIndex = function(pathConstraintName) {
      if (pathConstraintName == null)
        throw new Error("pathConstraintName cannot be null.");
      var pathConstraints = this.pathConstraints;
      for (var i2 = 0, n2 = pathConstraints.length; i2 < n2; i2++)
        if (pathConstraints[i2].name == pathConstraintName)
          return i2;
      return -1;
    };
    return SkeletonData2;
  }()
);
var SlotData$2 = (
  /** @class */
  function() {
    function SlotData2(index2, name, boneData) {
      this.color = new Color(1, 1, 1, 1);
      if (index2 < 0)
        throw new Error("index must be >= 0.");
      if (name == null)
        throw new Error("name cannot be null.");
      if (boneData == null)
        throw new Error("boneData cannot be null.");
      this.index = index2;
      this.name = name;
      this.boneData = boneData;
    }
    return SlotData2;
  }()
);
var TransformConstraintData$2 = (
  /** @class */
  function(_super) {
    __extends$4(TransformConstraintData2, _super);
    function TransformConstraintData2(name) {
      var _this = _super.call(this, name, 0, false) || this;
      _this.bones = new Array();
      _this.rotateMix = 0;
      _this.translateMix = 0;
      _this.scaleMix = 0;
      _this.shearMix = 0;
      _this.offsetRotation = 0;
      _this.offsetX = 0;
      _this.offsetY = 0;
      _this.offsetScaleX = 0;
      _this.offsetScaleY = 0;
      _this.offsetShearY = 0;
      _this.relative = false;
      _this.local = false;
      return _this;
    }
    return TransformConstraintData2;
  }(ConstraintData$1)
);
var SkinEntry$1 = (
  /** @class */
  function() {
    function SkinEntry2(slotIndex, name, attachment) {
      this.slotIndex = slotIndex;
      this.name = name;
      this.attachment = attachment;
    }
    return SkinEntry2;
  }()
);
var Skin$2 = (
  /** @class */
  function() {
    function Skin2(name) {
      this.attachments = new Array();
      this.bones = Array();
      this.constraints = new Array();
      if (name == null)
        throw new Error("name cannot be null.");
      this.name = name;
    }
    Skin2.prototype.setAttachment = function(slotIndex, name, attachment) {
      if (attachment == null)
        throw new Error("attachment cannot be null.");
      var attachments = this.attachments;
      if (slotIndex >= attachments.length)
        attachments.length = slotIndex + 1;
      if (!attachments[slotIndex])
        attachments[slotIndex] = {};
      attachments[slotIndex][name] = attachment;
    };
    Skin2.prototype.addSkin = function(skin) {
      for (var i2 = 0; i2 < skin.bones.length; i2++) {
        var bone = skin.bones[i2];
        var contained = false;
        for (var j2 = 0; j2 < this.bones.length; j2++) {
          if (this.bones[j2] == bone) {
            contained = true;
            break;
          }
        }
        if (!contained)
          this.bones.push(bone);
      }
      for (var i2 = 0; i2 < skin.constraints.length; i2++) {
        var constraint = skin.constraints[i2];
        var contained = false;
        for (var j2 = 0; j2 < this.constraints.length; j2++) {
          if (this.constraints[j2] == constraint) {
            contained = true;
            break;
          }
        }
        if (!contained)
          this.constraints.push(constraint);
      }
      var attachments = skin.getAttachments();
      for (var i2 = 0; i2 < attachments.length; i2++) {
        var attachment = attachments[i2];
        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
      }
    };
    Skin2.prototype.copySkin = function(skin) {
      for (var i2 = 0; i2 < skin.bones.length; i2++) {
        var bone = skin.bones[i2];
        var contained = false;
        for (var j2 = 0; j2 < this.bones.length; j2++) {
          if (this.bones[j2] == bone) {
            contained = true;
            break;
          }
        }
        if (!contained)
          this.bones.push(bone);
      }
      for (var i2 = 0; i2 < skin.constraints.length; i2++) {
        var constraint = skin.constraints[i2];
        var contained = false;
        for (var j2 = 0; j2 < this.constraints.length; j2++) {
          if (this.constraints[j2] == constraint) {
            contained = true;
            break;
          }
        }
        if (!contained)
          this.constraints.push(constraint);
      }
      var attachments = skin.getAttachments();
      for (var i2 = 0; i2 < attachments.length; i2++) {
        var attachment = attachments[i2];
        if (attachment.attachment == null)
          continue;
        if (attachment.attachment instanceof MeshAttachment$2) {
          attachment.attachment = attachment.attachment.newLinkedMesh();
          this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
        } else {
          attachment.attachment = attachment.attachment.copy();
          this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
        }
      }
    };
    Skin2.prototype.getAttachment = function(slotIndex, name) {
      var dictionary = this.attachments[slotIndex];
      return dictionary ? dictionary[name] : null;
    };
    Skin2.prototype.removeAttachment = function(slotIndex, name) {
      var dictionary = this.attachments[slotIndex];
      if (dictionary)
        dictionary[name] = null;
    };
    Skin2.prototype.getAttachments = function() {
      var entries = new Array();
      for (var i2 = 0; i2 < this.attachments.length; i2++) {
        var slotAttachments = this.attachments[i2];
        if (slotAttachments) {
          for (var name_1 in slotAttachments) {
            var attachment = slotAttachments[name_1];
            if (attachment)
              entries.push(new SkinEntry$1(i2, name_1, attachment));
          }
        }
      }
      return entries;
    };
    Skin2.prototype.getAttachmentsForSlot = function(slotIndex, attachments) {
      var slotAttachments = this.attachments[slotIndex];
      if (slotAttachments) {
        for (var name_2 in slotAttachments) {
          var attachment = slotAttachments[name_2];
          if (attachment)
            attachments.push(new SkinEntry$1(slotIndex, name_2, attachment));
        }
      }
    };
    Skin2.prototype.clear = function() {
      this.attachments.length = 0;
      this.bones.length = 0;
      this.constraints.length = 0;
    };
    Skin2.prototype.attachAll = function(skeleton, oldSkin) {
      var slotIndex = 0;
      for (var i2 = 0; i2 < skeleton.slots.length; i2++) {
        var slot = skeleton.slots[i2];
        var slotAttachment = slot.getAttachment();
        if (slotAttachment && slotIndex < oldSkin.attachments.length) {
          var dictionary = oldSkin.attachments[slotIndex];
          for (var key in dictionary) {
            var skinAttachment = dictionary[key];
            if (slotAttachment == skinAttachment) {
              var attachment = this.getAttachment(slotIndex, key);
              if (attachment != null)
                slot.setAttachment(attachment);
              break;
            }
          }
        }
        slotIndex++;
      }
    };
    return Skin2;
  }()
);
var SkeletonBinary$1 = (
  /** @class */
  function() {
    function SkeletonBinary2(attachmentLoader) {
      this.scale = 1;
      this.linkedMeshes = new Array();
      this.attachmentLoader = attachmentLoader;
    }
    SkeletonBinary2.prototype.readSkeletonData = function(binary) {
      var scale = this.scale;
      var skeletonData = new SkeletonData$2();
      skeletonData.name = "";
      var input = new BinaryInput(binary);
      skeletonData.hash = input.readString();
      skeletonData.version = input.readString();
      if (skeletonData.version === "3.8.75") {
        var error2 = "Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.";
        console.error(error2);
      }
      skeletonData.x = input.readFloat();
      skeletonData.y = input.readFloat();
      skeletonData.width = input.readFloat();
      skeletonData.height = input.readFloat();
      var nonessential = input.readBoolean();
      if (nonessential) {
        skeletonData.fps = input.readFloat();
        skeletonData.imagesPath = input.readString();
        skeletonData.audioPath = input.readString();
      }
      var n2 = 0;
      n2 = input.readInt(true);
      for (var i2 = 0; i2 < n2; i2++)
        input.strings.push(input.readString());
      n2 = input.readInt(true);
      for (var i2 = 0; i2 < n2; i2++) {
        var name_1 = input.readString();
        var parent_1 = i2 == 0 ? null : skeletonData.bones[input.readInt(true)];
        var data2 = new BoneData$2(i2, name_1, parent_1);
        data2.rotation = input.readFloat();
        data2.x = input.readFloat() * scale;
        data2.y = input.readFloat() * scale;
        data2.scaleX = input.readFloat();
        data2.scaleY = input.readFloat();
        data2.shearX = input.readFloat();
        data2.shearY = input.readFloat();
        data2.length = input.readFloat() * scale;
        data2.transformMode = SkeletonBinary2.TransformModeValues[input.readInt(true)];
        data2.skinRequired = input.readBoolean();
        if (nonessential)
          Color.rgba8888ToColor(data2.color, input.readInt32());
        skeletonData.bones.push(data2);
      }
      n2 = input.readInt(true);
      for (var i2 = 0; i2 < n2; i2++) {
        var slotName = input.readString();
        var boneData = skeletonData.bones[input.readInt(true)];
        var data2 = new SlotData$2(i2, slotName, boneData);
        Color.rgba8888ToColor(data2.color, input.readInt32());
        var darkColor = input.readInt32();
        if (darkColor != -1)
          Color.rgb888ToColor(data2.darkColor = new Color(), darkColor);
        data2.attachmentName = input.readStringRef();
        data2.blendMode = SkeletonBinary2.BlendModeValues[input.readInt(true)];
        skeletonData.slots.push(data2);
      }
      n2 = input.readInt(true);
      for (var i2 = 0, nn2 = void 0; i2 < n2; i2++) {
        var data2 = new IkConstraintData$2(input.readString());
        data2.order = input.readInt(true);
        data2.skinRequired = input.readBoolean();
        nn2 = input.readInt(true);
        for (var ii2 = 0; ii2 < nn2; ii2++)
          data2.bones.push(skeletonData.bones[input.readInt(true)]);
        data2.target = skeletonData.bones[input.readInt(true)];
        data2.mix = input.readFloat();
        data2.softness = input.readFloat() * scale;
        data2.bendDirection = input.readByte();
        data2.compress = input.readBoolean();
        data2.stretch = input.readBoolean();
        data2.uniform = input.readBoolean();
        skeletonData.ikConstraints.push(data2);
      }
      n2 = input.readInt(true);
      for (var i2 = 0, nn2 = void 0; i2 < n2; i2++) {
        var data2 = new TransformConstraintData$2(input.readString());
        data2.order = input.readInt(true);
        data2.skinRequired = input.readBoolean();
        nn2 = input.readInt(true);
        for (var ii2 = 0; ii2 < nn2; ii2++)
          data2.bones.push(skeletonData.bones[input.readInt(true)]);
        data2.target = skeletonData.bones[input.readInt(true)];
        data2.local = input.readBoolean();
        data2.relative = input.readBoolean();
        data2.offsetRotation = input.readFloat();
        data2.offsetX = input.readFloat() * scale;
        data2.offsetY = input.readFloat() * scale;
        data2.offsetScaleX = input.readFloat();
        data2.offsetScaleY = input.readFloat();
        data2.offsetShearY = input.readFloat();
        data2.rotateMix = input.readFloat();
        data2.translateMix = input.readFloat();
        data2.scaleMix = input.readFloat();
        data2.shearMix = input.readFloat();
        skeletonData.transformConstraints.push(data2);
      }
      n2 = input.readInt(true);
      for (var i2 = 0, nn2 = void 0; i2 < n2; i2++) {
        var data2 = new PathConstraintData$2(input.readString());
        data2.order = input.readInt(true);
        data2.skinRequired = input.readBoolean();
        nn2 = input.readInt(true);
        for (var ii2 = 0; ii2 < nn2; ii2++)
          data2.bones.push(skeletonData.bones[input.readInt(true)]);
        data2.target = skeletonData.slots[input.readInt(true)];
        data2.positionMode = SkeletonBinary2.PositionModeValues[input.readInt(true)];
        data2.spacingMode = SkeletonBinary2.SpacingModeValues[input.readInt(true)];
        data2.rotateMode = SkeletonBinary2.RotateModeValues[input.readInt(true)];
        data2.offsetRotation = input.readFloat();
        data2.position = input.readFloat();
        if (data2.positionMode == PositionMode.Fixed)
          data2.position *= scale;
        data2.spacing = input.readFloat();
        if (data2.spacingMode == SpacingMode$2.Length || data2.spacingMode == SpacingMode$2.Fixed)
          data2.spacing *= scale;
        data2.rotateMix = input.readFloat();
        data2.translateMix = input.readFloat();
        skeletonData.pathConstraints.push(data2);
      }
      var defaultSkin = this.readSkin(input, skeletonData, true, nonessential);
      if (defaultSkin != null) {
        skeletonData.defaultSkin = defaultSkin;
        skeletonData.skins.push(defaultSkin);
      }
      {
        var i2 = skeletonData.skins.length;
        Utils.setArraySize(skeletonData.skins, n2 = i2 + input.readInt(true));
        for (; i2 < n2; i2++)
          skeletonData.skins[i2] = this.readSkin(input, skeletonData, false, nonessential);
      }
      n2 = this.linkedMeshes.length;
      for (var i2 = 0; i2 < n2; i2++) {
        var linkedMesh = this.linkedMeshes[i2];
        var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
        if (skin == null)
          throw new Error("Skin not found: " + linkedMesh.skin);
        var parent_2 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
        if (parent_2 == null)
          throw new Error("Parent mesh not found: " + linkedMesh.parent);
        linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent_2 : linkedMesh.mesh;
        linkedMesh.mesh.setParentMesh(parent_2);
      }
      this.linkedMeshes.length = 0;
      n2 = input.readInt(true);
      for (var i2 = 0; i2 < n2; i2++) {
        var data2 = new EventData$2(input.readStringRef());
        data2.intValue = input.readInt(false);
        data2.floatValue = input.readFloat();
        data2.stringValue = input.readString();
        data2.audioPath = input.readString();
        if (data2.audioPath != null) {
          data2.volume = input.readFloat();
          data2.balance = input.readFloat();
        }
        skeletonData.events.push(data2);
      }
      n2 = input.readInt(true);
      for (var i2 = 0; i2 < n2; i2++)
        skeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));
      return skeletonData;
    };
    SkeletonBinary2.prototype.readSkin = function(input, skeletonData, defaultSkin, nonessential) {
      var skin = null;
      var slotCount = 0;
      if (defaultSkin) {
        slotCount = input.readInt(true);
        if (slotCount == 0)
          return null;
        skin = new Skin$2("default");
      } else {
        skin = new Skin$2(input.readStringRef());
        skin.bones.length = input.readInt(true);
        for (var i2 = 0, n2 = skin.bones.length; i2 < n2; i2++)
          skin.bones[i2] = skeletonData.bones[input.readInt(true)];
        for (var i2 = 0, n2 = input.readInt(true); i2 < n2; i2++)
          skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);
        for (var i2 = 0, n2 = input.readInt(true); i2 < n2; i2++)
          skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);
        for (var i2 = 0, n2 = input.readInt(true); i2 < n2; i2++)
          skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);
        slotCount = input.readInt(true);
      }
      for (var i2 = 0; i2 < slotCount; i2++) {
        var slotIndex = input.readInt(true);
        for (var ii2 = 0, nn2 = input.readInt(true); ii2 < nn2; ii2++) {
          var name_2 = input.readStringRef();
          var attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name_2, nonessential);
          if (attachment != null)
            skin.setAttachment(slotIndex, name_2, attachment);
        }
      }
      return skin;
    };
    SkeletonBinary2.prototype.readAttachment = function(input, skeletonData, skin, slotIndex, attachmentName, nonessential) {
      var scale = this.scale;
      var name = input.readStringRef();
      if (name == null)
        name = attachmentName;
      var typeIndex = input.readByte();
      var type2 = SkeletonBinary2.AttachmentTypeValues[typeIndex];
      switch (type2) {
        case AttachmentType.Region: {
          var path = input.readStringRef();
          var rotation = input.readFloat();
          var x = input.readFloat();
          var y2 = input.readFloat();
          var scaleX = input.readFloat();
          var scaleY = input.readFloat();
          var width = input.readFloat();
          var height = input.readFloat();
          var color2 = input.readInt32();
          if (path == null)
            path = name;
          var region = this.attachmentLoader.newRegionAttachment(skin, name, path);
          if (region == null)
            return null;
          region.path = path;
          region.x = x * scale;
          region.y = y2 * scale;
          region.scaleX = scaleX;
          region.scaleY = scaleY;
          region.rotation = rotation;
          region.width = width * scale;
          region.height = height * scale;
          Color.rgba8888ToColor(region.color, color2);
          return region;
        }
        case AttachmentType.BoundingBox: {
          var vertexCount = input.readInt(true);
          var vertices = this.readVertices(input, vertexCount);
          var color2 = nonessential ? input.readInt32() : 0;
          var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
          if (box == null)
            return null;
          box.worldVerticesLength = vertexCount << 1;
          box.vertices = vertices.vertices;
          box.bones = vertices.bones;
          if (nonessential)
            Color.rgba8888ToColor(box.color, color2);
          return box;
        }
        case AttachmentType.Mesh: {
          var path = input.readStringRef();
          var color2 = input.readInt32();
          var vertexCount = input.readInt(true);
          var uvs = this.readFloatArray(input, vertexCount << 1, 1);
          var triangles = this.readShortArray(input);
          var vertices = this.readVertices(input, vertexCount);
          var hullLength = input.readInt(true);
          var edges = null;
          var width = 0, height = 0;
          if (nonessential) {
            edges = this.readShortArray(input);
            width = input.readFloat();
            height = input.readFloat();
          }
          if (path == null)
            path = name;
          var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
          if (mesh == null)
            return null;
          mesh.path = path;
          Color.rgba8888ToColor(mesh.color, color2);
          mesh.bones = vertices.bones;
          mesh.vertices = vertices.vertices;
          mesh.worldVerticesLength = vertexCount << 1;
          mesh.triangles = triangles;
          mesh.regionUVs = new Float32Array(uvs);
          mesh.hullLength = hullLength << 1;
          if (nonessential) {
            mesh.edges = edges;
            mesh.width = width * scale;
            mesh.height = height * scale;
          }
          return mesh;
        }
        case AttachmentType.LinkedMesh: {
          var path = input.readStringRef();
          var color2 = input.readInt32();
          var skinName = input.readStringRef();
          var parent_3 = input.readStringRef();
          var inheritDeform = input.readBoolean();
          var width = 0, height = 0;
          if (nonessential) {
            width = input.readFloat();
            height = input.readFloat();
          }
          if (path == null)
            path = name;
          var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
          if (mesh == null)
            return null;
          mesh.path = path;
          Color.rgba8888ToColor(mesh.color, color2);
          if (nonessential) {
            mesh.width = width * scale;
            mesh.height = height * scale;
          }
          this.linkedMeshes.push(new LinkedMesh$1$1(mesh, skinName, slotIndex, parent_3, inheritDeform));
          return mesh;
        }
        case AttachmentType.Path: {
          var closed_1 = input.readBoolean();
          var constantSpeed = input.readBoolean();
          var vertexCount = input.readInt(true);
          var vertices = this.readVertices(input, vertexCount);
          var lengths = Utils.newArray(vertexCount / 3, 0);
          for (var i2 = 0, n2 = lengths.length; i2 < n2; i2++)
            lengths[i2] = input.readFloat() * scale;
          var color2 = nonessential ? input.readInt32() : 0;
          var path = this.attachmentLoader.newPathAttachment(skin, name);
          if (path == null)
            return null;
          path.closed = closed_1;
          path.constantSpeed = constantSpeed;
          path.worldVerticesLength = vertexCount << 1;
          path.vertices = vertices.vertices;
          path.bones = vertices.bones;
          path.lengths = lengths;
          if (nonessential)
            Color.rgba8888ToColor(path.color, color2);
          return path;
        }
        case AttachmentType.Point: {
          var rotation = input.readFloat();
          var x = input.readFloat();
          var y2 = input.readFloat();
          var color2 = nonessential ? input.readInt32() : 0;
          var point = this.attachmentLoader.newPointAttachment(skin, name);
          if (point == null)
            return null;
          point.x = x * scale;
          point.y = y2 * scale;
          point.rotation = rotation;
          if (nonessential)
            Color.rgba8888ToColor(point.color, color2);
          return point;
        }
        case AttachmentType.Clipping: {
          var endSlotIndex = input.readInt(true);
          var vertexCount = input.readInt(true);
          var vertices = this.readVertices(input, vertexCount);
          var color2 = nonessential ? input.readInt32() : 0;
          var clip = this.attachmentLoader.newClippingAttachment(skin, name);
          if (clip == null)
            return null;
          clip.endSlot = skeletonData.slots[endSlotIndex];
          clip.worldVerticesLength = vertexCount << 1;
          clip.vertices = vertices.vertices;
          clip.bones = vertices.bones;
          if (nonessential)
            Color.rgba8888ToColor(clip.color, color2);
          return clip;
        }
      }
      return null;
    };
    SkeletonBinary2.prototype.readVertices = function(input, vertexCount) {
      var verticesLength = vertexCount << 1;
      var vertices = new Vertices$1();
      var scale = this.scale;
      if (!input.readBoolean()) {
        vertices.vertices = this.readFloatArray(input, verticesLength, scale);
        return vertices;
      }
      var weights = new Array();
      var bonesArray = new Array();
      for (var i2 = 0; i2 < vertexCount; i2++) {
        var boneCount = input.readInt(true);
        bonesArray.push(boneCount);
        for (var ii2 = 0; ii2 < boneCount; ii2++) {
          bonesArray.push(input.readInt(true));
          weights.push(input.readFloat() * scale);
          weights.push(input.readFloat() * scale);
          weights.push(input.readFloat());
        }
      }
      vertices.vertices = Utils.toFloatArray(weights);
      vertices.bones = bonesArray;
      return vertices;
    };
    SkeletonBinary2.prototype.readFloatArray = function(input, n2, scale) {
      var array = new Array(n2);
      if (scale == 1) {
        for (var i2 = 0; i2 < n2; i2++)
          array[i2] = input.readFloat();
      } else {
        for (var i2 = 0; i2 < n2; i2++)
          array[i2] = input.readFloat() * scale;
      }
      return array;
    };
    SkeletonBinary2.prototype.readShortArray = function(input) {
      var n2 = input.readInt(true);
      var array = new Array(n2);
      for (var i2 = 0; i2 < n2; i2++)
        array[i2] = input.readShort();
      return array;
    };
    SkeletonBinary2.prototype.readAnimation = function(input, name, skeletonData) {
      var timelines = new Array();
      var scale = this.scale;
      var duration = 0;
      var tempColor1 = new Color();
      var tempColor2 = new Color();
      for (var i2 = 0, n2 = input.readInt(true); i2 < n2; i2++) {
        var slotIndex = input.readInt(true);
        for (var ii2 = 0, nn2 = input.readInt(true); ii2 < nn2; ii2++) {
          var timelineType = input.readByte();
          var frameCount = input.readInt(true);
          switch (timelineType) {
            case SkeletonBinary2.SLOT_ATTACHMENT: {
              var timeline = new AttachmentTimeline$2(frameCount);
              timeline.slotIndex = slotIndex;
              for (var frameIndex = 0; frameIndex < frameCount; frameIndex++)
                timeline.setFrame(frameIndex, input.readFloat(), input.readStringRef());
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[frameCount - 1]);
              break;
            }
            case SkeletonBinary2.SLOT_COLOR: {
              var timeline = new ColorTimeline$1(frameCount);
              timeline.slotIndex = slotIndex;
              for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                var time = input.readFloat();
                Color.rgba8888ToColor(tempColor1, input.readInt32());
                timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a);
                if (frameIndex < frameCount - 1)
                  this.readCurve(input, frameIndex, timeline);
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(frameCount - 1) * ColorTimeline$1.ENTRIES]);
              break;
            }
            case SkeletonBinary2.SLOT_TWO_COLOR: {
              var timeline = new TwoColorTimeline$1(frameCount);
              timeline.slotIndex = slotIndex;
              for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                var time = input.readFloat();
                Color.rgba8888ToColor(tempColor1, input.readInt32());
                Color.rgb888ToColor(tempColor2, input.readInt32());
                timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a, tempColor2.r, tempColor2.g, tempColor2.b);
                if (frameIndex < frameCount - 1)
                  this.readCurve(input, frameIndex, timeline);
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(frameCount - 1) * TwoColorTimeline$1.ENTRIES]);
              break;
            }
          }
        }
      }
      for (var i2 = 0, n2 = input.readInt(true); i2 < n2; i2++) {
        var boneIndex = input.readInt(true);
        for (var ii2 = 0, nn2 = input.readInt(true); ii2 < nn2; ii2++) {
          var timelineType = input.readByte();
          var frameCount = input.readInt(true);
          switch (timelineType) {
            case SkeletonBinary2.BONE_ROTATE: {
              var timeline = new RotateTimeline$2(frameCount);
              timeline.boneIndex = boneIndex;
              for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                timeline.setFrame(frameIndex, input.readFloat(), input.readFloat());
                if (frameIndex < frameCount - 1)
                  this.readCurve(input, frameIndex, timeline);
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(frameCount - 1) * RotateTimeline$2.ENTRIES]);
              break;
            }
            case SkeletonBinary2.BONE_TRANSLATE:
            case SkeletonBinary2.BONE_SCALE:
            case SkeletonBinary2.BONE_SHEAR: {
              var timeline = void 0;
              var timelineScale = 1;
              if (timelineType == SkeletonBinary2.BONE_SCALE)
                timeline = new ScaleTimeline$2(frameCount);
              else if (timelineType == SkeletonBinary2.BONE_SHEAR)
                timeline = new ShearTimeline$2(frameCount);
              else {
                timeline = new TranslateTimeline$2(frameCount);
                timelineScale = scale;
              }
              timeline.boneIndex = boneIndex;
              for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale, input.readFloat() * timelineScale);
                if (frameIndex < frameCount - 1)
                  this.readCurve(input, frameIndex, timeline);
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(frameCount - 1) * TranslateTimeline$2.ENTRIES]);
              break;
            }
          }
        }
      }
      for (var i2 = 0, n2 = input.readInt(true); i2 < n2; i2++) {
        var index2 = input.readInt(true);
        var frameCount = input.readInt(true);
        var timeline = new IkConstraintTimeline$2(frameCount);
        timeline.ikConstraintIndex = index2;
        for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
          timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat() * scale, input.readByte(), input.readBoolean(), input.readBoolean());
          if (frameIndex < frameCount - 1)
            this.readCurve(input, frameIndex, timeline);
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[(frameCount - 1) * IkConstraintTimeline$2.ENTRIES]);
      }
      for (var i2 = 0, n2 = input.readInt(true); i2 < n2; i2++) {
        var index2 = input.readInt(true);
        var frameCount = input.readInt(true);
        var timeline = new TransformConstraintTimeline$2(frameCount);
        timeline.transformConstraintIndex = index2;
        for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
          timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());
          if (frameIndex < frameCount - 1)
            this.readCurve(input, frameIndex, timeline);
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[(frameCount - 1) * TransformConstraintTimeline$2.ENTRIES]);
      }
      for (var i2 = 0, n2 = input.readInt(true); i2 < n2; i2++) {
        var index2 = input.readInt(true);
        var data2 = skeletonData.pathConstraints[index2];
        for (var ii2 = 0, nn2 = input.readInt(true); ii2 < nn2; ii2++) {
          var timelineType = input.readByte();
          var frameCount = input.readInt(true);
          switch (timelineType) {
            case SkeletonBinary2.PATH_POSITION:
            case SkeletonBinary2.PATH_SPACING: {
              var timeline = void 0;
              var timelineScale = 1;
              if (timelineType == SkeletonBinary2.PATH_SPACING) {
                timeline = new PathConstraintSpacingTimeline$2(frameCount);
                if (data2.spacingMode == SpacingMode$2.Length || data2.spacingMode == SpacingMode$2.Fixed)
                  timelineScale = scale;
              } else {
                timeline = new PathConstraintPositionTimeline$2(frameCount);
                if (data2.positionMode == PositionMode.Fixed)
                  timelineScale = scale;
              }
              timeline.pathConstraintIndex = index2;
              for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale);
                if (frameIndex < frameCount - 1)
                  this.readCurve(input, frameIndex, timeline);
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintPositionTimeline$2.ENTRIES]);
              break;
            }
            case SkeletonBinary2.PATH_MIX: {
              var timeline = new PathConstraintMixTimeline$2(frameCount);
              timeline.pathConstraintIndex = index2;
              for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat());
                if (frameIndex < frameCount - 1)
                  this.readCurve(input, frameIndex, timeline);
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintMixTimeline$2.ENTRIES]);
              break;
            }
          }
        }
      }
      for (var i2 = 0, n2 = input.readInt(true); i2 < n2; i2++) {
        var skin = skeletonData.skins[input.readInt(true)];
        for (var ii2 = 0, nn2 = input.readInt(true); ii2 < nn2; ii2++) {
          var slotIndex = input.readInt(true);
          for (var iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {
            var attachment = skin.getAttachment(slotIndex, input.readStringRef());
            var weighted = attachment.bones != null;
            var vertices = attachment.vertices;
            var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
            var frameCount = input.readInt(true);
            var timeline = new DeformTimeline$2(frameCount);
            timeline.slotIndex = slotIndex;
            timeline.attachment = attachment;
            for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
              var time = input.readFloat();
              var deform = void 0;
              var end2 = input.readInt(true);
              if (end2 == 0)
                deform = weighted ? Utils.newFloatArray(deformLength) : vertices;
              else {
                deform = Utils.newFloatArray(deformLength);
                var start = input.readInt(true);
                end2 += start;
                if (scale == 1) {
                  for (var v2 = start; v2 < end2; v2++)
                    deform[v2] = input.readFloat();
                } else {
                  for (var v2 = start; v2 < end2; v2++)
                    deform[v2] = input.readFloat() * scale;
                }
                if (!weighted) {
                  for (var v2 = 0, vn = deform.length; v2 < vn; v2++)
                    deform[v2] += vertices[v2];
                }
              }
              timeline.setFrame(frameIndex, time, deform);
              if (frameIndex < frameCount - 1)
                this.readCurve(input, frameIndex, timeline);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[frameCount - 1]);
          }
        }
      }
      var drawOrderCount = input.readInt(true);
      if (drawOrderCount > 0) {
        var timeline = new DrawOrderTimeline$2(drawOrderCount);
        var slotCount = skeletonData.slots.length;
        for (var i2 = 0; i2 < drawOrderCount; i2++) {
          var time = input.readFloat();
          var offsetCount = input.readInt(true);
          var drawOrder = Utils.newArray(slotCount, 0);
          for (var ii2 = slotCount - 1; ii2 >= 0; ii2--)
            drawOrder[ii2] = -1;
          var unchanged = Utils.newArray(slotCount - offsetCount, 0);
          var originalIndex = 0, unchangedIndex = 0;
          for (var ii2 = 0; ii2 < offsetCount; ii2++) {
            var slotIndex = input.readInt(true);
            while (originalIndex != slotIndex)
              unchanged[unchangedIndex++] = originalIndex++;
            drawOrder[originalIndex + input.readInt(true)] = originalIndex++;
          }
          while (originalIndex < slotCount)
            unchanged[unchangedIndex++] = originalIndex++;
          for (var ii2 = slotCount - 1; ii2 >= 0; ii2--)
            if (drawOrder[ii2] == -1)
              drawOrder[ii2] = unchanged[--unchangedIndex];
          timeline.setFrame(i2, time, drawOrder);
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[drawOrderCount - 1]);
      }
      var eventCount = input.readInt(true);
      if (eventCount > 0) {
        var timeline = new EventTimeline$2(eventCount);
        for (var i2 = 0; i2 < eventCount; i2++) {
          var time = input.readFloat();
          var eventData = skeletonData.events[input.readInt(true)];
          var event_1 = new Event$3(time, eventData);
          event_1.intValue = input.readInt(false);
          event_1.floatValue = input.readFloat();
          event_1.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;
          if (event_1.data.audioPath != null) {
            event_1.volume = input.readFloat();
            event_1.balance = input.readFloat();
          }
          timeline.setFrame(i2, event_1);
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[eventCount - 1]);
      }
      return new Animation$2(name, timelines, duration);
    };
    SkeletonBinary2.prototype.readCurve = function(input, frameIndex, timeline) {
      switch (input.readByte()) {
        case SkeletonBinary2.CURVE_STEPPED:
          timeline.setStepped(frameIndex);
          break;
        case SkeletonBinary2.CURVE_BEZIER:
          this.setCurve(timeline, frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());
          break;
      }
    };
    SkeletonBinary2.prototype.setCurve = function(timeline, frameIndex, cx1, cy1, cx2, cy2) {
      timeline.setCurve(frameIndex, cx1, cy1, cx2, cy2);
    };
    SkeletonBinary2.AttachmentTypeValues = [
      0,
      1,
      2,
      3,
      4,
      5,
      6
      /*AttachmentType.Clipping*/
    ];
    SkeletonBinary2.TransformModeValues = [TransformMode.Normal, TransformMode.OnlyTranslation, TransformMode.NoRotationOrReflection, TransformMode.NoScale, TransformMode.NoScaleOrReflection];
    SkeletonBinary2.PositionModeValues = [PositionMode.Fixed, PositionMode.Percent];
    SkeletonBinary2.SpacingModeValues = [SpacingMode$2.Length, SpacingMode$2.Fixed, SpacingMode$2.Percent];
    SkeletonBinary2.RotateModeValues = [RotateMode.Tangent, RotateMode.Chain, RotateMode.ChainScale];
    SkeletonBinary2.BlendModeValues = [BLEND_MODES$4.NORMAL, BLEND_MODES$4.ADD, BLEND_MODES$4.MULTIPLY, BLEND_MODES$4.SCREEN];
    SkeletonBinary2.BONE_ROTATE = 0;
    SkeletonBinary2.BONE_TRANSLATE = 1;
    SkeletonBinary2.BONE_SCALE = 2;
    SkeletonBinary2.BONE_SHEAR = 3;
    SkeletonBinary2.SLOT_ATTACHMENT = 0;
    SkeletonBinary2.SLOT_COLOR = 1;
    SkeletonBinary2.SLOT_TWO_COLOR = 2;
    SkeletonBinary2.PATH_POSITION = 0;
    SkeletonBinary2.PATH_SPACING = 1;
    SkeletonBinary2.PATH_MIX = 2;
    SkeletonBinary2.CURVE_LINEAR = 0;
    SkeletonBinary2.CURVE_STEPPED = 1;
    SkeletonBinary2.CURVE_BEZIER = 2;
    return SkeletonBinary2;
  }()
);
var LinkedMesh$1$1 = (
  /** @class */
  function() {
    function LinkedMesh2(mesh, skin, slotIndex, parent, inheritDeform) {
      this.mesh = mesh;
      this.skin = skin;
      this.slotIndex = slotIndex;
      this.parent = parent;
      this.inheritDeform = inheritDeform;
    }
    return LinkedMesh2;
  }()
);
var Vertices$1 = (
  /** @class */
  function() {
    function Vertices2(bones, vertices) {
      if (bones === void 0) {
        bones = null;
      }
      if (vertices === void 0) {
        vertices = null;
      }
      this.bones = bones;
      this.vertices = vertices;
    }
    return Vertices2;
  }()
);
var SkeletonBounds$2 = (
  /** @class */
  function(_super) {
    __extends$4(SkeletonBounds2, _super);
    function SkeletonBounds2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return SkeletonBounds2;
  }(SkeletonBoundsBase)
);
var SkeletonJson$2 = (
  /** @class */
  function() {
    function SkeletonJson2(attachmentLoader) {
      this.scale = 1;
      this.linkedMeshes = new Array();
      this.attachmentLoader = attachmentLoader;
    }
    SkeletonJson2.prototype.readSkeletonData = function(json) {
      var scale = this.scale;
      var skeletonData = new SkeletonData$2();
      var root2 = typeof json === "string" ? JSON.parse(json) : json;
      var skeletonMap = root2.skeleton;
      if (skeletonMap != null) {
        skeletonData.hash = skeletonMap.hash;
        skeletonData.version = skeletonMap.spine;
        if (skeletonData.version.substr(0, 3) !== "3.8") {
          var error2 = "Spine 3.8 loader cant load version " + skeletonMap.spine + ". Please configure your pixi-spine bundle";
          console.error(error2);
        }
        if (skeletonData.version === "3.8.75") {
          var error2 = "Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.";
          console.error(error2);
        }
        skeletonData.x = skeletonMap.x;
        skeletonData.y = skeletonMap.y;
        skeletonData.width = skeletonMap.width;
        skeletonData.height = skeletonMap.height;
        skeletonData.fps = skeletonMap.fps;
        skeletonData.imagesPath = skeletonMap.images;
      }
      if (root2.bones) {
        for (var i2 = 0; i2 < root2.bones.length; i2++) {
          var boneMap = root2.bones[i2];
          var parent_1 = null;
          var parentName = this.getValue(boneMap, "parent", null);
          if (parentName != null) {
            parent_1 = skeletonData.findBone(parentName);
            if (parent_1 == null)
              throw new Error("Parent bone not found: " + parentName);
          }
          var data2 = new BoneData$2(skeletonData.bones.length, boneMap.name, parent_1);
          data2.length = this.getValue(boneMap, "length", 0) * scale;
          data2.x = this.getValue(boneMap, "x", 0) * scale;
          data2.y = this.getValue(boneMap, "y", 0) * scale;
          data2.rotation = this.getValue(boneMap, "rotation", 0);
          data2.scaleX = this.getValue(boneMap, "scaleX", 1);
          data2.scaleY = this.getValue(boneMap, "scaleY", 1);
          data2.shearX = this.getValue(boneMap, "shearX", 0);
          data2.shearY = this.getValue(boneMap, "shearY", 0);
          data2.transformMode = SkeletonJson2.transformModeFromString(this.getValue(boneMap, "transform", "normal"));
          data2.skinRequired = this.getValue(boneMap, "skin", false);
          skeletonData.bones.push(data2);
        }
      }
      if (root2.slots) {
        for (var i2 = 0; i2 < root2.slots.length; i2++) {
          var slotMap = root2.slots[i2];
          var slotName = slotMap.name;
          var boneName = slotMap.bone;
          var boneData = skeletonData.findBone(boneName);
          if (boneData == null)
            throw new Error("Slot bone not found: " + boneName);
          var data2 = new SlotData$2(skeletonData.slots.length, slotName, boneData);
          var color2 = this.getValue(slotMap, "color", null);
          if (color2 != null)
            data2.color.setFromString(color2);
          var dark = this.getValue(slotMap, "dark", null);
          if (dark != null) {
            data2.darkColor = new Color(1, 1, 1, 1);
            data2.darkColor.setFromString(dark);
          }
          data2.attachmentName = this.getValue(slotMap, "attachment", null);
          data2.blendMode = SkeletonJson2.blendModeFromString(this.getValue(slotMap, "blend", "normal"));
          skeletonData.slots.push(data2);
        }
      }
      if (root2.ik) {
        for (var i2 = 0; i2 < root2.ik.length; i2++) {
          var constraintMap = root2.ik[i2];
          var data2 = new IkConstraintData$2(constraintMap.name);
          data2.order = this.getValue(constraintMap, "order", 0);
          data2.skinRequired = this.getValue(constraintMap, "skin", false);
          for (var j2 = 0; j2 < constraintMap.bones.length; j2++) {
            var boneName = constraintMap.bones[j2];
            var bone = skeletonData.findBone(boneName);
            if (bone == null)
              throw new Error("IK bone not found: " + boneName);
            data2.bones.push(bone);
          }
          var targetName = constraintMap.target;
          data2.target = skeletonData.findBone(targetName);
          if (data2.target == null)
            throw new Error("IK target bone not found: " + targetName);
          data2.mix = this.getValue(constraintMap, "mix", 1);
          data2.softness = this.getValue(constraintMap, "softness", 0) * scale;
          data2.bendDirection = this.getValue(constraintMap, "bendPositive", true) ? 1 : -1;
          data2.compress = this.getValue(constraintMap, "compress", false);
          data2.stretch = this.getValue(constraintMap, "stretch", false);
          data2.uniform = this.getValue(constraintMap, "uniform", false);
          skeletonData.ikConstraints.push(data2);
        }
      }
      if (root2.transform) {
        for (var i2 = 0; i2 < root2.transform.length; i2++) {
          var constraintMap = root2.transform[i2];
          var data2 = new TransformConstraintData$2(constraintMap.name);
          data2.order = this.getValue(constraintMap, "order", 0);
          data2.skinRequired = this.getValue(constraintMap, "skin", false);
          for (var j2 = 0; j2 < constraintMap.bones.length; j2++) {
            var boneName = constraintMap.bones[j2];
            var bone = skeletonData.findBone(boneName);
            if (bone == null)
              throw new Error("Transform constraint bone not found: " + boneName);
            data2.bones.push(bone);
          }
          var targetName = constraintMap.target;
          data2.target = skeletonData.findBone(targetName);
          if (data2.target == null)
            throw new Error("Transform constraint target bone not found: " + targetName);
          data2.local = this.getValue(constraintMap, "local", false);
          data2.relative = this.getValue(constraintMap, "relative", false);
          data2.offsetRotation = this.getValue(constraintMap, "rotation", 0);
          data2.offsetX = this.getValue(constraintMap, "x", 0) * scale;
          data2.offsetY = this.getValue(constraintMap, "y", 0) * scale;
          data2.offsetScaleX = this.getValue(constraintMap, "scaleX", 0);
          data2.offsetScaleY = this.getValue(constraintMap, "scaleY", 0);
          data2.offsetShearY = this.getValue(constraintMap, "shearY", 0);
          data2.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
          data2.translateMix = this.getValue(constraintMap, "translateMix", 1);
          data2.scaleMix = this.getValue(constraintMap, "scaleMix", 1);
          data2.shearMix = this.getValue(constraintMap, "shearMix", 1);
          skeletonData.transformConstraints.push(data2);
        }
      }
      if (root2.path) {
        for (var i2 = 0; i2 < root2.path.length; i2++) {
          var constraintMap = root2.path[i2];
          var data2 = new PathConstraintData$2(constraintMap.name);
          data2.order = this.getValue(constraintMap, "order", 0);
          data2.skinRequired = this.getValue(constraintMap, "skin", false);
          for (var j2 = 0; j2 < constraintMap.bones.length; j2++) {
            var boneName = constraintMap.bones[j2];
            var bone = skeletonData.findBone(boneName);
            if (bone == null)
              throw new Error("Transform constraint bone not found: " + boneName);
            data2.bones.push(bone);
          }
          var targetName = constraintMap.target;
          data2.target = skeletonData.findSlot(targetName);
          if (data2.target == null)
            throw new Error("Path target slot not found: " + targetName);
          data2.positionMode = SkeletonJson2.positionModeFromString(this.getValue(constraintMap, "positionMode", "percent"));
          data2.spacingMode = SkeletonJson2.spacingModeFromString(this.getValue(constraintMap, "spacingMode", "length"));
          data2.rotateMode = SkeletonJson2.rotateModeFromString(this.getValue(constraintMap, "rotateMode", "tangent"));
          data2.offsetRotation = this.getValue(constraintMap, "rotation", 0);
          data2.position = this.getValue(constraintMap, "position", 0);
          if (data2.positionMode == PositionMode.Fixed)
            data2.position *= scale;
          data2.spacing = this.getValue(constraintMap, "spacing", 0);
          if (data2.spacingMode == SpacingMode$2.Length || data2.spacingMode == SpacingMode$2.Fixed)
            data2.spacing *= scale;
          data2.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
          data2.translateMix = this.getValue(constraintMap, "translateMix", 1);
          skeletonData.pathConstraints.push(data2);
        }
      }
      if (root2.skins) {
        for (var i2 = 0; i2 < root2.skins.length; i2++) {
          var skinMap = root2.skins[i2];
          var skin = new Skin$2(skinMap.name);
          if (skinMap.bones) {
            for (var ii2 = 0; ii2 < skinMap.bones.length; ii2++) {
              var bone = skeletonData.findBone(skinMap.bones[ii2]);
              if (bone == null)
                throw new Error("Skin bone not found: " + skinMap.bones[i2]);
              skin.bones.push(bone);
            }
          }
          if (skinMap.ik) {
            for (var ii2 = 0; ii2 < skinMap.ik.length; ii2++) {
              var constraint = skeletonData.findIkConstraint(skinMap.ik[ii2]);
              if (constraint == null)
                throw new Error("Skin IK constraint not found: " + skinMap.ik[i2]);
              skin.constraints.push(constraint);
            }
          }
          if (skinMap.transform) {
            for (var ii2 = 0; ii2 < skinMap.transform.length; ii2++) {
              var constraint = skeletonData.findTransformConstraint(skinMap.transform[ii2]);
              if (constraint == null)
                throw new Error("Skin transform constraint not found: " + skinMap.transform[i2]);
              skin.constraints.push(constraint);
            }
          }
          if (skinMap.path) {
            for (var ii2 = 0; ii2 < skinMap.path.length; ii2++) {
              var constraint = skeletonData.findPathConstraint(skinMap.path[ii2]);
              if (constraint == null)
                throw new Error("Skin path constraint not found: " + skinMap.path[i2]);
              skin.constraints.push(constraint);
            }
          }
          for (var slotName in skinMap.attachments) {
            var slot = skeletonData.findSlot(slotName);
            if (slot == null)
              throw new Error("Slot not found: " + slotName);
            var slotMap = skinMap.attachments[slotName];
            for (var entryName in slotMap) {
              var attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);
              if (attachment != null)
                skin.setAttachment(slot.index, entryName, attachment);
            }
          }
          skeletonData.skins.push(skin);
          if (skin.name == "default")
            skeletonData.defaultSkin = skin;
        }
      }
      for (var i2 = 0, n2 = this.linkedMeshes.length; i2 < n2; i2++) {
        var linkedMesh = this.linkedMeshes[i2];
        var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
        if (skin == null)
          throw new Error("Skin not found: " + linkedMesh.skin);
        var parent_2 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
        if (parent_2 == null)
          throw new Error("Parent mesh not found: " + linkedMesh.parent);
        linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent_2 : linkedMesh.mesh;
        linkedMesh.mesh.setParentMesh(parent_2);
      }
      this.linkedMeshes.length = 0;
      if (root2.events) {
        for (var eventName in root2.events) {
          var eventMap = root2.events[eventName];
          var data2 = new EventData$2(eventName);
          data2.intValue = this.getValue(eventMap, "int", 0);
          data2.floatValue = this.getValue(eventMap, "float", 0);
          data2.stringValue = this.getValue(eventMap, "string", "");
          data2.audioPath = this.getValue(eventMap, "audio", null);
          if (data2.audioPath != null) {
            data2.volume = this.getValue(eventMap, "volume", 1);
            data2.balance = this.getValue(eventMap, "balance", 0);
          }
          skeletonData.events.push(data2);
        }
      }
      if (root2.animations) {
        for (var animationName in root2.animations) {
          var animationMap = root2.animations[animationName];
          this.readAnimation(animationMap, animationName, skeletonData);
        }
      }
      return skeletonData;
    };
    SkeletonJson2.prototype.readAttachment = function(map2, skin, slotIndex, name, skeletonData) {
      var scale = this.scale;
      name = this.getValue(map2, "name", name);
      var type2 = this.getValue(map2, "type", "region");
      switch (type2) {
        case "region": {
          var path = this.getValue(map2, "path", name);
          var region = this.attachmentLoader.newRegionAttachment(skin, name, path);
          if (region == null)
            return null;
          region.path = path;
          region.x = this.getValue(map2, "x", 0) * scale;
          region.y = this.getValue(map2, "y", 0) * scale;
          region.scaleX = this.getValue(map2, "scaleX", 1);
          region.scaleY = this.getValue(map2, "scaleY", 1);
          region.rotation = this.getValue(map2, "rotation", 0);
          region.width = map2.width * scale;
          region.height = map2.height * scale;
          var color2 = this.getValue(map2, "color", null);
          if (color2 != null)
            region.color.setFromString(color2);
          return region;
        }
        case "boundingbox": {
          var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
          if (box == null)
            return null;
          this.readVertices(map2, box, map2.vertexCount << 1);
          var color2 = this.getValue(map2, "color", null);
          if (color2 != null)
            box.color.setFromString(color2);
          return box;
        }
        case "mesh":
        case "linkedmesh": {
          var path = this.getValue(map2, "path", name);
          var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
          if (mesh == null)
            return null;
          mesh.path = path;
          var color2 = this.getValue(map2, "color", null);
          if (color2 != null)
            mesh.color.setFromString(color2);
          mesh.width = this.getValue(map2, "width", 0) * scale;
          mesh.height = this.getValue(map2, "height", 0) * scale;
          var parent_3 = this.getValue(map2, "parent", null);
          if (parent_3 != null) {
            this.linkedMeshes.push(new LinkedMesh$3(mesh, this.getValue(map2, "skin", null), slotIndex, parent_3, this.getValue(map2, "deform", true)));
            return mesh;
          }
          var uvs = map2.uvs;
          this.readVertices(map2, mesh, uvs.length);
          mesh.triangles = map2.triangles;
          mesh.regionUVs = new Float32Array(uvs);
          mesh.edges = this.getValue(map2, "edges", null);
          mesh.hullLength = this.getValue(map2, "hull", 0) * 2;
          return mesh;
        }
        case "path": {
          var path = this.attachmentLoader.newPathAttachment(skin, name);
          if (path == null)
            return null;
          path.closed = this.getValue(map2, "closed", false);
          path.constantSpeed = this.getValue(map2, "constantSpeed", true);
          var vertexCount = map2.vertexCount;
          this.readVertices(map2, path, vertexCount << 1);
          var lengths = Utils.newArray(vertexCount / 3, 0);
          for (var i2 = 0; i2 < map2.lengths.length; i2++)
            lengths[i2] = map2.lengths[i2] * scale;
          path.lengths = lengths;
          var color2 = this.getValue(map2, "color", null);
          if (color2 != null)
            path.color.setFromString(color2);
          return path;
        }
        case "point": {
          var point = this.attachmentLoader.newPointAttachment(skin, name);
          if (point == null)
            return null;
          point.x = this.getValue(map2, "x", 0) * scale;
          point.y = this.getValue(map2, "y", 0) * scale;
          point.rotation = this.getValue(map2, "rotation", 0);
          var color2 = this.getValue(map2, "color", null);
          if (color2 != null)
            point.color.setFromString(color2);
          return point;
        }
        case "clipping": {
          var clip = this.attachmentLoader.newClippingAttachment(skin, name);
          if (clip == null)
            return null;
          var end2 = this.getValue(map2, "end", null);
          if (end2 != null) {
            var slot = skeletonData.findSlot(end2);
            if (slot == null)
              throw new Error("Clipping end slot not found: " + end2);
            clip.endSlot = slot;
          }
          var vertexCount = map2.vertexCount;
          this.readVertices(map2, clip, vertexCount << 1);
          var color2 = this.getValue(map2, "color", null);
          if (color2 != null)
            clip.color.setFromString(color2);
          return clip;
        }
      }
      return null;
    };
    SkeletonJson2.prototype.readVertices = function(map2, attachment, verticesLength) {
      var scale = this.scale;
      attachment.worldVerticesLength = verticesLength;
      var vertices = map2.vertices;
      if (verticesLength == vertices.length) {
        var scaledVertices = Utils.toFloatArray(vertices);
        if (scale != 1) {
          for (var i2 = 0, n2 = vertices.length; i2 < n2; i2++)
            scaledVertices[i2] *= scale;
        }
        attachment.vertices = scaledVertices;
        return;
      }
      var weights = new Array();
      var bones = new Array();
      for (var i2 = 0, n2 = vertices.length; i2 < n2; ) {
        var boneCount = vertices[i2++];
        bones.push(boneCount);
        for (var nn2 = i2 + boneCount * 4; i2 < nn2; i2 += 4) {
          bones.push(vertices[i2]);
          weights.push(vertices[i2 + 1] * scale);
          weights.push(vertices[i2 + 2] * scale);
          weights.push(vertices[i2 + 3]);
        }
      }
      attachment.bones = bones;
      attachment.vertices = Utils.toFloatArray(weights);
    };
    SkeletonJson2.prototype.readAnimation = function(map2, name, skeletonData) {
      var scale = this.scale;
      var timelines = new Array();
      var duration = 0;
      if (map2.slots) {
        for (var slotName in map2.slots) {
          var slotMap = map2.slots[slotName];
          var slotIndex = skeletonData.findSlotIndex(slotName);
          if (slotIndex == -1)
            throw new Error("Slot not found: " + slotName);
          for (var timelineName in slotMap) {
            var timelineMap = slotMap[timelineName];
            if (timelineName == "attachment") {
              var timeline = new AttachmentTimeline$2(timelineMap.length);
              timeline.slotIndex = slotIndex;
              var frameIndex = 0;
              for (var i2 = 0; i2 < timelineMap.length; i2++) {
                var valueMap = timelineMap[i2];
                timeline.setFrame(frameIndex++, this.getValue(valueMap, "time", 0), valueMap.name);
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
            } else if (timelineName == "color") {
              var timeline = new ColorTimeline$1(timelineMap.length);
              timeline.slotIndex = slotIndex;
              var frameIndex = 0;
              for (var i2 = 0; i2 < timelineMap.length; i2++) {
                var valueMap = timelineMap[i2];
                var color2 = new Color();
                color2.setFromString(valueMap.color || "ffffffff");
                timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), color2.r, color2.g, color2.b, color2.a);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline$1.ENTRIES]);
            } else if (timelineName == "twoColor") {
              var timeline = new TwoColorTimeline$1(timelineMap.length);
              timeline.slotIndex = slotIndex;
              var frameIndex = 0;
              for (var i2 = 0; i2 < timelineMap.length; i2++) {
                var valueMap = timelineMap[i2];
                var light = new Color();
                var dark = new Color();
                light.setFromString(valueMap.light);
                dark.setFromString(valueMap.dark);
                timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TwoColorTimeline$1.ENTRIES]);
            } else
              throw new Error("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");
          }
        }
      }
      if (map2.bones) {
        for (var boneName in map2.bones) {
          var boneMap = map2.bones[boneName];
          var boneIndex = skeletonData.findBoneIndex(boneName);
          if (boneIndex == -1)
            throw new Error("Bone not found: " + boneName);
          for (var timelineName in boneMap) {
            var timelineMap = boneMap[timelineName];
            if (timelineName === "rotate") {
              var timeline = new RotateTimeline$2(timelineMap.length);
              timeline.boneIndex = boneIndex;
              var frameIndex = 0;
              for (var i2 = 0; i2 < timelineMap.length; i2++) {
                var valueMap = timelineMap[i2];
                timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "angle", 0));
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline$2.ENTRIES]);
            } else if (timelineName === "translate" || timelineName === "scale" || timelineName === "shear") {
              var timeline = null;
              var timelineScale = 1, defaultValue2 = 0;
              if (timelineName === "scale") {
                timeline = new ScaleTimeline$2(timelineMap.length);
                defaultValue2 = 1;
              } else if (timelineName === "shear")
                timeline = new ShearTimeline$2(timelineMap.length);
              else {
                timeline = new TranslateTimeline$2(timelineMap.length);
                timelineScale = scale;
              }
              timeline.boneIndex = boneIndex;
              var frameIndex = 0;
              for (var i2 = 0; i2 < timelineMap.length; i2++) {
                var valueMap = timelineMap[i2];
                var x = this.getValue(valueMap, "x", defaultValue2), y2 = this.getValue(valueMap, "y", defaultValue2);
                timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), x * timelineScale, y2 * timelineScale);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline$2.ENTRIES]);
            } else
              throw new Error("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");
          }
        }
      }
      if (map2.ik) {
        for (var constraintName in map2.ik) {
          var constraintMap = map2.ik[constraintName];
          var constraint = skeletonData.findIkConstraint(constraintName);
          var timeline = new IkConstraintTimeline$2(constraintMap.length);
          timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);
          var frameIndex = 0;
          for (var i2 = 0; i2 < constraintMap.length; i2++) {
            var valueMap = constraintMap[i2];
            timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "mix", 1), this.getValue(valueMap, "softness", 0) * scale, this.getValue(valueMap, "bendPositive", true) ? 1 : -1, this.getValue(valueMap, "compress", false), this.getValue(valueMap, "stretch", false));
            this.readCurve(valueMap, timeline, frameIndex);
            frameIndex++;
          }
          timelines.push(timeline);
          duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline$2.ENTRIES]);
        }
      }
      if (map2.transform) {
        for (var constraintName in map2.transform) {
          var constraintMap = map2.transform[constraintName];
          var constraint = skeletonData.findTransformConstraint(constraintName);
          var timeline = new TransformConstraintTimeline$2(constraintMap.length);
          timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);
          var frameIndex = 0;
          for (var i2 = 0; i2 < constraintMap.length; i2++) {
            var valueMap = constraintMap[i2];
            timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1), this.getValue(valueMap, "scaleMix", 1), this.getValue(valueMap, "shearMix", 1));
            this.readCurve(valueMap, timeline, frameIndex);
            frameIndex++;
          }
          timelines.push(timeline);
          duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline$2.ENTRIES]);
        }
      }
      if (map2.path) {
        for (var constraintName in map2.path) {
          var constraintMap = map2.path[constraintName];
          var index2 = skeletonData.findPathConstraintIndex(constraintName);
          if (index2 == -1)
            throw new Error("Path constraint not found: " + constraintName);
          var data2 = skeletonData.pathConstraints[index2];
          for (var timelineName in constraintMap) {
            var timelineMap = constraintMap[timelineName];
            if (timelineName === "position" || timelineName === "spacing") {
              var timeline = null;
              var timelineScale = 1;
              if (timelineName === "spacing") {
                timeline = new PathConstraintSpacingTimeline$2(timelineMap.length);
                if (data2.spacingMode == SpacingMode$2.Length || data2.spacingMode == SpacingMode$2.Fixed)
                  timelineScale = scale;
              } else {
                timeline = new PathConstraintPositionTimeline$2(timelineMap.length);
                if (data2.positionMode == PositionMode.Fixed)
                  timelineScale = scale;
              }
              timeline.pathConstraintIndex = index2;
              var frameIndex = 0;
              for (var i2 = 0; i2 < timelineMap.length; i2++) {
                var valueMap = timelineMap[i2];
                timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, timelineName, 0) * timelineScale);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline$2.ENTRIES]);
            } else if (timelineName === "mix") {
              var timeline = new PathConstraintMixTimeline$2(timelineMap.length);
              timeline.pathConstraintIndex = index2;
              var frameIndex = 0;
              for (var i2 = 0; i2 < timelineMap.length; i2++) {
                var valueMap = timelineMap[i2];
                timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1));
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline$2.ENTRIES]);
            }
          }
        }
      }
      if (map2.deform) {
        for (var deformName in map2.deform) {
          var deformMap = map2.deform[deformName];
          var skin = skeletonData.findSkin(deformName);
          if (skin == null) {
            {
              continue;
            }
          }
          for (var slotName in deformMap) {
            var slotMap = deformMap[slotName];
            var slotIndex = skeletonData.findSlotIndex(slotName);
            if (slotIndex == -1)
              throw new Error("Slot not found: " + slotMap.name);
            for (var timelineName in slotMap) {
              var timelineMap = slotMap[timelineName];
              var attachment = skin.getAttachment(slotIndex, timelineName);
              if (attachment == null)
                throw new Error("Deform attachment not found: " + timelineMap.name);
              var weighted = attachment.bones != null;
              var vertices = attachment.vertices;
              var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
              var timeline = new DeformTimeline$2(timelineMap.length);
              timeline.slotIndex = slotIndex;
              timeline.attachment = attachment;
              var frameIndex = 0;
              for (var j2 = 0; j2 < timelineMap.length; j2++) {
                var valueMap = timelineMap[j2];
                var deform = void 0;
                var verticesValue = this.getValue(valueMap, "vertices", null);
                if (verticesValue == null)
                  deform = weighted ? Utils.newFloatArray(deformLength) : vertices;
                else {
                  deform = Utils.newFloatArray(deformLength);
                  var start = this.getValue(valueMap, "offset", 0);
                  Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
                  if (scale != 1) {
                    for (var i2 = start, n2 = i2 + verticesValue.length; i2 < n2; i2++)
                      deform[i2] *= scale;
                  }
                  if (!weighted) {
                    for (var i2 = 0; i2 < deformLength; i2++)
                      deform[i2] += vertices[i2];
                  }
                }
                timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), deform);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
            }
          }
        }
      }
      var drawOrderNode = map2.drawOrder;
      if (drawOrderNode == null)
        drawOrderNode = map2.draworder;
      if (drawOrderNode != null) {
        var timeline = new DrawOrderTimeline$2(drawOrderNode.length);
        var slotCount = skeletonData.slots.length;
        var frameIndex = 0;
        for (var j2 = 0; j2 < drawOrderNode.length; j2++) {
          var drawOrderMap = drawOrderNode[j2];
          var drawOrder = null;
          var offsets = this.getValue(drawOrderMap, "offsets", null);
          if (offsets != null) {
            drawOrder = Utils.newArray(slotCount, -1);
            var unchanged = Utils.newArray(slotCount - offsets.length, 0);
            var originalIndex = 0, unchangedIndex = 0;
            for (var i2 = 0; i2 < offsets.length; i2++) {
              var offsetMap = offsets[i2];
              var slotIndex = skeletonData.findSlotIndex(offsetMap.slot);
              if (slotIndex == -1)
                throw new Error("Slot not found: " + offsetMap.slot);
              while (originalIndex != slotIndex)
                unchanged[unchangedIndex++] = originalIndex++;
              drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
            }
            while (originalIndex < slotCount)
              unchanged[unchangedIndex++] = originalIndex++;
            for (var i2 = slotCount - 1; i2 >= 0; i2--)
              if (drawOrder[i2] == -1)
                drawOrder[i2] = unchanged[--unchangedIndex];
          }
          timeline.setFrame(frameIndex++, this.getValue(drawOrderMap, "time", 0), drawOrder);
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
      }
      if (map2.events) {
        var timeline = new EventTimeline$2(map2.events.length);
        var frameIndex = 0;
        for (var i2 = 0; i2 < map2.events.length; i2++) {
          var eventMap = map2.events[i2];
          var eventData = skeletonData.findEvent(eventMap.name);
          if (eventData == null)
            throw new Error("Event not found: " + eventMap.name);
          var event_1 = new Event$3(Utils.toSinglePrecision(this.getValue(eventMap, "time", 0)), eventData);
          event_1.intValue = this.getValue(eventMap, "int", eventData.intValue);
          event_1.floatValue = this.getValue(eventMap, "float", eventData.floatValue);
          event_1.stringValue = this.getValue(eventMap, "string", eventData.stringValue);
          if (event_1.data.audioPath != null) {
            event_1.volume = this.getValue(eventMap, "volume", 1);
            event_1.balance = this.getValue(eventMap, "balance", 0);
          }
          timeline.setFrame(frameIndex++, event_1);
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
      }
      if (isNaN(duration)) {
        throw new Error("Error while parsing animation, duration is NaN");
      }
      skeletonData.animations.push(new Animation$2(name, timelines, duration));
    };
    SkeletonJson2.prototype.readCurve = function(map2, timeline, frameIndex) {
      if (!map2.hasOwnProperty("curve"))
        return;
      if (map2.curve === "stepped")
        timeline.setStepped(frameIndex);
      else {
        var curve = map2.curve;
        timeline.setCurve(frameIndex, curve, this.getValue(map2, "c2", 0), this.getValue(map2, "c3", 1), this.getValue(map2, "c4", 1));
      }
    };
    SkeletonJson2.prototype.getValue = function(map2, prop, defaultValue2) {
      return map2[prop] !== void 0 ? map2[prop] : defaultValue2;
    };
    SkeletonJson2.blendModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "normal")
        return BLEND_MODES$4.NORMAL;
      if (str == "additive")
        return BLEND_MODES$4.ADD;
      if (str == "multiply")
        return BLEND_MODES$4.MULTIPLY;
      if (str == "screen")
        return BLEND_MODES$4.SCREEN;
      throw new Error("Unknown blend mode: " + str);
    };
    SkeletonJson2.positionModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "fixed")
        return PositionMode.Fixed;
      if (str == "percent")
        return PositionMode.Percent;
      throw new Error("Unknown position mode: " + str);
    };
    SkeletonJson2.spacingModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "length")
        return SpacingMode$2.Length;
      if (str == "fixed")
        return SpacingMode$2.Fixed;
      if (str == "percent")
        return SpacingMode$2.Percent;
      throw new Error("Unknown position mode: " + str);
    };
    SkeletonJson2.rotateModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "tangent")
        return RotateMode.Tangent;
      if (str == "chain")
        return RotateMode.Chain;
      if (str == "chainscale")
        return RotateMode.ChainScale;
      throw new Error("Unknown rotate mode: " + str);
    };
    SkeletonJson2.transformModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "normal")
        return TransformMode.Normal;
      if (str == "onlytranslation")
        return TransformMode.OnlyTranslation;
      if (str == "norotationorreflection")
        return TransformMode.NoRotationOrReflection;
      if (str == "noscale")
        return TransformMode.NoScale;
      if (str == "noscaleorreflection")
        return TransformMode.NoScaleOrReflection;
      throw new Error("Unknown transform mode: " + str);
    };
    return SkeletonJson2;
  }()
);
var LinkedMesh$3 = (
  /** @class */
  function() {
    function LinkedMesh2(mesh, skin, slotIndex, parent, inheritDeform) {
      this.mesh = mesh;
      this.skin = skin;
      this.slotIndex = slotIndex;
      this.parent = parent;
      this.inheritDeform = inheritDeform;
    }
    return LinkedMesh2;
  }()
);
var Spine$3 = (
  /** @class */
  function(_super) {
    __extends$4(Spine2, _super);
    function Spine2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Spine2.prototype.createSkeleton = function(spineData) {
      this.skeleton = new Skeleton$2(spineData);
      this.skeleton.updateWorldTransform();
      this.stateData = new AnimationStateData$2(spineData);
      this.state = new AnimationState$2(this.stateData);
    };
    return Spine2;
  }(SpineBase)
);
const spine38 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Animation: Animation$2,
  AnimationState: AnimationState$2,
  AnimationStateAdapter: AnimationStateAdapter$1,
  AnimationStateData: AnimationStateData$2,
  AtlasAttachmentLoader: AtlasAttachmentLoader$2,
  Attachment: Attachment$2,
  AttachmentTimeline: AttachmentTimeline$2,
  Bone: Bone$2,
  BoneData: BoneData$2,
  BoundingBoxAttachment: BoundingBoxAttachment$2,
  ClippingAttachment: ClippingAttachment$2,
  ColorTimeline: ColorTimeline$1,
  ConstraintData: ConstraintData$1,
  CurveTimeline: CurveTimeline$2,
  DeformTimeline: DeformTimeline$2,
  DrawOrderTimeline: DrawOrderTimeline$2,
  Event: Event$3,
  EventData: EventData$2,
  EventQueue: EventQueue$2,
  EventTimeline: EventTimeline$2,
  get EventType() {
    return EventType$2;
  },
  IkConstraint: IkConstraint$2,
  IkConstraintData: IkConstraintData$2,
  IkConstraintTimeline: IkConstraintTimeline$2,
  JitterEffect: JitterEffect$1,
  MeshAttachment: MeshAttachment$2,
  PathAttachment: PathAttachment$2,
  PathConstraint: PathConstraint$2,
  PathConstraintData: PathConstraintData$2,
  PathConstraintMixTimeline: PathConstraintMixTimeline$2,
  PathConstraintPositionTimeline: PathConstraintPositionTimeline$2,
  PathConstraintSpacingTimeline: PathConstraintSpacingTimeline$2,
  PointAttachment: PointAttachment$2,
  RegionAttachment: RegionAttachment$2,
  RotateTimeline: RotateTimeline$2,
  ScaleTimeline: ScaleTimeline$2,
  ShearTimeline: ShearTimeline$2,
  Skeleton: Skeleton$2,
  SkeletonBinary: SkeletonBinary$1,
  SkeletonBounds: SkeletonBounds$2,
  SkeletonData: SkeletonData$2,
  SkeletonJson: SkeletonJson$2,
  Skin: Skin$2,
  SkinEntry: SkinEntry$1,
  Slot: Slot$2,
  SlotData: SlotData$2,
  get SpacingMode() {
    return SpacingMode$2;
  },
  Spine: Spine$3,
  SwirlEffect: SwirlEffect$1,
  get TimelineType() {
    return TimelineType$1;
  },
  TrackEntry: TrackEntry$2,
  TransformConstraint: TransformConstraint$2,
  TransformConstraintData: TransformConstraintData$2,
  TransformConstraintTimeline: TransformConstraintTimeline$2,
  TranslateTimeline: TranslateTimeline$2,
  TwoColorTimeline: TwoColorTimeline$1,
  VertexAttachment: VertexAttachment$2
}, Symbol.toStringTag, { value: "Module" }));
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$3 = function(d2, b2) {
  extendStatics$3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p))
        d3[p] = b3[p];
  };
  return extendStatics$3(d2, b2);
};
function __extends$3(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics$3(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var Attachment$1 = (
  /** @class */
  function() {
    function Attachment2(name) {
      if (name == null)
        throw new Error("name cannot be null.");
      this.name = name;
    }
    return Attachment2;
  }()
);
var VertexAttachment$1 = (
  /** @class */
  function(_super) {
    __extends$3(VertexAttachment2, _super);
    function VertexAttachment2(name) {
      var _this = _super.call(this, name) || this;
      _this.id = (VertexAttachment2.nextID++ & 65535) << 11;
      _this.worldVerticesLength = 0;
      return _this;
    }
    VertexAttachment2.prototype.computeWorldVerticesOld = function(slot, worldVertices) {
      this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);
    };
    VertexAttachment2.prototype.computeWorldVertices = function(slot, start, count, worldVertices, offset, stride) {
      count = offset + (count >> 1) * stride;
      var skeleton = slot.bone.skeleton;
      var deformArray = slot.attachmentVertices;
      var vertices = this.vertices;
      var bones = this.bones;
      if (bones == null) {
        if (deformArray.length > 0)
          vertices = deformArray;
        var mat = slot.bone.matrix;
        var x = mat.tx;
        var y2 = mat.ty;
        var a2 = mat.a, b2 = mat.c, c2 = mat.b, d2 = mat.d;
        for (var v_1 = start, w2 = offset; w2 < count; v_1 += 2, w2 += stride) {
          var vx2 = vertices[v_1], vy2 = vertices[v_1 + 1];
          worldVertices[w2] = vx2 * a2 + vy2 * b2 + x;
          worldVertices[w2 + 1] = vx2 * c2 + vy2 * d2 + y2;
        }
        return;
      }
      var v2 = 0, skip = 0;
      for (var i2 = 0; i2 < start; i2 += 2) {
        var n2 = bones[v2];
        v2 += n2 + 1;
        skip += n2;
      }
      var skeletonBones = skeleton.bones;
      if (deformArray.length == 0) {
        for (var w2 = offset, b2 = skip * 3; w2 < count; w2 += stride) {
          var wx = 0, wy = 0;
          var n2 = bones[v2++];
          n2 += v2;
          for (; v2 < n2; v2++, b2 += 3) {
            var mat = skeletonBones[bones[v2]].matrix;
            var vx2 = vertices[b2], vy2 = vertices[b2 + 1], weight = vertices[b2 + 2];
            wx += (vx2 * mat.a + vy2 * mat.c + mat.tx) * weight;
            wy += (vx2 * mat.b + vy2 * mat.d + mat.ty) * weight;
          }
          worldVertices[w2] = wx;
          worldVertices[w2 + 1] = wy;
        }
      } else {
        var deform = deformArray;
        for (var w2 = offset, b2 = skip * 3, f2 = skip << 1; w2 < count; w2 += stride) {
          var wx = 0, wy = 0;
          var n2 = bones[v2++];
          n2 += v2;
          for (; v2 < n2; v2++, b2 += 3, f2 += 2) {
            var mat = skeletonBones[bones[v2]].matrix;
            var vx2 = vertices[b2] + deform[f2], vy2 = vertices[b2 + 1] + deform[f2 + 1], weight = vertices[b2 + 2];
            wx += (vx2 * mat.a + vy2 * mat.c + mat.tx) * weight;
            wy += (vx2 * mat.b + vy2 * mat.d + mat.ty) * weight;
          }
          worldVertices[w2] = wx;
          worldVertices[w2 + 1] = wy;
        }
      }
    };
    VertexAttachment2.prototype.applyDeform = function(sourceAttachment) {
      return this == sourceAttachment;
    };
    VertexAttachment2.nextID = 0;
    return VertexAttachment2;
  }(Attachment$1)
);
var BoundingBoxAttachment$1 = (
  /** @class */
  function(_super) {
    __extends$3(BoundingBoxAttachment2, _super);
    function BoundingBoxAttachment2(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.BoundingBox;
      _this.color = new Color(1, 1, 1, 1);
      return _this;
    }
    return BoundingBoxAttachment2;
  }(VertexAttachment$1)
);
var ClippingAttachment$1 = (
  /** @class */
  function(_super) {
    __extends$3(ClippingAttachment2, _super);
    function ClippingAttachment2(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Clipping;
      _this.color = new Color(0.2275, 0.2275, 0.8078, 1);
      return _this;
    }
    return ClippingAttachment2;
  }(VertexAttachment$1)
);
var MeshAttachment$1 = (
  /** @class */
  function(_super) {
    __extends$3(MeshAttachment2, _super);
    function MeshAttachment2(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Mesh;
      _this.color = new Color(1, 1, 1, 1);
      _this.inheritDeform = false;
      _this.tempColor = new Color(0, 0, 0, 0);
      return _this;
    }
    MeshAttachment2.prototype.applyDeform = function(sourceAttachment) {
      return this == sourceAttachment || this.inheritDeform && this.parentMesh == sourceAttachment;
    };
    MeshAttachment2.prototype.getParentMesh = function() {
      return this.parentMesh;
    };
    MeshAttachment2.prototype.setParentMesh = function(parentMesh) {
      this.parentMesh = parentMesh;
      if (parentMesh != null) {
        this.bones = parentMesh.bones;
        this.vertices = parentMesh.vertices;
        this.worldVerticesLength = parentMesh.worldVerticesLength;
        this.regionUVs = parentMesh.regionUVs;
        this.triangles = parentMesh.triangles;
        this.hullLength = parentMesh.hullLength;
        this.worldVerticesLength = parentMesh.worldVerticesLength;
      }
    };
    return MeshAttachment2;
  }(VertexAttachment$1)
);
var PathAttachment$1 = (
  /** @class */
  function(_super) {
    __extends$3(PathAttachment2, _super);
    function PathAttachment2(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Path;
      _this.closed = false;
      _this.constantSpeed = false;
      _this.color = new Color(1, 1, 1, 1);
      return _this;
    }
    return PathAttachment2;
  }(VertexAttachment$1)
);
var PointAttachment$1 = (
  /** @class */
  function(_super) {
    __extends$3(PointAttachment2, _super);
    function PointAttachment2(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Point;
      _this.color = new Color(0.38, 0.94, 0, 1);
      return _this;
    }
    PointAttachment2.prototype.computeWorldPosition = function(bone, point) {
      var mat = bone.matrix;
      point.x = this.x * mat.a + this.y * mat.c + bone.worldX;
      point.y = this.x * mat.b + this.y * mat.d + bone.worldY;
      return point;
    };
    PointAttachment2.prototype.computeWorldRotation = function(bone) {
      var mat = bone.matrix;
      var cos = MathUtils.cosDeg(this.rotation), sin = MathUtils.sinDeg(this.rotation);
      var x = cos * mat.a + sin * mat.c;
      var y2 = cos * mat.b + sin * mat.d;
      return Math.atan2(y2, x) * MathUtils.radDeg;
    };
    return PointAttachment2;
  }(VertexAttachment$1)
);
var Slot$1 = (
  /** @class */
  function() {
    function Slot2(data2, bone) {
      this.attachmentVertices = new Array();
      if (data2 == null)
        throw new Error("data cannot be null.");
      if (bone == null)
        throw new Error("bone cannot be null.");
      this.data = data2;
      this.bone = bone;
      this.color = new Color();
      this.darkColor = data2.darkColor == null ? null : new Color();
      this.setToSetupPose();
      this.blendMode = this.data.blendMode;
    }
    Slot2.prototype.getAttachment = function() {
      return this.attachment;
    };
    Slot2.prototype.setAttachment = function(attachment) {
      if (this.attachment == attachment)
        return;
      this.attachment = attachment;
      this.attachmentTime = this.bone.skeleton.time;
      this.attachmentVertices.length = 0;
    };
    Slot2.prototype.setAttachmentTime = function(time) {
      this.attachmentTime = this.bone.skeleton.time - time;
    };
    Slot2.prototype.getAttachmentTime = function() {
      return this.bone.skeleton.time - this.attachmentTime;
    };
    Slot2.prototype.setToSetupPose = function() {
      this.color.setFromColor(this.data.color);
      if (this.darkColor != null)
        this.darkColor.setFromColor(this.data.darkColor);
      if (this.data.attachmentName == null)
        this.attachment = null;
      else {
        this.attachment = null;
        this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
      }
    };
    return Slot2;
  }()
);
var RegionAttachment$1 = (
  /** @class */
  function(_super) {
    __extends$3(RegionAttachment2, _super);
    function RegionAttachment2(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Region;
      _this.x = 0;
      _this.y = 0;
      _this.scaleX = 1;
      _this.scaleY = 1;
      _this.rotation = 0;
      _this.width = 0;
      _this.height = 0;
      _this.color = new Color(1, 1, 1, 1);
      _this.offset = Utils.newFloatArray(8);
      _this.uvs = Utils.newFloatArray(8);
      _this.tempColor = new Color(1, 1, 1, 1);
      return _this;
    }
    RegionAttachment2.prototype.updateOffset = function() {
      var regionScaleX = this.width / this.region.originalWidth * this.scaleX;
      var regionScaleY = this.height / this.region.originalHeight * this.scaleY;
      var localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
      var localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
      var localX2 = localX + this.region.width * regionScaleX;
      var localY2 = localY + this.region.height * regionScaleY;
      var radians = this.rotation * Math.PI / 180;
      var cos = Math.cos(radians);
      var sin = Math.sin(radians);
      var localXCos = localX * cos + this.x;
      var localXSin = localX * sin;
      var localYCos = localY * cos + this.y;
      var localYSin = localY * sin;
      var localX2Cos = localX2 * cos + this.x;
      var localX2Sin = localX2 * sin;
      var localY2Cos = localY2 * cos + this.y;
      var localY2Sin = localY2 * sin;
      var offset = this.offset;
      offset[RegionAttachment2.OX1] = localXCos - localYSin;
      offset[RegionAttachment2.OY1] = localYCos + localXSin;
      offset[RegionAttachment2.OX2] = localXCos - localY2Sin;
      offset[RegionAttachment2.OY2] = localY2Cos + localXSin;
      offset[RegionAttachment2.OX3] = localX2Cos - localY2Sin;
      offset[RegionAttachment2.OY3] = localY2Cos + localX2Sin;
      offset[RegionAttachment2.OX4] = localX2Cos - localYSin;
      offset[RegionAttachment2.OY4] = localYCos + localX2Sin;
    };
    RegionAttachment2.prototype.setRegion = function(region) {
      this.region = region;
      var uvs = this.uvs;
      if (region.rotate) {
        uvs[2] = region.u;
        uvs[3] = region.v2;
        uvs[4] = region.u;
        uvs[5] = region.v;
        uvs[6] = region.u2;
        uvs[7] = region.v;
        uvs[0] = region.u2;
        uvs[1] = region.v2;
      } else {
        uvs[0] = region.u;
        uvs[1] = region.v2;
        uvs[2] = region.u;
        uvs[3] = region.v;
        uvs[4] = region.u2;
        uvs[5] = region.v;
        uvs[6] = region.u2;
        uvs[7] = region.v2;
      }
    };
    RegionAttachment2.prototype.computeWorldVertices = function(bone, worldVertices, offset, stride) {
      var vertexOffset = this.offset;
      var mat = bone instanceof Slot$1 ? bone.bone.matrix : bone.matrix;
      var x = mat.tx, y2 = mat.ty;
      var a2 = mat.a, b2 = mat.c, c2 = mat.b, d2 = mat.d;
      var offsetX = 0, offsetY = 0;
      offsetX = vertexOffset[RegionAttachment2.OX1];
      offsetY = vertexOffset[RegionAttachment2.OY1];
      worldVertices[offset] = offsetX * a2 + offsetY * b2 + x;
      worldVertices[offset + 1] = offsetX * c2 + offsetY * d2 + y2;
      offset += stride;
      offsetX = vertexOffset[RegionAttachment2.OX2];
      offsetY = vertexOffset[RegionAttachment2.OY2];
      worldVertices[offset] = offsetX * a2 + offsetY * b2 + x;
      worldVertices[offset + 1] = offsetX * c2 + offsetY * d2 + y2;
      offset += stride;
      offsetX = vertexOffset[RegionAttachment2.OX3];
      offsetY = vertexOffset[RegionAttachment2.OY3];
      worldVertices[offset] = offsetX * a2 + offsetY * b2 + x;
      worldVertices[offset + 1] = offsetX * c2 + offsetY * d2 + y2;
      offset += stride;
      offsetX = vertexOffset[RegionAttachment2.OX4];
      offsetY = vertexOffset[RegionAttachment2.OY4];
      worldVertices[offset] = offsetX * a2 + offsetY * b2 + x;
      worldVertices[offset + 1] = offsetX * c2 + offsetY * d2 + y2;
    };
    RegionAttachment2.OX1 = 0;
    RegionAttachment2.OY1 = 1;
    RegionAttachment2.OX2 = 2;
    RegionAttachment2.OY2 = 3;
    RegionAttachment2.OX3 = 4;
    RegionAttachment2.OY3 = 5;
    RegionAttachment2.OX4 = 6;
    RegionAttachment2.OY4 = 7;
    RegionAttachment2.X1 = 0;
    RegionAttachment2.Y1 = 1;
    RegionAttachment2.C1R = 2;
    RegionAttachment2.C1G = 3;
    RegionAttachment2.C1B = 4;
    RegionAttachment2.C1A = 5;
    RegionAttachment2.U1 = 6;
    RegionAttachment2.V1 = 7;
    RegionAttachment2.X2 = 8;
    RegionAttachment2.Y2 = 9;
    RegionAttachment2.C2R = 10;
    RegionAttachment2.C2G = 11;
    RegionAttachment2.C2B = 12;
    RegionAttachment2.C2A = 13;
    RegionAttachment2.U2 = 14;
    RegionAttachment2.V2 = 15;
    RegionAttachment2.X3 = 16;
    RegionAttachment2.Y3 = 17;
    RegionAttachment2.C3R = 18;
    RegionAttachment2.C3G = 19;
    RegionAttachment2.C3B = 20;
    RegionAttachment2.C3A = 21;
    RegionAttachment2.U3 = 22;
    RegionAttachment2.V3 = 23;
    RegionAttachment2.X4 = 24;
    RegionAttachment2.Y4 = 25;
    RegionAttachment2.C4R = 26;
    RegionAttachment2.C4G = 27;
    RegionAttachment2.C4B = 28;
    RegionAttachment2.C4A = 29;
    RegionAttachment2.U4 = 30;
    RegionAttachment2.V4 = 31;
    return RegionAttachment2;
  }(Attachment$1)
);
var JitterEffect = (
  /** @class */
  function() {
    function JitterEffect2(jitterX, jitterY) {
      this.jitterX = 0;
      this.jitterY = 0;
      this.jitterX = jitterX;
      this.jitterY = jitterY;
    }
    JitterEffect2.prototype.begin = function(skeleton) {
    };
    JitterEffect2.prototype.transform = function(position2, uv, light, dark) {
      position2.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);
      position2.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);
    };
    JitterEffect2.prototype.end = function() {
    };
    return JitterEffect2;
  }()
);
var SwirlEffect = (
  /** @class */
  function() {
    function SwirlEffect2(radius) {
      this.centerX = 0;
      this.centerY = 0;
      this.radius = 0;
      this.angle = 0;
      this.worldX = 0;
      this.worldY = 0;
      this.radius = radius;
    }
    SwirlEffect2.prototype.begin = function(skeleton) {
      this.worldX = skeleton.x + this.centerX;
      this.worldY = skeleton.y + this.centerY;
    };
    SwirlEffect2.prototype.transform = function(position2, uv, light, dark) {
      var radAngle = this.angle * MathUtils.degreesToRadians;
      var x = position2.x - this.worldX;
      var y2 = position2.y - this.worldY;
      var dist = Math.sqrt(x * x + y2 * y2);
      if (dist < this.radius) {
        var theta = SwirlEffect2.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);
        var cos = Math.cos(theta);
        var sin = Math.sin(theta);
        position2.x = cos * x - sin * y2 + this.worldX;
        position2.y = sin * x + cos * y2 + this.worldY;
      }
    };
    SwirlEffect2.prototype.end = function() {
    };
    SwirlEffect2.interpolation = new PowOut(2);
    return SwirlEffect2;
  }()
);
var Animation$1 = (
  /** @class */
  function() {
    function Animation2(name, timelines, duration) {
      if (name == null)
        throw new Error("name cannot be null.");
      if (timelines == null)
        throw new Error("timelines cannot be null.");
      this.name = name;
      this.timelines = timelines;
      this.duration = duration;
    }
    Animation2.prototype.apply = function(skeleton, lastTime2, time, loop, events, alpha2, blend, direction) {
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      if (loop && this.duration != 0) {
        time %= this.duration;
        if (lastTime2 > 0)
          lastTime2 %= this.duration;
      }
      var timelines = this.timelines;
      for (var i2 = 0, n2 = timelines.length; i2 < n2; i2++)
        timelines[i2].apply(skeleton, lastTime2, time, events, alpha2, blend, direction);
    };
    Animation2.binarySearch = function(values, target, step) {
      if (step === void 0) {
        step = 1;
      }
      var low = 0;
      var high = values.length / step - 2;
      if (high == 0)
        return step;
      var current = high >>> 1;
      while (true) {
        if (values[(current + 1) * step] <= target)
          low = current + 1;
        else
          high = current;
        if (low == high)
          return (low + 1) * step;
        current = low + high >>> 1;
      }
    };
    Animation2.linearSearch = function(values, target, step) {
      for (var i2 = 0, last = values.length - step; i2 <= last; i2 += step)
        if (values[i2] > target)
          return i2;
      return -1;
    };
    return Animation2;
  }()
);
var TimelineType;
(function(TimelineType2) {
  TimelineType2[TimelineType2["rotate"] = 0] = "rotate";
  TimelineType2[TimelineType2["translate"] = 1] = "translate";
  TimelineType2[TimelineType2["scale"] = 2] = "scale";
  TimelineType2[TimelineType2["shear"] = 3] = "shear";
  TimelineType2[TimelineType2["attachment"] = 4] = "attachment";
  TimelineType2[TimelineType2["color"] = 5] = "color";
  TimelineType2[TimelineType2["deform"] = 6] = "deform";
  TimelineType2[TimelineType2["event"] = 7] = "event";
  TimelineType2[TimelineType2["drawOrder"] = 8] = "drawOrder";
  TimelineType2[TimelineType2["ikConstraint"] = 9] = "ikConstraint";
  TimelineType2[TimelineType2["transformConstraint"] = 10] = "transformConstraint";
  TimelineType2[TimelineType2["pathConstraintPosition"] = 11] = "pathConstraintPosition";
  TimelineType2[TimelineType2["pathConstraintSpacing"] = 12] = "pathConstraintSpacing";
  TimelineType2[TimelineType2["pathConstraintMix"] = 13] = "pathConstraintMix";
  TimelineType2[TimelineType2["twoColor"] = 14] = "twoColor";
})(TimelineType || (TimelineType = {}));
var CurveTimeline$1 = (
  /** @class */
  function() {
    function CurveTimeline3(frameCount) {
      if (frameCount <= 0)
        throw new Error("frameCount must be > 0: " + frameCount);
      this.curves = Utils.newFloatArray((frameCount - 1) * CurveTimeline3.BEZIER_SIZE);
    }
    CurveTimeline3.prototype.getFrameCount = function() {
      return this.curves.length / CurveTimeline3.BEZIER_SIZE + 1;
    };
    CurveTimeline3.prototype.setLinear = function(frameIndex) {
      this.curves[frameIndex * CurveTimeline3.BEZIER_SIZE] = CurveTimeline3.LINEAR;
    };
    CurveTimeline3.prototype.setStepped = function(frameIndex) {
      this.curves[frameIndex * CurveTimeline3.BEZIER_SIZE] = CurveTimeline3.STEPPED;
    };
    CurveTimeline3.prototype.getCurveType = function(frameIndex) {
      var index2 = frameIndex * CurveTimeline3.BEZIER_SIZE;
      if (index2 == this.curves.length)
        return CurveTimeline3.LINEAR;
      var type2 = this.curves[index2];
      if (type2 == CurveTimeline3.LINEAR)
        return CurveTimeline3.LINEAR;
      if (type2 == CurveTimeline3.STEPPED)
        return CurveTimeline3.STEPPED;
      return CurveTimeline3.BEZIER;
    };
    CurveTimeline3.prototype.setCurve = function(frameIndex, cx1, cy1, cx2, cy2) {
      var tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;
      var dddfx = ((cx1 - cx2) * 3 + 1) * 6e-3, dddfy = ((cy1 - cy2) * 3 + 1) * 6e-3;
      var ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;
      var dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;
      var i2 = frameIndex * CurveTimeline3.BEZIER_SIZE;
      var curves = this.curves;
      curves[i2++] = CurveTimeline3.BEZIER;
      var x = dfx, y2 = dfy;
      for (var n2 = i2 + CurveTimeline3.BEZIER_SIZE - 1; i2 < n2; i2 += 2) {
        curves[i2] = x;
        curves[i2 + 1] = y2;
        dfx += ddfx;
        dfy += ddfy;
        ddfx += dddfx;
        ddfy += dddfy;
        x += dfx;
        y2 += dfy;
      }
    };
    CurveTimeline3.prototype.getCurvePercent = function(frameIndex, percent2) {
      percent2 = MathUtils.clamp(percent2, 0, 1);
      var curves = this.curves;
      var i2 = frameIndex * CurveTimeline3.BEZIER_SIZE;
      var type2 = curves[i2];
      if (type2 == CurveTimeline3.LINEAR)
        return percent2;
      if (type2 == CurveTimeline3.STEPPED)
        return 0;
      i2++;
      var x = 0;
      for (var start = i2, n2 = i2 + CurveTimeline3.BEZIER_SIZE - 1; i2 < n2; i2 += 2) {
        x = curves[i2];
        if (x >= percent2) {
          var prevX = void 0, prevY = void 0;
          if (i2 == start) {
            prevX = 0;
            prevY = 0;
          } else {
            prevX = curves[i2 - 2];
            prevY = curves[i2 - 1];
          }
          return prevY + (curves[i2 + 1] - prevY) * (percent2 - prevX) / (x - prevX);
        }
      }
      var y2 = curves[i2 - 1];
      return y2 + (1 - y2) * (percent2 - x) / (1 - x);
    };
    CurveTimeline3.LINEAR = 0;
    CurveTimeline3.STEPPED = 1;
    CurveTimeline3.BEZIER = 2;
    CurveTimeline3.BEZIER_SIZE = 10 * 2 - 1;
    return CurveTimeline3;
  }()
);
var RotateTimeline$1 = (
  /** @class */
  function(_super) {
    __extends$3(RotateTimeline2, _super);
    function RotateTimeline2(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount << 1);
      return _this;
    }
    RotateTimeline2.prototype.getPropertyId = function() {
      return (TimelineType.rotate << 24) + this.boneIndex;
    };
    RotateTimeline2.prototype.setFrame = function(frameIndex, time, degrees) {
      frameIndex <<= 1;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + RotateTimeline2.ROTATION] = degrees;
    };
    RotateTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var frames = this.frames;
      var bone = skeleton.bones[this.boneIndex];
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.rotation = bone.data.rotation;
            return;
          case MixBlend.first:
            var r_1 = bone.data.rotation - bone.rotation;
            bone.rotation += (r_1 - (16384 - (16384.499999999996 - r_1 / 360 | 0)) * 360) * alpha2;
        }
        return;
      }
      if (time >= frames[frames.length - RotateTimeline2.ENTRIES]) {
        var r_2 = frames[frames.length + RotateTimeline2.PREV_ROTATION];
        switch (blend) {
          case MixBlend.setup:
            bone.rotation = bone.data.rotation + r_2 * alpha2;
            break;
          case MixBlend.first:
          case MixBlend.replace:
            r_2 += bone.data.rotation - bone.rotation;
            r_2 -= (16384 - (16384.499999999996 - r_2 / 360 | 0)) * 360;
          case MixBlend.add:
            bone.rotation += r_2 * alpha2;
        }
        return;
      }
      var frame2 = Animation$1.binarySearch(frames, time, RotateTimeline2.ENTRIES);
      var prevRotation = frames[frame2 + RotateTimeline2.PREV_ROTATION];
      var frameTime = frames[frame2];
      var percent2 = this.getCurvePercent((frame2 >> 1) - 1, 1 - (time - frameTime) / (frames[frame2 + RotateTimeline2.PREV_TIME] - frameTime));
      var r2 = frames[frame2 + RotateTimeline2.ROTATION] - prevRotation;
      r2 = prevRotation + (r2 - (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360) * percent2;
      switch (blend) {
        case MixBlend.setup:
          bone.rotation = bone.data.rotation + (r2 - (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360) * alpha2;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          r2 += bone.data.rotation - bone.rotation;
        case MixBlend.add:
          bone.rotation += (r2 - (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360) * alpha2;
      }
    };
    RotateTimeline2.ENTRIES = 2;
    RotateTimeline2.PREV_TIME = -2;
    RotateTimeline2.PREV_ROTATION = -1;
    RotateTimeline2.ROTATION = 1;
    return RotateTimeline2;
  }(CurveTimeline$1)
);
var TranslateTimeline$1 = (
  /** @class */
  function(_super) {
    __extends$3(TranslateTimeline2, _super);
    function TranslateTimeline2(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * TranslateTimeline2.ENTRIES);
      return _this;
    }
    TranslateTimeline2.prototype.getPropertyId = function() {
      return (TimelineType.translate << 24) + this.boneIndex;
    };
    TranslateTimeline2.prototype.setFrame = function(frameIndex, time, x, y2) {
      frameIndex *= TranslateTimeline2.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + TranslateTimeline2.X] = x;
      this.frames[frameIndex + TranslateTimeline2.Y] = y2;
    };
    TranslateTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var frames = this.frames;
      var bone = skeleton.bones[this.boneIndex];
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.x = bone.data.x;
            bone.y = bone.data.y;
            return;
          case MixBlend.first:
            bone.x += (bone.data.x - bone.x) * alpha2;
            bone.y += (bone.data.y - bone.y) * alpha2;
        }
        return;
      }
      var x = 0, y2 = 0;
      if (time >= frames[frames.length - TranslateTimeline2.ENTRIES]) {
        x = frames[frames.length + TranslateTimeline2.PREV_X];
        y2 = frames[frames.length + TranslateTimeline2.PREV_Y];
      } else {
        var frame2 = Animation$1.binarySearch(frames, time, TranslateTimeline2.ENTRIES);
        x = frames[frame2 + TranslateTimeline2.PREV_X];
        y2 = frames[frame2 + TranslateTimeline2.PREV_Y];
        var frameTime = frames[frame2];
        var percent2 = this.getCurvePercent(frame2 / TranslateTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame2 + TranslateTimeline2.PREV_TIME] - frameTime));
        x += (frames[frame2 + TranslateTimeline2.X] - x) * percent2;
        y2 += (frames[frame2 + TranslateTimeline2.Y] - y2) * percent2;
      }
      switch (blend) {
        case MixBlend.setup:
          bone.x = bone.data.x + x * alpha2;
          bone.y = bone.data.y + y2 * alpha2;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.x += (bone.data.x + x - bone.x) * alpha2;
          bone.y += (bone.data.y + y2 - bone.y) * alpha2;
          break;
        case MixBlend.add:
          bone.x += x * alpha2;
          bone.y += y2 * alpha2;
      }
    };
    TranslateTimeline2.ENTRIES = 3;
    TranslateTimeline2.PREV_TIME = -3;
    TranslateTimeline2.PREV_X = -2;
    TranslateTimeline2.PREV_Y = -1;
    TranslateTimeline2.X = 1;
    TranslateTimeline2.Y = 2;
    return TranslateTimeline2;
  }(CurveTimeline$1)
);
var ScaleTimeline$1 = (
  /** @class */
  function(_super) {
    __extends$3(ScaleTimeline2, _super);
    function ScaleTimeline2(frameCount) {
      return _super.call(this, frameCount) || this;
    }
    ScaleTimeline2.prototype.getPropertyId = function() {
      return (TimelineType.scale << 24) + this.boneIndex;
    };
    ScaleTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var frames = this.frames;
      var bone = skeleton.bones[this.boneIndex];
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.scaleX = bone.data.scaleX;
            bone.scaleY = bone.data.scaleY;
            return;
          case MixBlend.first:
            bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha2;
            bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha2;
        }
        return;
      }
      var x = 0, y2 = 0;
      if (time >= frames[frames.length - ScaleTimeline2.ENTRIES]) {
        x = frames[frames.length + ScaleTimeline2.PREV_X] * bone.data.scaleX;
        y2 = frames[frames.length + ScaleTimeline2.PREV_Y] * bone.data.scaleY;
      } else {
        var frame2 = Animation$1.binarySearch(frames, time, ScaleTimeline2.ENTRIES);
        x = frames[frame2 + ScaleTimeline2.PREV_X];
        y2 = frames[frame2 + ScaleTimeline2.PREV_Y];
        var frameTime = frames[frame2];
        var percent2 = this.getCurvePercent(frame2 / ScaleTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame2 + ScaleTimeline2.PREV_TIME] - frameTime));
        x = (x + (frames[frame2 + ScaleTimeline2.X] - x) * percent2) * bone.data.scaleX;
        y2 = (y2 + (frames[frame2 + ScaleTimeline2.Y] - y2) * percent2) * bone.data.scaleY;
      }
      if (alpha2 == 1) {
        if (blend == MixBlend.add) {
          bone.scaleX += x - bone.data.scaleX;
          bone.scaleY += y2 - bone.data.scaleY;
        } else {
          bone.scaleX = x;
          bone.scaleY = y2;
        }
      } else {
        var bx = 0, by = 0;
        if (direction == MixDirection.mixOut) {
          switch (blend) {
            case MixBlend.setup:
              bx = bone.data.scaleX;
              by = bone.data.scaleY;
              bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha2;
              bone.scaleY = by + (Math.abs(y2) * MathUtils.signum(by) - by) * alpha2;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              bx = bone.scaleX;
              by = bone.scaleY;
              bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha2;
              bone.scaleY = by + (Math.abs(y2) * MathUtils.signum(by) - by) * alpha2;
              break;
            case MixBlend.add:
              bx = bone.scaleX;
              by = bone.scaleY;
              bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha2;
              bone.scaleY = by + (Math.abs(y2) * MathUtils.signum(by) - bone.data.scaleY) * alpha2;
          }
        } else {
          switch (blend) {
            case MixBlend.setup:
              bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);
              by = Math.abs(bone.data.scaleY) * MathUtils.signum(y2);
              bone.scaleX = bx + (x - bx) * alpha2;
              bone.scaleY = by + (y2 - by) * alpha2;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              bx = Math.abs(bone.scaleX) * MathUtils.signum(x);
              by = Math.abs(bone.scaleY) * MathUtils.signum(y2);
              bone.scaleX = bx + (x - bx) * alpha2;
              bone.scaleY = by + (y2 - by) * alpha2;
              break;
            case MixBlend.add:
              bx = MathUtils.signum(x);
              by = MathUtils.signum(y2);
              bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha2;
              bone.scaleY = Math.abs(bone.scaleY) * by + (y2 - Math.abs(bone.data.scaleY) * by) * alpha2;
          }
        }
      }
    };
    return ScaleTimeline2;
  }(TranslateTimeline$1)
);
var ShearTimeline$1 = (
  /** @class */
  function(_super) {
    __extends$3(ShearTimeline2, _super);
    function ShearTimeline2(frameCount) {
      return _super.call(this, frameCount) || this;
    }
    ShearTimeline2.prototype.getPropertyId = function() {
      return (TimelineType.shear << 24) + this.boneIndex;
    };
    ShearTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var frames = this.frames;
      var bone = skeleton.bones[this.boneIndex];
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.shearX = bone.data.shearX;
            bone.shearY = bone.data.shearY;
            return;
          case MixBlend.first:
            bone.shearX += (bone.data.shearX - bone.shearX) * alpha2;
            bone.shearY += (bone.data.shearY - bone.shearY) * alpha2;
        }
        return;
      }
      var x = 0, y2 = 0;
      if (time >= frames[frames.length - ShearTimeline2.ENTRIES]) {
        x = frames[frames.length + ShearTimeline2.PREV_X];
        y2 = frames[frames.length + ShearTimeline2.PREV_Y];
      } else {
        var frame2 = Animation$1.binarySearch(frames, time, ShearTimeline2.ENTRIES);
        x = frames[frame2 + ShearTimeline2.PREV_X];
        y2 = frames[frame2 + ShearTimeline2.PREV_Y];
        var frameTime = frames[frame2];
        var percent2 = this.getCurvePercent(frame2 / ShearTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame2 + ShearTimeline2.PREV_TIME] - frameTime));
        x = x + (frames[frame2 + ShearTimeline2.X] - x) * percent2;
        y2 = y2 + (frames[frame2 + ShearTimeline2.Y] - y2) * percent2;
      }
      switch (blend) {
        case MixBlend.setup:
          bone.shearX = bone.data.shearX + x * alpha2;
          bone.shearY = bone.data.shearY + y2 * alpha2;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha2;
          bone.shearY += (bone.data.shearY + y2 - bone.shearY) * alpha2;
          break;
        case MixBlend.add:
          bone.shearX += x * alpha2;
          bone.shearY += y2 * alpha2;
      }
    };
    return ShearTimeline2;
  }(TranslateTimeline$1)
);
var ColorTimeline = (
  /** @class */
  function(_super) {
    __extends$3(ColorTimeline2, _super);
    function ColorTimeline2(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * ColorTimeline2.ENTRIES);
      return _this;
    }
    ColorTimeline2.prototype.getPropertyId = function() {
      return (TimelineType.color << 24) + this.slotIndex;
    };
    ColorTimeline2.prototype.setFrame = function(frameIndex, time, r2, g2, b2, a2) {
      frameIndex *= ColorTimeline2.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + ColorTimeline2.R] = r2;
      this.frames[frameIndex + ColorTimeline2.G] = g2;
      this.frames[frameIndex + ColorTimeline2.B] = b2;
      this.frames[frameIndex + ColorTimeline2.A] = a2;
    };
    ColorTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            slot.color.setFromColor(slot.data.color);
            return;
          case MixBlend.first:
            var color2 = slot.color, setup = slot.data.color;
            color2.add((setup.r - color2.r) * alpha2, (setup.g - color2.g) * alpha2, (setup.b - color2.b) * alpha2, (setup.a - color2.a) * alpha2);
        }
        return;
      }
      var r2 = 0, g2 = 0, b2 = 0, a2 = 0;
      if (time >= frames[frames.length - ColorTimeline2.ENTRIES]) {
        var i2 = frames.length;
        r2 = frames[i2 + ColorTimeline2.PREV_R];
        g2 = frames[i2 + ColorTimeline2.PREV_G];
        b2 = frames[i2 + ColorTimeline2.PREV_B];
        a2 = frames[i2 + ColorTimeline2.PREV_A];
      } else {
        var frame2 = Animation$1.binarySearch(frames, time, ColorTimeline2.ENTRIES);
        r2 = frames[frame2 + ColorTimeline2.PREV_R];
        g2 = frames[frame2 + ColorTimeline2.PREV_G];
        b2 = frames[frame2 + ColorTimeline2.PREV_B];
        a2 = frames[frame2 + ColorTimeline2.PREV_A];
        var frameTime = frames[frame2];
        var percent2 = this.getCurvePercent(frame2 / ColorTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame2 + ColorTimeline2.PREV_TIME] - frameTime));
        r2 += (frames[frame2 + ColorTimeline2.R] - r2) * percent2;
        g2 += (frames[frame2 + ColorTimeline2.G] - g2) * percent2;
        b2 += (frames[frame2 + ColorTimeline2.B] - b2) * percent2;
        a2 += (frames[frame2 + ColorTimeline2.A] - a2) * percent2;
      }
      if (alpha2 == 1)
        slot.color.set(r2, g2, b2, a2);
      else {
        var color2 = slot.color;
        if (blend == MixBlend.setup)
          color2.setFromColor(slot.data.color);
        color2.add((r2 - color2.r) * alpha2, (g2 - color2.g) * alpha2, (b2 - color2.b) * alpha2, (a2 - color2.a) * alpha2);
      }
    };
    ColorTimeline2.ENTRIES = 5;
    ColorTimeline2.PREV_TIME = -5;
    ColorTimeline2.PREV_R = -4;
    ColorTimeline2.PREV_G = -3;
    ColorTimeline2.PREV_B = -2;
    ColorTimeline2.PREV_A = -1;
    ColorTimeline2.R = 1;
    ColorTimeline2.G = 2;
    ColorTimeline2.B = 3;
    ColorTimeline2.A = 4;
    return ColorTimeline2;
  }(CurveTimeline$1)
);
var TwoColorTimeline = (
  /** @class */
  function(_super) {
    __extends$3(TwoColorTimeline2, _super);
    function TwoColorTimeline2(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * TwoColorTimeline2.ENTRIES);
      return _this;
    }
    TwoColorTimeline2.prototype.getPropertyId = function() {
      return (TimelineType.twoColor << 24) + this.slotIndex;
    };
    TwoColorTimeline2.prototype.setFrame = function(frameIndex, time, r2, g2, b2, a2, r22, g22, b22) {
      frameIndex *= TwoColorTimeline2.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + TwoColorTimeline2.R] = r2;
      this.frames[frameIndex + TwoColorTimeline2.G] = g2;
      this.frames[frameIndex + TwoColorTimeline2.B] = b2;
      this.frames[frameIndex + TwoColorTimeline2.A] = a2;
      this.frames[frameIndex + TwoColorTimeline2.R2] = r22;
      this.frames[frameIndex + TwoColorTimeline2.G2] = g22;
      this.frames[frameIndex + TwoColorTimeline2.B2] = b22;
    };
    TwoColorTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            slot.color.setFromColor(slot.data.color);
            slot.darkColor.setFromColor(slot.data.darkColor);
            return;
          case MixBlend.first:
            var light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;
            light.add((setupLight.r - light.r) * alpha2, (setupLight.g - light.g) * alpha2, (setupLight.b - light.b) * alpha2, (setupLight.a - light.a) * alpha2);
            dark.add((setupDark.r - dark.r) * alpha2, (setupDark.g - dark.g) * alpha2, (setupDark.b - dark.b) * alpha2, 0);
        }
        return;
      }
      var r2 = 0, g2 = 0, b2 = 0, a2 = 0, r22 = 0, g22 = 0, b22 = 0;
      if (time >= frames[frames.length - TwoColorTimeline2.ENTRIES]) {
        var i2 = frames.length;
        r2 = frames[i2 + TwoColorTimeline2.PREV_R];
        g2 = frames[i2 + TwoColorTimeline2.PREV_G];
        b2 = frames[i2 + TwoColorTimeline2.PREV_B];
        a2 = frames[i2 + TwoColorTimeline2.PREV_A];
        r22 = frames[i2 + TwoColorTimeline2.PREV_R2];
        g22 = frames[i2 + TwoColorTimeline2.PREV_G2];
        b22 = frames[i2 + TwoColorTimeline2.PREV_B2];
      } else {
        var frame2 = Animation$1.binarySearch(frames, time, TwoColorTimeline2.ENTRIES);
        r2 = frames[frame2 + TwoColorTimeline2.PREV_R];
        g2 = frames[frame2 + TwoColorTimeline2.PREV_G];
        b2 = frames[frame2 + TwoColorTimeline2.PREV_B];
        a2 = frames[frame2 + TwoColorTimeline2.PREV_A];
        r22 = frames[frame2 + TwoColorTimeline2.PREV_R2];
        g22 = frames[frame2 + TwoColorTimeline2.PREV_G2];
        b22 = frames[frame2 + TwoColorTimeline2.PREV_B2];
        var frameTime = frames[frame2];
        var percent2 = this.getCurvePercent(frame2 / TwoColorTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame2 + TwoColorTimeline2.PREV_TIME] - frameTime));
        r2 += (frames[frame2 + TwoColorTimeline2.R] - r2) * percent2;
        g2 += (frames[frame2 + TwoColorTimeline2.G] - g2) * percent2;
        b2 += (frames[frame2 + TwoColorTimeline2.B] - b2) * percent2;
        a2 += (frames[frame2 + TwoColorTimeline2.A] - a2) * percent2;
        r22 += (frames[frame2 + TwoColorTimeline2.R2] - r22) * percent2;
        g22 += (frames[frame2 + TwoColorTimeline2.G2] - g22) * percent2;
        b22 += (frames[frame2 + TwoColorTimeline2.B2] - b22) * percent2;
      }
      if (alpha2 == 1) {
        slot.color.set(r2, g2, b2, a2);
        slot.darkColor.set(r22, g22, b22, 1);
      } else {
        var light = slot.color, dark = slot.darkColor;
        if (blend == MixBlend.setup) {
          light.setFromColor(slot.data.color);
          dark.setFromColor(slot.data.darkColor);
        }
        light.add((r2 - light.r) * alpha2, (g2 - light.g) * alpha2, (b2 - light.b) * alpha2, (a2 - light.a) * alpha2);
        dark.add((r22 - dark.r) * alpha2, (g22 - dark.g) * alpha2, (b22 - dark.b) * alpha2, 0);
      }
    };
    TwoColorTimeline2.ENTRIES = 8;
    TwoColorTimeline2.PREV_TIME = -8;
    TwoColorTimeline2.PREV_R = -7;
    TwoColorTimeline2.PREV_G = -6;
    TwoColorTimeline2.PREV_B = -5;
    TwoColorTimeline2.PREV_A = -4;
    TwoColorTimeline2.PREV_R2 = -3;
    TwoColorTimeline2.PREV_G2 = -2;
    TwoColorTimeline2.PREV_B2 = -1;
    TwoColorTimeline2.R = 1;
    TwoColorTimeline2.G = 2;
    TwoColorTimeline2.B = 3;
    TwoColorTimeline2.A = 4;
    TwoColorTimeline2.R2 = 5;
    TwoColorTimeline2.G2 = 6;
    TwoColorTimeline2.B2 = 7;
    return TwoColorTimeline2;
  }(CurveTimeline$1)
);
var AttachmentTimeline$1 = (
  /** @class */
  function() {
    function AttachmentTimeline2(frameCount) {
      this.frames = Utils.newFloatArray(frameCount);
      this.attachmentNames = new Array(frameCount);
    }
    AttachmentTimeline2.prototype.getPropertyId = function() {
      return (TimelineType.attachment << 24) + this.slotIndex;
    };
    AttachmentTimeline2.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    AttachmentTimeline2.prototype.setFrame = function(frameIndex, time, attachmentName) {
      this.frames[frameIndex] = time;
      this.attachmentNames[frameIndex] = attachmentName;
    };
    AttachmentTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (direction == MixDirection.mixOut && blend == MixBlend.setup) {
        var attachmentName_1 = slot.data.attachmentName;
        slot.setAttachment(attachmentName_1 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_1));
        return;
      }
      var frames = this.frames;
      if (time < frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first) {
          var attachmentName_2 = slot.data.attachmentName;
          slot.setAttachment(attachmentName_2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_2));
        }
        return;
      }
      var frameIndex = 0;
      if (time >= frames[frames.length - 1])
        frameIndex = frames.length - 1;
      else
        frameIndex = Animation$1.binarySearch(frames, time, 1) - 1;
      var attachmentName = this.attachmentNames[frameIndex];
      skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
    };
    return AttachmentTimeline2;
  }()
);
var zeros = null;
var DeformTimeline$1 = (
  /** @class */
  function(_super) {
    __extends$3(DeformTimeline2, _super);
    function DeformTimeline2(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount);
      _this.frameVertices = new Array(frameCount);
      if (zeros == null)
        zeros = Utils.newFloatArray(64);
      return _this;
    }
    DeformTimeline2.prototype.getPropertyId = function() {
      return (TimelineType.deform << 27) + +this.attachment.id + this.slotIndex;
    };
    DeformTimeline2.prototype.setFrame = function(frameIndex, time, vertices) {
      this.frames[frameIndex] = time;
      this.frameVertices[frameIndex] = vertices;
    };
    DeformTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      var slotAttachment = slot.getAttachment();
      if (!(slotAttachment instanceof VertexAttachment$1) || !slotAttachment.applyDeform(this.attachment))
        return;
      var verticesArray = slot.attachmentVertices;
      if (verticesArray.length == 0)
        blend = MixBlend.setup;
      var frameVertices = this.frameVertices;
      var vertexCount = frameVertices[0].length;
      var frames = this.frames;
      if (time < frames[0]) {
        var vertexAttachment = slotAttachment;
        switch (blend) {
          case MixBlend.setup:
            verticesArray.length = 0;
            return;
          case MixBlend.first:
            if (alpha2 == 1) {
              verticesArray.length = 0;
              break;
            }
            var vertices_1 = Utils.setArraySize(verticesArray, vertexCount);
            if (vertexAttachment.bones == null) {
              var setupVertices = vertexAttachment.vertices;
              for (var i2 = 0; i2 < vertexCount; i2++)
                vertices_1[i2] += (setupVertices[i2] - vertices_1[i2]) * alpha2;
            } else {
              alpha2 = 1 - alpha2;
              for (var i2 = 0; i2 < vertexCount; i2++)
                vertices_1[i2] *= alpha2;
            }
        }
        return;
      }
      var vertices = Utils.setArraySize(verticesArray, vertexCount);
      if (time >= frames[frames.length - 1]) {
        var lastVertices = frameVertices[frames.length - 1];
        if (alpha2 == 1) {
          if (blend == MixBlend.add) {
            var vertexAttachment = slotAttachment;
            if (vertexAttachment.bones == null) {
              var setupVertices = vertexAttachment.vertices;
              for (var i2 = 0; i2 < vertexCount; i2++) {
                vertices[i2] += lastVertices[i2] - setupVertices[i2];
              }
            } else {
              for (var i2 = 0; i2 < vertexCount; i2++)
                vertices[i2] += lastVertices[i2];
            }
          } else {
            Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);
          }
        } else {
          switch (blend) {
            case MixBlend.setup: {
              var vertexAttachment_1 = slotAttachment;
              if (vertexAttachment_1.bones == null) {
                var setupVertices = vertexAttachment_1.vertices;
                for (var i2 = 0; i2 < vertexCount; i2++) {
                  var setup = setupVertices[i2];
                  vertices[i2] = setup + (lastVertices[i2] - setup) * alpha2;
                }
              } else {
                for (var i2 = 0; i2 < vertexCount; i2++)
                  vertices[i2] = lastVertices[i2] * alpha2;
              }
              break;
            }
            case MixBlend.first:
            case MixBlend.replace:
              for (var i2 = 0; i2 < vertexCount; i2++)
                vertices[i2] += (lastVertices[i2] - vertices[i2]) * alpha2;
            case MixBlend.add:
              var vertexAttachment = slotAttachment;
              if (vertexAttachment.bones == null) {
                var setupVertices = vertexAttachment.vertices;
                for (var i2 = 0; i2 < vertexCount; i2++) {
                  vertices[i2] += (lastVertices[i2] - setupVertices[i2]) * alpha2;
                }
              } else {
                for (var i2 = 0; i2 < vertexCount; i2++)
                  vertices[i2] += lastVertices[i2] * alpha2;
              }
          }
        }
        return;
      }
      var frame2 = Animation$1.binarySearch(frames, time);
      var prevVertices = frameVertices[frame2 - 1];
      var nextVertices = frameVertices[frame2];
      var frameTime = frames[frame2];
      var percent2 = this.getCurvePercent(frame2 - 1, 1 - (time - frameTime) / (frames[frame2 - 1] - frameTime));
      if (alpha2 == 1) {
        if (blend == MixBlend.add) {
          var vertexAttachment = slotAttachment;
          if (vertexAttachment.bones == null) {
            var setupVertices = vertexAttachment.vertices;
            for (var i2 = 0; i2 < vertexCount; i2++) {
              var prev2 = prevVertices[i2];
              vertices[i2] += prev2 + (nextVertices[i2] - prev2) * percent2 - setupVertices[i2];
            }
          } else {
            for (var i2 = 0; i2 < vertexCount; i2++) {
              var prev2 = prevVertices[i2];
              vertices[i2] += prev2 + (nextVertices[i2] - prev2) * percent2;
            }
          }
        } else {
          for (var i2 = 0; i2 < vertexCount; i2++) {
            var prev2 = prevVertices[i2];
            vertices[i2] = prev2 + (nextVertices[i2] - prev2) * percent2;
          }
        }
      } else {
        switch (blend) {
          case MixBlend.setup: {
            var vertexAttachment_2 = slotAttachment;
            if (vertexAttachment_2.bones == null) {
              var setupVertices = vertexAttachment_2.vertices;
              for (var i2 = 0; i2 < vertexCount; i2++) {
                var prev2 = prevVertices[i2], setup = setupVertices[i2];
                vertices[i2] = setup + (prev2 + (nextVertices[i2] - prev2) * percent2 - setup) * alpha2;
              }
            } else {
              for (var i2 = 0; i2 < vertexCount; i2++) {
                var prev2 = prevVertices[i2];
                vertices[i2] = (prev2 + (nextVertices[i2] - prev2) * percent2) * alpha2;
              }
            }
            break;
          }
          case MixBlend.first:
          case MixBlend.replace:
            for (var i2 = 0; i2 < vertexCount; i2++) {
              var prev2 = prevVertices[i2];
              vertices[i2] += (prev2 + (nextVertices[i2] - prev2) * percent2 - vertices[i2]) * alpha2;
            }
            break;
          case MixBlend.add:
            var vertexAttachment = slotAttachment;
            if (vertexAttachment.bones == null) {
              var setupVertices = vertexAttachment.vertices;
              for (var i2 = 0; i2 < vertexCount; i2++) {
                var prev2 = prevVertices[i2];
                vertices[i2] += (prev2 + (nextVertices[i2] - prev2) * percent2 - setupVertices[i2]) * alpha2;
              }
            } else {
              for (var i2 = 0; i2 < vertexCount; i2++) {
                var prev2 = prevVertices[i2];
                vertices[i2] += (prev2 + (nextVertices[i2] - prev2) * percent2) * alpha2;
              }
            }
        }
      }
    };
    return DeformTimeline2;
  }(CurveTimeline$1)
);
var EventTimeline$1 = (
  /** @class */
  function() {
    function EventTimeline2(frameCount) {
      this.frames = Utils.newFloatArray(frameCount);
      this.events = new Array(frameCount);
    }
    EventTimeline2.prototype.getPropertyId = function() {
      return TimelineType.event << 24;
    };
    EventTimeline2.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    EventTimeline2.prototype.setFrame = function(frameIndex, event) {
      this.frames[frameIndex] = event.time;
      this.events[frameIndex] = event;
    };
    EventTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      if (firedEvents == null)
        return;
      var frames = this.frames;
      var frameCount = this.frames.length;
      if (lastTime2 > time) {
        this.apply(skeleton, lastTime2, Number.MAX_VALUE, firedEvents, alpha2, blend, direction);
        lastTime2 = -1;
      } else if (lastTime2 >= frames[frameCount - 1])
        return;
      if (time < frames[0])
        return;
      var frame2 = 0;
      if (lastTime2 < frames[0])
        frame2 = 0;
      else {
        frame2 = Animation$1.binarySearch(frames, lastTime2);
        var frameTime = frames[frame2];
        while (frame2 > 0) {
          if (frames[frame2 - 1] != frameTime)
            break;
          frame2--;
        }
      }
      for (; frame2 < frameCount && time >= frames[frame2]; frame2++)
        firedEvents.push(this.events[frame2]);
    };
    return EventTimeline2;
  }()
);
var DrawOrderTimeline$1 = (
  /** @class */
  function() {
    function DrawOrderTimeline2(frameCount) {
      this.frames = Utils.newFloatArray(frameCount);
      this.drawOrders = new Array(frameCount);
    }
    DrawOrderTimeline2.prototype.getPropertyId = function() {
      return TimelineType.drawOrder << 24;
    };
    DrawOrderTimeline2.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    DrawOrderTimeline2.prototype.setFrame = function(frameIndex, time, drawOrder) {
      this.frames[frameIndex] = time;
      this.drawOrders[frameIndex] = drawOrder;
    };
    DrawOrderTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      var drawOrder = skeleton.drawOrder;
      var slots = skeleton.slots;
      if (direction == MixDirection.mixOut && blend == MixBlend.setup) {
        Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
        return;
      }
      var frames = this.frames;
      if (time < frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first)
          Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
        return;
      }
      var frame2 = 0;
      if (time >= frames[frames.length - 1])
        frame2 = frames.length - 1;
      else
        frame2 = Animation$1.binarySearch(frames, time) - 1;
      var drawOrderToSetupIndex = this.drawOrders[frame2];
      if (drawOrderToSetupIndex == null)
        Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);
      else {
        for (var i2 = 0, n2 = drawOrderToSetupIndex.length; i2 < n2; i2++)
          drawOrder[i2] = slots[drawOrderToSetupIndex[i2]];
      }
    };
    return DrawOrderTimeline2;
  }()
);
var IkConstraintTimeline$1 = (
  /** @class */
  function(_super) {
    __extends$3(IkConstraintTimeline2, _super);
    function IkConstraintTimeline2(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * IkConstraintTimeline2.ENTRIES);
      return _this;
    }
    IkConstraintTimeline2.prototype.getPropertyId = function() {
      return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;
    };
    IkConstraintTimeline2.prototype.setFrame = function(frameIndex, time, mix2, bendDirection, compress, stretch) {
      frameIndex *= IkConstraintTimeline2.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + IkConstraintTimeline2.MIX] = mix2;
      this.frames[frameIndex + IkConstraintTimeline2.BEND_DIRECTION] = bendDirection;
      this.frames[frameIndex + IkConstraintTimeline2.COMPRESS] = compress ? 1 : 0;
      this.frames[frameIndex + IkConstraintTimeline2.STRETCH] = stretch ? 1 : 0;
    };
    IkConstraintTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      var frames = this.frames;
      var constraint = skeleton.ikConstraints[this.ikConstraintIndex];
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.mix = constraint.data.mix;
            constraint.bendDirection = constraint.data.bendDirection;
            constraint.compress = constraint.data.compress;
            constraint.stretch = constraint.data.stretch;
            return;
          case MixBlend.first:
            constraint.mix += (constraint.data.mix - constraint.mix) * alpha2;
            constraint.bendDirection = constraint.data.bendDirection;
            constraint.compress = constraint.data.compress;
            constraint.stretch = constraint.data.stretch;
        }
        return;
      }
      if (time >= frames[frames.length - IkConstraintTimeline2.ENTRIES]) {
        if (blend == MixBlend.setup) {
          constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline2.PREV_MIX] - constraint.data.mix) * alpha2;
          if (direction == MixDirection.mixOut) {
            constraint.bendDirection = constraint.data.bendDirection;
            constraint.compress = constraint.data.compress;
            constraint.stretch = constraint.data.stretch;
          } else {
            constraint.bendDirection = frames[frames.length + IkConstraintTimeline2.PREV_BEND_DIRECTION];
            constraint.compress = frames[frames.length + IkConstraintTimeline2.PREV_COMPRESS] != 0;
            constraint.stretch = frames[frames.length + IkConstraintTimeline2.PREV_STRETCH] != 0;
          }
        } else {
          constraint.mix += (frames[frames.length + IkConstraintTimeline2.PREV_MIX] - constraint.mix) * alpha2;
          if (direction == MixDirection.mixIn) {
            constraint.bendDirection = frames[frames.length + IkConstraintTimeline2.PREV_BEND_DIRECTION];
            constraint.compress = frames[frames.length + IkConstraintTimeline2.PREV_COMPRESS] != 0;
            constraint.stretch = frames[frames.length + IkConstraintTimeline2.PREV_STRETCH] != 0;
          }
        }
        return;
      }
      var frame2 = Animation$1.binarySearch(frames, time, IkConstraintTimeline2.ENTRIES);
      var mix2 = frames[frame2 + IkConstraintTimeline2.PREV_MIX];
      var frameTime = frames[frame2];
      var percent2 = this.getCurvePercent(frame2 / IkConstraintTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame2 + IkConstraintTimeline2.PREV_TIME] - frameTime));
      if (blend == MixBlend.setup) {
        constraint.mix = constraint.data.mix + (mix2 + (frames[frame2 + IkConstraintTimeline2.MIX] - mix2) * percent2 - constraint.data.mix) * alpha2;
        if (direction == MixDirection.mixOut) {
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
        } else {
          constraint.bendDirection = frames[frame2 + IkConstraintTimeline2.PREV_BEND_DIRECTION];
          constraint.compress = frames[frame2 + IkConstraintTimeline2.PREV_COMPRESS] != 0;
          constraint.stretch = frames[frame2 + IkConstraintTimeline2.PREV_STRETCH] != 0;
        }
      } else {
        constraint.mix += (mix2 + (frames[frame2 + IkConstraintTimeline2.MIX] - mix2) * percent2 - constraint.mix) * alpha2;
        if (direction == MixDirection.mixIn) {
          constraint.bendDirection = frames[frame2 + IkConstraintTimeline2.PREV_BEND_DIRECTION];
          constraint.compress = frames[frame2 + IkConstraintTimeline2.PREV_COMPRESS] != 0;
          constraint.stretch = frames[frame2 + IkConstraintTimeline2.PREV_STRETCH] != 0;
        }
      }
    };
    IkConstraintTimeline2.ENTRIES = 5;
    IkConstraintTimeline2.PREV_TIME = -5;
    IkConstraintTimeline2.PREV_MIX = -4;
    IkConstraintTimeline2.PREV_BEND_DIRECTION = -3;
    IkConstraintTimeline2.PREV_COMPRESS = -2;
    IkConstraintTimeline2.PREV_STRETCH = -1;
    IkConstraintTimeline2.MIX = 1;
    IkConstraintTimeline2.BEND_DIRECTION = 2;
    IkConstraintTimeline2.COMPRESS = 3;
    IkConstraintTimeline2.STRETCH = 4;
    return IkConstraintTimeline2;
  }(CurveTimeline$1)
);
var TransformConstraintTimeline$1 = (
  /** @class */
  function(_super) {
    __extends$3(TransformConstraintTimeline2, _super);
    function TransformConstraintTimeline2(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * TransformConstraintTimeline2.ENTRIES);
      return _this;
    }
    TransformConstraintTimeline2.prototype.getPropertyId = function() {
      return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;
    };
    TransformConstraintTimeline2.prototype.setFrame = function(frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {
      frameIndex *= TransformConstraintTimeline2.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + TransformConstraintTimeline2.ROTATE] = rotateMix;
      this.frames[frameIndex + TransformConstraintTimeline2.TRANSLATE] = translateMix;
      this.frames[frameIndex + TransformConstraintTimeline2.SCALE] = scaleMix;
      this.frames[frameIndex + TransformConstraintTimeline2.SHEAR] = shearMix;
    };
    TransformConstraintTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      var frames = this.frames;
      var constraint = skeleton.transformConstraints[this.transformConstraintIndex];
      if (time < frames[0]) {
        var data2 = constraint.data;
        switch (blend) {
          case MixBlend.setup:
            constraint.rotateMix = data2.rotateMix;
            constraint.translateMix = data2.translateMix;
            constraint.scaleMix = data2.scaleMix;
            constraint.shearMix = data2.shearMix;
            return;
          case MixBlend.first:
            constraint.rotateMix += (data2.rotateMix - constraint.rotateMix) * alpha2;
            constraint.translateMix += (data2.translateMix - constraint.translateMix) * alpha2;
            constraint.scaleMix += (data2.scaleMix - constraint.scaleMix) * alpha2;
            constraint.shearMix += (data2.shearMix - constraint.shearMix) * alpha2;
        }
        return;
      }
      var rotate = 0, translate = 0, scale = 0, shear = 0;
      if (time >= frames[frames.length - TransformConstraintTimeline2.ENTRIES]) {
        var i2 = frames.length;
        rotate = frames[i2 + TransformConstraintTimeline2.PREV_ROTATE];
        translate = frames[i2 + TransformConstraintTimeline2.PREV_TRANSLATE];
        scale = frames[i2 + TransformConstraintTimeline2.PREV_SCALE];
        shear = frames[i2 + TransformConstraintTimeline2.PREV_SHEAR];
      } else {
        var frame2 = Animation$1.binarySearch(frames, time, TransformConstraintTimeline2.ENTRIES);
        rotate = frames[frame2 + TransformConstraintTimeline2.PREV_ROTATE];
        translate = frames[frame2 + TransformConstraintTimeline2.PREV_TRANSLATE];
        scale = frames[frame2 + TransformConstraintTimeline2.PREV_SCALE];
        shear = frames[frame2 + TransformConstraintTimeline2.PREV_SHEAR];
        var frameTime = frames[frame2];
        var percent2 = this.getCurvePercent(frame2 / TransformConstraintTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame2 + TransformConstraintTimeline2.PREV_TIME] - frameTime));
        rotate += (frames[frame2 + TransformConstraintTimeline2.ROTATE] - rotate) * percent2;
        translate += (frames[frame2 + TransformConstraintTimeline2.TRANSLATE] - translate) * percent2;
        scale += (frames[frame2 + TransformConstraintTimeline2.SCALE] - scale) * percent2;
        shear += (frames[frame2 + TransformConstraintTimeline2.SHEAR] - shear) * percent2;
      }
      if (blend == MixBlend.setup) {
        var data2 = constraint.data;
        constraint.rotateMix = data2.rotateMix + (rotate - data2.rotateMix) * alpha2;
        constraint.translateMix = data2.translateMix + (translate - data2.translateMix) * alpha2;
        constraint.scaleMix = data2.scaleMix + (scale - data2.scaleMix) * alpha2;
        constraint.shearMix = data2.shearMix + (shear - data2.shearMix) * alpha2;
      } else {
        constraint.rotateMix += (rotate - constraint.rotateMix) * alpha2;
        constraint.translateMix += (translate - constraint.translateMix) * alpha2;
        constraint.scaleMix += (scale - constraint.scaleMix) * alpha2;
        constraint.shearMix += (shear - constraint.shearMix) * alpha2;
      }
    };
    TransformConstraintTimeline2.ENTRIES = 5;
    TransformConstraintTimeline2.PREV_TIME = -5;
    TransformConstraintTimeline2.PREV_ROTATE = -4;
    TransformConstraintTimeline2.PREV_TRANSLATE = -3;
    TransformConstraintTimeline2.PREV_SCALE = -2;
    TransformConstraintTimeline2.PREV_SHEAR = -1;
    TransformConstraintTimeline2.ROTATE = 1;
    TransformConstraintTimeline2.TRANSLATE = 2;
    TransformConstraintTimeline2.SCALE = 3;
    TransformConstraintTimeline2.SHEAR = 4;
    return TransformConstraintTimeline2;
  }(CurveTimeline$1)
);
var PathConstraintPositionTimeline$1 = (
  /** @class */
  function(_super) {
    __extends$3(PathConstraintPositionTimeline2, _super);
    function PathConstraintPositionTimeline2(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * PathConstraintPositionTimeline2.ENTRIES);
      return _this;
    }
    PathConstraintPositionTimeline2.prototype.getPropertyId = function() {
      return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;
    };
    PathConstraintPositionTimeline2.prototype.setFrame = function(frameIndex, time, value) {
      frameIndex *= PathConstraintPositionTimeline2.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + PathConstraintPositionTimeline2.VALUE] = value;
    };
    PathConstraintPositionTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      var frames = this.frames;
      var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.position = constraint.data.position;
            return;
          case MixBlend.first:
            constraint.position += (constraint.data.position - constraint.position) * alpha2;
        }
        return;
      }
      var position2 = 0;
      if (time >= frames[frames.length - PathConstraintPositionTimeline2.ENTRIES])
        position2 = frames[frames.length + PathConstraintPositionTimeline2.PREV_VALUE];
      else {
        var frame2 = Animation$1.binarySearch(frames, time, PathConstraintPositionTimeline2.ENTRIES);
        position2 = frames[frame2 + PathConstraintPositionTimeline2.PREV_VALUE];
        var frameTime = frames[frame2];
        var percent2 = this.getCurvePercent(frame2 / PathConstraintPositionTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame2 + PathConstraintPositionTimeline2.PREV_TIME] - frameTime));
        position2 += (frames[frame2 + PathConstraintPositionTimeline2.VALUE] - position2) * percent2;
      }
      if (blend == MixBlend.setup)
        constraint.position = constraint.data.position + (position2 - constraint.data.position) * alpha2;
      else
        constraint.position += (position2 - constraint.position) * alpha2;
    };
    PathConstraintPositionTimeline2.ENTRIES = 2;
    PathConstraintPositionTimeline2.PREV_TIME = -2;
    PathConstraintPositionTimeline2.PREV_VALUE = -1;
    PathConstraintPositionTimeline2.VALUE = 1;
    return PathConstraintPositionTimeline2;
  }(CurveTimeline$1)
);
var PathConstraintSpacingTimeline$1 = (
  /** @class */
  function(_super) {
    __extends$3(PathConstraintSpacingTimeline2, _super);
    function PathConstraintSpacingTimeline2(frameCount) {
      return _super.call(this, frameCount) || this;
    }
    PathConstraintSpacingTimeline2.prototype.getPropertyId = function() {
      return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;
    };
    PathConstraintSpacingTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      var frames = this.frames;
      var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.spacing = constraint.data.spacing;
            return;
          case MixBlend.first:
            constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha2;
        }
        return;
      }
      var spacing = 0;
      if (time >= frames[frames.length - PathConstraintSpacingTimeline2.ENTRIES])
        spacing = frames[frames.length + PathConstraintSpacingTimeline2.PREV_VALUE];
      else {
        var frame2 = Animation$1.binarySearch(frames, time, PathConstraintSpacingTimeline2.ENTRIES);
        spacing = frames[frame2 + PathConstraintSpacingTimeline2.PREV_VALUE];
        var frameTime = frames[frame2];
        var percent2 = this.getCurvePercent(frame2 / PathConstraintSpacingTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame2 + PathConstraintSpacingTimeline2.PREV_TIME] - frameTime));
        spacing += (frames[frame2 + PathConstraintSpacingTimeline2.VALUE] - spacing) * percent2;
      }
      if (blend == MixBlend.setup)
        constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha2;
      else
        constraint.spacing += (spacing - constraint.spacing) * alpha2;
    };
    return PathConstraintSpacingTimeline2;
  }(PathConstraintPositionTimeline$1)
);
var PathConstraintMixTimeline$1 = (
  /** @class */
  function(_super) {
    __extends$3(PathConstraintMixTimeline2, _super);
    function PathConstraintMixTimeline2(frameCount) {
      var _this = _super.call(this, frameCount) || this;
      _this.frames = Utils.newFloatArray(frameCount * PathConstraintMixTimeline2.ENTRIES);
      return _this;
    }
    PathConstraintMixTimeline2.prototype.getPropertyId = function() {
      return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;
    };
    PathConstraintMixTimeline2.prototype.setFrame = function(frameIndex, time, rotateMix, translateMix) {
      frameIndex *= PathConstraintMixTimeline2.ENTRIES;
      this.frames[frameIndex] = time;
      this.frames[frameIndex + PathConstraintMixTimeline2.ROTATE] = rotateMix;
      this.frames[frameIndex + PathConstraintMixTimeline2.TRANSLATE] = translateMix;
    };
    PathConstraintMixTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      var frames = this.frames;
      var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.rotateMix = constraint.data.rotateMix;
            constraint.translateMix = constraint.data.translateMix;
            return;
          case MixBlend.first:
            constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha2;
            constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha2;
        }
        return;
      }
      var rotate = 0, translate = 0;
      if (time >= frames[frames.length - PathConstraintMixTimeline2.ENTRIES]) {
        rotate = frames[frames.length + PathConstraintMixTimeline2.PREV_ROTATE];
        translate = frames[frames.length + PathConstraintMixTimeline2.PREV_TRANSLATE];
      } else {
        var frame2 = Animation$1.binarySearch(frames, time, PathConstraintMixTimeline2.ENTRIES);
        rotate = frames[frame2 + PathConstraintMixTimeline2.PREV_ROTATE];
        translate = frames[frame2 + PathConstraintMixTimeline2.PREV_TRANSLATE];
        var frameTime = frames[frame2];
        var percent2 = this.getCurvePercent(frame2 / PathConstraintMixTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame2 + PathConstraintMixTimeline2.PREV_TIME] - frameTime));
        rotate += (frames[frame2 + PathConstraintMixTimeline2.ROTATE] - rotate) * percent2;
        translate += (frames[frame2 + PathConstraintMixTimeline2.TRANSLATE] - translate) * percent2;
      }
      if (blend == MixBlend.setup) {
        constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha2;
        constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha2;
      } else {
        constraint.rotateMix += (rotate - constraint.rotateMix) * alpha2;
        constraint.translateMix += (translate - constraint.translateMix) * alpha2;
      }
    };
    PathConstraintMixTimeline2.ENTRIES = 3;
    PathConstraintMixTimeline2.PREV_TIME = -3;
    PathConstraintMixTimeline2.PREV_ROTATE = -2;
    PathConstraintMixTimeline2.PREV_TRANSLATE = -1;
    PathConstraintMixTimeline2.ROTATE = 1;
    PathConstraintMixTimeline2.TRANSLATE = 2;
    return PathConstraintMixTimeline2;
  }(CurveTimeline$1)
);
var AnimationState$1 = (
  /** @class */
  function() {
    function AnimationState2(data2) {
      this.tracks = new Array();
      this.events = new Array();
      this.listeners = new Array();
      this.queue = new EventQueue$1(this);
      this.propertyIDs = new IntSet();
      this.animationsChanged = false;
      this.timeScale = 1;
      this.trackEntryPool = new Pool(function() {
        return new TrackEntry$1();
      });
      this.data = data2;
    }
    AnimationState2.prototype.update = function(delta) {
      delta *= this.timeScale;
      var tracks = this.tracks;
      for (var i2 = 0, n2 = tracks.length; i2 < n2; i2++) {
        var current = tracks[i2];
        if (current == null)
          continue;
        current.animationLast = current.nextAnimationLast;
        current.trackLast = current.nextTrackLast;
        var currentDelta = delta * current.timeScale;
        if (current.delay > 0) {
          current.delay -= currentDelta;
          if (current.delay > 0)
            continue;
          currentDelta = -current.delay;
          current.delay = 0;
        }
        var next2 = current.next;
        if (next2 != null) {
          var nextTime = current.trackLast - next2.delay;
          if (nextTime >= 0) {
            next2.delay = 0;
            next2.trackTime = current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next2.timeScale;
            current.trackTime += currentDelta;
            this.setCurrent(i2, next2, true);
            while (next2.mixingFrom != null) {
              next2.mixTime += delta;
              next2 = next2.mixingFrom;
            }
            continue;
          }
        } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {
          tracks[i2] = null;
          this.queue.end(current);
          this.disposeNext(current);
          continue;
        }
        if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {
          var from2 = current.mixingFrom;
          current.mixingFrom = null;
          if (from2 != null)
            from2.mixingTo = null;
          while (from2 != null) {
            this.queue.end(from2);
            from2 = from2.mixingFrom;
          }
        }
        current.trackTime += currentDelta;
      }
      this.queue.drain();
    };
    AnimationState2.prototype.updateMixingFrom = function(to, delta) {
      var from2 = to.mixingFrom;
      if (from2 == null)
        return true;
      var finished = this.updateMixingFrom(from2, delta);
      from2.animationLast = from2.nextAnimationLast;
      from2.trackLast = from2.nextTrackLast;
      if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {
        if (from2.totalAlpha == 0 || to.mixDuration == 0) {
          to.mixingFrom = from2.mixingFrom;
          if (from2.mixingFrom != null)
            from2.mixingFrom.mixingTo = to;
          to.interruptAlpha = from2.interruptAlpha;
          this.queue.end(from2);
        }
        return finished;
      }
      from2.trackTime += delta * from2.timeScale;
      to.mixTime += delta;
      return false;
    };
    AnimationState2.prototype.apply = function(skeleton) {
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      if (this.animationsChanged)
        this._animationsChanged();
      var events = this.events;
      var tracks = this.tracks;
      var applied = false;
      for (var i2 = 0, n2 = tracks.length; i2 < n2; i2++) {
        var current = tracks[i2];
        if (current == null || current.delay > 0)
          continue;
        applied = true;
        var blend = i2 == 0 ? MixBlend.first : current.mixBlend;
        var mix2 = current.alpha;
        if (current.mixingFrom != null)
          mix2 *= this.applyMixingFrom(current, skeleton, blend);
        else if (current.trackTime >= current.trackEnd && current.next == null)
          mix2 = 0;
        var animationLast = current.animationLast, animationTime = current.getAnimationTime();
        var timelineCount = current.animation.timelines.length;
        var timelines = current.animation.timelines;
        if (i2 == 0 && mix2 == 1 || blend == MixBlend.add) {
          for (var ii2 = 0; ii2 < timelineCount; ii2++) {
            Utils.webkit602BugfixHelper(mix2, blend);
            timelines[ii2].apply(skeleton, animationLast, animationTime, events, mix2, blend, MixDirection.mixIn);
          }
        } else {
          var timelineMode = current.timelineMode;
          var firstFrame = current.timelinesRotation.length == 0;
          if (firstFrame)
            Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);
          var timelinesRotation = current.timelinesRotation;
          for (var ii2 = 0; ii2 < timelineCount; ii2++) {
            var timeline = timelines[ii2];
            var timelineBlend = timelineMode[ii2] == AnimationState2.SUBSEQUENT ? blend : MixBlend.setup;
            if (timeline instanceof RotateTimeline$1) {
              this.applyRotateTimeline(timeline, skeleton, animationTime, mix2, timelineBlend, timelinesRotation, ii2 << 1, firstFrame);
            } else {
              Utils.webkit602BugfixHelper(mix2, blend);
              timeline.apply(skeleton, animationLast, animationTime, events, mix2, timelineBlend, MixDirection.mixIn);
            }
          }
        }
        this.queueEvents(current, animationTime);
        events.length = 0;
        current.nextAnimationLast = animationTime;
        current.nextTrackLast = current.trackTime;
      }
      this.queue.drain();
      return applied;
    };
    AnimationState2.prototype.applyMixingFrom = function(to, skeleton, blend) {
      var from2 = to.mixingFrom;
      if (from2.mixingFrom != null)
        this.applyMixingFrom(from2, skeleton, blend);
      var mix2 = 0;
      if (to.mixDuration == 0) {
        mix2 = 1;
        if (blend == MixBlend.first)
          blend = MixBlend.setup;
      } else {
        mix2 = to.mixTime / to.mixDuration;
        if (mix2 > 1)
          mix2 = 1;
        if (blend != MixBlend.first)
          blend = from2.mixBlend;
      }
      var events = mix2 < from2.eventThreshold ? this.events : null;
      var attachments = mix2 < from2.attachmentThreshold, drawOrder = mix2 < from2.drawOrderThreshold;
      var animationLast = from2.animationLast, animationTime = from2.getAnimationTime();
      var timelineCount = from2.animation.timelines.length;
      var timelines = from2.animation.timelines;
      var alphaHold = from2.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix2);
      if (blend == MixBlend.add) {
        for (var i2 = 0; i2 < timelineCount; i2++)
          timelines[i2].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, MixDirection.mixOut);
      } else {
        var timelineMode = from2.timelineMode;
        var timelineHoldMix = from2.timelineHoldMix;
        var firstFrame = from2.timelinesRotation.length == 0;
        if (firstFrame)
          Utils.setArraySize(from2.timelinesRotation, timelineCount << 1, null);
        var timelinesRotation = from2.timelinesRotation;
        from2.totalAlpha = 0;
        for (var i2 = 0; i2 < timelineCount; i2++) {
          var timeline = timelines[i2];
          var direction = MixDirection.mixOut;
          var timelineBlend = void 0;
          var alpha2 = 0;
          switch (timelineMode[i2]) {
            case AnimationState2.SUBSEQUENT:
              if (!attachments && timeline instanceof AttachmentTimeline$1)
                continue;
              if (!drawOrder && timeline instanceof DrawOrderTimeline$1)
                continue;
              timelineBlend = blend;
              alpha2 = alphaMix;
              break;
            case AnimationState2.FIRST:
              timelineBlend = MixBlend.setup;
              alpha2 = alphaMix;
              break;
            case AnimationState2.HOLD:
              timelineBlend = MixBlend.setup;
              alpha2 = alphaHold;
              break;
            default:
              timelineBlend = MixBlend.setup;
              var holdMix = timelineHoldMix[i2];
              alpha2 = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
              break;
          }
          from2.totalAlpha += alpha2;
          if (timeline instanceof RotateTimeline$1)
            this.applyRotateTimeline(timeline, skeleton, animationTime, alpha2, timelineBlend, timelinesRotation, i2 << 1, firstFrame);
          else {
            Utils.webkit602BugfixHelper(alpha2, blend);
            if (timelineBlend == MixBlend.setup) {
              if (timeline instanceof AttachmentTimeline$1) {
                if (attachments)
                  direction = MixDirection.mixOut;
              } else if (timeline instanceof DrawOrderTimeline$1) {
                if (drawOrder)
                  direction = MixDirection.mixOut;
              }
            }
            timeline.apply(skeleton, animationLast, animationTime, events, alpha2, timelineBlend, direction);
          }
        }
      }
      if (to.mixDuration > 0)
        this.queueEvents(from2, animationTime);
      this.events.length = 0;
      from2.nextAnimationLast = animationTime;
      from2.nextTrackLast = from2.trackTime;
      return mix2;
    };
    AnimationState2.prototype.applyRotateTimeline = function(timeline, skeleton, time, alpha2, blend, timelinesRotation, i2, firstFrame) {
      if (firstFrame)
        timelinesRotation[i2] = 0;
      if (alpha2 == 1) {
        timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);
        return;
      }
      var rotateTimeline = timeline;
      var frames = rotateTimeline.frames;
      var bone = skeleton.bones[rotateTimeline.boneIndex];
      var r1 = 0, r2 = 0;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.rotation = bone.data.rotation;
          default:
            return;
          case MixBlend.first:
            r1 = bone.rotation;
            r2 = bone.data.rotation;
        }
      } else {
        r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;
        if (time >= frames[frames.length - RotateTimeline$1.ENTRIES])
          r2 = bone.data.rotation + frames[frames.length + RotateTimeline$1.PREV_ROTATION];
        else {
          var frame2 = Animation$1.binarySearch(frames, time, RotateTimeline$1.ENTRIES);
          var prevRotation = frames[frame2 + RotateTimeline$1.PREV_ROTATION];
          var frameTime = frames[frame2];
          var percent2 = rotateTimeline.getCurvePercent((frame2 >> 1) - 1, 1 - (time - frameTime) / (frames[frame2 + RotateTimeline$1.PREV_TIME] - frameTime));
          r2 = frames[frame2 + RotateTimeline$1.ROTATION] - prevRotation;
          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
          r2 = prevRotation + r2 * percent2 + bone.data.rotation;
          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
        }
      }
      var total = 0, diff = r2 - r1;
      diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;
      if (diff == 0) {
        total = timelinesRotation[i2];
      } else {
        var lastTotal = 0, lastDiff = 0;
        if (firstFrame) {
          lastTotal = 0;
          lastDiff = diff;
        } else {
          lastTotal = timelinesRotation[i2];
          lastDiff = timelinesRotation[i2 + 1];
        }
        var current = diff > 0, dir = lastTotal >= 0;
        if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
          if (Math.abs(lastTotal) > 180)
            lastTotal += 360 * MathUtils.signum(lastTotal);
          dir = current;
        }
        total = diff + lastTotal - lastTotal % 360;
        if (dir != current)
          total += 360 * MathUtils.signum(lastTotal);
        timelinesRotation[i2] = total;
      }
      timelinesRotation[i2 + 1] = diff;
      r1 += total * alpha2;
      bone.rotation = r1 - (16384 - (16384.499999999996 - r1 / 360 | 0)) * 360;
    };
    AnimationState2.prototype.queueEvents = function(entry, animationTime) {
      var animationStart = entry.animationStart, animationEnd = entry.animationEnd;
      var duration = animationEnd - animationStart;
      var trackLastWrapped = entry.trackLast % duration;
      var events = this.events;
      var i2 = 0, n2 = events.length;
      for (; i2 < n2; i2++) {
        var event_1 = events[i2];
        if (event_1.time < trackLastWrapped)
          break;
        if (event_1.time > animationEnd)
          continue;
        this.queue.event(entry, event_1);
      }
      var complete = false;
      if (entry.loop)
        complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;
      else
        complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
      if (complete)
        this.queue.complete(entry);
      for (; i2 < n2; i2++) {
        var event_2 = events[i2];
        if (event_2.time < animationStart)
          continue;
        this.queue.event(entry, events[i2]);
      }
    };
    AnimationState2.prototype.clearTracks = function() {
      var oldDrainDisabled = this.queue.drainDisabled;
      this.queue.drainDisabled = true;
      for (var i2 = 0, n2 = this.tracks.length; i2 < n2; i2++)
        this.clearTrack(i2);
      this.tracks.length = 0;
      this.queue.drainDisabled = oldDrainDisabled;
      this.queue.drain();
    };
    AnimationState2.prototype.clearTrack = function(trackIndex) {
      if (trackIndex >= this.tracks.length)
        return;
      var current = this.tracks[trackIndex];
      if (current == null)
        return;
      this.queue.end(current);
      this.disposeNext(current);
      var entry = current;
      while (true) {
        var from2 = entry.mixingFrom;
        if (from2 == null)
          break;
        this.queue.end(from2);
        entry.mixingFrom = null;
        entry.mixingTo = null;
        entry = from2;
      }
      this.tracks[current.trackIndex] = null;
      this.queue.drain();
    };
    AnimationState2.prototype.setCurrent = function(index2, current, interrupt) {
      var from2 = this.expandToIndex(index2);
      this.tracks[index2] = current;
      if (from2 != null) {
        if (interrupt)
          this.queue.interrupt(from2);
        current.mixingFrom = from2;
        from2.mixingTo = current;
        current.mixTime = 0;
        if (from2.mixingFrom != null && from2.mixDuration > 0)
          current.interruptAlpha *= Math.min(1, from2.mixTime / from2.mixDuration);
        from2.timelinesRotation.length = 0;
      }
      this.queue.start(current);
    };
    AnimationState2.prototype.setAnimation = function(trackIndex, animationName, loop) {
      var animation2 = this.data.skeletonData.findAnimation(animationName);
      if (animation2 == null)
        throw new Error("Animation not found: " + animationName);
      return this.setAnimationWith(trackIndex, animation2, loop);
    };
    AnimationState2.prototype.setAnimationWith = function(trackIndex, animation2, loop) {
      if (animation2 == null)
        throw new Error("animation cannot be null.");
      var interrupt = true;
      var current = this.expandToIndex(trackIndex);
      if (current != null) {
        if (current.nextTrackLast == -1) {
          this.tracks[trackIndex] = current.mixingFrom;
          this.queue.interrupt(current);
          this.queue.end(current);
          this.disposeNext(current);
          current = current.mixingFrom;
          interrupt = false;
        } else
          this.disposeNext(current);
      }
      var entry = this.trackEntry(trackIndex, animation2, loop, current);
      this.setCurrent(trackIndex, entry, interrupt);
      this.queue.drain();
      return entry;
    };
    AnimationState2.prototype.addAnimation = function(trackIndex, animationName, loop, delay) {
      var animation2 = this.data.skeletonData.findAnimation(animationName);
      if (animation2 == null)
        throw new Error("Animation not found: " + animationName);
      return this.addAnimationWith(trackIndex, animation2, loop, delay);
    };
    AnimationState2.prototype.addAnimationWith = function(trackIndex, animation2, loop, delay) {
      if (animation2 == null)
        throw new Error("animation cannot be null.");
      var last = this.expandToIndex(trackIndex);
      if (last != null) {
        while (last.next != null)
          last = last.next;
      }
      var entry = this.trackEntry(trackIndex, animation2, loop, last);
      if (last == null) {
        this.setCurrent(trackIndex, entry, true);
        this.queue.drain();
      } else {
        last.next = entry;
        if (delay <= 0) {
          var duration = last.animationEnd - last.animationStart;
          if (duration != 0) {
            if (last.loop)
              delay += duration * (1 + (last.trackTime / duration | 0));
            else
              delay += Math.max(duration, last.trackTime);
            delay -= this.data.getMix(last.animation, animation2);
          } else
            delay = last.trackTime;
        }
      }
      entry.delay = delay;
      return entry;
    };
    AnimationState2.prototype.setEmptyAnimation = function(trackIndex, mixDuration) {
      var entry = this.setAnimationWith(trackIndex, AnimationState2.emptyAnimation, false);
      entry.mixDuration = mixDuration;
      entry.trackEnd = mixDuration;
      return entry;
    };
    AnimationState2.prototype.addEmptyAnimation = function(trackIndex, mixDuration, delay) {
      if (delay <= 0)
        delay -= mixDuration;
      var entry = this.addAnimationWith(trackIndex, AnimationState2.emptyAnimation, false, delay);
      entry.mixDuration = mixDuration;
      entry.trackEnd = mixDuration;
      return entry;
    };
    AnimationState2.prototype.setEmptyAnimations = function(mixDuration) {
      var oldDrainDisabled = this.queue.drainDisabled;
      this.queue.drainDisabled = true;
      for (var i2 = 0, n2 = this.tracks.length; i2 < n2; i2++) {
        var current = this.tracks[i2];
        if (current != null)
          this.setEmptyAnimation(current.trackIndex, mixDuration);
      }
      this.queue.drainDisabled = oldDrainDisabled;
      this.queue.drain();
    };
    AnimationState2.prototype.expandToIndex = function(index2) {
      if (index2 < this.tracks.length)
        return this.tracks[index2];
      Utils.ensureArrayCapacity(this.tracks, index2 - this.tracks.length + 1, null);
      this.tracks.length = index2 + 1;
      return null;
    };
    AnimationState2.prototype.trackEntry = function(trackIndex, animation2, loop, last) {
      var entry = this.trackEntryPool.obtain();
      entry.trackIndex = trackIndex;
      entry.animation = animation2;
      entry.loop = loop;
      entry.holdPrevious = false;
      entry.eventThreshold = 0;
      entry.attachmentThreshold = 0;
      entry.drawOrderThreshold = 0;
      entry.animationStart = 0;
      entry.animationEnd = animation2.duration;
      entry.animationLast = -1;
      entry.nextAnimationLast = -1;
      entry.delay = 0;
      entry.trackTime = 0;
      entry.trackLast = -1;
      entry.nextTrackLast = -1;
      entry.trackEnd = Number.MAX_VALUE;
      entry.timeScale = 1;
      entry.alpha = 1;
      entry.interruptAlpha = 1;
      entry.mixTime = 0;
      entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation2);
      return entry;
    };
    AnimationState2.prototype.disposeNext = function(entry) {
      var next2 = entry.next;
      while (next2 != null) {
        this.queue.dispose(next2);
        next2 = next2.next;
      }
      entry.next = null;
    };
    AnimationState2.prototype._animationsChanged = function() {
      this.animationsChanged = false;
      this.propertyIDs.clear();
      for (var i2 = 0, n2 = this.tracks.length; i2 < n2; i2++) {
        var entry = this.tracks[i2];
        if (entry == null)
          continue;
        while (entry.mixingFrom != null)
          entry = entry.mixingFrom;
        do {
          if (entry.mixingFrom == null || entry.mixBlend != MixBlend.add)
            this.setTimelineModes(entry);
          entry = entry.mixingTo;
        } while (entry != null);
      }
    };
    AnimationState2.prototype.setTimelineModes = function(entry) {
      var to = entry.mixingTo;
      var timelines = entry.animation.timelines;
      var timelinesCount = entry.animation.timelines.length;
      var timelineMode = Utils.setArraySize(entry.timelineMode, timelinesCount);
      entry.timelineHoldMix.length = 0;
      var timelineDipMix = Utils.setArraySize(entry.timelineHoldMix, timelinesCount);
      var propertyIDs = this.propertyIDs;
      if (to != null && to.holdPrevious) {
        for (var i2 = 0; i2 < timelinesCount; i2++) {
          propertyIDs.add(timelines[i2].getPropertyId());
          timelineMode[i2] = AnimationState2.HOLD;
        }
        return;
      }
      outer:
        for (var i2 = 0; i2 < timelinesCount; i2++) {
          var id2 = timelines[i2].getPropertyId();
          if (!propertyIDs.add(id2))
            timelineMode[i2] = AnimationState2.SUBSEQUENT;
          else if (to == null || !this.hasTimeline(to, id2))
            timelineMode[i2] = AnimationState2.FIRST;
          else {
            for (var next2 = to.mixingTo; next2 != null; next2 = next2.mixingTo) {
              if (this.hasTimeline(next2, id2))
                continue;
              if (entry.mixDuration > 0) {
                timelineMode[i2] = AnimationState2.HOLD_MIX;
                timelineDipMix[i2] = next2;
                continue outer;
              }
              break;
            }
            timelineMode[i2] = AnimationState2.HOLD;
          }
        }
    };
    AnimationState2.prototype.hasTimeline = function(entry, id2) {
      var timelines = entry.animation.timelines;
      for (var i2 = 0, n2 = timelines.length; i2 < n2; i2++)
        if (timelines[i2].getPropertyId() == id2)
          return true;
      return false;
    };
    AnimationState2.prototype.getCurrent = function(trackIndex) {
      if (trackIndex >= this.tracks.length)
        return null;
      return this.tracks[trackIndex];
    };
    AnimationState2.prototype.addListener = function(listener) {
      if (listener == null)
        throw new Error("listener cannot be null.");
      this.listeners.push(listener);
    };
    AnimationState2.prototype.removeListener = function(listener) {
      var index2 = this.listeners.indexOf(listener);
      if (index2 >= 0)
        this.listeners.splice(index2, 1);
    };
    AnimationState2.prototype.clearListeners = function() {
      this.listeners.length = 0;
    };
    AnimationState2.prototype.clearListenerNotifications = function() {
      this.queue.clear();
    };
    AnimationState2.prototype.setAnimationByName = function(trackIndex, animationName, loop) {
      if (!AnimationState2.deprecatedWarning1) {
        AnimationState2.deprecatedWarning1 = true;
        console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.");
      }
      this.setAnimation(trackIndex, animationName, loop);
    };
    AnimationState2.prototype.addAnimationByName = function(trackIndex, animationName, loop, delay) {
      if (!AnimationState2.deprecatedWarning2) {
        AnimationState2.deprecatedWarning2 = true;
        console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.");
      }
      this.addAnimation(trackIndex, animationName, loop, delay);
    };
    AnimationState2.prototype.hasAnimation = function(animationName) {
      var animation2 = this.data.skeletonData.findAnimation(animationName);
      return animation2 !== null;
    };
    AnimationState2.prototype.hasAnimationByName = function(animationName) {
      if (!AnimationState2.deprecatedWarning3) {
        AnimationState2.deprecatedWarning3 = true;
        console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.");
      }
      return this.hasAnimation(animationName);
    };
    AnimationState2.emptyAnimation = new Animation$1("<empty>", [], 0);
    AnimationState2.SUBSEQUENT = 0;
    AnimationState2.FIRST = 1;
    AnimationState2.HOLD = 2;
    AnimationState2.HOLD_MIX = 3;
    AnimationState2.deprecatedWarning1 = false;
    AnimationState2.deprecatedWarning2 = false;
    AnimationState2.deprecatedWarning3 = false;
    return AnimationState2;
  }()
);
var TrackEntry$1 = (
  /** @class */
  function() {
    function TrackEntry2() {
      this.mixBlend = MixBlend.replace;
      this.timelineMode = new Array();
      this.timelineHoldMix = new Array();
      this.timelinesRotation = new Array();
    }
    TrackEntry2.prototype.reset = function() {
      this.next = null;
      this.mixingFrom = null;
      this.mixingTo = null;
      this.animation = null;
      this.listener = null;
      this.timelineMode.length = 0;
      this.timelineHoldMix.length = 0;
      this.timelinesRotation.length = 0;
    };
    TrackEntry2.prototype.getAnimationTime = function() {
      if (this.loop) {
        var duration = this.animationEnd - this.animationStart;
        if (duration == 0)
          return this.animationStart;
        return this.trackTime % duration + this.animationStart;
      }
      return Math.min(this.trackTime + this.animationStart, this.animationEnd);
    };
    TrackEntry2.prototype.setAnimationLast = function(animationLast) {
      this.animationLast = animationLast;
      this.nextAnimationLast = animationLast;
    };
    TrackEntry2.prototype.isComplete = function() {
      return this.trackTime >= this.animationEnd - this.animationStart;
    };
    TrackEntry2.prototype.resetRotationDirections = function() {
      this.timelinesRotation.length = 0;
    };
    Object.defineProperty(TrackEntry2.prototype, "time", {
      get: function() {
        if (!TrackEntry2.deprecatedWarning1) {
          TrackEntry2.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
        }
        return this.trackTime;
      },
      set: function(value) {
        if (!TrackEntry2.deprecatedWarning1) {
          TrackEntry2.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
        }
        this.trackTime = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TrackEntry2.prototype, "endTime", {
      get: function() {
        if (!TrackEntry2.deprecatedWarning2) {
          TrackEntry2.deprecatedWarning2 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
        }
        return this.trackTime;
      },
      set: function(value) {
        if (!TrackEntry2.deprecatedWarning2) {
          TrackEntry2.deprecatedWarning2 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
        }
        this.trackTime = value;
      },
      enumerable: false,
      configurable: true
    });
    TrackEntry2.prototype.loopsCount = function() {
      return Math.floor(this.trackTime / this.trackEnd);
    };
    TrackEntry2.deprecatedWarning1 = false;
    TrackEntry2.deprecatedWarning2 = false;
    return TrackEntry2;
  }()
);
var EventQueue$1 = (
  /** @class */
  function() {
    function EventQueue2(animState) {
      this.objects = [];
      this.drainDisabled = false;
      this.animState = animState;
    }
    EventQueue2.prototype.start = function(entry) {
      this.objects.push(EventType$1.start);
      this.objects.push(entry);
      this.animState.animationsChanged = true;
    };
    EventQueue2.prototype.interrupt = function(entry) {
      this.objects.push(EventType$1.interrupt);
      this.objects.push(entry);
    };
    EventQueue2.prototype.end = function(entry) {
      this.objects.push(EventType$1.end);
      this.objects.push(entry);
      this.animState.animationsChanged = true;
    };
    EventQueue2.prototype.dispose = function(entry) {
      this.objects.push(EventType$1.dispose);
      this.objects.push(entry);
    };
    EventQueue2.prototype.complete = function(entry) {
      this.objects.push(EventType$1.complete);
      this.objects.push(entry);
    };
    EventQueue2.prototype.event = function(entry, event) {
      this.objects.push(EventType$1.event);
      this.objects.push(entry);
      this.objects.push(event);
    };
    EventQueue2.prototype.deprecateStuff = function() {
      if (!EventQueue2.deprecatedWarning1) {
        EventQueue2.deprecatedWarning1 = true;
        console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'");
      }
      return true;
    };
    EventQueue2.prototype.drain = function() {
      if (this.drainDisabled)
        return;
      this.drainDisabled = true;
      var objects = this.objects;
      var listeners = this.animState.listeners;
      for (var i2 = 0; i2 < objects.length; i2 += 2) {
        var type2 = objects[i2];
        var entry = objects[i2 + 1];
        switch (type2) {
          case EventType$1.start:
            if (entry.listener != null && entry.listener.start)
              entry.listener.start(entry);
            for (var ii2 = 0; ii2 < listeners.length; ii2++)
              if (listeners[ii2].start)
                listeners[ii2].start(entry);
            entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);
            this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);
            break;
          case EventType$1.interrupt:
            if (entry.listener != null && entry.listener.interrupt)
              entry.listener.interrupt(entry);
            for (var ii2 = 0; ii2 < listeners.length; ii2++)
              if (listeners[ii2].interrupt)
                listeners[ii2].interrupt(entry);
            break;
          case EventType$1.end:
            if (entry.listener != null && entry.listener.end)
              entry.listener.end(entry);
            for (var ii2 = 0; ii2 < listeners.length; ii2++)
              if (listeners[ii2].end)
                listeners[ii2].end(entry);
            entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);
            this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);
          case EventType$1.dispose:
            if (entry.listener != null && entry.listener.dispose)
              entry.listener.dispose(entry);
            for (var ii2 = 0; ii2 < listeners.length; ii2++)
              if (listeners[ii2].dispose)
                listeners[ii2].dispose(entry);
            this.animState.trackEntryPool.free(entry);
            break;
          case EventType$1.complete:
            if (entry.listener != null && entry.listener.complete)
              entry.listener.complete(entry);
            for (var ii2 = 0; ii2 < listeners.length; ii2++)
              if (listeners[ii2].complete)
                listeners[ii2].complete(entry);
            var count = MathUtils.toInt(entry.loopsCount());
            entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);
            this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);
            break;
          case EventType$1.event:
            var event_3 = objects[i2++ + 2];
            if (entry.listener != null && entry.listener.event)
              entry.listener.event(entry, event_3);
            for (var ii2 = 0; ii2 < listeners.length; ii2++)
              if (listeners[ii2].event)
                listeners[ii2].event(entry, event_3);
            entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event_3);
            this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event_3);
            break;
        }
      }
      this.clear();
      this.drainDisabled = false;
    };
    EventQueue2.prototype.clear = function() {
      this.objects.length = 0;
    };
    EventQueue2.deprecatedWarning1 = false;
    return EventQueue2;
  }()
);
var EventType$1;
(function(EventType2) {
  EventType2[EventType2["start"] = 0] = "start";
  EventType2[EventType2["interrupt"] = 1] = "interrupt";
  EventType2[EventType2["end"] = 2] = "end";
  EventType2[EventType2["dispose"] = 3] = "dispose";
  EventType2[EventType2["complete"] = 4] = "complete";
  EventType2[EventType2["event"] = 5] = "event";
})(EventType$1 || (EventType$1 = {}));
var AnimationStateAdapter2 = (
  /** @class */
  function() {
    function AnimationStateAdapter22() {
    }
    AnimationStateAdapter22.prototype.start = function(entry) {
    };
    AnimationStateAdapter22.prototype.interrupt = function(entry) {
    };
    AnimationStateAdapter22.prototype.end = function(entry) {
    };
    AnimationStateAdapter22.prototype.dispose = function(entry) {
    };
    AnimationStateAdapter22.prototype.complete = function(entry) {
    };
    AnimationStateAdapter22.prototype.event = function(entry, event) {
    };
    return AnimationStateAdapter22;
  }()
);
var AnimationStateData$1 = (
  /** @class */
  function() {
    function AnimationStateData2(skeletonData) {
      this.animationToMixTime = {};
      this.defaultMix = 0;
      if (skeletonData == null)
        throw new Error("skeletonData cannot be null.");
      this.skeletonData = skeletonData;
    }
    AnimationStateData2.prototype.setMix = function(fromName, toName, duration) {
      var from2 = this.skeletonData.findAnimation(fromName);
      if (from2 == null)
        throw new Error("Animation not found: " + fromName);
      var to = this.skeletonData.findAnimation(toName);
      if (to == null)
        throw new Error("Animation not found: " + toName);
      this.setMixWith(from2, to, duration);
    };
    AnimationStateData2.prototype.setMixByName = function(fromName, toName, duration) {
      if (!AnimationStateData2.deprecatedWarning1) {
        AnimationStateData2.deprecatedWarning1 = true;
        console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.");
      }
      this.setMix(fromName, toName, duration);
    };
    AnimationStateData2.prototype.setMixWith = function(from2, to, duration) {
      if (from2 == null)
        throw new Error("from cannot be null.");
      if (to == null)
        throw new Error("to cannot be null.");
      var key = from2.name + "." + to.name;
      this.animationToMixTime[key] = duration;
    };
    AnimationStateData2.prototype.getMix = function(from2, to) {
      var key = from2.name + "." + to.name;
      var value = this.animationToMixTime[key];
      return value === void 0 ? this.defaultMix : value;
    };
    AnimationStateData2.deprecatedWarning1 = false;
    return AnimationStateData2;
  }()
);
var AtlasAttachmentLoader$1 = (
  /** @class */
  function() {
    function AtlasAttachmentLoader2(atlas) {
      this.atlas = atlas;
    }
    AtlasAttachmentLoader2.prototype.newRegionAttachment = function(skin, name, path) {
      var region = this.atlas.findRegion(path);
      if (region == null)
        throw new Error("Region not found in atlas: " + path + " (region attachment: " + name + ")");
      var attachment = new RegionAttachment$1(name);
      attachment.region = region;
      return attachment;
    };
    AtlasAttachmentLoader2.prototype.newMeshAttachment = function(skin, name, path) {
      var region = this.atlas.findRegion(path);
      if (region == null)
        throw new Error("Region not found in atlas: " + path + " (mesh attachment: " + name + ")");
      var attachment = new MeshAttachment$1(name);
      attachment.region = region;
      return attachment;
    };
    AtlasAttachmentLoader2.prototype.newBoundingBoxAttachment = function(skin, name) {
      return new BoundingBoxAttachment$1(name);
    };
    AtlasAttachmentLoader2.prototype.newPathAttachment = function(skin, name) {
      return new PathAttachment$1(name);
    };
    AtlasAttachmentLoader2.prototype.newPointAttachment = function(skin, name) {
      return new PointAttachment$1(name);
    };
    AtlasAttachmentLoader2.prototype.newClippingAttachment = function(skin, name) {
      return new ClippingAttachment$1(name);
    };
    return AtlasAttachmentLoader2;
  }()
);
var Bone$1 = (
  /** @class */
  function() {
    function Bone2(data2, skeleton, parent) {
      this.matrix = new Matrix();
      this.children = new Array();
      this.x = 0;
      this.y = 0;
      this.rotation = 0;
      this.scaleX = 0;
      this.scaleY = 0;
      this.shearX = 0;
      this.shearY = 0;
      this.ax = 0;
      this.ay = 0;
      this.arotation = 0;
      this.ascaleX = 0;
      this.ascaleY = 0;
      this.ashearX = 0;
      this.ashearY = 0;
      this.appliedValid = false;
      this.sorted = false;
      this.active = true;
      if (data2 == null)
        throw new Error("data cannot be null.");
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      this.data = data2;
      this.skeleton = skeleton;
      this.parent = parent;
      this.setToSetupPose();
    }
    Object.defineProperty(Bone2.prototype, "worldX", {
      get: function() {
        return this.matrix.tx;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bone2.prototype, "worldY", {
      get: function() {
        return this.matrix.ty;
      },
      enumerable: false,
      configurable: true
    });
    Bone2.prototype.update = function() {
      this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
    };
    Bone2.prototype.updateWorldTransform = function() {
      this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
    };
    Bone2.prototype.updateWorldTransformWith = function(x, y2, rotation, scaleX, scaleY, shearX, shearY) {
      this.ax = x;
      this.ay = y2;
      this.arotation = rotation;
      this.ascaleX = scaleX;
      this.ascaleY = scaleY;
      this.ashearX = shearX;
      this.ashearY = shearY;
      this.appliedValid = true;
      var parent = this.parent;
      var m2 = this.matrix;
      var sx = this.skeleton.scaleX;
      var sy = -this.skeleton.scaleY;
      if (parent == null) {
        var skeleton = this.skeleton;
        var rotationY = rotation + 90 + shearY;
        m2.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;
        m2.c = MathUtils.cosDeg(rotationY) * scaleY * sx;
        m2.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;
        m2.d = MathUtils.sinDeg(rotationY) * scaleY * sy;
        m2.tx = x * sx + skeleton.x;
        m2.ty = y2 * sy + skeleton.y;
        return;
      }
      var pa2 = parent.matrix.a, pb2 = parent.matrix.c, pc2 = parent.matrix.b, pd2 = parent.matrix.d;
      m2.tx = pa2 * x + pb2 * y2 + parent.matrix.tx;
      m2.ty = pc2 * x + pd2 * y2 + parent.matrix.ty;
      switch (this.data.transformMode) {
        case TransformMode.Normal: {
          var rotationY = rotation + 90 + shearY;
          var la2 = MathUtils.cosDeg(rotation + shearX) * scaleX;
          var lb2 = MathUtils.cosDeg(rotationY) * scaleY;
          var lc2 = MathUtils.sinDeg(rotation + shearX) * scaleX;
          var ld2 = MathUtils.sinDeg(rotationY) * scaleY;
          m2.a = pa2 * la2 + pb2 * lc2;
          m2.c = pa2 * lb2 + pb2 * ld2;
          m2.b = pc2 * la2 + pd2 * lc2;
          m2.d = pc2 * lb2 + pd2 * ld2;
          return;
        }
        case TransformMode.OnlyTranslation: {
          var rotationY = rotation + 90 + shearY;
          m2.a = MathUtils.cosDeg(rotation + shearX) * scaleX;
          m2.c = MathUtils.cosDeg(rotationY) * scaleY;
          m2.b = MathUtils.sinDeg(rotation + shearX) * scaleX;
          m2.d = MathUtils.sinDeg(rotationY) * scaleY;
          break;
        }
        case TransformMode.NoRotationOrReflection: {
          var s2 = pa2 * pa2 + pc2 * pc2;
          var prx = 0;
          if (s2 > 1e-4) {
            s2 = Math.abs(pa2 * pd2 - pb2 * pc2) / s2;
            pb2 = pc2 * s2;
            pd2 = pa2 * s2;
            prx = Math.atan2(pc2, pa2) * MathUtils.radDeg;
          } else {
            pa2 = 0;
            pc2 = 0;
            prx = 90 - Math.atan2(pd2, pb2) * MathUtils.radDeg;
          }
          var rx = rotation + shearX - prx;
          var ry = rotation + shearY - prx + 90;
          var la2 = MathUtils.cosDeg(rx) * scaleX;
          var lb2 = MathUtils.cosDeg(ry) * scaleY;
          var lc2 = MathUtils.sinDeg(rx) * scaleX;
          var ld2 = MathUtils.sinDeg(ry) * scaleY;
          m2.a = pa2 * la2 - pb2 * lc2;
          m2.c = pa2 * lb2 - pb2 * ld2;
          m2.b = pc2 * la2 + pd2 * lc2;
          m2.d = pc2 * lb2 + pd2 * ld2;
          break;
        }
        case TransformMode.NoScale:
        case TransformMode.NoScaleOrReflection: {
          var cos = MathUtils.cosDeg(rotation);
          var sin = MathUtils.sinDeg(rotation);
          var za2 = (pa2 * cos + pb2 * sin) / sx;
          var zc2 = (pc2 * cos + pd2 * sin) / sy;
          var s2 = Math.sqrt(za2 * za2 + zc2 * zc2);
          if (s2 > 1e-5)
            s2 = 1 / s2;
          za2 *= s2;
          zc2 *= s2;
          s2 = Math.sqrt(za2 * za2 + zc2 * zc2);
          if (this.data.transformMode == TransformMode.NoScale && pa2 * pd2 - pb2 * pc2 < 0 != (this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0))
            s2 = -s2;
          var r2 = Math.PI / 2 + Math.atan2(zc2, za2);
          var zb2 = Math.cos(r2) * s2;
          var zd2 = Math.sin(r2) * s2;
          var la2 = MathUtils.cosDeg(shearX) * scaleX;
          var lb2 = MathUtils.cosDeg(90 + shearY) * scaleY;
          var lc2 = MathUtils.sinDeg(shearX) * scaleX;
          var ld2 = MathUtils.sinDeg(90 + shearY) * scaleY;
          m2.a = za2 * la2 + zb2 * lc2;
          m2.c = za2 * lb2 + zb2 * ld2;
          m2.b = zc2 * la2 + zd2 * lc2;
          m2.d = zc2 * lb2 + zd2 * ld2;
          break;
        }
      }
      m2.a *= sx;
      m2.c *= sx;
      m2.b *= sy;
      m2.d *= sy;
    };
    Bone2.prototype.setToSetupPose = function() {
      var data2 = this.data;
      this.x = data2.x;
      this.y = data2.y;
      this.rotation = data2.rotation;
      this.scaleX = data2.scaleX;
      this.scaleY = data2.scaleY;
      this.shearX = data2.shearX;
      this.shearY = data2.shearY;
    };
    Bone2.prototype.getWorldRotationX = function() {
      return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;
    };
    Bone2.prototype.getWorldRotationY = function() {
      return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;
    };
    Bone2.prototype.getWorldScaleX = function() {
      var m2 = this.matrix;
      return Math.sqrt(m2.a * m2.a + m2.c * m2.c);
    };
    Bone2.prototype.getWorldScaleY = function() {
      var m2 = this.matrix;
      return Math.sqrt(m2.b * m2.b + m2.d * m2.d);
    };
    Bone2.prototype.updateAppliedTransform = function() {
      this.appliedValid = true;
      var parent = this.parent;
      var m2 = this.matrix;
      if (parent == null) {
        this.ax = m2.tx;
        this.ay = m2.ty;
        this.arotation = Math.atan2(m2.b, m2.a) * MathUtils.radDeg;
        this.ascaleX = Math.sqrt(m2.a * m2.a + m2.b * m2.b);
        this.ascaleY = Math.sqrt(m2.c * m2.c + m2.d * m2.d);
        this.ashearX = 0;
        this.ashearY = Math.atan2(m2.a * m2.c + m2.b * m2.d, m2.a * m2.d - m2.b * m2.c) * MathUtils.radDeg;
        return;
      }
      var pm = parent.matrix;
      var pid = 1 / (pm.a * pm.d - pm.b * pm.c);
      var dx = m2.tx - pm.tx, dy = m2.ty - pm.ty;
      this.ax = dx * pm.d * pid - dy * pm.c * pid;
      this.ay = dy * pm.a * pid - dx * pm.b * pid;
      var ia2 = pid * pm.d;
      var id2 = pid * pm.a;
      var ib2 = pid * pm.c;
      var ic2 = pid * pm.b;
      var ra2 = ia2 * m2.a - ib2 * m2.b;
      var rb2 = ia2 * m2.c - ib2 * m2.d;
      var rc2 = id2 * m2.b - ic2 * m2.a;
      var rd2 = id2 * m2.d - ic2 * m2.c;
      this.ashearX = 0;
      this.ascaleX = Math.sqrt(ra2 * ra2 + rc2 * rc2);
      if (this.ascaleX > 1e-4) {
        var det = ra2 * rd2 - rb2 * rc2;
        this.ascaleY = det / this.ascaleX;
        this.ashearY = Math.atan2(ra2 * rb2 + rc2 * rd2, det) * MathUtils.radDeg;
        this.arotation = Math.atan2(rc2, ra2) * MathUtils.radDeg;
      } else {
        this.ascaleX = 0;
        this.ascaleY = Math.sqrt(rb2 * rb2 + rd2 * rd2);
        this.ashearY = 0;
        this.arotation = 90 - Math.atan2(rd2, rb2) * MathUtils.radDeg;
      }
    };
    Bone2.prototype.worldToLocal = function(world) {
      var m2 = this.matrix;
      var a2 = m2.a, b2 = m2.c, c2 = m2.b, d2 = m2.d;
      var invDet = 1 / (a2 * d2 - b2 * c2);
      var x = world.x - m2.tx, y2 = world.y - m2.ty;
      world.x = x * d2 * invDet - y2 * b2 * invDet;
      world.y = y2 * a2 * invDet - x * c2 * invDet;
      return world;
    };
    Bone2.prototype.localToWorld = function(local) {
      var m2 = this.matrix;
      var x = local.x, y2 = local.y;
      local.x = x * m2.a + y2 * m2.c + m2.tx;
      local.y = x * m2.b + y2 * m2.d + m2.ty;
      return local;
    };
    Bone2.prototype.worldToLocalRotation = function(worldRotation) {
      var sin = MathUtils.sinDeg(worldRotation), cos = MathUtils.cosDeg(worldRotation);
      var mat = this.matrix;
      return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;
    };
    Bone2.prototype.localToWorldRotation = function(localRotation) {
      var sin = MathUtils.sinDeg(localRotation), cos = MathUtils.cosDeg(localRotation);
      var mat = this.matrix;
      return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;
    };
    Bone2.prototype.rotateWorld = function(degrees) {
      var mat = this.matrix;
      var a2 = mat.a, b2 = mat.c, c2 = mat.b, d2 = mat.d;
      var cos = MathUtils.cosDeg(degrees), sin = MathUtils.sinDeg(degrees);
      mat.a = cos * a2 - sin * c2;
      mat.c = cos * b2 - sin * d2;
      mat.b = sin * a2 + cos * c2;
      mat.d = sin * b2 + cos * d2;
      this.appliedValid = false;
    };
    return Bone2;
  }()
);
var BoneData$1 = (
  /** @class */
  function() {
    function BoneData2(index2, name, parent) {
      this.x = 0;
      this.y = 0;
      this.rotation = 0;
      this.scaleX = 1;
      this.scaleY = 1;
      this.shearX = 0;
      this.shearY = 0;
      this.transformMode = TransformMode.Normal;
      if (index2 < 0)
        throw new Error("index must be >= 0.");
      if (name == null)
        throw new Error("name cannot be null.");
      this.index = index2;
      this.name = name;
      this.parent = parent;
    }
    return BoneData2;
  }()
);
var Event$2 = (
  /** @class */
  function() {
    function Event2(time, data2) {
      if (data2 == null)
        throw new Error("data cannot be null.");
      this.time = time;
      this.data = data2;
    }
    return Event2;
  }()
);
var EventData$1 = (
  /** @class */
  function() {
    function EventData2(name) {
      this.name = name;
    }
    return EventData2;
  }()
);
var IkConstraint$1 = (
  /** @class */
  function() {
    function IkConstraint2(data2, skeleton) {
      this.bendDirection = 0;
      this.compress = false;
      this.stretch = false;
      this.mix = 1;
      if (data2 == null)
        throw new Error("data cannot be null.");
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      this.data = data2;
      this.mix = data2.mix;
      this.bendDirection = data2.bendDirection;
      this.compress = data2.compress;
      this.stretch = data2.stretch;
      this.bones = new Array();
      for (var i2 = 0; i2 < data2.bones.length; i2++)
        this.bones.push(skeleton.findBone(data2.bones[i2].name));
      this.target = skeleton.findBone(data2.target.name);
    }
    IkConstraint2.prototype.getOrder = function() {
      return this.data.order;
    };
    IkConstraint2.prototype.apply = function() {
      this.update();
    };
    IkConstraint2.prototype.update = function() {
      var target = this.target;
      var bones = this.bones;
      switch (bones.length) {
        case 1:
          this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
          break;
        case 2:
          this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.mix);
          break;
      }
    };
    IkConstraint2.prototype.apply1 = function(bone, targetX, targetY, compress, stretch, uniform, alpha2) {
      if (!bone.appliedValid)
        bone.updateAppliedTransform();
      var p = bone.parent.matrix;
      var id2 = 1 / (p.a * p.d - p.b * p.c);
      var x = targetX - p.tx, y2 = targetY - p.ty;
      var tx = (x * p.d - y2 * p.c) * id2 - bone.ax, ty = (y2 * p.a - x * p.b) * id2 - bone.ay;
      var rotationIK = Math.atan2(ty, tx) * MathUtils.radDeg - bone.ashearX - bone.arotation;
      if (bone.ascaleX < 0)
        rotationIK += 180;
      if (rotationIK > 180)
        rotationIK -= 360;
      else if (rotationIK < -180)
        rotationIK += 360;
      var sx = bone.ascaleX, sy = bone.ascaleY;
      if (compress || stretch) {
        var b2 = bone.data.length * sx, dd2 = Math.sqrt(tx * tx + ty * ty);
        if (compress && dd2 < b2 || stretch && dd2 > b2 && b2 > 1e-4) {
          var s2 = (dd2 / b2 - 1) * alpha2 + 1;
          sx *= s2;
          if (uniform)
            sy *= s2;
        }
      }
      bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha2, sx, sy, bone.ashearX, bone.ashearY);
    };
    IkConstraint2.prototype.apply2 = function(parent, child, targetX, targetY, bendDir, stretch, alpha2) {
      if (alpha2 == 0) {
        child.updateWorldTransform();
        return;
      }
      if (!parent.appliedValid)
        parent.updateAppliedTransform();
      if (!child.appliedValid)
        child.updateAppliedTransform();
      var px = parent.ax, py = parent.ay, psx = parent.ascaleX, sx = psx, psy = parent.ascaleY, csx = child.ascaleX;
      var pmat = parent.matrix;
      var os1 = 0, os2 = 0, s2 = 0;
      if (psx < 0) {
        psx = -psx;
        os1 = 180;
        s2 = -1;
      } else {
        os1 = 0;
        s2 = 1;
      }
      if (psy < 0) {
        psy = -psy;
        s2 = -s2;
      }
      if (csx < 0) {
        csx = -csx;
        os2 = 180;
      } else
        os2 = 0;
      var cx = child.ax, cy = 0, cwx = 0, cwy = 0, a2 = pmat.a, b2 = pmat.c, c2 = pmat.b, d2 = pmat.d;
      var u2 = Math.abs(psx - psy) <= 1e-4;
      if (!u2) {
        cy = 0;
        cwx = a2 * cx + pmat.tx;
        cwy = c2 * cx + pmat.ty;
      } else {
        cy = child.ay;
        cwx = a2 * cx + b2 * cy + pmat.tx;
        cwy = c2 * cx + d2 * cy + pmat.ty;
      }
      var pp = parent.parent.matrix;
      a2 = pp.a;
      b2 = pp.c;
      c2 = pp.b;
      d2 = pp.d;
      var id2 = 1 / (a2 * d2 - b2 * c2), x = targetX - pp.tx, y2 = targetY - pp.ty;
      var tx = (x * d2 - y2 * b2) * id2 - px, ty = (y2 * a2 - x * c2) * id2 - py, dd2 = tx * tx + ty * ty;
      x = cwx - pp.tx;
      y2 = cwy - pp.ty;
      var dx = (x * d2 - y2 * b2) * id2 - px, dy = (y2 * a2 - x * c2) * id2 - py;
      var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1 = 0, a22 = 0;
      outer:
        if (u2) {
          l2 *= psx;
          var cos = (dd2 - l1 * l1 - l2 * l2) / (2 * l1 * l2);
          if (cos < -1)
            cos = -1;
          else if (cos > 1) {
            cos = 1;
            if (stretch && l1 + l2 > 1e-4)
              sx *= (Math.sqrt(dd2) / (l1 + l2) - 1) * alpha2 + 1;
          }
          a22 = Math.acos(cos) * bendDir;
          a2 = l1 + l2 * cos;
          b2 = l2 * Math.sin(a22);
          a1 = Math.atan2(ty * a2 - tx * b2, tx * a2 + ty * b2);
        } else {
          a2 = psx * l2;
          b2 = psy * l2;
          var aa2 = a2 * a2, bb2 = b2 * b2, ta2 = Math.atan2(ty, tx);
          c2 = bb2 * l1 * l1 + aa2 * dd2 - aa2 * bb2;
          var c1 = -2 * bb2 * l1, c22 = bb2 - aa2;
          d2 = c1 * c1 - 4 * c22 * c2;
          if (d2 >= 0) {
            var q2 = Math.sqrt(d2);
            if (c1 < 0)
              q2 = -q2;
            q2 = -(c1 + q2) / 2;
            var r0 = q2 / c22, r1 = c2 / q2;
            var r2 = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
            if (r2 * r2 <= dd2) {
              y2 = Math.sqrt(dd2 - r2 * r2) * bendDir;
              a1 = ta2 - Math.atan2(y2, r2);
              a22 = Math.atan2(y2 / psy, (r2 - l1) / psx);
              break outer;
            }
          }
          var minAngle = MathUtils.PI, minX = l1 - a2, minDist = minX * minX, minY = 0;
          var maxAngle = 0, maxX = l1 + a2, maxDist = maxX * maxX, maxY = 0;
          c2 = -a2 * l1 / (aa2 - bb2);
          if (c2 >= -1 && c2 <= 1) {
            c2 = Math.acos(c2);
            x = a2 * Math.cos(c2) + l1;
            y2 = b2 * Math.sin(c2);
            d2 = x * x + y2 * y2;
            if (d2 < minDist) {
              minAngle = c2;
              minDist = d2;
              minX = x;
              minY = y2;
            }
            if (d2 > maxDist) {
              maxAngle = c2;
              maxDist = d2;
              maxX = x;
              maxY = y2;
            }
          }
          if (dd2 <= (minDist + maxDist) / 2) {
            a1 = ta2 - Math.atan2(minY * bendDir, minX);
            a22 = minAngle * bendDir;
          } else {
            a1 = ta2 - Math.atan2(maxY * bendDir, maxX);
            a22 = maxAngle * bendDir;
          }
        }
      var os = Math.atan2(cy, cx) * s2;
      var rotation = parent.arotation;
      a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;
      if (a1 > 180)
        a1 -= 360;
      else if (a1 < -180)
        a1 += 360;
      parent.updateWorldTransformWith(px, py, rotation + a1 * alpha2, sx, parent.ascaleY, 0, 0);
      rotation = child.arotation;
      a22 = ((a22 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
      if (a22 > 180)
        a22 -= 360;
      else if (a22 < -180)
        a22 += 360;
      child.updateWorldTransformWith(cx, cy, rotation + a22 * alpha2, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
    };
    return IkConstraint2;
  }()
);
var IkConstraintData$1 = (
  /** @class */
  function() {
    function IkConstraintData2(name) {
      this.order = 0;
      this.bones = new Array();
      this.bendDirection = 1;
      this.compress = false;
      this.stretch = false;
      this.uniform = false;
      this.mix = 1;
      this.name = name;
    }
    return IkConstraintData2;
  }()
);
var PathConstraintData$1 = (
  /** @class */
  function() {
    function PathConstraintData2(name) {
      this.order = 0;
      this.bones = new Array();
      this.name = name;
    }
    return PathConstraintData2;
  }()
);
var SpacingMode$1;
(function(SpacingMode2) {
  SpacingMode2[SpacingMode2["Length"] = 0] = "Length";
  SpacingMode2[SpacingMode2["Fixed"] = 1] = "Fixed";
  SpacingMode2[SpacingMode2["Percent"] = 2] = "Percent";
})(SpacingMode$1 || (SpacingMode$1 = {}));
var PathConstraint$1 = (
  /** @class */
  function() {
    function PathConstraint2(data2, skeleton) {
      this.position = 0;
      this.spacing = 0;
      this.rotateMix = 0;
      this.translateMix = 0;
      this.spaces = new Array();
      this.positions = new Array();
      this.world = new Array();
      this.curves = new Array();
      this.lengths = new Array();
      this.segments = new Array();
      if (data2 == null)
        throw new Error("data cannot be null.");
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      this.data = data2;
      this.bones = new Array();
      for (var i2 = 0, n2 = data2.bones.length; i2 < n2; i2++)
        this.bones.push(skeleton.findBone(data2.bones[i2].name));
      this.target = skeleton.findSlot(data2.target.name);
      this.position = data2.position;
      this.spacing = data2.spacing;
      this.rotateMix = data2.rotateMix;
      this.translateMix = data2.translateMix;
    }
    PathConstraint2.prototype.apply = function() {
      this.update();
    };
    PathConstraint2.prototype.update = function() {
      var attachment = this.target.getAttachment();
      if (!(attachment instanceof PathAttachment$1))
        return;
      var rotateMix = this.rotateMix, translateMix = this.translateMix;
      var translate = translateMix > 0, rotate = rotateMix > 0;
      if (!translate && !rotate)
        return;
      var data2 = this.data;
      var spacingMode = data2.spacingMode;
      var lengthSpacing = spacingMode == SpacingMode$1.Length;
      var rotateMode = data2.rotateMode;
      var tangents = rotateMode == RotateMode.Tangent, scale = rotateMode == RotateMode.ChainScale;
      var boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;
      var bones = this.bones;
      var spaces = Utils.setArraySize(this.spaces, spacesCount), lengths = null;
      var spacing = this.spacing;
      if (scale || lengthSpacing) {
        if (scale)
          lengths = Utils.setArraySize(this.lengths, boneCount);
        for (var i2 = 0, n2 = spacesCount - 1; i2 < n2; ) {
          var bone = bones[i2];
          var setupLength = bone.data.length;
          if (setupLength < PathConstraint2.epsilon) {
            if (scale)
              lengths[i2] = 0;
            spaces[++i2] = 0;
          } else {
            var x = setupLength * bone.matrix.a, y2 = setupLength * bone.matrix.b;
            var length_1 = Math.sqrt(x * x + y2 * y2);
            if (scale)
              lengths[i2] = length_1;
            spaces[++i2] = (lengthSpacing ? setupLength + spacing : spacing) * length_1 / setupLength;
          }
        }
      } else {
        for (var i2 = 1; i2 < spacesCount; i2++)
          spaces[i2] = spacing;
      }
      var positions = this.computeWorldPositions(attachment, spacesCount, tangents, data2.positionMode == PositionMode.Percent, spacingMode == SpacingMode$1.Percent);
      var boneX = positions[0], boneY = positions[1], offsetRotation = data2.offsetRotation;
      var tip = false;
      if (offsetRotation == 0)
        tip = rotateMode == RotateMode.Chain;
      else {
        tip = false;
        var p = this.target.bone.matrix;
        offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;
      }
      for (var i2 = 0, p = 3; i2 < boneCount; i2++, p += 3) {
        var bone = bones[i2];
        var mat = bone.matrix;
        mat.tx += (boneX - mat.tx) * translateMix;
        mat.ty += (boneY - mat.ty) * translateMix;
        var x = positions[p], y2 = positions[p + 1], dx = x - boneX, dy = y2 - boneY;
        if (scale) {
          var length_2 = lengths[i2];
          if (length_2 != 0) {
            var s2 = (Math.sqrt(dx * dx + dy * dy) / length_2 - 1) * rotateMix + 1;
            mat.a *= s2;
            mat.b *= s2;
          }
        }
        boneX = x;
        boneY = y2;
        if (rotate) {
          var a2 = mat.a, b2 = mat.c, c2 = mat.b, d2 = mat.d, r2 = 0, cos = 0, sin = 0;
          if (tangents)
            r2 = positions[p - 1];
          else if (spaces[i2 + 1] == 0)
            r2 = positions[p + 2];
          else
            r2 = Math.atan2(dy, dx);
          r2 -= Math.atan2(c2, a2);
          if (tip) {
            cos = Math.cos(r2);
            sin = Math.sin(r2);
            var length_3 = bone.data.length;
            boneX += (length_3 * (cos * a2 - sin * c2) - dx) * rotateMix;
            boneY += (length_3 * (sin * a2 + cos * c2) - dy) * rotateMix;
          } else {
            r2 += offsetRotation;
          }
          if (r2 > MathUtils.PI)
            r2 -= MathUtils.PI2;
          else if (r2 < -MathUtils.PI)
            r2 += MathUtils.PI2;
          r2 *= rotateMix;
          cos = Math.cos(r2);
          sin = Math.sin(r2);
          mat.a = cos * a2 - sin * c2;
          mat.c = cos * b2 - sin * d2;
          mat.b = sin * a2 + cos * c2;
          mat.d = sin * b2 + cos * d2;
        }
        bone.appliedValid = false;
      }
    };
    PathConstraint2.prototype.computeWorldPositions = function(path, spacesCount, tangents, percentPosition, percentSpacing) {
      var target = this.target;
      var position2 = this.position;
      var spaces = this.spaces, out = Utils.setArraySize(this.positions, spacesCount * 3 + 2), world = null;
      var closed2 = path.closed;
      var verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint2.NONE;
      if (!path.constantSpeed) {
        var lengths = path.lengths;
        curveCount -= closed2 ? 1 : 2;
        var pathLength_1 = lengths[curveCount];
        if (percentPosition)
          position2 *= pathLength_1;
        if (percentSpacing) {
          for (var i2 = 0; i2 < spacesCount; i2++)
            spaces[i2] *= pathLength_1;
        }
        world = Utils.setArraySize(this.world, 8);
        for (var i2 = 0, o2 = 0, curve = 0; i2 < spacesCount; i2++, o2 += 3) {
          var space = spaces[i2];
          position2 += space;
          var p = position2;
          if (closed2) {
            p %= pathLength_1;
            if (p < 0)
              p += pathLength_1;
            curve = 0;
          } else if (p < 0) {
            if (prevCurve != PathConstraint2.BEFORE) {
              prevCurve = PathConstraint2.BEFORE;
              path.computeWorldVertices(target, 2, 4, world, 0, 2);
            }
            this.addBeforePosition(p, world, 0, out, o2);
            continue;
          } else if (p > pathLength_1) {
            if (prevCurve != PathConstraint2.AFTER) {
              prevCurve = PathConstraint2.AFTER;
              path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);
            }
            this.addAfterPosition(p - pathLength_1, world, 0, out, o2);
            continue;
          }
          for (; ; curve++) {
            var length_4 = lengths[curve];
            if (p > length_4)
              continue;
            if (curve == 0)
              p /= length_4;
            else {
              var prev2 = lengths[curve - 1];
              p = (p - prev2) / (length_4 - prev2);
            }
            break;
          }
          if (curve != prevCurve) {
            prevCurve = curve;
            if (closed2 && curve == curveCount) {
              path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
              path.computeWorldVertices(target, 0, 4, world, 4, 2);
            } else
              path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);
          }
          this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o2, tangents || i2 > 0 && space == 0);
        }
        return out;
      }
      if (closed2) {
        verticesLength += 2;
        world = Utils.setArraySize(this.world, verticesLength);
        path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
        path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
        world[verticesLength - 2] = world[0];
        world[verticesLength - 1] = world[1];
      } else {
        curveCount--;
        verticesLength -= 4;
        world = Utils.setArraySize(this.world, verticesLength);
        path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);
      }
      var curves = Utils.setArraySize(this.curves, curveCount);
      var pathLength = 0;
      var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;
      var tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;
      for (var i2 = 0, w2 = 2; i2 < curveCount; i2++, w2 += 6) {
        cx1 = world[w2];
        cy1 = world[w2 + 1];
        cx2 = world[w2 + 2];
        cy2 = world[w2 + 3];
        x2 = world[w2 + 4];
        y2 = world[w2 + 5];
        tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
        tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
        ddfx = tmpx * 2 + dddfx;
        ddfy = tmpy * 2 + dddfy;
        dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
        dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        dfx += ddfx;
        dfy += ddfy;
        ddfx += dddfx;
        ddfy += dddfy;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        dfx += ddfx;
        dfy += ddfy;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        dfx += ddfx + dddfx;
        dfy += ddfy + dddfy;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        curves[i2] = pathLength;
        x1 = x2;
        y1 = y2;
      }
      if (percentPosition)
        position2 *= pathLength;
      if (percentSpacing) {
        for (var i2 = 0; i2 < spacesCount; i2++)
          spaces[i2] *= pathLength;
      }
      var segments = this.segments;
      var curveLength = 0;
      for (var i2 = 0, o2 = 0, curve = 0, segment = 0; i2 < spacesCount; i2++, o2 += 3) {
        var space = spaces[i2];
        position2 += space;
        var p = position2;
        if (closed2) {
          p %= pathLength;
          if (p < 0)
            p += pathLength;
          curve = 0;
        } else if (p < 0) {
          this.addBeforePosition(p, world, 0, out, o2);
          continue;
        } else if (p > pathLength) {
          this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o2);
          continue;
        }
        for (; ; curve++) {
          var length_5 = curves[curve];
          if (p > length_5)
            continue;
          if (curve == 0)
            p /= length_5;
          else {
            var prev2 = curves[curve - 1];
            p = (p - prev2) / (length_5 - prev2);
          }
          break;
        }
        if (curve != prevCurve) {
          prevCurve = curve;
          var ii2 = curve * 6;
          x1 = world[ii2];
          y1 = world[ii2 + 1];
          cx1 = world[ii2 + 2];
          cy1 = world[ii2 + 3];
          cx2 = world[ii2 + 4];
          cy2 = world[ii2 + 5];
          x2 = world[ii2 + 6];
          y2 = world[ii2 + 7];
          tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
          tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
          dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;
          dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;
          ddfx = tmpx * 2 + dddfx;
          ddfy = tmpy * 2 + dddfy;
          dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
          dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
          curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
          segments[0] = curveLength;
          for (ii2 = 1; ii2 < 8; ii2++) {
            dfx += ddfx;
            dfy += ddfy;
            ddfx += dddfx;
            ddfy += dddfy;
            curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
            segments[ii2] = curveLength;
          }
          dfx += ddfx;
          dfy += ddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[8] = curveLength;
          dfx += ddfx + dddfx;
          dfy += ddfy + dddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[9] = curveLength;
          segment = 0;
        }
        p *= curveLength;
        for (; ; segment++) {
          var length_6 = segments[segment];
          if (p > length_6)
            continue;
          if (segment == 0)
            p /= length_6;
          else {
            var prev2 = segments[segment - 1];
            p = segment + (p - prev2) / (length_6 - prev2);
          }
          break;
        }
        this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o2, tangents || i2 > 0 && space == 0);
      }
      return out;
    };
    PathConstraint2.prototype.addBeforePosition = function(p, temp2, i2, out, o2) {
      var x1 = temp2[i2], y1 = temp2[i2 + 1], dx = temp2[i2 + 2] - x1, dy = temp2[i2 + 3] - y1, r2 = Math.atan2(dy, dx);
      out[o2] = x1 + p * Math.cos(r2);
      out[o2 + 1] = y1 + p * Math.sin(r2);
      out[o2 + 2] = r2;
    };
    PathConstraint2.prototype.addAfterPosition = function(p, temp2, i2, out, o2) {
      var x1 = temp2[i2 + 2], y1 = temp2[i2 + 3], dx = x1 - temp2[i2], dy = y1 - temp2[i2 + 1], r2 = Math.atan2(dy, dx);
      out[o2] = x1 + p * Math.cos(r2);
      out[o2 + 1] = y1 + p * Math.sin(r2);
      out[o2 + 2] = r2;
    };
    PathConstraint2.prototype.addCurvePosition = function(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o2, tangents) {
      if (p == 0 || isNaN(p))
        p = 1e-4;
      var tt = p * p, ttt = tt * p, u2 = 1 - p, uu = u2 * u2, uuu = uu * u2;
      var ut = u2 * p, ut3 = ut * 3, uut3 = u2 * ut3, utt3 = ut3 * p;
      var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y3 = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
      out[o2] = x;
      out[o2 + 1] = y3;
      if (tangents)
        out[o2 + 2] = Math.atan2(y3 - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
    };
    PathConstraint2.prototype.getOrder = function() {
      return this.data.order;
    };
    PathConstraint2.NONE = -1;
    PathConstraint2.BEFORE = -2;
    PathConstraint2.AFTER = -3;
    PathConstraint2.epsilon = 1e-5;
    return PathConstraint2;
  }()
);
var TransformConstraint$1 = (
  /** @class */
  function() {
    function TransformConstraint2(data2, skeleton) {
      this.rotateMix = 0;
      this.translateMix = 0;
      this.scaleMix = 0;
      this.shearMix = 0;
      this.temp = new Vector2();
      if (data2 == null)
        throw new Error("data cannot be null.");
      if (skeleton == null)
        throw new Error("skeleton cannot be null.");
      this.data = data2;
      this.rotateMix = data2.rotateMix;
      this.translateMix = data2.translateMix;
      this.scaleMix = data2.scaleMix;
      this.shearMix = data2.shearMix;
      this.bones = new Array();
      for (var i2 = 0; i2 < data2.bones.length; i2++)
        this.bones.push(skeleton.findBone(data2.bones[i2].name));
      this.target = skeleton.findBone(data2.target.name);
    }
    TransformConstraint2.prototype.apply = function() {
      this.update();
    };
    TransformConstraint2.prototype.update = function() {
      if (this.data.local) {
        if (this.data.relative)
          this.applyRelativeLocal();
        else
          this.applyAbsoluteLocal();
      } else {
        if (this.data.relative)
          this.applyRelativeWorld();
        else
          this.applyAbsoluteWorld();
      }
    };
    TransformConstraint2.prototype.applyAbsoluteWorld = function() {
      var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
      var target = this.target;
      var targetMat = target.matrix;
      var ta2 = targetMat.a, tb2 = targetMat.c, tc2 = targetMat.b, td2 = targetMat.d;
      var degRadReflect = ta2 * td2 - tb2 * tc2 > 0 ? MathUtils.degRad : -MathUtils.degRad;
      var offsetRotation = this.data.offsetRotation * degRadReflect;
      var offsetShearY = this.data.offsetShearY * degRadReflect;
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        var modified = false;
        var mat = bone.matrix;
        if (rotateMix != 0) {
          var a2 = mat.a, b2 = mat.c, c2 = mat.b, d2 = mat.d;
          var r2 = Math.atan2(tc2, ta2) - Math.atan2(c2, a2) + offsetRotation;
          if (r2 > MathUtils.PI)
            r2 -= MathUtils.PI2;
          else if (r2 < -MathUtils.PI)
            r2 += MathUtils.PI2;
          r2 *= rotateMix;
          var cos = Math.cos(r2), sin = Math.sin(r2);
          mat.a = cos * a2 - sin * c2;
          mat.c = cos * b2 - sin * d2;
          mat.b = sin * a2 + cos * c2;
          mat.d = sin * b2 + cos * d2;
          modified = true;
        }
        if (translateMix != 0) {
          var temp2 = this.temp;
          target.localToWorld(temp2.set(this.data.offsetX, this.data.offsetY));
          mat.tx += (temp2.x - mat.tx) * translateMix;
          mat.ty += (temp2.y - mat.ty) * translateMix;
          modified = true;
        }
        if (scaleMix > 0) {
          var s2 = Math.sqrt(mat.a * mat.a + mat.b * mat.b);
          var ts = Math.sqrt(ta2 * ta2 + tc2 * tc2);
          if (s2 > 1e-5)
            s2 = (s2 + (ts - s2 + this.data.offsetScaleX) * scaleMix) / s2;
          mat.a *= s2;
          mat.b *= s2;
          s2 = Math.sqrt(mat.c * mat.c + mat.d * mat.d);
          ts = Math.sqrt(tb2 * tb2 + td2 * td2);
          if (s2 > 1e-5)
            s2 = (s2 + (ts - s2 + this.data.offsetScaleY) * scaleMix) / s2;
          mat.c *= s2;
          mat.d *= s2;
          modified = true;
        }
        if (shearMix > 0) {
          var b2 = mat.c, d2 = mat.d;
          var by = Math.atan2(d2, b2);
          var r2 = Math.atan2(td2, tb2) - Math.atan2(tc2, ta2) - (by - Math.atan2(mat.b, mat.a));
          if (r2 > MathUtils.PI)
            r2 -= MathUtils.PI2;
          else if (r2 < -MathUtils.PI)
            r2 += MathUtils.PI2;
          r2 = by + (r2 + offsetShearY) * shearMix;
          var s2 = Math.sqrt(b2 * b2 + d2 * d2);
          mat.c = Math.cos(r2) * s2;
          mat.d = Math.sin(r2) * s2;
          modified = true;
        }
        if (modified)
          bone.appliedValid = false;
      }
    };
    TransformConstraint2.prototype.applyRelativeWorld = function() {
      var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
      var target = this.target;
      var targetMat = target.matrix;
      var ta2 = targetMat.a, tb2 = targetMat.c, tc2 = targetMat.b, td2 = targetMat.d;
      var degRadReflect = ta2 * td2 - tb2 * tc2 > 0 ? MathUtils.degRad : -MathUtils.degRad;
      var offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        var modified = false;
        var mat = bone.matrix;
        if (rotateMix != 0) {
          var a2 = mat.a, b2 = mat.c, c2 = mat.b, d2 = mat.d;
          var r2 = Math.atan2(tc2, ta2) + offsetRotation;
          if (r2 > MathUtils.PI)
            r2 -= MathUtils.PI2;
          else if (r2 < -MathUtils.PI)
            r2 += MathUtils.PI2;
          r2 *= rotateMix;
          var cos = Math.cos(r2), sin = Math.sin(r2);
          mat.a = cos * a2 - sin * c2;
          mat.c = cos * b2 - sin * d2;
          mat.b = sin * a2 + cos * c2;
          mat.d = sin * b2 + cos * d2;
          modified = true;
        }
        if (translateMix != 0) {
          var temp2 = this.temp;
          target.localToWorld(temp2.set(this.data.offsetX, this.data.offsetY));
          mat.tx += temp2.x * translateMix;
          mat.ty += temp2.y * translateMix;
          modified = true;
        }
        if (scaleMix > 0) {
          var s2 = (Math.sqrt(ta2 * ta2 + tc2 * tc2) - 1 + this.data.offsetScaleX) * scaleMix + 1;
          mat.a *= s2;
          mat.b *= s2;
          s2 = (Math.sqrt(tb2 * tb2 + td2 * td2) - 1 + this.data.offsetScaleY) * scaleMix + 1;
          mat.c *= s2;
          mat.d *= s2;
          modified = true;
        }
        if (shearMix > 0) {
          var r2 = Math.atan2(td2, tb2) - Math.atan2(tc2, ta2);
          if (r2 > MathUtils.PI)
            r2 -= MathUtils.PI2;
          else if (r2 < -MathUtils.PI)
            r2 += MathUtils.PI2;
          var b2 = mat.c, d2 = mat.d;
          r2 = Math.atan2(d2, b2) + (r2 - MathUtils.PI / 2 + offsetShearY) * shearMix;
          var s2 = Math.sqrt(b2 * b2 + d2 * d2);
          mat.c = Math.cos(r2) * s2;
          mat.d = Math.sin(r2) * s2;
          modified = true;
        }
        if (modified)
          bone.appliedValid = false;
      }
    };
    TransformConstraint2.prototype.applyAbsoluteLocal = function() {
      var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
      var target = this.target;
      if (!target.appliedValid)
        target.updateAppliedTransform();
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        if (!bone.appliedValid)
          bone.updateAppliedTransform();
        var rotation = bone.arotation;
        if (rotateMix != 0) {
          var r2 = target.arotation - rotation + this.data.offsetRotation;
          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
          rotation += r2 * rotateMix;
        }
        var x = bone.ax, y2 = bone.ay;
        if (translateMix != 0) {
          x += (target.ax - x + this.data.offsetX) * translateMix;
          y2 += (target.ay - y2 + this.data.offsetY) * translateMix;
        }
        var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
        if (scaleMix > 0) {
          if (scaleX > 1e-5)
            scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;
          if (scaleY > 1e-5)
            scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;
        }
        var shearY = bone.ashearY;
        if (shearMix > 0) {
          var r2 = target.ashearY - shearY + this.data.offsetShearY;
          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
          bone.shearY += r2 * shearMix;
        }
        bone.updateWorldTransformWith(x, y2, rotation, scaleX, scaleY, bone.ashearX, shearY);
      }
    };
    TransformConstraint2.prototype.applyRelativeLocal = function() {
      var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
      var target = this.target;
      if (!target.appliedValid)
        target.updateAppliedTransform();
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        if (!bone.appliedValid)
          bone.updateAppliedTransform();
        var rotation = bone.arotation;
        if (rotateMix != 0)
          rotation += (target.arotation + this.data.offsetRotation) * rotateMix;
        var x = bone.ax, y2 = bone.ay;
        if (translateMix != 0) {
          x += (target.ax + this.data.offsetX) * translateMix;
          y2 += (target.ay + this.data.offsetY) * translateMix;
        }
        var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
        if (scaleMix > 0) {
          if (scaleX > 1e-5)
            scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;
          if (scaleY > 1e-5)
            scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;
        }
        var shearY = bone.ashearY;
        if (shearMix > 0)
          shearY += (target.ashearY + this.data.offsetShearY) * shearMix;
        bone.updateWorldTransformWith(x, y2, rotation, scaleX, scaleY, bone.ashearX, shearY);
      }
    };
    TransformConstraint2.prototype.getOrder = function() {
      return this.data.order;
    };
    return TransformConstraint2;
  }()
);
var Skeleton$1 = (
  /** @class */
  function() {
    function Skeleton2(data2) {
      this._updateCache = new Array();
      this.updateCacheReset = new Array();
      this.time = 0;
      this.scaleX = 1;
      this.scaleY = 1;
      this.x = 0;
      this.y = 0;
      if (data2 == null)
        throw new Error("data cannot be null.");
      this.data = data2;
      this.bones = new Array();
      for (var i2 = 0; i2 < data2.bones.length; i2++) {
        var boneData = data2.bones[i2];
        var bone = void 0;
        if (boneData.parent == null)
          bone = new Bone$1(boneData, this, null);
        else {
          var parent_1 = this.bones[boneData.parent.index];
          bone = new Bone$1(boneData, this, parent_1);
          parent_1.children.push(bone);
        }
        this.bones.push(bone);
      }
      this.slots = new Array();
      this.drawOrder = new Array();
      for (var i2 = 0; i2 < data2.slots.length; i2++) {
        var slotData = data2.slots[i2];
        var bone = this.bones[slotData.boneData.index];
        var slot = new Slot$1(slotData, bone);
        this.slots.push(slot);
        this.drawOrder.push(slot);
      }
      this.ikConstraints = new Array();
      for (var i2 = 0; i2 < data2.ikConstraints.length; i2++) {
        var ikConstraintData = data2.ikConstraints[i2];
        this.ikConstraints.push(new IkConstraint$1(ikConstraintData, this));
      }
      this.transformConstraints = new Array();
      for (var i2 = 0; i2 < data2.transformConstraints.length; i2++) {
        var transformConstraintData = data2.transformConstraints[i2];
        this.transformConstraints.push(new TransformConstraint$1(transformConstraintData, this));
      }
      this.pathConstraints = new Array();
      for (var i2 = 0; i2 < data2.pathConstraints.length; i2++) {
        var pathConstraintData = data2.pathConstraints[i2];
        this.pathConstraints.push(new PathConstraint$1(pathConstraintData, this));
      }
      this.color = new Color(1, 1, 1, 1);
      this.updateCache();
    }
    Skeleton2.prototype.updateCache = function() {
      var updateCache = this._updateCache;
      updateCache.length = 0;
      this.updateCacheReset.length = 0;
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++)
        bones[i2].sorted = false;
      var ikConstraints = this.ikConstraints;
      var transformConstraints = this.transformConstraints;
      var pathConstraints = this.pathConstraints;
      var ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;
      var constraintCount = ikCount + transformCount + pathCount;
      outer:
        for (var i2 = 0; i2 < constraintCount; i2++) {
          for (var ii2 = 0; ii2 < ikCount; ii2++) {
            var constraint = ikConstraints[ii2];
            if (constraint.data.order == i2) {
              this.sortIkConstraint(constraint);
              continue outer;
            }
          }
          for (var ii2 = 0; ii2 < transformCount; ii2++) {
            var constraint = transformConstraints[ii2];
            if (constraint.data.order == i2) {
              this.sortTransformConstraint(constraint);
              continue outer;
            }
          }
          for (var ii2 = 0; ii2 < pathCount; ii2++) {
            var constraint = pathConstraints[ii2];
            if (constraint.data.order == i2) {
              this.sortPathConstraint(constraint);
              continue outer;
            }
          }
        }
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++)
        this.sortBone(bones[i2]);
    };
    Skeleton2.prototype.sortIkConstraint = function(constraint) {
      var target = constraint.target;
      this.sortBone(target);
      var constrained = constraint.bones;
      var parent = constrained[0];
      this.sortBone(parent);
      if (constrained.length > 1) {
        var child = constrained[constrained.length - 1];
        if (!(this._updateCache.indexOf(child) > -1))
          this.updateCacheReset.push(child);
      }
      this._updateCache.push(constraint);
      this.sortReset(parent.children);
      constrained[constrained.length - 1].sorted = true;
    };
    Skeleton2.prototype.sortPathConstraint = function(constraint) {
      var slot = constraint.target;
      var slotIndex = slot.data.index;
      var slotBone = slot.bone;
      if (this.skin != null)
        this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
      if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)
        this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
      for (var i2 = 0, n2 = this.data.skins.length; i2 < n2; i2++)
        this.sortPathConstraintAttachment(this.data.skins[i2], slotIndex, slotBone);
      var attachment = slot.getAttachment();
      if (attachment instanceof PathAttachment$1)
        this.sortPathConstraintAttachmentWith(attachment, slotBone);
      var constrained = constraint.bones;
      var boneCount = constrained.length;
      for (var i2 = 0; i2 < boneCount; i2++)
        this.sortBone(constrained[i2]);
      this._updateCache.push(constraint);
      for (var i2 = 0; i2 < boneCount; i2++)
        this.sortReset(constrained[i2].children);
      for (var i2 = 0; i2 < boneCount; i2++)
        constrained[i2].sorted = true;
    };
    Skeleton2.prototype.sortTransformConstraint = function(constraint) {
      this.sortBone(constraint.target);
      var constrained = constraint.bones;
      var boneCount = constrained.length;
      if (constraint.data.local) {
        for (var i2 = 0; i2 < boneCount; i2++) {
          var child = constrained[i2];
          this.sortBone(child.parent);
          if (!(this._updateCache.indexOf(child) > -1))
            this.updateCacheReset.push(child);
        }
      } else {
        for (var i2 = 0; i2 < boneCount; i2++) {
          this.sortBone(constrained[i2]);
        }
      }
      this._updateCache.push(constraint);
      for (var ii2 = 0; ii2 < boneCount; ii2++)
        this.sortReset(constrained[ii2].children);
      for (var ii2 = 0; ii2 < boneCount; ii2++)
        constrained[ii2].sorted = true;
    };
    Skeleton2.prototype.sortPathConstraintAttachment = function(skin, slotIndex, slotBone) {
      var attachments = skin.attachments[slotIndex];
      if (!attachments)
        return;
      for (var key in attachments) {
        this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
      }
    };
    Skeleton2.prototype.sortPathConstraintAttachmentWith = function(attachment, slotBone) {
      if (!(attachment instanceof PathAttachment$1))
        return;
      var pathBones = attachment.bones;
      if (pathBones == null)
        this.sortBone(slotBone);
      else {
        var bones = this.bones;
        var i2 = 0;
        while (i2 < pathBones.length) {
          var boneCount = pathBones[i2++];
          for (var n2 = i2 + boneCount; i2 < n2; i2++) {
            var boneIndex = pathBones[i2];
            this.sortBone(bones[boneIndex]);
          }
        }
      }
    };
    Skeleton2.prototype.sortBone = function(bone) {
      if (bone.sorted)
        return;
      var parent = bone.parent;
      if (parent != null)
        this.sortBone(parent);
      bone.sorted = true;
      this._updateCache.push(bone);
    };
    Skeleton2.prototype.sortReset = function(bones) {
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        if (bone.sorted)
          this.sortReset(bone.children);
        bone.sorted = false;
      }
    };
    Skeleton2.prototype.updateWorldTransform = function() {
      var updateCacheReset = this.updateCacheReset;
      for (var i2 = 0, n2 = updateCacheReset.length; i2 < n2; i2++) {
        var bone = updateCacheReset[i2];
        bone.ax = bone.x;
        bone.ay = bone.y;
        bone.arotation = bone.rotation;
        bone.ascaleX = bone.scaleX;
        bone.ascaleY = bone.scaleY;
        bone.ashearX = bone.shearX;
        bone.ashearY = bone.shearY;
        bone.appliedValid = true;
      }
      var updateCache = this._updateCache;
      for (var i2 = 0, n2 = updateCache.length; i2 < n2; i2++)
        updateCache[i2].update();
    };
    Skeleton2.prototype.setToSetupPose = function() {
      this.setBonesToSetupPose();
      this.setSlotsToSetupPose();
    };
    Skeleton2.prototype.setBonesToSetupPose = function() {
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++)
        bones[i2].setToSetupPose();
      var ikConstraints = this.ikConstraints;
      for (var i2 = 0, n2 = ikConstraints.length; i2 < n2; i2++) {
        var constraint = ikConstraints[i2];
        constraint.bendDirection = constraint.data.bendDirection;
        constraint.mix = constraint.data.mix;
      }
      var transformConstraints = this.transformConstraints;
      for (var i2 = 0, n2 = transformConstraints.length; i2 < n2; i2++) {
        var constraint = transformConstraints[i2];
        var data2 = constraint.data;
        constraint.rotateMix = data2.rotateMix;
        constraint.translateMix = data2.translateMix;
        constraint.scaleMix = data2.scaleMix;
        constraint.shearMix = data2.shearMix;
      }
      var pathConstraints = this.pathConstraints;
      for (var i2 = 0, n2 = pathConstraints.length; i2 < n2; i2++) {
        var constraint = pathConstraints[i2];
        var data2 = constraint.data;
        constraint.position = data2.position;
        constraint.spacing = data2.spacing;
        constraint.rotateMix = data2.rotateMix;
        constraint.translateMix = data2.translateMix;
      }
    };
    Skeleton2.prototype.setSlotsToSetupPose = function() {
      var slots = this.slots;
      Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
      for (var i2 = 0, n2 = slots.length; i2 < n2; i2++)
        slots[i2].setToSetupPose();
    };
    Skeleton2.prototype.getRootBone = function() {
      if (this.bones.length == 0)
        return null;
      return this.bones[0];
    };
    Skeleton2.prototype.findBone = function(boneName) {
      if (boneName == null)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        if (bone.data.name == boneName)
          return bone;
      }
      return null;
    };
    Skeleton2.prototype.findBoneIndex = function(boneName) {
      if (boneName == null)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++)
        if (bones[i2].data.name == boneName)
          return i2;
      return -1;
    };
    Skeleton2.prototype.findSlot = function(slotName) {
      if (slotName == null)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i2 = 0, n2 = slots.length; i2 < n2; i2++) {
        var slot = slots[i2];
        if (slot.data.name == slotName)
          return slot;
      }
      return null;
    };
    Skeleton2.prototype.findSlotIndex = function(slotName) {
      if (slotName == null)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i2 = 0, n2 = slots.length; i2 < n2; i2++)
        if (slots[i2].data.name == slotName)
          return i2;
      return -1;
    };
    Skeleton2.prototype.setSkinByName = function(skinName) {
      var skin = this.data.findSkin(skinName);
      if (skin == null)
        throw new Error("Skin not found: " + skinName);
      this.setSkin(skin);
    };
    Skeleton2.prototype.setSkin = function(newSkin) {
      if (newSkin != null) {
        if (this.skin != null)
          newSkin.attachAll(this, this.skin);
        else {
          var slots = this.slots;
          for (var i2 = 0, n2 = slots.length; i2 < n2; i2++) {
            var slot = slots[i2];
            var name_1 = slot.data.attachmentName;
            if (name_1 != null) {
              var attachment = newSkin.getAttachment(i2, name_1);
              if (attachment != null)
                slot.setAttachment(attachment);
            }
          }
        }
      }
      this.skin = newSkin;
    };
    Skeleton2.prototype.getAttachmentByName = function(slotName, attachmentName) {
      return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);
    };
    Skeleton2.prototype.getAttachment = function(slotIndex, attachmentName) {
      if (attachmentName == null)
        throw new Error("attachmentName cannot be null.");
      if (this.skin != null) {
        var attachment = this.skin.getAttachment(slotIndex, attachmentName);
        if (attachment != null)
          return attachment;
      }
      if (this.data.defaultSkin != null)
        return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
      return null;
    };
    Skeleton2.prototype.setAttachment = function(slotName, attachmentName) {
      if (slotName == null)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i2 = 0, n2 = slots.length; i2 < n2; i2++) {
        var slot = slots[i2];
        if (slot.data.name == slotName) {
          var attachment = null;
          if (attachmentName != null) {
            attachment = this.getAttachment(i2, attachmentName);
            if (attachment == null)
              throw new Error("Attachment not found: " + attachmentName + ", for slot: " + slotName);
          }
          slot.setAttachment(attachment);
          return;
        }
      }
      throw new Error("Slot not found: " + slotName);
    };
    Skeleton2.prototype.findIkConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var ikConstraints = this.ikConstraints;
      for (var i2 = 0, n2 = ikConstraints.length; i2 < n2; i2++) {
        var ikConstraint = ikConstraints[i2];
        if (ikConstraint.data.name == constraintName)
          return ikConstraint;
      }
      return null;
    };
    Skeleton2.prototype.findTransformConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var transformConstraints = this.transformConstraints;
      for (var i2 = 0, n2 = transformConstraints.length; i2 < n2; i2++) {
        var constraint = transformConstraints[i2];
        if (constraint.data.name == constraintName)
          return constraint;
      }
      return null;
    };
    Skeleton2.prototype.findPathConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var pathConstraints = this.pathConstraints;
      for (var i2 = 0, n2 = pathConstraints.length; i2 < n2; i2++) {
        var constraint = pathConstraints[i2];
        if (constraint.data.name == constraintName)
          return constraint;
      }
      return null;
    };
    Skeleton2.prototype.getBounds = function(offset, size, temp2) {
      if (offset == null)
        throw new Error("offset cannot be null.");
      if (size == null)
        throw new Error("size cannot be null.");
      var drawOrder = this.drawOrder;
      var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
      for (var i2 = 0, n2 = drawOrder.length; i2 < n2; i2++) {
        var slot = drawOrder[i2];
        var verticesLength = 0;
        var vertices = null;
        var attachment = slot.getAttachment();
        if (attachment instanceof RegionAttachment$1) {
          verticesLength = 8;
          vertices = Utils.setArraySize(temp2, verticesLength, 0);
          attachment.computeWorldVertices(slot.bone, vertices, 0, 2);
        } else if (attachment instanceof MeshAttachment$1) {
          var mesh = attachment;
          verticesLength = mesh.worldVerticesLength;
          vertices = Utils.setArraySize(temp2, verticesLength, 0);
          mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
        }
        if (vertices != null) {
          for (var ii2 = 0, nn2 = vertices.length; ii2 < nn2; ii2 += 2) {
            var x = vertices[ii2], y2 = vertices[ii2 + 1];
            minX = Math.min(minX, x);
            minY = Math.min(minY, y2);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y2);
          }
        }
      }
      offset.set(minX, minY);
      size.set(maxX - minX, maxY - minY);
    };
    Skeleton2.prototype.update = function(delta) {
      this.time += delta;
    };
    Object.defineProperty(Skeleton2.prototype, "flipX", {
      get: function() {
        return this.scaleX == -1;
      },
      set: function(value) {
        if (!Skeleton2.deprecatedWarning1) {
          Skeleton2.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
        }
        this.scaleX = value ? 1 : -1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Skeleton2.prototype, "flipY", {
      get: function() {
        return this.scaleY == -1;
      },
      set: function(value) {
        if (!Skeleton2.deprecatedWarning1) {
          Skeleton2.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
        }
        this.scaleY = value ? 1 : -1;
      },
      enumerable: false,
      configurable: true
    });
    Skeleton2.deprecatedWarning1 = false;
    return Skeleton2;
  }()
);
var SkeletonBounds$1 = (
  /** @class */
  function(_super) {
    __extends$3(SkeletonBounds2, _super);
    function SkeletonBounds2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return SkeletonBounds2;
  }(SkeletonBoundsBase)
);
var SkeletonData$1 = (
  /** @class */
  function() {
    function SkeletonData2() {
      this.bones = new Array();
      this.slots = new Array();
      this.skins = new Array();
      this.events = new Array();
      this.animations = new Array();
      this.ikConstraints = new Array();
      this.transformConstraints = new Array();
      this.pathConstraints = new Array();
      this.fps = 0;
    }
    SkeletonData2.prototype.findBone = function(boneName) {
      if (boneName == null)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        if (bone.name == boneName)
          return bone;
      }
      return null;
    };
    SkeletonData2.prototype.findBoneIndex = function(boneName) {
      if (boneName == null)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++)
        if (bones[i2].name == boneName)
          return i2;
      return -1;
    };
    SkeletonData2.prototype.findSlot = function(slotName) {
      if (slotName == null)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i2 = 0, n2 = slots.length; i2 < n2; i2++) {
        var slot = slots[i2];
        if (slot.name == slotName)
          return slot;
      }
      return null;
    };
    SkeletonData2.prototype.findSlotIndex = function(slotName) {
      if (slotName == null)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i2 = 0, n2 = slots.length; i2 < n2; i2++)
        if (slots[i2].name == slotName)
          return i2;
      return -1;
    };
    SkeletonData2.prototype.findSkin = function(skinName) {
      if (skinName == null)
        throw new Error("skinName cannot be null.");
      var skins = this.skins;
      for (var i2 = 0, n2 = skins.length; i2 < n2; i2++) {
        var skin = skins[i2];
        if (skin.name == skinName)
          return skin;
      }
      return null;
    };
    SkeletonData2.prototype.findEvent = function(eventDataName) {
      if (eventDataName == null)
        throw new Error("eventDataName cannot be null.");
      var events = this.events;
      for (var i2 = 0, n2 = events.length; i2 < n2; i2++) {
        var event_1 = events[i2];
        if (event_1.name == eventDataName)
          return event_1;
      }
      return null;
    };
    SkeletonData2.prototype.findAnimation = function(animationName) {
      if (animationName == null)
        throw new Error("animationName cannot be null.");
      var animations = this.animations;
      for (var i2 = 0, n2 = animations.length; i2 < n2; i2++) {
        var animation2 = animations[i2];
        if (animation2.name == animationName)
          return animation2;
      }
      return null;
    };
    SkeletonData2.prototype.findIkConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var ikConstraints = this.ikConstraints;
      for (var i2 = 0, n2 = ikConstraints.length; i2 < n2; i2++) {
        var constraint = ikConstraints[i2];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    };
    SkeletonData2.prototype.findTransformConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var transformConstraints = this.transformConstraints;
      for (var i2 = 0, n2 = transformConstraints.length; i2 < n2; i2++) {
        var constraint = transformConstraints[i2];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    };
    SkeletonData2.prototype.findPathConstraint = function(constraintName) {
      if (constraintName == null)
        throw new Error("constraintName cannot be null.");
      var pathConstraints = this.pathConstraints;
      for (var i2 = 0, n2 = pathConstraints.length; i2 < n2; i2++) {
        var constraint = pathConstraints[i2];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    };
    SkeletonData2.prototype.findPathConstraintIndex = function(pathConstraintName) {
      if (pathConstraintName == null)
        throw new Error("pathConstraintName cannot be null.");
      var pathConstraints = this.pathConstraints;
      for (var i2 = 0, n2 = pathConstraints.length; i2 < n2; i2++)
        if (pathConstraints[i2].name == pathConstraintName)
          return i2;
      return -1;
    };
    return SkeletonData2;
  }()
);
var SlotData$1 = (
  /** @class */
  function() {
    function SlotData2(index2, name, boneData) {
      this.color = new Color(1, 1, 1, 1);
      if (index2 < 0)
        throw new Error("index must be >= 0.");
      if (name == null)
        throw new Error("name cannot be null.");
      if (boneData == null)
        throw new Error("boneData cannot be null.");
      this.index = index2;
      this.name = name;
      this.boneData = boneData;
    }
    return SlotData2;
  }()
);
var TransformConstraintData$1 = (
  /** @class */
  function() {
    function TransformConstraintData2(name) {
      this.order = 0;
      this.bones = new Array();
      this.rotateMix = 0;
      this.translateMix = 0;
      this.scaleMix = 0;
      this.shearMix = 0;
      this.offsetRotation = 0;
      this.offsetX = 0;
      this.offsetY = 0;
      this.offsetScaleX = 0;
      this.offsetScaleY = 0;
      this.offsetShearY = 0;
      this.relative = false;
      this.local = false;
      if (name == null)
        throw new Error("name cannot be null.");
      this.name = name;
    }
    return TransformConstraintData2;
  }()
);
var Skin$1 = (
  /** @class */
  function() {
    function Skin2(name) {
      this.attachments = new Array();
      if (name == null)
        throw new Error("name cannot be null.");
      this.name = name;
    }
    Skin2.prototype.addAttachment = function(slotIndex, name, attachment) {
      if (attachment == null)
        throw new Error("attachment cannot be null.");
      var attachments = this.attachments;
      if (slotIndex >= attachments.length)
        attachments.length = slotIndex + 1;
      if (!attachments[slotIndex])
        attachments[slotIndex] = {};
      attachments[slotIndex][name] = attachment;
    };
    Skin2.prototype.getAttachment = function(slotIndex, name) {
      var dictionary = this.attachments[slotIndex];
      return dictionary ? dictionary[name] : null;
    };
    Skin2.prototype.attachAll = function(skeleton, oldSkin) {
      var slotIndex = 0;
      for (var i2 = 0; i2 < skeleton.slots.length; i2++) {
        var slot = skeleton.slots[i2];
        var slotAttachment = slot.getAttachment();
        if (slotAttachment && slotIndex < oldSkin.attachments.length) {
          var dictionary = oldSkin.attachments[slotIndex];
          for (var key in dictionary) {
            var skinAttachment = dictionary[key];
            if (slotAttachment == skinAttachment) {
              var attachment = this.getAttachment(slotIndex, key);
              if (attachment != null)
                slot.setAttachment(attachment);
              break;
            }
          }
        }
        slotIndex++;
      }
    };
    return Skin2;
  }()
);
var SkeletonJson$1 = (
  /** @class */
  function() {
    function SkeletonJson2(attachmentLoader) {
      this.scale = 1;
      this.linkedMeshes = new Array();
      this.attachmentLoader = attachmentLoader;
    }
    SkeletonJson2.prototype.readSkeletonData = function(json) {
      var scale = this.scale;
      var skeletonData = new SkeletonData$1();
      var root2 = typeof json === "string" ? JSON.parse(json) : json;
      var skeletonMap = root2.skeleton;
      if (skeletonMap != null) {
        skeletonData.hash = skeletonMap.hash;
        skeletonData.version = skeletonMap.spine;
        skeletonData.width = skeletonMap.width;
        skeletonData.height = skeletonMap.height;
        skeletonData.fps = skeletonMap.fps;
        skeletonData.imagesPath = skeletonMap.images;
      }
      if (root2.bones) {
        for (var i2 = 0; i2 < root2.bones.length; i2++) {
          var boneMap = root2.bones[i2];
          var parent_1 = null;
          var parentName = this.getValue(boneMap, "parent", null);
          if (parentName != null) {
            parent_1 = skeletonData.findBone(parentName);
            if (parent_1 == null)
              throw new Error("Parent bone not found: " + parentName);
          }
          var data2 = new BoneData$1(skeletonData.bones.length, boneMap.name, parent_1);
          data2.length = this.getValue(boneMap, "length", 0) * scale;
          data2.x = this.getValue(boneMap, "x", 0) * scale;
          data2.y = this.getValue(boneMap, "y", 0) * scale;
          data2.rotation = this.getValue(boneMap, "rotation", 0);
          data2.scaleX = this.getValue(boneMap, "scaleX", 1);
          data2.scaleY = this.getValue(boneMap, "scaleY", 1);
          data2.shearX = this.getValue(boneMap, "shearX", 0);
          data2.shearY = this.getValue(boneMap, "shearY", 0);
          data2.transformMode = SkeletonJson2.transformModeFromString(this.getValue(boneMap, "transform", "normal"));
          skeletonData.bones.push(data2);
        }
      }
      if (root2.slots) {
        for (var i2 = 0; i2 < root2.slots.length; i2++) {
          var slotMap = root2.slots[i2];
          var slotName = slotMap.name;
          var boneName = slotMap.bone;
          var boneData = skeletonData.findBone(boneName);
          if (boneData == null)
            throw new Error("Slot bone not found: " + boneName);
          var data2 = new SlotData$1(skeletonData.slots.length, slotName, boneData);
          var color2 = this.getValue(slotMap, "color", null);
          if (color2 != null)
            data2.color.setFromString(color2);
          var dark = this.getValue(slotMap, "dark", null);
          if (dark != null) {
            data2.darkColor = new Color(1, 1, 1, 1);
            data2.darkColor.setFromString(dark);
          }
          data2.attachmentName = this.getValue(slotMap, "attachment", null);
          data2.blendMode = SkeletonJson2.blendModeFromString(this.getValue(slotMap, "blend", "normal"));
          skeletonData.slots.push(data2);
        }
      }
      if (root2.ik) {
        for (var i2 = 0; i2 < root2.ik.length; i2++) {
          var constraintMap = root2.ik[i2];
          var data2 = new IkConstraintData$1(constraintMap.name);
          data2.order = this.getValue(constraintMap, "order", 0);
          for (var j2 = 0; j2 < constraintMap.bones.length; j2++) {
            var boneName = constraintMap.bones[j2];
            var bone = skeletonData.findBone(boneName);
            if (bone == null)
              throw new Error("IK bone not found: " + boneName);
            data2.bones.push(bone);
          }
          var targetName = constraintMap.target;
          data2.target = skeletonData.findBone(targetName);
          if (data2.target == null)
            throw new Error("IK target bone not found: " + targetName);
          data2.bendDirection = this.getValue(constraintMap, "bendPositive", true) ? 1 : -1;
          data2.mix = this.getValue(constraintMap, "mix", 1);
          skeletonData.ikConstraints.push(data2);
        }
      }
      if (root2.transform) {
        for (var i2 = 0; i2 < root2.transform.length; i2++) {
          var constraintMap = root2.transform[i2];
          var data2 = new TransformConstraintData$1(constraintMap.name);
          data2.order = this.getValue(constraintMap, "order", 0);
          for (var j2 = 0; j2 < constraintMap.bones.length; j2++) {
            var boneName = constraintMap.bones[j2];
            var bone = skeletonData.findBone(boneName);
            if (bone == null)
              throw new Error("Transform constraint bone not found: " + boneName);
            data2.bones.push(bone);
          }
          var targetName = constraintMap.target;
          data2.target = skeletonData.findBone(targetName);
          if (data2.target == null)
            throw new Error("Transform constraint target bone not found: " + targetName);
          data2.local = this.getValue(constraintMap, "local", false);
          data2.relative = this.getValue(constraintMap, "relative", false);
          data2.offsetRotation = this.getValue(constraintMap, "rotation", 0);
          data2.offsetX = this.getValue(constraintMap, "x", 0) * scale;
          data2.offsetY = this.getValue(constraintMap, "y", 0) * scale;
          data2.offsetScaleX = this.getValue(constraintMap, "scaleX", 0);
          data2.offsetScaleY = this.getValue(constraintMap, "scaleY", 0);
          data2.offsetShearY = this.getValue(constraintMap, "shearY", 0);
          data2.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
          data2.translateMix = this.getValue(constraintMap, "translateMix", 1);
          data2.scaleMix = this.getValue(constraintMap, "scaleMix", 1);
          data2.shearMix = this.getValue(constraintMap, "shearMix", 1);
          skeletonData.transformConstraints.push(data2);
        }
      }
      if (root2.path) {
        for (var i2 = 0; i2 < root2.path.length; i2++) {
          var constraintMap = root2.path[i2];
          var data2 = new PathConstraintData$1(constraintMap.name);
          data2.order = this.getValue(constraintMap, "order", 0);
          for (var j2 = 0; j2 < constraintMap.bones.length; j2++) {
            var boneName = constraintMap.bones[j2];
            var bone = skeletonData.findBone(boneName);
            if (bone == null)
              throw new Error("Transform constraint bone not found: " + boneName);
            data2.bones.push(bone);
          }
          var targetName = constraintMap.target;
          data2.target = skeletonData.findSlot(targetName);
          if (data2.target == null)
            throw new Error("Path target slot not found: " + targetName);
          data2.positionMode = SkeletonJson2.positionModeFromString(this.getValue(constraintMap, "positionMode", "percent"));
          data2.spacingMode = SkeletonJson2.spacingModeFromString(this.getValue(constraintMap, "spacingMode", "length"));
          data2.rotateMode = SkeletonJson2.rotateModeFromString(this.getValue(constraintMap, "rotateMode", "tangent"));
          data2.offsetRotation = this.getValue(constraintMap, "rotation", 0);
          data2.position = this.getValue(constraintMap, "position", 0);
          if (data2.positionMode == PositionMode.Fixed)
            data2.position *= scale;
          data2.spacing = this.getValue(constraintMap, "spacing", 0);
          if (data2.spacingMode == SpacingMode$1.Length || data2.spacingMode == SpacingMode$1.Fixed)
            data2.spacing *= scale;
          data2.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
          data2.translateMix = this.getValue(constraintMap, "translateMix", 1);
          skeletonData.pathConstraints.push(data2);
        }
      }
      if (root2.skins) {
        for (var skinName in root2.skins) {
          var skinMap = root2.skins[skinName];
          var skin = new Skin$1(skinName);
          for (var slotName in skinMap) {
            var slotIndex = skeletonData.findSlotIndex(slotName);
            if (slotIndex == -1)
              throw new Error("Slot not found: " + slotName);
            var slotMap = skinMap[slotName];
            for (var entryName in slotMap) {
              var attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName, skeletonData);
              if (attachment != null)
                skin.addAttachment(slotIndex, entryName, attachment);
            }
          }
          skeletonData.skins.push(skin);
          if (skin.name == "default")
            skeletonData.defaultSkin = skin;
        }
      }
      for (var i2 = 0, n2 = this.linkedMeshes.length; i2 < n2; i2++) {
        var linkedMesh = this.linkedMeshes[i2];
        var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
        if (skin == null)
          throw new Error("Skin not found: " + linkedMesh.skin);
        var parent_2 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
        if (parent_2 == null)
          throw new Error("Parent mesh not found: " + linkedMesh.parent);
        linkedMesh.mesh.setParentMesh(parent_2);
      }
      this.linkedMeshes.length = 0;
      if (root2.events) {
        for (var eventName in root2.events) {
          var eventMap = root2.events[eventName];
          var data2 = new EventData$1(eventName);
          data2.intValue = this.getValue(eventMap, "int", 0);
          data2.floatValue = this.getValue(eventMap, "float", 0);
          data2.stringValue = this.getValue(eventMap, "string", "");
          data2.audioPath = this.getValue(eventMap, "audio", null);
          if (data2.audioPath != null) {
            data2.volume = this.getValue(eventMap, "volume", 1);
            data2.balance = this.getValue(eventMap, "balance", 0);
          }
          skeletonData.events.push(data2);
        }
      }
      if (root2.animations) {
        for (var animationName in root2.animations) {
          var animationMap = root2.animations[animationName];
          this.readAnimation(animationMap, animationName, skeletonData);
        }
      }
      return skeletonData;
    };
    SkeletonJson2.prototype.readAttachment = function(map2, skin, slotIndex, name, skeletonData) {
      var scale = this.scale;
      name = this.getValue(map2, "name", name);
      var type2 = this.getValue(map2, "type", "region");
      switch (type2) {
        case "region": {
          var path = this.getValue(map2, "path", name);
          var region = this.attachmentLoader.newRegionAttachment(skin, name, path);
          if (region == null)
            return null;
          region.path = path;
          region.x = this.getValue(map2, "x", 0) * scale;
          region.y = this.getValue(map2, "y", 0) * scale;
          region.scaleX = this.getValue(map2, "scaleX", 1);
          region.scaleY = this.getValue(map2, "scaleY", 1);
          region.rotation = this.getValue(map2, "rotation", 0);
          region.width = map2.width * scale;
          region.height = map2.height * scale;
          var color2 = this.getValue(map2, "color", null);
          if (color2 != null)
            region.color.setFromString(color2);
          return region;
        }
        case "boundingbox": {
          var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
          if (box == null)
            return null;
          this.readVertices(map2, box, map2.vertexCount << 1);
          var color2 = this.getValue(map2, "color", null);
          if (color2 != null)
            box.color.setFromString(color2);
          return box;
        }
        case "mesh":
        case "linkedmesh": {
          var path = this.getValue(map2, "path", name);
          var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
          if (mesh == null)
            return null;
          mesh.path = path;
          var color2 = this.getValue(map2, "color", null);
          if (color2 != null)
            mesh.color.setFromString(color2);
          var parent_3 = this.getValue(map2, "parent", null);
          if (parent_3 != null) {
            mesh.inheritDeform = this.getValue(map2, "deform", true);
            this.linkedMeshes.push(new LinkedMesh$2(mesh, this.getValue(map2, "skin", null), slotIndex, parent_3));
            return mesh;
          }
          var uvs = map2.uvs;
          this.readVertices(map2, mesh, uvs.length);
          mesh.triangles = map2.triangles;
          mesh.regionUVs = new Float32Array(uvs);
          mesh.hullLength = this.getValue(map2, "hull", 0) * 2;
          return mesh;
        }
        case "path": {
          var path = this.attachmentLoader.newPathAttachment(skin, name);
          if (path == null)
            return null;
          path.closed = this.getValue(map2, "closed", false);
          path.constantSpeed = this.getValue(map2, "constantSpeed", true);
          var vertexCount = map2.vertexCount;
          this.readVertices(map2, path, vertexCount << 1);
          var lengths = Utils.newArray(vertexCount / 3, 0);
          for (var i2 = 0; i2 < map2.lengths.length; i2++)
            lengths[i2] = map2.lengths[i2] * scale;
          path.lengths = lengths;
          var color2 = this.getValue(map2, "color", null);
          if (color2 != null)
            path.color.setFromString(color2);
          return path;
        }
        case "point": {
          var point = this.attachmentLoader.newPointAttachment(skin, name);
          if (point == null)
            return null;
          point.x = this.getValue(map2, "x", 0) * scale;
          point.y = this.getValue(map2, "y", 0) * scale;
          point.rotation = this.getValue(map2, "rotation", 0);
          var color2 = this.getValue(map2, "color", null);
          if (color2 != null)
            point.color.setFromString(color2);
          return point;
        }
        case "clipping": {
          var clip = this.attachmentLoader.newClippingAttachment(skin, name);
          if (clip == null)
            return null;
          var end2 = this.getValue(map2, "end", null);
          if (end2 != null) {
            var slot = skeletonData.findSlot(end2);
            if (slot == null)
              throw new Error("Clipping end slot not found: " + end2);
            clip.endSlot = slot;
          }
          var vertexCount = map2.vertexCount;
          this.readVertices(map2, clip, vertexCount << 1);
          var color2 = this.getValue(map2, "color", null);
          if (color2 != null)
            clip.color.setFromString(color2);
          return clip;
        }
      }
      return null;
    };
    SkeletonJson2.prototype.readVertices = function(map2, attachment, verticesLength) {
      var scale = this.scale;
      attachment.worldVerticesLength = verticesLength;
      var vertices = map2.vertices;
      if (verticesLength == vertices.length) {
        var scaledVertices = Utils.toFloatArray(vertices);
        if (scale != 1) {
          for (var i2 = 0, n2 = vertices.length; i2 < n2; i2++)
            scaledVertices[i2] *= scale;
        }
        attachment.vertices = scaledVertices;
        return;
      }
      var weights = new Array();
      var bones = new Array();
      for (var i2 = 0, n2 = vertices.length; i2 < n2; ) {
        var boneCount = vertices[i2++];
        bones.push(boneCount);
        for (var nn2 = i2 + boneCount * 4; i2 < nn2; i2 += 4) {
          bones.push(vertices[i2]);
          weights.push(vertices[i2 + 1] * scale);
          weights.push(vertices[i2 + 2] * scale);
          weights.push(vertices[i2 + 3]);
        }
      }
      attachment.bones = bones;
      attachment.vertices = Utils.toFloatArray(weights);
    };
    SkeletonJson2.prototype.readAnimation = function(map2, name, skeletonData) {
      var scale = this.scale;
      var timelines = new Array();
      var duration = 0;
      if (map2.slots) {
        for (var slotName in map2.slots) {
          var slotMap = map2.slots[slotName];
          var slotIndex = skeletonData.findSlotIndex(slotName);
          if (slotIndex == -1)
            throw new Error("Slot not found: " + slotName);
          for (var timelineName in slotMap) {
            var timelineMap = slotMap[timelineName];
            if (timelineName == "attachment") {
              var timeline = new AttachmentTimeline$1(timelineMap.length);
              timeline.slotIndex = slotIndex;
              var frameIndex = 0;
              for (var i2 = 0; i2 < timelineMap.length; i2++) {
                var valueMap = timelineMap[i2];
                timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
            } else if (timelineName == "color") {
              var timeline = new ColorTimeline(timelineMap.length);
              timeline.slotIndex = slotIndex;
              var frameIndex = 0;
              for (var i2 = 0; i2 < timelineMap.length; i2++) {
                var valueMap = timelineMap[i2];
                var color2 = new Color();
                color2.setFromString(valueMap.color || "ffffffff");
                timeline.setFrame(frameIndex, valueMap.time, color2.r, color2.g, color2.b, color2.a);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);
            } else if (timelineName == "twoColor") {
              var timeline = new TwoColorTimeline(timelineMap.length);
              timeline.slotIndex = slotIndex;
              var frameIndex = 0;
              for (var i2 = 0; i2 < timelineMap.length; i2++) {
                var valueMap = timelineMap[i2];
                var light = new Color();
                var dark = new Color();
                light.setFromString(valueMap.light);
                dark.setFromString(valueMap.dark);
                timeline.setFrame(frameIndex, valueMap.time, light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TwoColorTimeline.ENTRIES]);
            } else
              throw new Error("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");
          }
        }
      }
      if (map2.bones) {
        for (var boneName in map2.bones) {
          var boneMap = map2.bones[boneName];
          var boneIndex = skeletonData.findBoneIndex(boneName);
          if (boneIndex == -1)
            throw new Error("Bone not found: " + boneName);
          for (var timelineName in boneMap) {
            var timelineMap = boneMap[timelineName];
            if (timelineName === "rotate") {
              var timeline = new RotateTimeline$1(timelineMap.length);
              timeline.boneIndex = boneIndex;
              var frameIndex = 0;
              for (var i2 = 0; i2 < timelineMap.length; i2++) {
                var valueMap = timelineMap[i2];
                timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline$1.ENTRIES]);
            } else if (timelineName === "translate" || timelineName === "scale" || timelineName === "shear") {
              var timeline = null;
              var timelineScale = 1;
              if (timelineName === "scale")
                timeline = new ScaleTimeline$1(timelineMap.length);
              else if (timelineName === "shear")
                timeline = new ShearTimeline$1(timelineMap.length);
              else {
                timeline = new TranslateTimeline$1(timelineMap.length);
                timelineScale = scale;
              }
              timeline.boneIndex = boneIndex;
              var frameIndex = 0;
              for (var i2 = 0; i2 < timelineMap.length; i2++) {
                var valueMap = timelineMap[i2];
                var x = this.getValue(valueMap, "x", 0), y2 = this.getValue(valueMap, "y", 0);
                timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y2 * timelineScale);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline$1.ENTRIES]);
            } else
              throw new Error("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");
          }
        }
      }
      if (map2.ik) {
        for (var constraintName in map2.ik) {
          var constraintMap = map2.ik[constraintName];
          var constraint = skeletonData.findIkConstraint(constraintName);
          var timeline = new IkConstraintTimeline$1(constraintMap.length);
          timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);
          var frameIndex = 0;
          for (var i2 = 0; i2 < constraintMap.length; i2++) {
            var valueMap = constraintMap[i2];
            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "mix", 1), this.getValue(valueMap, "bendPositive", true) ? 1 : -1, this.getValue(valueMap, "compress", false), this.getValue(valueMap, "stretch", false));
            this.readCurve(valueMap, timeline, frameIndex);
            frameIndex++;
          }
          timelines.push(timeline);
          duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline$1.ENTRIES]);
        }
      }
      if (map2.transform) {
        for (var constraintName in map2.transform) {
          var constraintMap = map2.transform[constraintName];
          var constraint = skeletonData.findTransformConstraint(constraintName);
          var timeline = new TransformConstraintTimeline$1(constraintMap.length);
          timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);
          var frameIndex = 0;
          for (var i2 = 0; i2 < constraintMap.length; i2++) {
            var valueMap = constraintMap[i2];
            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1), this.getValue(valueMap, "scaleMix", 1), this.getValue(valueMap, "shearMix", 1));
            this.readCurve(valueMap, timeline, frameIndex);
            frameIndex++;
          }
          timelines.push(timeline);
          duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline$1.ENTRIES]);
        }
      }
      if (map2.paths) {
        for (var constraintName in map2.paths) {
          var constraintMap = map2.paths[constraintName];
          var index2 = skeletonData.findPathConstraintIndex(constraintName);
          if (index2 == -1)
            throw new Error("Path constraint not found: " + constraintName);
          var data2 = skeletonData.pathConstraints[index2];
          for (var timelineName in constraintMap) {
            var timelineMap = constraintMap[timelineName];
            if (timelineName === "position" || timelineName === "spacing") {
              var timeline = null;
              var timelineScale = 1;
              if (timelineName === "spacing") {
                timeline = new PathConstraintSpacingTimeline$1(timelineMap.length);
                if (data2.spacingMode == SpacingMode$1.Length || data2.spacingMode == SpacingMode$1.Fixed)
                  timelineScale = scale;
              } else {
                timeline = new PathConstraintPositionTimeline$1(timelineMap.length);
                if (data2.positionMode == PositionMode.Fixed)
                  timelineScale = scale;
              }
              timeline.pathConstraintIndex = index2;
              var frameIndex = 0;
              for (var i2 = 0; i2 < timelineMap.length; i2++) {
                var valueMap = timelineMap[i2];
                timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline$1.ENTRIES]);
            } else if (timelineName === "mix") {
              var timeline = new PathConstraintMixTimeline$1(timelineMap.length);
              timeline.pathConstraintIndex = index2;
              var frameIndex = 0;
              for (var i2 = 0; i2 < timelineMap.length; i2++) {
                var valueMap = timelineMap[i2];
                timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1));
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline$1.ENTRIES]);
            }
          }
        }
      }
      if (map2.deform) {
        for (var deformName in map2.deform) {
          var deformMap = map2.deform[deformName];
          var skin = skeletonData.findSkin(deformName);
          if (skin == null) {
            {
              continue;
            }
          }
          for (var slotName in deformMap) {
            var slotMap = deformMap[slotName];
            var slotIndex = skeletonData.findSlotIndex(slotName);
            if (slotIndex == -1)
              throw new Error("Slot not found: " + slotMap.name);
            for (var timelineName in slotMap) {
              var timelineMap = slotMap[timelineName];
              var attachment = skin.getAttachment(slotIndex, timelineName);
              if (attachment == null)
                throw new Error("Deform attachment not found: " + timelineMap.name);
              var weighted = attachment.bones != null;
              var vertices = attachment.vertices;
              var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
              var timeline = new DeformTimeline$1(timelineMap.length);
              timeline.slotIndex = slotIndex;
              timeline.attachment = attachment;
              var frameIndex = 0;
              for (var j2 = 0; j2 < timelineMap.length; j2++) {
                var valueMap = timelineMap[j2];
                var deform = void 0;
                var verticesValue = this.getValue(valueMap, "vertices", null);
                if (verticesValue == null)
                  deform = weighted ? Utils.newFloatArray(deformLength) : vertices;
                else {
                  deform = Utils.newFloatArray(deformLength);
                  var start = this.getValue(valueMap, "offset", 0);
                  Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
                  if (scale != 1) {
                    for (var i2 = start, n2 = i2 + verticesValue.length; i2 < n2; i2++)
                      deform[i2] *= scale;
                  }
                  if (!weighted) {
                    for (var i2 = 0; i2 < deformLength; i2++)
                      deform[i2] += vertices[i2];
                  }
                }
                timeline.setFrame(frameIndex, valueMap.time, deform);
                this.readCurve(valueMap, timeline, frameIndex);
                frameIndex++;
              }
              timelines.push(timeline);
              duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
            }
          }
        }
      }
      var drawOrderNode = map2.drawOrder;
      if (drawOrderNode == null)
        drawOrderNode = map2.draworder;
      if (drawOrderNode != null) {
        var timeline = new DrawOrderTimeline$1(drawOrderNode.length);
        var slotCount = skeletonData.slots.length;
        var frameIndex = 0;
        for (var j2 = 0; j2 < drawOrderNode.length; j2++) {
          var drawOrderMap = drawOrderNode[j2];
          var drawOrder = null;
          var offsets = this.getValue(drawOrderMap, "offsets", null);
          if (offsets != null) {
            drawOrder = Utils.newArray(slotCount, -1);
            var unchanged = Utils.newArray(slotCount - offsets.length, 0);
            var originalIndex = 0, unchangedIndex = 0;
            for (var i2 = 0; i2 < offsets.length; i2++) {
              var offsetMap = offsets[i2];
              var slotIndex = skeletonData.findSlotIndex(offsetMap.slot);
              if (slotIndex == -1)
                throw new Error("Slot not found: " + offsetMap.slot);
              while (originalIndex != slotIndex)
                unchanged[unchangedIndex++] = originalIndex++;
              drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
            }
            while (originalIndex < slotCount)
              unchanged[unchangedIndex++] = originalIndex++;
            for (var i2 = slotCount - 1; i2 >= 0; i2--)
              if (drawOrder[i2] == -1)
                drawOrder[i2] = unchanged[--unchangedIndex];
          }
          timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
      }
      if (map2.events) {
        var timeline = new EventTimeline$1(map2.events.length);
        var frameIndex = 0;
        for (var i2 = 0; i2 < map2.events.length; i2++) {
          var eventMap = map2.events[i2];
          var eventData = skeletonData.findEvent(eventMap.name);
          if (eventData == null)
            throw new Error("Event not found: " + eventMap.name);
          var event_1 = new Event$2(Utils.toSinglePrecision(eventMap.time), eventData);
          event_1.intValue = this.getValue(eventMap, "int", eventData.intValue);
          event_1.floatValue = this.getValue(eventMap, "float", eventData.floatValue);
          event_1.stringValue = this.getValue(eventMap, "string", eventData.stringValue);
          if (event_1.data.audioPath != null) {
            event_1.volume = this.getValue(eventMap, "volume", 1);
            event_1.balance = this.getValue(eventMap, "balance", 0);
          }
          timeline.setFrame(frameIndex++, event_1);
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
      }
      if (isNaN(duration)) {
        throw new Error("Error while parsing animation, duration is NaN");
      }
      skeletonData.animations.push(new Animation$1(name, timelines, duration));
    };
    SkeletonJson2.prototype.readCurve = function(map2, timeline, frameIndex) {
      if (!map2.curve)
        return;
      if (map2.curve === "stepped")
        timeline.setStepped(frameIndex);
      else if (Object.prototype.toString.call(map2.curve) === "[object Array]") {
        var curve = map2.curve;
        timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);
      }
    };
    SkeletonJson2.prototype.getValue = function(map2, prop, defaultValue2) {
      return map2[prop] !== void 0 ? map2[prop] : defaultValue2;
    };
    SkeletonJson2.blendModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "normal")
        return BLEND_MODES$4.NORMAL;
      if (str == "additive")
        return BLEND_MODES$4.ADD;
      if (str == "multiply")
        return BLEND_MODES$4.MULTIPLY;
      if (str == "screen")
        return BLEND_MODES$4.SCREEN;
      throw new Error("Unknown blend mode: " + str);
    };
    SkeletonJson2.positionModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "fixed")
        return PositionMode.Fixed;
      if (str == "percent")
        return PositionMode.Percent;
      throw new Error("Unknown position mode: " + str);
    };
    SkeletonJson2.spacingModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "length")
        return SpacingMode$1.Length;
      if (str == "fixed")
        return SpacingMode$1.Fixed;
      if (str == "percent")
        return SpacingMode$1.Percent;
      throw new Error("Unknown position mode: " + str);
    };
    SkeletonJson2.rotateModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "tangent")
        return RotateMode.Tangent;
      if (str == "chain")
        return RotateMode.Chain;
      if (str == "chainscale")
        return RotateMode.ChainScale;
      throw new Error("Unknown rotate mode: " + str);
    };
    SkeletonJson2.transformModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "normal")
        return TransformMode.Normal;
      if (str == "onlytranslation")
        return TransformMode.OnlyTranslation;
      if (str == "norotationorreflection")
        return TransformMode.NoRotationOrReflection;
      if (str == "noscale")
        return TransformMode.NoScale;
      if (str == "noscaleorreflection")
        return TransformMode.NoScaleOrReflection;
      throw new Error("Unknown transform mode: " + str);
    };
    return SkeletonJson2;
  }()
);
var LinkedMesh$2 = (
  /** @class */
  function() {
    function LinkedMesh2(mesh, skin, slotIndex, parent) {
      this.mesh = mesh;
      this.skin = skin;
      this.slotIndex = slotIndex;
      this.parent = parent;
    }
    return LinkedMesh2;
  }()
);
var Spine$2 = (
  /** @class */
  function(_super) {
    __extends$3(Spine2, _super);
    function Spine2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Spine2.prototype.createSkeleton = function(spineData) {
      this.skeleton = new Skeleton$1(spineData);
      this.skeleton.updateWorldTransform();
      this.stateData = new AnimationStateData$1(spineData);
      this.state = new AnimationState$1(this.stateData);
    };
    return Spine2;
  }(SpineBase)
);
const spine37 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Animation: Animation$1,
  AnimationState: AnimationState$1,
  AnimationStateAdapter2,
  AnimationStateData: AnimationStateData$1,
  AtlasAttachmentLoader: AtlasAttachmentLoader$1,
  Attachment: Attachment$1,
  AttachmentTimeline: AttachmentTimeline$1,
  Bone: Bone$1,
  BoneData: BoneData$1,
  BoundingBoxAttachment: BoundingBoxAttachment$1,
  ClippingAttachment: ClippingAttachment$1,
  ColorTimeline,
  CurveTimeline: CurveTimeline$1,
  DeformTimeline: DeformTimeline$1,
  DrawOrderTimeline: DrawOrderTimeline$1,
  Event: Event$2,
  EventData: EventData$1,
  EventQueue: EventQueue$1,
  EventTimeline: EventTimeline$1,
  get EventType() {
    return EventType$1;
  },
  IkConstraint: IkConstraint$1,
  IkConstraintData: IkConstraintData$1,
  IkConstraintTimeline: IkConstraintTimeline$1,
  JitterEffect,
  MeshAttachment: MeshAttachment$1,
  PathAttachment: PathAttachment$1,
  PathConstraint: PathConstraint$1,
  PathConstraintData: PathConstraintData$1,
  PathConstraintMixTimeline: PathConstraintMixTimeline$1,
  PathConstraintPositionTimeline: PathConstraintPositionTimeline$1,
  PathConstraintSpacingTimeline: PathConstraintSpacingTimeline$1,
  PointAttachment: PointAttachment$1,
  RegionAttachment: RegionAttachment$1,
  RotateTimeline: RotateTimeline$1,
  ScaleTimeline: ScaleTimeline$1,
  ShearTimeline: ShearTimeline$1,
  Skeleton: Skeleton$1,
  SkeletonBounds: SkeletonBounds$1,
  SkeletonData: SkeletonData$1,
  SkeletonJson: SkeletonJson$1,
  Skin: Skin$1,
  Slot: Slot$1,
  SlotData: SlotData$1,
  get SpacingMode() {
    return SpacingMode$1;
  },
  Spine: Spine$2,
  SwirlEffect,
  get TimelineType() {
    return TimelineType;
  },
  TrackEntry: TrackEntry$1,
  TransformConstraint: TransformConstraint$1,
  TransformConstraintData: TransformConstraintData$1,
  TransformConstraintTimeline: TransformConstraintTimeline$1,
  TranslateTimeline: TranslateTimeline$1,
  TwoColorTimeline,
  VertexAttachment: VertexAttachment$1
}, Symbol.toStringTag, { value: "Module" }));
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$2 = function(d2, b2) {
  extendStatics$2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p))
        d3[p] = b3[p];
  };
  return extendStatics$2(d2, b2);
};
function __extends$2(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics$2(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var Attachment = (
  /** @class */
  function() {
    function Attachment2(name) {
      if (!name)
        throw new Error("name cannot be null.");
      this.name = name;
    }
    return Attachment2;
  }()
);
var VertexAttachment = (
  /** @class */
  function(_super) {
    __extends$2(VertexAttachment2, _super);
    function VertexAttachment2(name) {
      var _this = _super.call(this, name) || this;
      _this.id = VertexAttachment2.nextID++;
      _this.bones = null;
      _this.vertices = [];
      _this.worldVerticesLength = 0;
      _this.timelineAttachment = _this;
      return _this;
    }
    VertexAttachment2.prototype.computeWorldVerticesOld = function(slot, worldVertices) {
      this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);
    };
    VertexAttachment2.prototype.computeWorldVertices = function(slot, start, count, worldVertices, offset, stride) {
      count = offset + (count >> 1) * stride;
      var skeleton = slot.bone.skeleton;
      var deformArray = slot.deform;
      var vertices = this.vertices;
      var bones = this.bones;
      if (!bones) {
        if (deformArray.length > 0)
          vertices = deformArray;
        var mat = slot.bone.matrix;
        var x = mat.tx;
        var y2 = mat.ty;
        var a2 = mat.a, b2 = mat.c, c2 = mat.b, d2 = mat.d;
        for (var v_1 = start, w2 = offset; w2 < count; v_1 += 2, w2 += stride) {
          var vx2 = vertices[v_1], vy2 = vertices[v_1 + 1];
          worldVertices[w2] = vx2 * a2 + vy2 * b2 + x;
          worldVertices[w2 + 1] = vx2 * c2 + vy2 * d2 + y2;
        }
        return;
      }
      var v2 = 0, skip = 0;
      for (var i2 = 0; i2 < start; i2 += 2) {
        var n2 = bones[v2];
        v2 += n2 + 1;
        skip += n2;
      }
      var skeletonBones = skeleton.bones;
      if (deformArray.length == 0) {
        for (var w2 = offset, b2 = skip * 3; w2 < count; w2 += stride) {
          var wx = 0, wy = 0;
          var n2 = bones[v2++];
          n2 += v2;
          for (; v2 < n2; v2++, b2 += 3) {
            var mat = skeletonBones[bones[v2]].matrix;
            var vx2 = vertices[b2], vy2 = vertices[b2 + 1], weight = vertices[b2 + 2];
            wx += (vx2 * mat.a + vy2 * mat.c + mat.tx) * weight;
            wy += (vx2 * mat.b + vy2 * mat.d + mat.ty) * weight;
          }
          worldVertices[w2] = wx;
          worldVertices[w2 + 1] = wy;
        }
      } else {
        var deform = deformArray;
        for (var w2 = offset, b2 = skip * 3, f2 = skip << 1; w2 < count; w2 += stride) {
          var wx = 0, wy = 0;
          var n2 = bones[v2++];
          n2 += v2;
          for (; v2 < n2; v2++, b2 += 3, f2 += 2) {
            var mat = skeletonBones[bones[v2]].matrix;
            var vx2 = vertices[b2] + deform[f2], vy2 = vertices[b2 + 1] + deform[f2 + 1], weight = vertices[b2 + 2];
            wx += (vx2 * mat.a + vy2 * mat.c + mat.tx) * weight;
            wy += (vx2 * mat.b + vy2 * mat.d + mat.ty) * weight;
          }
          worldVertices[w2] = wx;
          worldVertices[w2 + 1] = wy;
        }
      }
    };
    VertexAttachment2.prototype.copyTo = function(attachment) {
      if (this.bones) {
        attachment.bones = new Array(this.bones.length);
        Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);
      } else
        attachment.bones = null;
      if (this.vertices) {
        attachment.vertices = Utils.newFloatArray(this.vertices.length);
        Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);
      }
      attachment.worldVerticesLength = this.worldVerticesLength;
      attachment.timelineAttachment = this.timelineAttachment;
    };
    VertexAttachment2.nextID = 0;
    return VertexAttachment2;
  }(Attachment)
);
var BoundingBoxAttachment = (
  /** @class */
  function(_super) {
    __extends$2(BoundingBoxAttachment2, _super);
    function BoundingBoxAttachment2(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.BoundingBox;
      _this.color = new Color(1, 1, 1, 1);
      return _this;
    }
    BoundingBoxAttachment2.prototype.copy = function() {
      var copy2 = new BoundingBoxAttachment2(this.name);
      this.copyTo(copy2);
      copy2.color.setFromColor(this.color);
      return copy2;
    };
    return BoundingBoxAttachment2;
  }(VertexAttachment)
);
var ClippingAttachment = (
  /** @class */
  function(_super) {
    __extends$2(ClippingAttachment2, _super);
    function ClippingAttachment2(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Clipping;
      _this.endSlot = null;
      _this.color = new Color(0.2275, 0.2275, 0.8078, 1);
      return _this;
    }
    ClippingAttachment2.prototype.copy = function() {
      var copy2 = new ClippingAttachment2(this.name);
      this.copyTo(copy2);
      copy2.endSlot = this.endSlot;
      copy2.color.setFromColor(this.color);
      return copy2;
    };
    return ClippingAttachment2;
  }(VertexAttachment)
);
var MeshAttachment = (
  /** @class */
  function(_super) {
    __extends$2(MeshAttachment2, _super);
    function MeshAttachment2(name, path) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Mesh;
      _this.region = null;
      _this.triangles = [];
      _this.color = new Color(1, 1, 1, 1);
      _this.width = 0;
      _this.height = 0;
      _this.hullLength = 0;
      _this.edges = [];
      _this.parentMesh = null;
      _this.sequence = null;
      _this.tempColor = new Color(0, 0, 0, 0);
      _this.path = path;
      return _this;
    }
    MeshAttachment2.prototype.getParentMesh = function() {
      return this.parentMesh;
    };
    MeshAttachment2.prototype.setParentMesh = function(parentMesh) {
      this.parentMesh = parentMesh;
      if (parentMesh) {
        this.bones = parentMesh.bones;
        this.vertices = parentMesh.vertices;
        this.worldVerticesLength = parentMesh.worldVerticesLength;
        this.regionUVs = parentMesh.regionUVs;
        this.triangles = parentMesh.triangles;
        this.hullLength = parentMesh.hullLength;
        this.worldVerticesLength = parentMesh.worldVerticesLength;
      }
    };
    MeshAttachment2.prototype.copy = function() {
      if (this.parentMesh)
        return this.newLinkedMesh();
      var copy2 = new MeshAttachment2(this.name, this.path);
      copy2.region = this.region;
      copy2.color.setFromColor(this.color);
      this.copyTo(copy2);
      copy2.regionUVs = new Float32Array(this.regionUVs.length);
      Utils.arrayCopy(this.regionUVs, 0, copy2.regionUVs, 0, this.regionUVs.length);
      copy2.triangles = new Array(this.triangles.length);
      Utils.arrayCopy(this.triangles, 0, copy2.triangles, 0, this.triangles.length);
      copy2.hullLength = this.hullLength;
      copy2.sequence = this.sequence != null ? this.sequence.copy() : null;
      if (this.edges) {
        copy2.edges = new Array(this.edges.length);
        Utils.arrayCopy(this.edges, 0, copy2.edges, 0, this.edges.length);
      }
      copy2.width = this.width;
      copy2.height = this.height;
      return copy2;
    };
    MeshAttachment2.prototype.computeWorldVertices = function(slot, start, count, worldVertices, offset, stride) {
      if (this.sequence != null)
        this.sequence.apply(slot, this);
      _super.prototype.computeWorldVertices.call(this, slot, start, count, worldVertices, offset, stride);
    };
    MeshAttachment2.prototype.newLinkedMesh = function() {
      var copy2 = new MeshAttachment2(this.name, this.path);
      copy2.region = this.region;
      copy2.color.setFromColor(this.color);
      copy2.timelineAttachment = this.timelineAttachment;
      copy2.setParentMesh(this.parentMesh ? this.parentMesh : this);
      return copy2;
    };
    return MeshAttachment2;
  }(VertexAttachment)
);
var PathAttachment = (
  /** @class */
  function(_super) {
    __extends$2(PathAttachment2, _super);
    function PathAttachment2(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Path;
      _this.lengths = [];
      _this.closed = false;
      _this.constantSpeed = false;
      _this.color = new Color(1, 1, 1, 1);
      return _this;
    }
    PathAttachment2.prototype.copy = function() {
      var copy2 = new PathAttachment2(this.name);
      this.copyTo(copy2);
      copy2.lengths = new Array(this.lengths.length);
      Utils.arrayCopy(this.lengths, 0, copy2.lengths, 0, this.lengths.length);
      copy2.closed = closed;
      copy2.constantSpeed = this.constantSpeed;
      copy2.color.setFromColor(this.color);
      return copy2;
    };
    return PathAttachment2;
  }(VertexAttachment)
);
var PointAttachment = (
  /** @class */
  function(_super) {
    __extends$2(PointAttachment2, _super);
    function PointAttachment2(name) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Point;
      _this.x = 0;
      _this.y = 0;
      _this.rotation = 0;
      _this.color = new Color(0.38, 0.94, 0, 1);
      return _this;
    }
    PointAttachment2.prototype.computeWorldPosition = function(bone, point) {
      var mat = bone.matrix;
      point.x = this.x * mat.a + this.y * mat.c + bone.worldX;
      point.y = this.x * mat.b + this.y * mat.d + bone.worldY;
      return point;
    };
    PointAttachment2.prototype.computeWorldRotation = function(bone) {
      var mat = bone.matrix;
      var cos = MathUtils.cosDeg(this.rotation), sin = MathUtils.sinDeg(this.rotation);
      var x = cos * mat.a + sin * mat.c;
      var y2 = cos * mat.b + sin * mat.d;
      return Math.atan2(y2, x) * MathUtils.radDeg;
    };
    PointAttachment2.prototype.copy = function() {
      var copy2 = new PointAttachment2(this.name);
      copy2.x = this.x;
      copy2.y = this.y;
      copy2.rotation = this.rotation;
      copy2.color.setFromColor(this.color);
      return copy2;
    };
    return PointAttachment2;
  }(VertexAttachment)
);
var RegionAttachment = (
  /** @class */
  function(_super) {
    __extends$2(RegionAttachment2, _super);
    function RegionAttachment2(name, path) {
      var _this = _super.call(this, name) || this;
      _this.type = AttachmentType.Region;
      _this.x = 0;
      _this.y = 0;
      _this.scaleX = 1;
      _this.scaleY = 1;
      _this.rotation = 0;
      _this.width = 0;
      _this.height = 0;
      _this.color = new Color(1, 1, 1, 1);
      _this.rendererObject = null;
      _this.region = null;
      _this.sequence = null;
      _this.offset = Utils.newFloatArray(8);
      _this.uvs = Utils.newFloatArray(8);
      _this.tempColor = new Color(1, 1, 1, 1);
      _this.path = path;
      return _this;
    }
    RegionAttachment2.prototype.updateRegion = function() {
      if (!this.region)
        throw new Error("Region not set.");
      var region = this.region;
      var regionScaleX = this.width / this.region.originalWidth * this.scaleX;
      var regionScaleY = this.height / this.region.originalHeight * this.scaleY;
      var localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
      var localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
      var localX2 = localX + this.region.width * regionScaleX;
      var localY2 = localY + this.region.height * regionScaleY;
      var radians = this.rotation * Math.PI / 180;
      var cos = Math.cos(radians);
      var sin = Math.sin(radians);
      var x = this.x, y2 = this.y;
      var localXCos = localX * cos + x;
      var localXSin = localX * sin;
      var localYCos = localY * cos + y2;
      var localYSin = localY * sin;
      var localX2Cos = localX2 * cos + x;
      var localX2Sin = localX2 * sin;
      var localY2Cos = localY2 * cos + y2;
      var localY2Sin = localY2 * sin;
      var offset = this.offset;
      offset[0] = localXCos - localYSin;
      offset[1] = localYCos + localXSin;
      offset[2] = localXCos - localY2Sin;
      offset[3] = localY2Cos + localXSin;
      offset[4] = localX2Cos - localY2Sin;
      offset[5] = localY2Cos + localX2Sin;
      offset[6] = localX2Cos - localYSin;
      offset[7] = localYCos + localX2Sin;
      var uvs = this.uvs;
      if (region.degrees == 90) {
        uvs[2] = region.u;
        uvs[3] = region.v2;
        uvs[4] = region.u;
        uvs[5] = region.v;
        uvs[6] = region.u2;
        uvs[7] = region.v;
        uvs[0] = region.u2;
        uvs[1] = region.v2;
      } else {
        uvs[0] = region.u;
        uvs[1] = region.v2;
        uvs[2] = region.u;
        uvs[3] = region.v;
        uvs[4] = region.u2;
        uvs[5] = region.v;
        uvs[6] = region.u2;
        uvs[7] = region.v2;
      }
    };
    RegionAttachment2.prototype.computeWorldVertices = function(slot, worldVertices, offset, stride) {
      if (this.sequence != null)
        this.sequence.apply(slot, this);
      var bone = slot.bone;
      var vertexOffset = this.offset;
      var mat = bone.matrix;
      var x = mat.tx, y2 = mat.ty;
      var a2 = mat.a, b2 = mat.c, c2 = mat.b, d2 = mat.d;
      var offsetX = 0, offsetY = 0;
      offsetX = vertexOffset[0];
      offsetY = vertexOffset[1];
      worldVertices[offset] = offsetX * a2 + offsetY * b2 + x;
      worldVertices[offset + 1] = offsetX * c2 + offsetY * d2 + y2;
      offset += stride;
      offsetX = vertexOffset[2];
      offsetY = vertexOffset[3];
      worldVertices[offset] = offsetX * a2 + offsetY * b2 + x;
      worldVertices[offset + 1] = offsetX * c2 + offsetY * d2 + y2;
      offset += stride;
      offsetX = vertexOffset[4];
      offsetY = vertexOffset[5];
      worldVertices[offset] = offsetX * a2 + offsetY * b2 + x;
      worldVertices[offset + 1] = offsetX * c2 + offsetY * d2 + y2;
      offset += stride;
      offsetX = vertexOffset[6];
      offsetY = vertexOffset[7];
      worldVertices[offset] = offsetX * a2 + offsetY * b2 + x;
      worldVertices[offset + 1] = offsetX * c2 + offsetY * d2 + y2;
    };
    RegionAttachment2.prototype.copy = function() {
      var copy2 = new RegionAttachment2(this.name, this.path);
      copy2.region = this.region;
      copy2.rendererObject = this.rendererObject;
      copy2.x = this.x;
      copy2.y = this.y;
      copy2.scaleX = this.scaleX;
      copy2.scaleY = this.scaleY;
      copy2.rotation = this.rotation;
      copy2.width = this.width;
      copy2.height = this.height;
      Utils.arrayCopy(this.uvs, 0, copy2.uvs, 0, 8);
      Utils.arrayCopy(this.offset, 0, copy2.offset, 0, 8);
      copy2.color.setFromColor(this.color);
      copy2.sequence = this.sequence != null ? this.sequence.copy() : null;
      return copy2;
    };
    RegionAttachment2.X1 = 0;
    RegionAttachment2.Y1 = 1;
    RegionAttachment2.C1R = 2;
    RegionAttachment2.C1G = 3;
    RegionAttachment2.C1B = 4;
    RegionAttachment2.C1A = 5;
    RegionAttachment2.U1 = 6;
    RegionAttachment2.V1 = 7;
    RegionAttachment2.X2 = 8;
    RegionAttachment2.Y2 = 9;
    RegionAttachment2.C2R = 10;
    RegionAttachment2.C2G = 11;
    RegionAttachment2.C2B = 12;
    RegionAttachment2.C2A = 13;
    RegionAttachment2.U2 = 14;
    RegionAttachment2.V2 = 15;
    RegionAttachment2.X3 = 16;
    RegionAttachment2.Y3 = 17;
    RegionAttachment2.C3R = 18;
    RegionAttachment2.C3G = 19;
    RegionAttachment2.C3B = 20;
    RegionAttachment2.C3A = 21;
    RegionAttachment2.U3 = 22;
    RegionAttachment2.V3 = 23;
    RegionAttachment2.X4 = 24;
    RegionAttachment2.Y4 = 25;
    RegionAttachment2.C4R = 26;
    RegionAttachment2.C4G = 27;
    RegionAttachment2.C4B = 28;
    RegionAttachment2.C4A = 29;
    RegionAttachment2.U4 = 30;
    RegionAttachment2.V4 = 31;
    return RegionAttachment2;
  }(Attachment)
);
var Sequence = (
  /** @class */
  function() {
    function Sequence2(count) {
      this.id = Sequence2.nextID();
      this.start = 0;
      this.digits = 0;
      this.setupIndex = 0;
      this.regions = new Array(count);
    }
    Sequence2.prototype.copy = function() {
      var copy2 = new Sequence2(this.regions.length);
      Utils.arrayCopy(this.regions, 0, copy2.regions, 0, this.regions.length);
      copy2.start = this.start;
      copy2.digits = this.digits;
      copy2.setupIndex = this.setupIndex;
      return copy2;
    };
    Sequence2.prototype.apply = function(slot, attachment) {
      var index2 = slot.sequenceIndex;
      if (index2 == -1)
        index2 = this.setupIndex;
      if (index2 >= this.regions.length)
        index2 = this.regions.length - 1;
      var region = this.regions[index2];
      if (attachment.region != region) {
        attachment.region = region;
      }
    };
    Sequence2.prototype.getPath = function(basePath, index2) {
      var result = basePath;
      var frame2 = (this.start + index2).toString();
      for (var i2 = this.digits - frame2.length; i2 > 0; i2--)
        result += "0";
      result += frame2;
      return result;
    };
    Sequence2.nextID = function() {
      return Sequence2._nextID++;
    };
    Sequence2._nextID = 0;
    return Sequence2;
  }()
);
var SequenceMode;
(function(SequenceMode2) {
  SequenceMode2[SequenceMode2["hold"] = 0] = "hold";
  SequenceMode2[SequenceMode2["once"] = 1] = "once";
  SequenceMode2[SequenceMode2["loop"] = 2] = "loop";
  SequenceMode2[SequenceMode2["pingpong"] = 3] = "pingpong";
  SequenceMode2[SequenceMode2["onceReverse"] = 4] = "onceReverse";
  SequenceMode2[SequenceMode2["loopReverse"] = 5] = "loopReverse";
  SequenceMode2[SequenceMode2["pingpongReverse"] = 6] = "pingpongReverse";
})(SequenceMode || (SequenceMode = {}));
var SequenceModeValues = [
  SequenceMode.hold,
  SequenceMode.once,
  SequenceMode.loop,
  SequenceMode.pingpong,
  SequenceMode.onceReverse,
  SequenceMode.loopReverse,
  SequenceMode.pingpongReverse
];
var Animation = (
  /** @class */
  function() {
    function Animation2(name, timelines, duration) {
      this.timelines = [];
      this.timelineIds = new StringSet();
      if (!name)
        throw new Error("name cannot be null.");
      this.name = name;
      this.setTimelines(timelines);
      this.duration = duration;
    }
    Animation2.prototype.setTimelines = function(timelines) {
      if (!timelines)
        throw new Error("timelines cannot be null.");
      this.timelines = timelines;
      this.timelineIds.clear();
      for (var i2 = 0; i2 < timelines.length; i2++)
        this.timelineIds.addAll(timelines[i2].getPropertyIds());
    };
    Animation2.prototype.hasTimeline = function(ids) {
      for (var i2 = 0; i2 < ids.length; i2++)
        if (this.timelineIds.contains(ids[i2]))
          return true;
      return false;
    };
    Animation2.prototype.apply = function(skeleton, lastTime2, time, loop, events, alpha2, blend, direction) {
      if (!skeleton)
        throw new Error("skeleton cannot be null.");
      if (loop && this.duration != 0) {
        time %= this.duration;
        if (lastTime2 > 0)
          lastTime2 %= this.duration;
      }
      var timelines = this.timelines;
      for (var i2 = 0, n2 = timelines.length; i2 < n2; i2++)
        timelines[i2].apply(skeleton, lastTime2, time, events, alpha2, blend, direction);
    };
    return Animation2;
  }()
);
var Property = {
  rotate: 0,
  x: 1,
  y: 2,
  scaleX: 3,
  scaleY: 4,
  shearX: 5,
  shearY: 6,
  rgb: 7,
  alpha: 8,
  rgb2: 9,
  attachment: 10,
  deform: 11,
  event: 12,
  drawOrder: 13,
  ikConstraint: 14,
  transformConstraint: 15,
  pathConstraintPosition: 16,
  pathConstraintSpacing: 17,
  pathConstraintMix: 18,
  sequence: 19
};
var Timeline = (
  /** @class */
  function() {
    function Timeline2(frameCount, propertyIds) {
      this.propertyIds = propertyIds;
      this.frames = Utils.newFloatArray(frameCount * this.getFrameEntries());
    }
    Timeline2.prototype.getPropertyIds = function() {
      return this.propertyIds;
    };
    Timeline2.prototype.getFrameEntries = function() {
      return 1;
    };
    Timeline2.prototype.getFrameCount = function() {
      return this.frames.length / this.getFrameEntries();
    };
    Timeline2.prototype.getDuration = function() {
      return this.frames[this.frames.length - this.getFrameEntries()];
    };
    Timeline2.search1 = function(frames, time) {
      var n2 = frames.length;
      for (var i2 = 1; i2 < n2; i2++)
        if (frames[i2] > time)
          return i2 - 1;
      return n2 - 1;
    };
    Timeline2.search = function(frames, time, step) {
      var n2 = frames.length;
      for (var i2 = step; i2 < n2; i2 += step)
        if (frames[i2] > time)
          return i2 - step;
      return n2 - step;
    };
    return Timeline2;
  }()
);
var CurveTimeline = (
  /** @class */
  function(_super) {
    __extends$2(CurveTimeline3, _super);
    function CurveTimeline3(frameCount, bezierCount, propertyIds) {
      var _this = _super.call(this, frameCount, propertyIds) || this;
      _this.curves = Utils.newFloatArray(
        frameCount + bezierCount * 18
        /*BEZIER_SIZE*/
      );
      _this.curves[frameCount - 1] = 1;
      return _this;
    }
    CurveTimeline3.prototype.setLinear = function(frame2) {
      this.curves[frame2] = 0;
    };
    CurveTimeline3.prototype.setStepped = function(frame2) {
      this.curves[frame2] = 1;
    };
    CurveTimeline3.prototype.shrink = function(bezierCount) {
      var size = this.getFrameCount() + bezierCount * 18;
      if (this.curves.length > size) {
        var newCurves = Utils.newFloatArray(size);
        Utils.arrayCopy(this.curves, 0, newCurves, 0, size);
        this.curves = newCurves;
      }
    };
    CurveTimeline3.prototype.setBezier = function(bezier, frame2, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {
      var curves = this.curves;
      var i2 = this.getFrameCount() + bezier * 18;
      if (value == 0)
        curves[frame2] = 2 + i2;
      var tmpx = (time1 - cx1 * 2 + cx2) * 0.03, tmpy = (value1 - cy1 * 2 + cy2) * 0.03;
      var dddx = ((cx1 - cx2) * 3 - time1 + time2) * 6e-3, dddy = ((cy1 - cy2) * 3 - value1 + value2) * 6e-3;
      var ddx = tmpx * 2 + dddx, ddy = tmpy * 2 + dddy;
      var dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667, dy = (cy1 - value1) * 0.3 + tmpy + dddy * 0.16666667;
      var x = time1 + dx, y2 = value1 + dy;
      for (var n2 = i2 + 18; i2 < n2; i2 += 2) {
        curves[i2] = x;
        curves[i2 + 1] = y2;
        dx += ddx;
        dy += ddy;
        ddx += dddx;
        ddy += dddy;
        x += dx;
        y2 += dy;
      }
    };
    CurveTimeline3.prototype.getBezierValue = function(time, frameIndex, valueOffset, i2) {
      var curves = this.curves;
      if (curves[i2] > time) {
        var x_1 = this.frames[frameIndex], y_1 = this.frames[frameIndex + valueOffset];
        return y_1 + (time - x_1) / (curves[i2] - x_1) * (curves[i2 + 1] - y_1);
      }
      var n2 = i2 + 18;
      for (i2 += 2; i2 < n2; i2 += 2) {
        if (curves[i2] >= time) {
          var x_2 = curves[i2 - 2], y_2 = curves[i2 - 1];
          return y_2 + (time - x_2) / (curves[i2] - x_2) * (curves[i2 + 1] - y_2);
        }
      }
      frameIndex += this.getFrameEntries();
      var x = curves[n2 - 2], y2 = curves[n2 - 1];
      return y2 + (time - x) / (this.frames[frameIndex] - x) * (this.frames[frameIndex + valueOffset] - y2);
    };
    return CurveTimeline3;
  }(Timeline)
);
var CurveTimeline1 = (
  /** @class */
  function(_super) {
    __extends$2(CurveTimeline12, _super);
    function CurveTimeline12(frameCount, bezierCount, propertyId) {
      return _super.call(this, frameCount, bezierCount, [propertyId]) || this;
    }
    CurveTimeline12.prototype.getFrameEntries = function() {
      return 2;
    };
    CurveTimeline12.prototype.setFrame = function(frame2, time, value) {
      frame2 <<= 1;
      this.frames[frame2] = time;
      this.frames[
        frame2 + 1
        /*VALUE*/
      ] = value;
    };
    CurveTimeline12.prototype.getCurveValue = function(time) {
      var frames = this.frames;
      var i2 = frames.length - 2;
      for (var ii2 = 2; ii2 <= i2; ii2 += 2) {
        if (frames[ii2] > time) {
          i2 = ii2 - 2;
          break;
        }
      }
      var curveType = this.curves[i2 >> 1];
      switch (curveType) {
        case 0:
          var before = frames[i2], value = frames[
            i2 + 1
            /*VALUE*/
          ];
          return value + (time - before) / (frames[
            i2 + 2
            /*ENTRIES*/
          ] - before) * (frames[
            i2 + 2 + 1
            /*VALUE*/
          ] - value);
        case 1:
          return frames[
            i2 + 1
            /*VALUE*/
          ];
      }
      return this.getBezierValue(
        time,
        i2,
        1,
        curveType - 2
        /*BEZIER*/
      );
    };
    return CurveTimeline12;
  }(CurveTimeline)
);
var CurveTimeline2 = (
  /** @class */
  function(_super) {
    __extends$2(CurveTimeline22, _super);
    function CurveTimeline22(frameCount, bezierCount, propertyId1, propertyId2) {
      return _super.call(this, frameCount, bezierCount, [propertyId1, propertyId2]) || this;
    }
    CurveTimeline22.prototype.getFrameEntries = function() {
      return 3;
    };
    CurveTimeline22.prototype.setFrame = function(frame2, time, value1, value2) {
      frame2 *= 3;
      this.frames[frame2] = time;
      this.frames[
        frame2 + 1
        /*VALUE1*/
      ] = value1;
      this.frames[
        frame2 + 2
        /*VALUE2*/
      ] = value2;
    };
    return CurveTimeline22;
  }(CurveTimeline)
);
var RotateTimeline = (
  /** @class */
  function(_super) {
    __extends$2(RotateTimeline2, _super);
    function RotateTimeline2(frameCount, bezierCount, boneIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.rotate + "|" + boneIndex) || this;
      _this.boneIndex = 0;
      _this.boneIndex = boneIndex;
      return _this;
    }
    RotateTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.rotation = bone.data.rotation;
            return;
          case MixBlend.first:
            bone.rotation += (bone.data.rotation - bone.rotation) * alpha2;
        }
        return;
      }
      var r2 = this.getCurveValue(time);
      switch (blend) {
        case MixBlend.setup:
          bone.rotation = bone.data.rotation + r2 * alpha2;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          r2 += bone.data.rotation - bone.rotation;
        case MixBlend.add:
          bone.rotation += r2 * alpha2;
      }
    };
    return RotateTimeline2;
  }(CurveTimeline1)
);
var TranslateTimeline = (
  /** @class */
  function(_super) {
    __extends$2(TranslateTimeline2, _super);
    function TranslateTimeline2(frameCount, bezierCount, boneIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.x + "|" + boneIndex, Property.y + "|" + boneIndex) || this;
      _this.boneIndex = 0;
      _this.boneIndex = boneIndex;
      return _this;
    }
    TranslateTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.x = bone.data.x;
            bone.y = bone.data.y;
            return;
          case MixBlend.first:
            bone.x += (bone.data.x - bone.x) * alpha2;
            bone.y += (bone.data.y - bone.y) * alpha2;
        }
        return;
      }
      var x = 0, y2 = 0;
      var i2 = Timeline.search(
        frames,
        time,
        3
        /*ENTRIES*/
      );
      var curveType = this.curves[
        i2 / 3
        /*ENTRIES*/
      ];
      switch (curveType) {
        case 0:
          var before = frames[i2];
          x = frames[
            i2 + 1
            /*VALUE1*/
          ];
          y2 = frames[
            i2 + 2
            /*VALUE2*/
          ];
          var t2 = (time - before) / (frames[
            i2 + 3
            /*ENTRIES*/
          ] - before);
          x += (frames[
            i2 + 3 + 1
            /*VALUE1*/
          ] - x) * t2;
          y2 += (frames[
            i2 + 3 + 2
            /*VALUE2*/
          ] - y2) * t2;
          break;
        case 1:
          x = frames[
            i2 + 1
            /*VALUE1*/
          ];
          y2 = frames[
            i2 + 2
            /*VALUE2*/
          ];
          break;
        default:
          x = this.getBezierValue(
            time,
            i2,
            1,
            curveType - 2
            /*BEZIER*/
          );
          y2 = this.getBezierValue(
            time,
            i2,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
      }
      switch (blend) {
        case MixBlend.setup:
          bone.x = bone.data.x + x * alpha2;
          bone.y = bone.data.y + y2 * alpha2;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.x += (bone.data.x + x - bone.x) * alpha2;
          bone.y += (bone.data.y + y2 - bone.y) * alpha2;
          break;
        case MixBlend.add:
          bone.x += x * alpha2;
          bone.y += y2 * alpha2;
      }
    };
    return TranslateTimeline2;
  }(CurveTimeline2)
);
var TranslateXTimeline = (
  /** @class */
  function(_super) {
    __extends$2(TranslateXTimeline2, _super);
    function TranslateXTimeline2(frameCount, bezierCount, boneIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.x + "|" + boneIndex) || this;
      _this.boneIndex = 0;
      _this.boneIndex = boneIndex;
      return _this;
    }
    TranslateXTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.x = bone.data.x;
            return;
          case MixBlend.first:
            bone.x += (bone.data.x - bone.x) * alpha2;
        }
        return;
      }
      var x = this.getCurveValue(time);
      switch (blend) {
        case MixBlend.setup:
          bone.x = bone.data.x + x * alpha2;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.x += (bone.data.x + x - bone.x) * alpha2;
          break;
        case MixBlend.add:
          bone.x += x * alpha2;
      }
    };
    return TranslateXTimeline2;
  }(CurveTimeline1)
);
var TranslateYTimeline = (
  /** @class */
  function(_super) {
    __extends$2(TranslateYTimeline2, _super);
    function TranslateYTimeline2(frameCount, bezierCount, boneIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.y + "|" + boneIndex) || this;
      _this.boneIndex = 0;
      _this.boneIndex = boneIndex;
      return _this;
    }
    TranslateYTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.y = bone.data.y;
            return;
          case MixBlend.first:
            bone.y += (bone.data.y - bone.y) * alpha2;
        }
        return;
      }
      var y2 = this.getCurveValue(time);
      switch (blend) {
        case MixBlend.setup:
          bone.y = bone.data.y + y2 * alpha2;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.y += (bone.data.y + y2 - bone.y) * alpha2;
          break;
        case MixBlend.add:
          bone.y += y2 * alpha2;
      }
    };
    return TranslateYTimeline2;
  }(CurveTimeline1)
);
var ScaleTimeline = (
  /** @class */
  function(_super) {
    __extends$2(ScaleTimeline2, _super);
    function ScaleTimeline2(frameCount, bezierCount, boneIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.scaleX + "|" + boneIndex, Property.scaleY + "|" + boneIndex) || this;
      _this.boneIndex = 0;
      _this.boneIndex = boneIndex;
      return _this;
    }
    ScaleTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.scaleX = bone.data.scaleX;
            bone.scaleY = bone.data.scaleY;
            return;
          case MixBlend.first:
            bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha2;
            bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha2;
        }
        return;
      }
      var x, y2;
      var i2 = Timeline.search(
        frames,
        time,
        3
        /*ENTRIES*/
      );
      var curveType = this.curves[
        i2 / 3
        /*ENTRIES*/
      ];
      switch (curveType) {
        case 0:
          var before = frames[i2];
          x = frames[
            i2 + 1
            /*VALUE1*/
          ];
          y2 = frames[
            i2 + 2
            /*VALUE2*/
          ];
          var t2 = (time - before) / (frames[
            i2 + 3
            /*ENTRIES*/
          ] - before);
          x += (frames[
            i2 + 3 + 1
            /*VALUE1*/
          ] - x) * t2;
          y2 += (frames[
            i2 + 3 + 2
            /*VALUE2*/
          ] - y2) * t2;
          break;
        case 1:
          x = frames[
            i2 + 1
            /*VALUE1*/
          ];
          y2 = frames[
            i2 + 2
            /*VALUE2*/
          ];
          break;
        default:
          x = this.getBezierValue(
            time,
            i2,
            1,
            curveType - 2
            /*BEZIER*/
          );
          y2 = this.getBezierValue(
            time,
            i2,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
      }
      x *= bone.data.scaleX;
      y2 *= bone.data.scaleY;
      if (alpha2 == 1) {
        if (blend == MixBlend.add) {
          bone.scaleX += x - bone.data.scaleX;
          bone.scaleY += y2 - bone.data.scaleY;
        } else {
          bone.scaleX = x;
          bone.scaleY = y2;
        }
      } else {
        var bx = 0, by = 0;
        if (direction == MixDirection.mixOut) {
          switch (blend) {
            case MixBlend.setup:
              bx = bone.data.scaleX;
              by = bone.data.scaleY;
              bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha2;
              bone.scaleY = by + (Math.abs(y2) * MathUtils.signum(by) - by) * alpha2;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              bx = bone.scaleX;
              by = bone.scaleY;
              bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha2;
              bone.scaleY = by + (Math.abs(y2) * MathUtils.signum(by) - by) * alpha2;
              break;
            case MixBlend.add:
              bone.scaleX += (x - bone.data.scaleX) * alpha2;
              bone.scaleY += (y2 - bone.data.scaleY) * alpha2;
          }
        } else {
          switch (blend) {
            case MixBlend.setup:
              bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);
              by = Math.abs(bone.data.scaleY) * MathUtils.signum(y2);
              bone.scaleX = bx + (x - bx) * alpha2;
              bone.scaleY = by + (y2 - by) * alpha2;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              bx = Math.abs(bone.scaleX) * MathUtils.signum(x);
              by = Math.abs(bone.scaleY) * MathUtils.signum(y2);
              bone.scaleX = bx + (x - bx) * alpha2;
              bone.scaleY = by + (y2 - by) * alpha2;
              break;
            case MixBlend.add:
              bone.scaleX += (x - bone.data.scaleX) * alpha2;
              bone.scaleY += (y2 - bone.data.scaleY) * alpha2;
          }
        }
      }
    };
    return ScaleTimeline2;
  }(CurveTimeline2)
);
var ScaleXTimeline = (
  /** @class */
  function(_super) {
    __extends$2(ScaleXTimeline2, _super);
    function ScaleXTimeline2(frameCount, bezierCount, boneIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.scaleX + "|" + boneIndex) || this;
      _this.boneIndex = 0;
      _this.boneIndex = boneIndex;
      return _this;
    }
    ScaleXTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.scaleX = bone.data.scaleX;
            return;
          case MixBlend.first:
            bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha2;
        }
        return;
      }
      var x = this.getCurveValue(time) * bone.data.scaleX;
      if (alpha2 == 1) {
        if (blend == MixBlend.add)
          bone.scaleX += x - bone.data.scaleX;
        else
          bone.scaleX = x;
      } else {
        var bx = 0;
        if (direction == MixDirection.mixOut) {
          switch (blend) {
            case MixBlend.setup:
              bx = bone.data.scaleX;
              bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha2;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              bx = bone.scaleX;
              bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha2;
              break;
            case MixBlend.add:
              bone.scaleX += (x - bone.data.scaleX) * alpha2;
          }
        } else {
          switch (blend) {
            case MixBlend.setup:
              bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);
              bone.scaleX = bx + (x - bx) * alpha2;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              bx = Math.abs(bone.scaleX) * MathUtils.signum(x);
              bone.scaleX = bx + (x - bx) * alpha2;
              break;
            case MixBlend.add:
              bone.scaleX += (x - bone.data.scaleX) * alpha2;
          }
        }
      }
    };
    return ScaleXTimeline2;
  }(CurveTimeline1)
);
var ScaleYTimeline = (
  /** @class */
  function(_super) {
    __extends$2(ScaleYTimeline2, _super);
    function ScaleYTimeline2(frameCount, bezierCount, boneIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.scaleY + "|" + boneIndex) || this;
      _this.boneIndex = 0;
      _this.boneIndex = boneIndex;
      return _this;
    }
    ScaleYTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.scaleY = bone.data.scaleY;
            return;
          case MixBlend.first:
            bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha2;
        }
        return;
      }
      var y2 = this.getCurveValue(time) * bone.data.scaleY;
      if (alpha2 == 1) {
        if (blend == MixBlend.add)
          bone.scaleY += y2 - bone.data.scaleY;
        else
          bone.scaleY = y2;
      } else {
        var by = 0;
        if (direction == MixDirection.mixOut) {
          switch (blend) {
            case MixBlend.setup:
              by = bone.data.scaleY;
              bone.scaleY = by + (Math.abs(y2) * MathUtils.signum(by) - by) * alpha2;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              by = bone.scaleY;
              bone.scaleY = by + (Math.abs(y2) * MathUtils.signum(by) - by) * alpha2;
              break;
            case MixBlend.add:
              bone.scaleY += (y2 - bone.data.scaleY) * alpha2;
          }
        } else {
          switch (blend) {
            case MixBlend.setup:
              by = Math.abs(bone.data.scaleY) * MathUtils.signum(y2);
              bone.scaleY = by + (y2 - by) * alpha2;
              break;
            case MixBlend.first:
            case MixBlend.replace:
              by = Math.abs(bone.scaleY) * MathUtils.signum(y2);
              bone.scaleY = by + (y2 - by) * alpha2;
              break;
            case MixBlend.add:
              bone.scaleY += (y2 - bone.data.scaleY) * alpha2;
          }
        }
      }
    };
    return ScaleYTimeline2;
  }(CurveTimeline1)
);
var ShearTimeline = (
  /** @class */
  function(_super) {
    __extends$2(ShearTimeline2, _super);
    function ShearTimeline2(frameCount, bezierCount, boneIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.shearX + "|" + boneIndex, Property.shearY + "|" + boneIndex) || this;
      _this.boneIndex = 0;
      _this.boneIndex = boneIndex;
      return _this;
    }
    ShearTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.shearX = bone.data.shearX;
            bone.shearY = bone.data.shearY;
            return;
          case MixBlend.first:
            bone.shearX += (bone.data.shearX - bone.shearX) * alpha2;
            bone.shearY += (bone.data.shearY - bone.shearY) * alpha2;
        }
        return;
      }
      var x = 0, y2 = 0;
      var i2 = Timeline.search(
        frames,
        time,
        3
        /*ENTRIES*/
      );
      var curveType = this.curves[
        i2 / 3
        /*ENTRIES*/
      ];
      switch (curveType) {
        case 0:
          var before = frames[i2];
          x = frames[
            i2 + 1
            /*VALUE1*/
          ];
          y2 = frames[
            i2 + 2
            /*VALUE2*/
          ];
          var t2 = (time - before) / (frames[
            i2 + 3
            /*ENTRIES*/
          ] - before);
          x += (frames[
            i2 + 3 + 1
            /*VALUE1*/
          ] - x) * t2;
          y2 += (frames[
            i2 + 3 + 2
            /*VALUE2*/
          ] - y2) * t2;
          break;
        case 1:
          x = frames[
            i2 + 1
            /*VALUE1*/
          ];
          y2 = frames[
            i2 + 2
            /*VALUE2*/
          ];
          break;
        default:
          x = this.getBezierValue(
            time,
            i2,
            1,
            curveType - 2
            /*BEZIER*/
          );
          y2 = this.getBezierValue(
            time,
            i2,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
      }
      switch (blend) {
        case MixBlend.setup:
          bone.shearX = bone.data.shearX + x * alpha2;
          bone.shearY = bone.data.shearY + y2 * alpha2;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha2;
          bone.shearY += (bone.data.shearY + y2 - bone.shearY) * alpha2;
          break;
        case MixBlend.add:
          bone.shearX += x * alpha2;
          bone.shearY += y2 * alpha2;
      }
    };
    return ShearTimeline2;
  }(CurveTimeline2)
);
var ShearXTimeline = (
  /** @class */
  function(_super) {
    __extends$2(ShearXTimeline2, _super);
    function ShearXTimeline2(frameCount, bezierCount, boneIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.shearX + "|" + boneIndex) || this;
      _this.boneIndex = 0;
      _this.boneIndex = boneIndex;
      return _this;
    }
    ShearXTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.shearX = bone.data.shearX;
            return;
          case MixBlend.first:
            bone.shearX += (bone.data.shearX - bone.shearX) * alpha2;
        }
        return;
      }
      var x = this.getCurveValue(time);
      switch (blend) {
        case MixBlend.setup:
          bone.shearX = bone.data.shearX + x * alpha2;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha2;
          break;
        case MixBlend.add:
          bone.shearX += x * alpha2;
      }
    };
    return ShearXTimeline2;
  }(CurveTimeline1)
);
var ShearYTimeline = (
  /** @class */
  function(_super) {
    __extends$2(ShearYTimeline2, _super);
    function ShearYTimeline2(frameCount, bezierCount, boneIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.shearY + "|" + boneIndex) || this;
      _this.boneIndex = 0;
      _this.boneIndex = boneIndex;
      return _this;
    }
    ShearYTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var bone = skeleton.bones[this.boneIndex];
      if (!bone.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.shearY = bone.data.shearY;
            return;
          case MixBlend.first:
            bone.shearY += (bone.data.shearY - bone.shearY) * alpha2;
        }
        return;
      }
      var y2 = this.getCurveValue(time);
      switch (blend) {
        case MixBlend.setup:
          bone.shearY = bone.data.shearY + y2 * alpha2;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          bone.shearY += (bone.data.shearY + y2 - bone.shearY) * alpha2;
          break;
        case MixBlend.add:
          bone.shearY += y2 * alpha2;
      }
    };
    return ShearYTimeline2;
  }(CurveTimeline1)
);
var RGBATimeline = (
  /** @class */
  function(_super) {
    __extends$2(RGBATimeline2, _super);
    function RGBATimeline2(frameCount, bezierCount, slotIndex) {
      var _this = _super.call(this, frameCount, bezierCount, [
        Property.rgb + "|" + slotIndex,
        Property.alpha + "|" + slotIndex
      ]) || this;
      _this.slotIndex = 0;
      _this.slotIndex = slotIndex;
      return _this;
    }
    RGBATimeline2.prototype.getFrameEntries = function() {
      return 5;
    };
    RGBATimeline2.prototype.setFrame = function(frame2, time, r2, g2, b2, a2) {
      frame2 *= 5;
      this.frames[frame2] = time;
      this.frames[
        frame2 + 1
        /*R*/
      ] = r2;
      this.frames[
        frame2 + 2
        /*G*/
      ] = g2;
      this.frames[
        frame2 + 3
        /*B*/
      ] = b2;
      this.frames[
        frame2 + 4
        /*A*/
      ] = a2;
    };
    RGBATimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      var frames = this.frames;
      var color2 = slot.color;
      if (time < frames[0]) {
        var setup = slot.data.color;
        switch (blend) {
          case MixBlend.setup:
            color2.setFromColor(setup);
            return;
          case MixBlend.first:
            color2.add((setup.r - color2.r) * alpha2, (setup.g - color2.g) * alpha2, (setup.b - color2.b) * alpha2, (setup.a - color2.a) * alpha2);
        }
        return;
      }
      var r2 = 0, g2 = 0, b2 = 0, a2 = 0;
      var i2 = Timeline.search(
        frames,
        time,
        5
        /*ENTRIES*/
      );
      var curveType = this.curves[
        i2 / 5
        /*ENTRIES*/
      ];
      switch (curveType) {
        case 0:
          var before = frames[i2];
          r2 = frames[
            i2 + 1
            /*R*/
          ];
          g2 = frames[
            i2 + 2
            /*G*/
          ];
          b2 = frames[
            i2 + 3
            /*B*/
          ];
          a2 = frames[
            i2 + 4
            /*A*/
          ];
          var t2 = (time - before) / (frames[
            i2 + 5
            /*ENTRIES*/
          ] - before);
          r2 += (frames[
            i2 + 5 + 1
            /*R*/
          ] - r2) * t2;
          g2 += (frames[
            i2 + 5 + 2
            /*G*/
          ] - g2) * t2;
          b2 += (frames[
            i2 + 5 + 3
            /*B*/
          ] - b2) * t2;
          a2 += (frames[
            i2 + 5 + 4
            /*A*/
          ] - a2) * t2;
          break;
        case 1:
          r2 = frames[
            i2 + 1
            /*R*/
          ];
          g2 = frames[
            i2 + 2
            /*G*/
          ];
          b2 = frames[
            i2 + 3
            /*B*/
          ];
          a2 = frames[
            i2 + 4
            /*A*/
          ];
          break;
        default:
          r2 = this.getBezierValue(
            time,
            i2,
            1,
            curveType - 2
            /*BEZIER*/
          );
          g2 = this.getBezierValue(
            time,
            i2,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
          b2 = this.getBezierValue(
            time,
            i2,
            3,
            curveType + 18 * 2 - 2
            /*BEZIER*/
          );
          a2 = this.getBezierValue(
            time,
            i2,
            4,
            curveType + 18 * 3 - 2
            /*BEZIER*/
          );
      }
      if (alpha2 == 1)
        color2.set(r2, g2, b2, a2);
      else {
        if (blend == MixBlend.setup)
          color2.setFromColor(slot.data.color);
        color2.add((r2 - color2.r) * alpha2, (g2 - color2.g) * alpha2, (b2 - color2.b) * alpha2, (a2 - color2.a) * alpha2);
      }
    };
    return RGBATimeline2;
  }(CurveTimeline)
);
var RGBTimeline = (
  /** @class */
  function(_super) {
    __extends$2(RGBTimeline2, _super);
    function RGBTimeline2(frameCount, bezierCount, slotIndex) {
      var _this = _super.call(this, frameCount, bezierCount, [
        Property.rgb + "|" + slotIndex
      ]) || this;
      _this.slotIndex = 0;
      _this.slotIndex = slotIndex;
      return _this;
    }
    RGBTimeline2.prototype.getFrameEntries = function() {
      return 4;
    };
    RGBTimeline2.prototype.setFrame = function(frame2, time, r2, g2, b2) {
      frame2 <<= 2;
      this.frames[frame2] = time;
      this.frames[
        frame2 + 1
        /*R*/
      ] = r2;
      this.frames[
        frame2 + 2
        /*G*/
      ] = g2;
      this.frames[
        frame2 + 3
        /*B*/
      ] = b2;
    };
    RGBTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      var frames = this.frames;
      var color2 = slot.color;
      if (time < frames[0]) {
        var setup = slot.data.color;
        switch (blend) {
          case MixBlend.setup:
            color2.r = setup.r;
            color2.g = setup.g;
            color2.b = setup.b;
            return;
          case MixBlend.first:
            color2.r += (setup.r - color2.r) * alpha2;
            color2.g += (setup.g - color2.g) * alpha2;
            color2.b += (setup.b - color2.b) * alpha2;
        }
        return;
      }
      var r2 = 0, g2 = 0, b2 = 0;
      var i2 = Timeline.search(
        frames,
        time,
        4
        /*ENTRIES*/
      );
      var curveType = this.curves[i2 >> 2];
      switch (curveType) {
        case 0:
          var before = frames[i2];
          r2 = frames[
            i2 + 1
            /*R*/
          ];
          g2 = frames[
            i2 + 2
            /*G*/
          ];
          b2 = frames[
            i2 + 3
            /*B*/
          ];
          var t2 = (time - before) / (frames[
            i2 + 4
            /*ENTRIES*/
          ] - before);
          r2 += (frames[
            i2 + 4 + 1
            /*R*/
          ] - r2) * t2;
          g2 += (frames[
            i2 + 4 + 2
            /*G*/
          ] - g2) * t2;
          b2 += (frames[
            i2 + 4 + 3
            /*B*/
          ] - b2) * t2;
          break;
        case 1:
          r2 = frames[
            i2 + 1
            /*R*/
          ];
          g2 = frames[
            i2 + 2
            /*G*/
          ];
          b2 = frames[
            i2 + 3
            /*B*/
          ];
          break;
        default:
          r2 = this.getBezierValue(
            time,
            i2,
            1,
            curveType - 2
            /*BEZIER*/
          );
          g2 = this.getBezierValue(
            time,
            i2,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
          b2 = this.getBezierValue(
            time,
            i2,
            3,
            curveType + 18 * 2 - 2
            /*BEZIER*/
          );
      }
      if (alpha2 == 1) {
        color2.r = r2;
        color2.g = g2;
        color2.b = b2;
      } else {
        if (blend == MixBlend.setup) {
          var setup = slot.data.color;
          color2.r = setup.r;
          color2.g = setup.g;
          color2.b = setup.b;
        }
        color2.r += (r2 - color2.r) * alpha2;
        color2.g += (g2 - color2.g) * alpha2;
        color2.b += (b2 - color2.b) * alpha2;
      }
    };
    return RGBTimeline2;
  }(CurveTimeline)
);
var AlphaTimeline = (
  /** @class */
  function(_super) {
    __extends$2(AlphaTimeline2, _super);
    function AlphaTimeline2(frameCount, bezierCount, slotIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.alpha + "|" + slotIndex) || this;
      _this.slotIndex = 0;
      _this.slotIndex = slotIndex;
      return _this;
    }
    AlphaTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      var color2 = slot.color;
      if (time < this.frames[0]) {
        var setup = slot.data.color;
        switch (blend) {
          case MixBlend.setup:
            color2.a = setup.a;
            return;
          case MixBlend.first:
            color2.a += (setup.a - color2.a) * alpha2;
        }
        return;
      }
      var a2 = this.getCurveValue(time);
      if (alpha2 == 1)
        color2.a = a2;
      else {
        if (blend == MixBlend.setup)
          color2.a = slot.data.color.a;
        color2.a += (a2 - color2.a) * alpha2;
      }
    };
    return AlphaTimeline2;
  }(CurveTimeline1)
);
var RGBA2Timeline = (
  /** @class */
  function(_super) {
    __extends$2(RGBA2Timeline2, _super);
    function RGBA2Timeline2(frameCount, bezierCount, slotIndex) {
      var _this = _super.call(this, frameCount, bezierCount, [
        Property.rgb + "|" + slotIndex,
        Property.alpha + "|" + slotIndex,
        Property.rgb2 + "|" + slotIndex
      ]) || this;
      _this.slotIndex = 0;
      _this.slotIndex = slotIndex;
      return _this;
    }
    RGBA2Timeline2.prototype.getFrameEntries = function() {
      return 8;
    };
    RGBA2Timeline2.prototype.setFrame = function(frame2, time, r2, g2, b2, a2, r22, g22, b22) {
      frame2 <<= 3;
      this.frames[frame2] = time;
      this.frames[
        frame2 + 1
        /*R*/
      ] = r2;
      this.frames[
        frame2 + 2
        /*G*/
      ] = g2;
      this.frames[
        frame2 + 3
        /*B*/
      ] = b2;
      this.frames[
        frame2 + 4
        /*A*/
      ] = a2;
      this.frames[
        frame2 + 5
        /*R2*/
      ] = r22;
      this.frames[
        frame2 + 6
        /*G2*/
      ] = g22;
      this.frames[
        frame2 + 7
        /*B2*/
      ] = b22;
    };
    RGBA2Timeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      var frames = this.frames;
      var light = slot.color, dark = slot.darkColor;
      if (time < frames[0]) {
        var setupLight = slot.data.color, setupDark = slot.data.darkColor;
        switch (blend) {
          case MixBlend.setup:
            light.setFromColor(setupLight);
            dark.r = setupDark.r;
            dark.g = setupDark.g;
            dark.b = setupDark.b;
            return;
          case MixBlend.first:
            light.add((setupLight.r - light.r) * alpha2, (setupLight.g - light.g) * alpha2, (setupLight.b - light.b) * alpha2, (setupLight.a - light.a) * alpha2);
            dark.r += (setupDark.r - dark.r) * alpha2;
            dark.g += (setupDark.g - dark.g) * alpha2;
            dark.b += (setupDark.b - dark.b) * alpha2;
        }
        return;
      }
      var r2 = 0, g2 = 0, b2 = 0, a2 = 0, r22 = 0, g22 = 0, b22 = 0;
      var i2 = Timeline.search(
        frames,
        time,
        8
        /*ENTRIES*/
      );
      var curveType = this.curves[i2 >> 3];
      switch (curveType) {
        case 0:
          var before = frames[i2];
          r2 = frames[
            i2 + 1
            /*R*/
          ];
          g2 = frames[
            i2 + 2
            /*G*/
          ];
          b2 = frames[
            i2 + 3
            /*B*/
          ];
          a2 = frames[
            i2 + 4
            /*A*/
          ];
          r22 = frames[
            i2 + 5
            /*R2*/
          ];
          g22 = frames[
            i2 + 6
            /*G2*/
          ];
          b22 = frames[
            i2 + 7
            /*B2*/
          ];
          var t2 = (time - before) / (frames[
            i2 + 8
            /*ENTRIES*/
          ] - before);
          r2 += (frames[
            i2 + 8 + 1
            /*R*/
          ] - r2) * t2;
          g2 += (frames[
            i2 + 8 + 2
            /*G*/
          ] - g2) * t2;
          b2 += (frames[
            i2 + 8 + 3
            /*B*/
          ] - b2) * t2;
          a2 += (frames[
            i2 + 8 + 4
            /*A*/
          ] - a2) * t2;
          r22 += (frames[
            i2 + 8 + 5
            /*R2*/
          ] - r22) * t2;
          g22 += (frames[
            i2 + 8 + 6
            /*G2*/
          ] - g22) * t2;
          b22 += (frames[
            i2 + 8 + 7
            /*B2*/
          ] - b22) * t2;
          break;
        case 1:
          r2 = frames[
            i2 + 1
            /*R*/
          ];
          g2 = frames[
            i2 + 2
            /*G*/
          ];
          b2 = frames[
            i2 + 3
            /*B*/
          ];
          a2 = frames[
            i2 + 4
            /*A*/
          ];
          r22 = frames[
            i2 + 5
            /*R2*/
          ];
          g22 = frames[
            i2 + 6
            /*G2*/
          ];
          b22 = frames[
            i2 + 7
            /*B2*/
          ];
          break;
        default:
          r2 = this.getBezierValue(
            time,
            i2,
            1,
            curveType - 2
            /*BEZIER*/
          );
          g2 = this.getBezierValue(
            time,
            i2,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
          b2 = this.getBezierValue(
            time,
            i2,
            3,
            curveType + 18 * 2 - 2
            /*BEZIER*/
          );
          a2 = this.getBezierValue(
            time,
            i2,
            4,
            curveType + 18 * 3 - 2
            /*BEZIER*/
          );
          r22 = this.getBezierValue(
            time,
            i2,
            5,
            curveType + 18 * 4 - 2
            /*BEZIER*/
          );
          g22 = this.getBezierValue(
            time,
            i2,
            6,
            curveType + 18 * 5 - 2
            /*BEZIER*/
          );
          b22 = this.getBezierValue(
            time,
            i2,
            7,
            curveType + 18 * 6 - 2
            /*BEZIER*/
          );
      }
      if (alpha2 == 1) {
        light.set(r2, g2, b2, a2);
        dark.r = r22;
        dark.g = g22;
        dark.b = b22;
      } else {
        if (blend == MixBlend.setup) {
          light.setFromColor(slot.data.color);
          var setupDark = slot.data.darkColor;
          dark.r = setupDark.r;
          dark.g = setupDark.g;
          dark.b = setupDark.b;
        }
        light.add((r2 - light.r) * alpha2, (g2 - light.g) * alpha2, (b2 - light.b) * alpha2, (a2 - light.a) * alpha2);
        dark.r += (r22 - dark.r) * alpha2;
        dark.g += (g22 - dark.g) * alpha2;
        dark.b += (b22 - dark.b) * alpha2;
      }
    };
    return RGBA2Timeline2;
  }(CurveTimeline)
);
var RGB2Timeline = (
  /** @class */
  function(_super) {
    __extends$2(RGB2Timeline2, _super);
    function RGB2Timeline2(frameCount, bezierCount, slotIndex) {
      var _this = _super.call(this, frameCount, bezierCount, [
        Property.rgb + "|" + slotIndex,
        Property.rgb2 + "|" + slotIndex
      ]) || this;
      _this.slotIndex = 0;
      _this.slotIndex = slotIndex;
      return _this;
    }
    RGB2Timeline2.prototype.getFrameEntries = function() {
      return 7;
    };
    RGB2Timeline2.prototype.setFrame = function(frame2, time, r2, g2, b2, r22, g22, b22) {
      frame2 *= 7;
      this.frames[frame2] = time;
      this.frames[
        frame2 + 1
        /*R*/
      ] = r2;
      this.frames[
        frame2 + 2
        /*G*/
      ] = g2;
      this.frames[
        frame2 + 3
        /*B*/
      ] = b2;
      this.frames[
        frame2 + 4
        /*R2*/
      ] = r22;
      this.frames[
        frame2 + 5
        /*G2*/
      ] = g22;
      this.frames[
        frame2 + 6
        /*B2*/
      ] = b22;
    };
    RGB2Timeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      var frames = this.frames;
      var light = slot.color, dark = slot.darkColor;
      if (time < frames[0]) {
        var setupLight = slot.data.color, setupDark = slot.data.darkColor;
        switch (blend) {
          case MixBlend.setup:
            light.r = setupLight.r;
            light.g = setupLight.g;
            light.b = setupLight.b;
            dark.r = setupDark.r;
            dark.g = setupDark.g;
            dark.b = setupDark.b;
            return;
          case MixBlend.first:
            light.r += (setupLight.r - light.r) * alpha2;
            light.g += (setupLight.g - light.g) * alpha2;
            light.b += (setupLight.b - light.b) * alpha2;
            dark.r += (setupDark.r - dark.r) * alpha2;
            dark.g += (setupDark.g - dark.g) * alpha2;
            dark.b += (setupDark.b - dark.b) * alpha2;
        }
        return;
      }
      var r2 = 0, g2 = 0, b2 = 0, r22 = 0, g22 = 0, b22 = 0;
      var i2 = Timeline.search(
        frames,
        time,
        7
        /*ENTRIES*/
      );
      var curveType = this.curves[
        i2 / 7
        /*ENTRIES*/
      ];
      switch (curveType) {
        case 0:
          var before = frames[i2];
          r2 = frames[
            i2 + 1
            /*R*/
          ];
          g2 = frames[
            i2 + 2
            /*G*/
          ];
          b2 = frames[
            i2 + 3
            /*B*/
          ];
          r22 = frames[
            i2 + 4
            /*R2*/
          ];
          g22 = frames[
            i2 + 5
            /*G2*/
          ];
          b22 = frames[
            i2 + 6
            /*B2*/
          ];
          var t2 = (time - before) / (frames[
            i2 + 7
            /*ENTRIES*/
          ] - before);
          r2 += (frames[
            i2 + 7 + 1
            /*R*/
          ] - r2) * t2;
          g2 += (frames[
            i2 + 7 + 2
            /*G*/
          ] - g2) * t2;
          b2 += (frames[
            i2 + 7 + 3
            /*B*/
          ] - b2) * t2;
          r22 += (frames[
            i2 + 7 + 4
            /*R2*/
          ] - r22) * t2;
          g22 += (frames[
            i2 + 7 + 5
            /*G2*/
          ] - g22) * t2;
          b22 += (frames[
            i2 + 7 + 6
            /*B2*/
          ] - b22) * t2;
          break;
        case 1:
          r2 = frames[
            i2 + 1
            /*R*/
          ];
          g2 = frames[
            i2 + 2
            /*G*/
          ];
          b2 = frames[
            i2 + 3
            /*B*/
          ];
          r22 = frames[
            i2 + 4
            /*R2*/
          ];
          g22 = frames[
            i2 + 5
            /*G2*/
          ];
          b22 = frames[
            i2 + 6
            /*B2*/
          ];
          break;
        default:
          r2 = this.getBezierValue(
            time,
            i2,
            1,
            curveType - 2
            /*BEZIER*/
          );
          g2 = this.getBezierValue(
            time,
            i2,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
          b2 = this.getBezierValue(
            time,
            i2,
            3,
            curveType + 18 * 2 - 2
            /*BEZIER*/
          );
          r22 = this.getBezierValue(
            time,
            i2,
            4,
            curveType + 18 * 3 - 2
            /*BEZIER*/
          );
          g22 = this.getBezierValue(
            time,
            i2,
            5,
            curveType + 18 * 4 - 2
            /*BEZIER*/
          );
          b22 = this.getBezierValue(
            time,
            i2,
            6,
            curveType + 18 * 5 - 2
            /*BEZIER*/
          );
      }
      if (alpha2 == 1) {
        light.r = r2;
        light.g = g2;
        light.b = b2;
        dark.r = r22;
        dark.g = g22;
        dark.b = b22;
      } else {
        if (blend == MixBlend.setup) {
          var setupLight = slot.data.color, setupDark = slot.data.darkColor;
          light.r = setupLight.r;
          light.g = setupLight.g;
          light.b = setupLight.b;
          dark.r = setupDark.r;
          dark.g = setupDark.g;
          dark.b = setupDark.b;
        }
        light.r += (r2 - light.r) * alpha2;
        light.g += (g2 - light.g) * alpha2;
        light.b += (b2 - light.b) * alpha2;
        dark.r += (r22 - dark.r) * alpha2;
        dark.g += (g22 - dark.g) * alpha2;
        dark.b += (b22 - dark.b) * alpha2;
      }
    };
    return RGB2Timeline2;
  }(CurveTimeline)
);
var AttachmentTimeline = (
  /** @class */
  function(_super) {
    __extends$2(AttachmentTimeline2, _super);
    function AttachmentTimeline2(frameCount, slotIndex) {
      var _this = _super.call(this, frameCount, [
        Property.attachment + "|" + slotIndex
      ]) || this;
      _this.slotIndex = 0;
      _this.slotIndex = slotIndex;
      _this.attachmentNames = new Array(frameCount);
      return _this;
    }
    AttachmentTimeline2.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    AttachmentTimeline2.prototype.setFrame = function(frame2, time, attachmentName) {
      this.frames[frame2] = time;
      this.attachmentNames[frame2] = attachmentName;
    };
    AttachmentTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      if (direction == MixDirection.mixOut) {
        if (blend == MixBlend.setup)
          this.setAttachment(skeleton, slot, slot.data.attachmentName);
        return;
      }
      if (time < this.frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first)
          this.setAttachment(skeleton, slot, slot.data.attachmentName);
        return;
      }
      this.setAttachment(skeleton, slot, this.attachmentNames[Timeline.search1(this.frames, time)]);
    };
    AttachmentTimeline2.prototype.setAttachment = function(skeleton, slot, attachmentName) {
      slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
    };
    return AttachmentTimeline2;
  }(Timeline)
);
var DeformTimeline = (
  /** @class */
  function(_super) {
    __extends$2(DeformTimeline2, _super);
    function DeformTimeline2(frameCount, bezierCount, slotIndex, attachment) {
      var _this = _super.call(this, frameCount, bezierCount, [
        Property.deform + "|" + slotIndex + "|" + attachment.id
      ]) || this;
      _this.slotIndex = 0;
      _this.slotIndex = slotIndex;
      _this.attachment = attachment;
      _this.vertices = new Array(frameCount);
      return _this;
    }
    DeformTimeline2.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    DeformTimeline2.prototype.setFrame = function(frame2, time, vertices) {
      this.frames[frame2] = time;
      this.vertices[frame2] = vertices;
    };
    DeformTimeline2.prototype.setBezier = function(bezier, frame2, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {
      var curves = this.curves;
      var i2 = this.getFrameCount() + bezier * 18;
      if (value == 0)
        curves[frame2] = 2 + i2;
      var tmpx = (time1 - cx1 * 2 + cx2) * 0.03, tmpy = cy2 * 0.03 - cy1 * 0.06;
      var dddx = ((cx1 - cx2) * 3 - time1 + time2) * 6e-3, dddy = (cy1 - cy2 + 0.33333333) * 0.018;
      var ddx = tmpx * 2 + dddx, ddy = tmpy * 2 + dddy;
      var dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667, dy = cy1 * 0.3 + tmpy + dddy * 0.16666667;
      var x = time1 + dx, y2 = dy;
      for (var n2 = i2 + 18; i2 < n2; i2 += 2) {
        curves[i2] = x;
        curves[i2 + 1] = y2;
        dx += ddx;
        dy += ddy;
        ddx += dddx;
        ddy += dddy;
        x += dx;
        y2 += dy;
      }
    };
    DeformTimeline2.prototype.getCurvePercent = function(time, frame2) {
      var curves = this.curves;
      var i2 = curves[frame2];
      switch (i2) {
        case 0:
          var x_3 = this.frames[frame2];
          return (time - x_3) / (this.frames[frame2 + this.getFrameEntries()] - x_3);
        case 1:
          return 0;
      }
      i2 -= 2;
      if (curves[i2] > time) {
        var x_4 = this.frames[frame2];
        return curves[i2 + 1] * (time - x_4) / (curves[i2] - x_4);
      }
      var n2 = i2 + 18;
      for (i2 += 2; i2 < n2; i2 += 2) {
        if (curves[i2] >= time) {
          var x_5 = curves[i2 - 2], y_3 = curves[i2 - 1];
          return y_3 + (time - x_5) / (curves[i2] - x_5) * (curves[i2 + 1] - y_3);
        }
      }
      var x = curves[n2 - 2], y2 = curves[n2 - 1];
      return y2 + (1 - y2) * (time - x) / (this.frames[frame2 + this.getFrameEntries()] - x);
    };
    DeformTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      var slotAttachment = slot.getAttachment();
      if (!slotAttachment)
        return;
      if (!(slotAttachment instanceof VertexAttachment) || slotAttachment.timelineAttachment != this.attachment)
        return;
      var deform = slot.deform;
      if (deform.length == 0)
        blend = MixBlend.setup;
      var vertices = this.vertices;
      var vertexCount = vertices[0].length;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            deform.length = 0;
            return;
          case MixBlend.first:
            if (alpha2 == 1) {
              deform.length = 0;
              return;
            }
            deform.length = vertexCount;
            var vertexAttachment = slotAttachment;
            if (!vertexAttachment.bones) {
              var setupVertices = vertexAttachment.vertices;
              for (var i2 = 0; i2 < vertexCount; i2++)
                deform[i2] += (setupVertices[i2] - deform[i2]) * alpha2;
            } else {
              alpha2 = 1 - alpha2;
              for (var i2 = 0; i2 < vertexCount; i2++)
                deform[i2] *= alpha2;
            }
        }
        return;
      }
      deform.length = vertexCount;
      if (time >= frames[frames.length - 1]) {
        var lastVertices = vertices[frames.length - 1];
        if (alpha2 == 1) {
          if (blend == MixBlend.add) {
            var vertexAttachment = slotAttachment;
            if (!vertexAttachment.bones) {
              var setupVertices = vertexAttachment.vertices;
              for (var i_1 = 0; i_1 < vertexCount; i_1++)
                deform[i_1] += lastVertices[i_1] - setupVertices[i_1];
            } else {
              for (var i_2 = 0; i_2 < vertexCount; i_2++)
                deform[i_2] += lastVertices[i_2];
            }
          } else
            Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);
        } else {
          switch (blend) {
            case MixBlend.setup: {
              var vertexAttachment_1 = slotAttachment;
              if (!vertexAttachment_1.bones) {
                var setupVertices = vertexAttachment_1.vertices;
                for (var i_3 = 0; i_3 < vertexCount; i_3++) {
                  var setup = setupVertices[i_3];
                  deform[i_3] = setup + (lastVertices[i_3] - setup) * alpha2;
                }
              } else {
                for (var i_4 = 0; i_4 < vertexCount; i_4++)
                  deform[i_4] = lastVertices[i_4] * alpha2;
              }
              break;
            }
            case MixBlend.first:
            case MixBlend.replace:
              for (var i_5 = 0; i_5 < vertexCount; i_5++)
                deform[i_5] += (lastVertices[i_5] - deform[i_5]) * alpha2;
              break;
            case MixBlend.add:
              var vertexAttachment = slotAttachment;
              if (!vertexAttachment.bones) {
                var setupVertices = vertexAttachment.vertices;
                for (var i_6 = 0; i_6 < vertexCount; i_6++)
                  deform[i_6] += (lastVertices[i_6] - setupVertices[i_6]) * alpha2;
              } else {
                for (var i_7 = 0; i_7 < vertexCount; i_7++)
                  deform[i_7] += lastVertices[i_7] * alpha2;
              }
          }
        }
        return;
      }
      var frame2 = Timeline.search1(frames, time);
      var percent2 = this.getCurvePercent(time, frame2);
      var prevVertices = vertices[frame2];
      var nextVertices = vertices[frame2 + 1];
      if (alpha2 == 1) {
        if (blend == MixBlend.add) {
          var vertexAttachment = slotAttachment;
          if (!vertexAttachment.bones) {
            var setupVertices = vertexAttachment.vertices;
            for (var i_8 = 0; i_8 < vertexCount; i_8++) {
              var prev2 = prevVertices[i_8];
              deform[i_8] += prev2 + (nextVertices[i_8] - prev2) * percent2 - setupVertices[i_8];
            }
          } else {
            for (var i_9 = 0; i_9 < vertexCount; i_9++) {
              var prev2 = prevVertices[i_9];
              deform[i_9] += prev2 + (nextVertices[i_9] - prev2) * percent2;
            }
          }
        } else {
          for (var i_10 = 0; i_10 < vertexCount; i_10++) {
            var prev2 = prevVertices[i_10];
            deform[i_10] = prev2 + (nextVertices[i_10] - prev2) * percent2;
          }
        }
      } else {
        switch (blend) {
          case MixBlend.setup: {
            var vertexAttachment_2 = slotAttachment;
            if (!vertexAttachment_2.bones) {
              var setupVertices = vertexAttachment_2.vertices;
              for (var i_11 = 0; i_11 < vertexCount; i_11++) {
                var prev2 = prevVertices[i_11], setup = setupVertices[i_11];
                deform[i_11] = setup + (prev2 + (nextVertices[i_11] - prev2) * percent2 - setup) * alpha2;
              }
            } else {
              for (var i_12 = 0; i_12 < vertexCount; i_12++) {
                var prev2 = prevVertices[i_12];
                deform[i_12] = (prev2 + (nextVertices[i_12] - prev2) * percent2) * alpha2;
              }
            }
            break;
          }
          case MixBlend.first:
          case MixBlend.replace:
            for (var i_13 = 0; i_13 < vertexCount; i_13++) {
              var prev2 = prevVertices[i_13];
              deform[i_13] += (prev2 + (nextVertices[i_13] - prev2) * percent2 - deform[i_13]) * alpha2;
            }
            break;
          case MixBlend.add:
            var vertexAttachment = slotAttachment;
            if (!vertexAttachment.bones) {
              var setupVertices = vertexAttachment.vertices;
              for (var i_14 = 0; i_14 < vertexCount; i_14++) {
                var prev2 = prevVertices[i_14];
                deform[i_14] += (prev2 + (nextVertices[i_14] - prev2) * percent2 - setupVertices[i_14]) * alpha2;
              }
            } else {
              for (var i_15 = 0; i_15 < vertexCount; i_15++) {
                var prev2 = prevVertices[i_15];
                deform[i_15] += (prev2 + (nextVertices[i_15] - prev2) * percent2) * alpha2;
              }
            }
        }
      }
    };
    return DeformTimeline2;
  }(CurveTimeline)
);
var EventTimeline = (
  /** @class */
  function(_super) {
    __extends$2(EventTimeline2, _super);
    function EventTimeline2(frameCount) {
      var _this = _super.call(this, frameCount, EventTimeline2.propertyIds) || this;
      _this.events = new Array(frameCount);
      return _this;
    }
    EventTimeline2.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    EventTimeline2.prototype.setFrame = function(frame2, event) {
      this.frames[frame2] = event.time;
      this.events[frame2] = event;
    };
    EventTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      if (!firedEvents)
        return;
      var frames = this.frames;
      var frameCount = this.frames.length;
      if (lastTime2 > time) {
        this.apply(skeleton, lastTime2, Number.MAX_VALUE, firedEvents, alpha2, blend, direction);
        lastTime2 = -1;
      } else if (lastTime2 >= frames[frameCount - 1])
        return;
      if (time < frames[0])
        return;
      var i2 = 0;
      if (lastTime2 < frames[0])
        i2 = 0;
      else {
        i2 = Timeline.search1(frames, lastTime2) + 1;
        var frameTime = frames[i2];
        while (i2 > 0) {
          if (frames[i2 - 1] != frameTime)
            break;
          i2--;
        }
      }
      for (; i2 < frameCount && time >= frames[i2]; i2++)
        firedEvents.push(this.events[i2]);
    };
    EventTimeline2.propertyIds = ["" + Property.event];
    return EventTimeline2;
  }(Timeline)
);
var DrawOrderTimeline = (
  /** @class */
  function(_super) {
    __extends$2(DrawOrderTimeline2, _super);
    function DrawOrderTimeline2(frameCount) {
      var _this = _super.call(this, frameCount, DrawOrderTimeline2.propertyIds) || this;
      _this.drawOrders = new Array(frameCount);
      return _this;
    }
    DrawOrderTimeline2.prototype.getFrameCount = function() {
      return this.frames.length;
    };
    DrawOrderTimeline2.prototype.setFrame = function(frame2, time, drawOrder) {
      this.frames[frame2] = time;
      this.drawOrders[frame2] = drawOrder;
    };
    DrawOrderTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      if (direction == MixDirection.mixOut) {
        if (blend == MixBlend.setup)
          Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
        return;
      }
      if (time < this.frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first)
          Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
        return;
      }
      var idx = Timeline.search1(this.frames, time);
      var drawOrderToSetupIndex = this.drawOrders[idx];
      if (!drawOrderToSetupIndex)
        Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      else {
        var drawOrder = skeleton.drawOrder;
        var slots = skeleton.slots;
        for (var i2 = 0, n2 = drawOrderToSetupIndex.length; i2 < n2; i2++)
          drawOrder[i2] = slots[drawOrderToSetupIndex[i2]];
      }
    };
    DrawOrderTimeline2.propertyIds = ["" + Property.drawOrder];
    return DrawOrderTimeline2;
  }(Timeline)
);
var IkConstraintTimeline = (
  /** @class */
  function(_super) {
    __extends$2(IkConstraintTimeline2, _super);
    function IkConstraintTimeline2(frameCount, bezierCount, ikConstraintIndex) {
      var _this = _super.call(this, frameCount, bezierCount, [
        Property.ikConstraint + "|" + ikConstraintIndex
      ]) || this;
      _this.ikConstraintIndex = 0;
      _this.ikConstraintIndex = ikConstraintIndex;
      return _this;
    }
    IkConstraintTimeline2.prototype.getFrameEntries = function() {
      return 6;
    };
    IkConstraintTimeline2.prototype.setFrame = function(frame2, time, mix2, softness, bendDirection, compress, stretch) {
      frame2 *= 6;
      this.frames[frame2] = time;
      this.frames[
        frame2 + 1
        /*MIX*/
      ] = mix2;
      this.frames[
        frame2 + 2
        /*SOFTNESS*/
      ] = softness;
      this.frames[
        frame2 + 3
        /*BEND_DIRECTION*/
      ] = bendDirection;
      this.frames[
        frame2 + 4
        /*COMPRESS*/
      ] = compress ? 1 : 0;
      this.frames[
        frame2 + 5
        /*STRETCH*/
      ] = stretch ? 1 : 0;
    };
    IkConstraintTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      var constraint = skeleton.ikConstraints[this.ikConstraintIndex];
      if (!constraint.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.mix = constraint.data.mix;
            constraint.softness = constraint.data.softness;
            constraint.bendDirection = constraint.data.bendDirection;
            constraint.compress = constraint.data.compress;
            constraint.stretch = constraint.data.stretch;
            return;
          case MixBlend.first:
            constraint.mix += (constraint.data.mix - constraint.mix) * alpha2;
            constraint.softness += (constraint.data.softness - constraint.softness) * alpha2;
            constraint.bendDirection = constraint.data.bendDirection;
            constraint.compress = constraint.data.compress;
            constraint.stretch = constraint.data.stretch;
        }
        return;
      }
      var mix2 = 0, softness = 0;
      var i2 = Timeline.search(
        frames,
        time,
        6
        /*ENTRIES*/
      );
      var curveType = this.curves[
        i2 / 6
        /*ENTRIES*/
      ];
      switch (curveType) {
        case 0:
          var before = frames[i2];
          mix2 = frames[
            i2 + 1
            /*MIX*/
          ];
          softness = frames[
            i2 + 2
            /*SOFTNESS*/
          ];
          var t2 = (time - before) / (frames[
            i2 + 6
            /*ENTRIES*/
          ] - before);
          mix2 += (frames[
            i2 + 6 + 1
            /*MIX*/
          ] - mix2) * t2;
          softness += (frames[
            i2 + 6 + 2
            /*SOFTNESS*/
          ] - softness) * t2;
          break;
        case 1:
          mix2 = frames[
            i2 + 1
            /*MIX*/
          ];
          softness = frames[
            i2 + 2
            /*SOFTNESS*/
          ];
          break;
        default:
          mix2 = this.getBezierValue(
            time,
            i2,
            1,
            curveType - 2
            /*BEZIER*/
          );
          softness = this.getBezierValue(
            time,
            i2,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
      }
      if (blend == MixBlend.setup) {
        constraint.mix = constraint.data.mix + (mix2 - constraint.data.mix) * alpha2;
        constraint.softness = constraint.data.softness + (softness - constraint.data.softness) * alpha2;
        if (direction == MixDirection.mixOut) {
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
        } else {
          constraint.bendDirection = frames[
            i2 + 3
            /*BEND_DIRECTION*/
          ];
          constraint.compress = frames[
            i2 + 4
            /*COMPRESS*/
          ] != 0;
          constraint.stretch = frames[
            i2 + 5
            /*STRETCH*/
          ] != 0;
        }
      } else {
        constraint.mix += (mix2 - constraint.mix) * alpha2;
        constraint.softness += (softness - constraint.softness) * alpha2;
        if (direction == MixDirection.mixIn) {
          constraint.bendDirection = frames[
            i2 + 3
            /*BEND_DIRECTION*/
          ];
          constraint.compress = frames[
            i2 + 4
            /*COMPRESS*/
          ] != 0;
          constraint.stretch = frames[
            i2 + 5
            /*STRETCH*/
          ] != 0;
        }
      }
    };
    return IkConstraintTimeline2;
  }(CurveTimeline)
);
var TransformConstraintTimeline = (
  /** @class */
  function(_super) {
    __extends$2(TransformConstraintTimeline2, _super);
    function TransformConstraintTimeline2(frameCount, bezierCount, transformConstraintIndex) {
      var _this = _super.call(this, frameCount, bezierCount, [
        Property.transformConstraint + "|" + transformConstraintIndex
      ]) || this;
      _this.transformConstraintIndex = 0;
      _this.transformConstraintIndex = transformConstraintIndex;
      return _this;
    }
    TransformConstraintTimeline2.prototype.getFrameEntries = function() {
      return 7;
    };
    TransformConstraintTimeline2.prototype.setFrame = function(frame2, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY) {
      var frames = this.frames;
      frame2 *= 7;
      frames[frame2] = time;
      frames[
        frame2 + 1
        /*ROTATE*/
      ] = mixRotate;
      frames[
        frame2 + 2
        /*X*/
      ] = mixX;
      frames[
        frame2 + 3
        /*Y*/
      ] = mixY;
      frames[
        frame2 + 4
        /*SCALEX*/
      ] = mixScaleX;
      frames[
        frame2 + 5
        /*SCALEY*/
      ] = mixScaleY;
      frames[
        frame2 + 6
        /*SHEARY*/
      ] = mixShearY;
    };
    TransformConstraintTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      var constraint = skeleton.transformConstraints[this.transformConstraintIndex];
      if (!constraint.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        var data2 = constraint.data;
        switch (blend) {
          case MixBlend.setup:
            constraint.mixRotate = data2.mixRotate;
            constraint.mixX = data2.mixX;
            constraint.mixY = data2.mixY;
            constraint.mixScaleX = data2.mixScaleX;
            constraint.mixScaleY = data2.mixScaleY;
            constraint.mixShearY = data2.mixShearY;
            return;
          case MixBlend.first:
            constraint.mixRotate += (data2.mixRotate - constraint.mixRotate) * alpha2;
            constraint.mixX += (data2.mixX - constraint.mixX) * alpha2;
            constraint.mixY += (data2.mixY - constraint.mixY) * alpha2;
            constraint.mixScaleX += (data2.mixScaleX - constraint.mixScaleX) * alpha2;
            constraint.mixScaleY += (data2.mixScaleY - constraint.mixScaleY) * alpha2;
            constraint.mixShearY += (data2.mixShearY - constraint.mixShearY) * alpha2;
        }
        return;
      }
      var rotate, x, y2, scaleX, scaleY, shearY;
      var i2 = Timeline.search(
        frames,
        time,
        7
        /*ENTRIES*/
      );
      var curveType = this.curves[
        i2 / 7
        /*ENTRIES*/
      ];
      switch (curveType) {
        case 0:
          var before = frames[i2];
          rotate = frames[
            i2 + 1
            /*ROTATE*/
          ];
          x = frames[
            i2 + 2
            /*X*/
          ];
          y2 = frames[
            i2 + 3
            /*Y*/
          ];
          scaleX = frames[
            i2 + 4
            /*SCALEX*/
          ];
          scaleY = frames[
            i2 + 5
            /*SCALEY*/
          ];
          shearY = frames[
            i2 + 6
            /*SHEARY*/
          ];
          var t2 = (time - before) / (frames[
            i2 + 7
            /*ENTRIES*/
          ] - before);
          rotate += (frames[
            i2 + 7 + 1
            /*ROTATE*/
          ] - rotate) * t2;
          x += (frames[
            i2 + 7 + 2
            /*X*/
          ] - x) * t2;
          y2 += (frames[
            i2 + 7 + 3
            /*Y*/
          ] - y2) * t2;
          scaleX += (frames[
            i2 + 7 + 4
            /*SCALEX*/
          ] - scaleX) * t2;
          scaleY += (frames[
            i2 + 7 + 5
            /*SCALEY*/
          ] - scaleY) * t2;
          shearY += (frames[
            i2 + 7 + 6
            /*SHEARY*/
          ] - shearY) * t2;
          break;
        case 1:
          rotate = frames[
            i2 + 1
            /*ROTATE*/
          ];
          x = frames[
            i2 + 2
            /*X*/
          ];
          y2 = frames[
            i2 + 3
            /*Y*/
          ];
          scaleX = frames[
            i2 + 4
            /*SCALEX*/
          ];
          scaleY = frames[
            i2 + 5
            /*SCALEY*/
          ];
          shearY = frames[
            i2 + 6
            /*SHEARY*/
          ];
          break;
        default:
          rotate = this.getBezierValue(
            time,
            i2,
            1,
            curveType - 2
            /*BEZIER*/
          );
          x = this.getBezierValue(
            time,
            i2,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
          y2 = this.getBezierValue(
            time,
            i2,
            3,
            curveType + 18 * 2 - 2
            /*BEZIER*/
          );
          scaleX = this.getBezierValue(
            time,
            i2,
            4,
            curveType + 18 * 3 - 2
            /*BEZIER*/
          );
          scaleY = this.getBezierValue(
            time,
            i2,
            5,
            curveType + 18 * 4 - 2
            /*BEZIER*/
          );
          shearY = this.getBezierValue(
            time,
            i2,
            6,
            curveType + 18 * 5 - 2
            /*BEZIER*/
          );
      }
      if (blend == MixBlend.setup) {
        var data2 = constraint.data;
        constraint.mixRotate = data2.mixRotate + (rotate - data2.mixRotate) * alpha2;
        constraint.mixX = data2.mixX + (x - data2.mixX) * alpha2;
        constraint.mixY = data2.mixY + (y2 - data2.mixY) * alpha2;
        constraint.mixScaleX = data2.mixScaleX + (scaleX - data2.mixScaleX) * alpha2;
        constraint.mixScaleY = data2.mixScaleY + (scaleY - data2.mixScaleY) * alpha2;
        constraint.mixShearY = data2.mixShearY + (shearY - data2.mixShearY) * alpha2;
      } else {
        constraint.mixRotate += (rotate - constraint.mixRotate) * alpha2;
        constraint.mixX += (x - constraint.mixX) * alpha2;
        constraint.mixY += (y2 - constraint.mixY) * alpha2;
        constraint.mixScaleX += (scaleX - constraint.mixScaleX) * alpha2;
        constraint.mixScaleY += (scaleY - constraint.mixScaleY) * alpha2;
        constraint.mixShearY += (shearY - constraint.mixShearY) * alpha2;
      }
    };
    return TransformConstraintTimeline2;
  }(CurveTimeline)
);
var PathConstraintPositionTimeline = (
  /** @class */
  function(_super) {
    __extends$2(PathConstraintPositionTimeline2, _super);
    function PathConstraintPositionTimeline2(frameCount, bezierCount, pathConstraintIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.pathConstraintPosition + "|" + pathConstraintIndex) || this;
      _this.pathConstraintIndex = 0;
      _this.pathConstraintIndex = pathConstraintIndex;
      return _this;
    }
    PathConstraintPositionTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
      if (!constraint.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.position = constraint.data.position;
            return;
          case MixBlend.first:
            constraint.position += (constraint.data.position - constraint.position) * alpha2;
        }
        return;
      }
      var position2 = this.getCurveValue(time);
      if (blend == MixBlend.setup)
        constraint.position = constraint.data.position + (position2 - constraint.data.position) * alpha2;
      else
        constraint.position += (position2 - constraint.position) * alpha2;
    };
    return PathConstraintPositionTimeline2;
  }(CurveTimeline1)
);
var PathConstraintSpacingTimeline = (
  /** @class */
  function(_super) {
    __extends$2(PathConstraintSpacingTimeline2, _super);
    function PathConstraintSpacingTimeline2(frameCount, bezierCount, pathConstraintIndex) {
      var _this = _super.call(this, frameCount, bezierCount, Property.pathConstraintSpacing + "|" + pathConstraintIndex) || this;
      _this.pathConstraintIndex = 0;
      _this.pathConstraintIndex = pathConstraintIndex;
      return _this;
    }
    PathConstraintSpacingTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
      if (!constraint.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.spacing = constraint.data.spacing;
            return;
          case MixBlend.first:
            constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha2;
        }
        return;
      }
      var spacing = this.getCurveValue(time);
      if (blend == MixBlend.setup)
        constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha2;
      else
        constraint.spacing += (spacing - constraint.spacing) * alpha2;
    };
    return PathConstraintSpacingTimeline2;
  }(CurveTimeline1)
);
var PathConstraintMixTimeline = (
  /** @class */
  function(_super) {
    __extends$2(PathConstraintMixTimeline2, _super);
    function PathConstraintMixTimeline2(frameCount, bezierCount, pathConstraintIndex) {
      var _this = _super.call(this, frameCount, bezierCount, [
        Property.pathConstraintMix + "|" + pathConstraintIndex
      ]) || this;
      _this.pathConstraintIndex = 0;
      _this.pathConstraintIndex = pathConstraintIndex;
      return _this;
    }
    PathConstraintMixTimeline2.prototype.getFrameEntries = function() {
      return 4;
    };
    PathConstraintMixTimeline2.prototype.setFrame = function(frame2, time, mixRotate, mixX, mixY) {
      var frames = this.frames;
      frame2 <<= 2;
      frames[frame2] = time;
      frames[
        frame2 + 1
        /*ROTATE*/
      ] = mixRotate;
      frames[
        frame2 + 2
        /*X*/
      ] = mixX;
      frames[
        frame2 + 3
        /*Y*/
      ] = mixY;
    };
    PathConstraintMixTimeline2.prototype.apply = function(skeleton, lastTime2, time, firedEvents, alpha2, blend, direction) {
      var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
      if (!constraint.active)
        return;
      var frames = this.frames;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            constraint.mixRotate = constraint.data.mixRotate;
            constraint.mixX = constraint.data.mixX;
            constraint.mixY = constraint.data.mixY;
            return;
          case MixBlend.first:
            constraint.mixRotate += (constraint.data.mixRotate - constraint.mixRotate) * alpha2;
            constraint.mixX += (constraint.data.mixX - constraint.mixX) * alpha2;
            constraint.mixY += (constraint.data.mixY - constraint.mixY) * alpha2;
        }
        return;
      }
      var rotate, x, y2;
      var i2 = Timeline.search(
        frames,
        time,
        4
        /*ENTRIES*/
      );
      var curveType = this.curves[i2 >> 2];
      switch (curveType) {
        case 0:
          var before = frames[i2];
          rotate = frames[
            i2 + 1
            /*ROTATE*/
          ];
          x = frames[
            i2 + 2
            /*X*/
          ];
          y2 = frames[
            i2 + 3
            /*Y*/
          ];
          var t2 = (time - before) / (frames[
            i2 + 4
            /*ENTRIES*/
          ] - before);
          rotate += (frames[
            i2 + 4 + 1
            /*ROTATE*/
          ] - rotate) * t2;
          x += (frames[
            i2 + 4 + 2
            /*X*/
          ] - x) * t2;
          y2 += (frames[
            i2 + 4 + 3
            /*Y*/
          ] - y2) * t2;
          break;
        case 1:
          rotate = frames[
            i2 + 1
            /*ROTATE*/
          ];
          x = frames[
            i2 + 2
            /*X*/
          ];
          y2 = frames[
            i2 + 3
            /*Y*/
          ];
          break;
        default:
          rotate = this.getBezierValue(
            time,
            i2,
            1,
            curveType - 2
            /*BEZIER*/
          );
          x = this.getBezierValue(
            time,
            i2,
            2,
            curveType + 18 - 2
            /*BEZIER*/
          );
          y2 = this.getBezierValue(
            time,
            i2,
            3,
            curveType + 18 * 2 - 2
            /*BEZIER*/
          );
      }
      if (blend == MixBlend.setup) {
        var data2 = constraint.data;
        constraint.mixRotate = data2.mixRotate + (rotate - data2.mixRotate) * alpha2;
        constraint.mixX = data2.mixX + (x - data2.mixX) * alpha2;
        constraint.mixY = data2.mixY + (y2 - data2.mixY) * alpha2;
      } else {
        constraint.mixRotate += (rotate - constraint.mixRotate) * alpha2;
        constraint.mixX += (x - constraint.mixX) * alpha2;
        constraint.mixY += (y2 - constraint.mixY) * alpha2;
      }
    };
    return PathConstraintMixTimeline2;
  }(CurveTimeline)
);
var SequenceTimeline = (
  /** @class */
  function(_super) {
    __extends$2(SequenceTimeline2, _super);
    function SequenceTimeline2(frameCount, slotIndex, attachment) {
      var _this = _super.call(this, frameCount, [
        Property.sequence + "|" + slotIndex + "|" + attachment.sequence.id
      ]) || this;
      _this.slotIndex = slotIndex;
      _this.attachment = attachment;
      return _this;
    }
    SequenceTimeline2.prototype.getFrameEntries = function() {
      return SequenceTimeline2.ENTRIES;
    };
    SequenceTimeline2.prototype.getSlotIndex = function() {
      return this.slotIndex;
    };
    SequenceTimeline2.prototype.getAttachment = function() {
      return this.attachment;
    };
    SequenceTimeline2.prototype.setFrame = function(frame2, time, mode, index2, delay) {
      var frames = this.frames;
      frame2 *= SequenceTimeline2.ENTRIES;
      frames[frame2] = time;
      frames[frame2 + SequenceTimeline2.MODE] = mode | index2 << 4;
      frames[frame2 + SequenceTimeline2.DELAY] = delay;
    };
    SequenceTimeline2.prototype.apply = function(skeleton, lastTime2, time, events, alpha2, blend, direction) {
      var slot = skeleton.slots[this.slotIndex];
      if (!slot.bone.active)
        return;
      var slotAttachment = slot.attachment;
      var attachment = this.attachment;
      if (slotAttachment != attachment) {
        if (!(slotAttachment instanceof VertexAttachment) || slotAttachment.timelineAttachment != attachment)
          return;
      }
      var frames = this.frames;
      if (time < frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first)
          slot.sequenceIndex = -1;
        return;
      }
      var i2 = Timeline.search(frames, time, SequenceTimeline2.ENTRIES);
      var before = frames[i2];
      var modeAndIndex = frames[i2 + SequenceTimeline2.MODE];
      var delay = frames[i2 + SequenceTimeline2.DELAY];
      if (!this.attachment.sequence)
        return;
      var index2 = modeAndIndex >> 4, count = this.attachment.sequence.regions.length;
      var mode = SequenceModeValues[modeAndIndex & 15];
      if (mode != SequenceMode.hold) {
        index2 += (time - before) / delay + 1e-5 | 0;
        switch (mode) {
          case SequenceMode.once:
            index2 = Math.min(count - 1, index2);
            break;
          case SequenceMode.loop:
            index2 %= count;
            break;
          case SequenceMode.pingpong: {
            var n2 = (count << 1) - 2;
            index2 = n2 == 0 ? 0 : index2 % n2;
            if (index2 >= count)
              index2 = n2 - index2;
            break;
          }
          case SequenceMode.onceReverse:
            index2 = Math.max(count - 1 - index2, 0);
            break;
          case SequenceMode.loopReverse:
            index2 = count - 1 - index2 % count;
            break;
          case SequenceMode.pingpongReverse: {
            var n2 = (count << 1) - 2;
            index2 = n2 == 0 ? 0 : (index2 + count - 1) % n2;
            if (index2 >= count)
              index2 = n2 - index2;
          }
        }
      }
      slot.sequenceIndex = index2;
    };
    SequenceTimeline2.ENTRIES = 3;
    SequenceTimeline2.MODE = 1;
    SequenceTimeline2.DELAY = 2;
    return SequenceTimeline2;
  }(Timeline)
);
var AnimationState = (
  /** @class */
  function() {
    function AnimationState2(data2) {
      this.tracks = new Array();
      this.timeScale = 1;
      this.unkeyedState = 0;
      this.events = new Array();
      this.listeners = new Array();
      this.queue = new EventQueue(this);
      this.propertyIDs = new StringSet();
      this.animationsChanged = false;
      this.trackEntryPool = new Pool(function() {
        return new TrackEntry();
      });
      this.data = data2;
    }
    AnimationState2.emptyAnimation = function() {
      return AnimationState2._emptyAnimation;
    };
    AnimationState2.prototype.update = function(delta) {
      delta *= this.timeScale;
      var tracks = this.tracks;
      for (var i2 = 0, n2 = tracks.length; i2 < n2; i2++) {
        var current = tracks[i2];
        if (!current)
          continue;
        current.animationLast = current.nextAnimationLast;
        current.trackLast = current.nextTrackLast;
        var currentDelta = delta * current.timeScale;
        if (current.delay > 0) {
          current.delay -= currentDelta;
          if (current.delay > 0)
            continue;
          currentDelta = -current.delay;
          current.delay = 0;
        }
        var next2 = current.next;
        if (next2) {
          var nextTime = current.trackLast - next2.delay;
          if (nextTime >= 0) {
            next2.delay = 0;
            next2.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next2.timeScale;
            current.trackTime += currentDelta;
            this.setCurrent(i2, next2, true);
            while (next2.mixingFrom) {
              next2.mixTime += delta;
              next2 = next2.mixingFrom;
            }
            continue;
          }
        } else if (current.trackLast >= current.trackEnd && !current.mixingFrom) {
          tracks[i2] = null;
          this.queue.end(current);
          this.clearNext(current);
          continue;
        }
        if (current.mixingFrom && this.updateMixingFrom(current, delta)) {
          var from2 = current.mixingFrom;
          current.mixingFrom = null;
          if (from2)
            from2.mixingTo = null;
          while (from2) {
            this.queue.end(from2);
            from2 = from2.mixingFrom;
          }
        }
        current.trackTime += currentDelta;
      }
      this.queue.drain();
    };
    AnimationState2.prototype.updateMixingFrom = function(to, delta) {
      var from2 = to.mixingFrom;
      if (!from2)
        return true;
      var finished = this.updateMixingFrom(from2, delta);
      from2.animationLast = from2.nextAnimationLast;
      from2.trackLast = from2.nextTrackLast;
      if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {
        if (from2.totalAlpha == 0 || to.mixDuration == 0) {
          to.mixingFrom = from2.mixingFrom;
          if (from2.mixingFrom)
            from2.mixingFrom.mixingTo = to;
          to.interruptAlpha = from2.interruptAlpha;
          this.queue.end(from2);
        }
        return finished;
      }
      from2.trackTime += delta * from2.timeScale;
      to.mixTime += delta;
      return false;
    };
    AnimationState2.prototype.apply = function(skeleton) {
      if (!skeleton)
        throw new Error("skeleton cannot be null.");
      if (this.animationsChanged)
        this._animationsChanged();
      var events = this.events;
      var tracks = this.tracks;
      var applied = false;
      for (var i_1 = 0, n_1 = tracks.length; i_1 < n_1; i_1++) {
        var current = tracks[i_1];
        if (!current || current.delay > 0)
          continue;
        applied = true;
        var blend = i_1 == 0 ? MixBlend.first : current.mixBlend;
        var mix2 = current.alpha;
        if (current.mixingFrom)
          mix2 *= this.applyMixingFrom(current, skeleton, blend);
        else if (current.trackTime >= current.trackEnd && !current.next)
          mix2 = 0;
        var animationLast = current.animationLast, animationTime = current.getAnimationTime(), applyTime = animationTime;
        var applyEvents = events;
        if (current.reverse) {
          applyTime = current.animation.duration - applyTime;
          applyEvents = null;
        }
        var timelines = current.animation.timelines;
        var timelineCount = timelines.length;
        if (i_1 == 0 && mix2 == 1 || blend == MixBlend.add) {
          for (var ii2 = 0; ii2 < timelineCount; ii2++) {
            Utils.webkit602BugfixHelper(mix2, blend);
            var timeline = timelines[ii2];
            if (timeline instanceof AttachmentTimeline)
              this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);
            else
              timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix2, blend, MixDirection.mixIn);
          }
        } else {
          var timelineMode = current.timelineMode;
          var shortestRotation = current.shortestRotation;
          var firstFrame = !shortestRotation && current.timelinesRotation.length != timelineCount << 1;
          if (firstFrame)
            current.timelinesRotation.length = timelineCount << 1;
          for (var ii2 = 0; ii2 < timelineCount; ii2++) {
            var timeline_1 = timelines[ii2];
            var timelineBlend = timelineMode[ii2] == SUBSEQUENT ? blend : MixBlend.setup;
            if (!shortestRotation && timeline_1 instanceof RotateTimeline) {
              this.applyRotateTimeline(timeline_1, skeleton, applyTime, mix2, timelineBlend, current.timelinesRotation, ii2 << 1, firstFrame);
            } else if (timeline_1 instanceof AttachmentTimeline) {
              this.applyAttachmentTimeline(timeline_1, skeleton, applyTime, blend, true);
            } else {
              Utils.webkit602BugfixHelper(mix2, blend);
              timeline_1.apply(skeleton, animationLast, applyTime, applyEvents, mix2, timelineBlend, MixDirection.mixIn);
            }
          }
        }
        this.queueEvents(current, animationTime);
        events.length = 0;
        current.nextAnimationLast = animationTime;
        current.nextTrackLast = current.trackTime;
      }
      var setupState = this.unkeyedState + SETUP;
      var slots = skeleton.slots;
      for (var i2 = 0, n2 = skeleton.slots.length; i2 < n2; i2++) {
        var slot = slots[i2];
        if (slot.attachmentState == setupState) {
          var attachmentName = slot.data.attachmentName;
          slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));
        }
      }
      this.unkeyedState += 2;
      this.queue.drain();
      return applied;
    };
    AnimationState2.prototype.applyMixingFrom = function(to, skeleton, blend) {
      var from2 = to.mixingFrom;
      if (from2.mixingFrom)
        this.applyMixingFrom(from2, skeleton, blend);
      var mix2 = 0;
      if (to.mixDuration == 0) {
        mix2 = 1;
        if (blend == MixBlend.first)
          blend = MixBlend.setup;
      } else {
        mix2 = to.mixTime / to.mixDuration;
        if (mix2 > 1)
          mix2 = 1;
        if (blend != MixBlend.first)
          blend = from2.mixBlend;
      }
      var attachments = mix2 < from2.attachmentThreshold, drawOrder = mix2 < from2.drawOrderThreshold;
      var timelines = from2.animation.timelines;
      var timelineCount = timelines.length;
      var alphaHold = from2.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix2);
      var animationLast = from2.animationLast, animationTime = from2.getAnimationTime(), applyTime = animationTime;
      var events = null;
      if (from2.reverse)
        applyTime = from2.animation.duration - applyTime;
      else if (mix2 < from2.eventThreshold)
        events = this.events;
      if (blend == MixBlend.add) {
        for (var i2 = 0; i2 < timelineCount; i2++)
          timelines[i2].apply(skeleton, animationLast, applyTime, events, alphaMix, blend, MixDirection.mixOut);
      } else {
        var timelineMode = from2.timelineMode;
        var timelineHoldMix = from2.timelineHoldMix;
        var shortestRotation = from2.shortestRotation;
        var firstFrame = !shortestRotation && from2.timelinesRotation.length != timelineCount << 1;
        if (firstFrame)
          from2.timelinesRotation.length = timelineCount << 1;
        from2.totalAlpha = 0;
        for (var i2 = 0; i2 < timelineCount; i2++) {
          var timeline = timelines[i2];
          var direction = MixDirection.mixOut;
          var timelineBlend = void 0;
          var alpha2 = 0;
          switch (timelineMode[i2]) {
            case SUBSEQUENT:
              if (!drawOrder && timeline instanceof DrawOrderTimeline)
                continue;
              timelineBlend = blend;
              alpha2 = alphaMix;
              break;
            case FIRST:
              timelineBlend = MixBlend.setup;
              alpha2 = alphaMix;
              break;
            case HOLD_SUBSEQUENT:
              timelineBlend = blend;
              alpha2 = alphaHold;
              break;
            case HOLD_FIRST:
              timelineBlend = MixBlend.setup;
              alpha2 = alphaHold;
              break;
            default:
              timelineBlend = MixBlend.setup;
              var holdMix = timelineHoldMix[i2];
              alpha2 = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
              break;
          }
          from2.totalAlpha += alpha2;
          if (!shortestRotation && timeline instanceof RotateTimeline)
            this.applyRotateTimeline(timeline, skeleton, applyTime, alpha2, timelineBlend, from2.timelinesRotation, i2 << 1, firstFrame);
          else if (timeline instanceof AttachmentTimeline)
            this.applyAttachmentTimeline(timeline, skeleton, applyTime, timelineBlend, attachments);
          else {
            Utils.webkit602BugfixHelper(alpha2, blend);
            if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup)
              direction = MixDirection.mixIn;
            timeline.apply(skeleton, animationLast, applyTime, events, alpha2, timelineBlend, direction);
          }
        }
      }
      if (to.mixDuration > 0)
        this.queueEvents(from2, animationTime);
      this.events.length = 0;
      from2.nextAnimationLast = animationTime;
      from2.nextTrackLast = from2.trackTime;
      return mix2;
    };
    AnimationState2.prototype.applyAttachmentTimeline = function(timeline, skeleton, time, blend, attachments) {
      var slot = skeleton.slots[timeline.slotIndex];
      if (!slot.bone.active)
        return;
      if (time < timeline.frames[0]) {
        if (blend == MixBlend.setup || blend == MixBlend.first)
          this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);
      } else
        this.setAttachment(skeleton, slot, timeline.attachmentNames[Timeline.search1(timeline.frames, time)], attachments);
      if (slot.attachmentState <= this.unkeyedState)
        slot.attachmentState = this.unkeyedState + SETUP;
    };
    AnimationState2.prototype.setAttachment = function(skeleton, slot, attachmentName, attachments) {
      slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));
      if (attachments)
        slot.attachmentState = this.unkeyedState + CURRENT;
    };
    AnimationState2.prototype.applyRotateTimeline = function(timeline, skeleton, time, alpha2, blend, timelinesRotation, i2, firstFrame) {
      if (firstFrame)
        timelinesRotation[i2] = 0;
      if (alpha2 == 1) {
        timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);
        return;
      }
      var bone = skeleton.bones[timeline.boneIndex];
      if (!bone.active)
        return;
      var frames = timeline.frames;
      var r1 = 0, r2 = 0;
      if (time < frames[0]) {
        switch (blend) {
          case MixBlend.setup:
            bone.rotation = bone.data.rotation;
          default:
            return;
          case MixBlend.first:
            r1 = bone.rotation;
            r2 = bone.data.rotation;
        }
      } else {
        r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;
        r2 = bone.data.rotation + timeline.getCurveValue(time);
      }
      var total = 0, diff = r2 - r1;
      diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;
      if (diff == 0) {
        total = timelinesRotation[i2];
      } else {
        var lastTotal = 0, lastDiff = 0;
        if (firstFrame) {
          lastTotal = 0;
          lastDiff = diff;
        } else {
          lastTotal = timelinesRotation[i2];
          lastDiff = timelinesRotation[i2 + 1];
        }
        var current = diff > 0, dir = lastTotal >= 0;
        if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
          if (Math.abs(lastTotal) > 180)
            lastTotal += 360 * MathUtils.signum(lastTotal);
          dir = current;
        }
        total = diff + lastTotal - lastTotal % 360;
        if (dir != current)
          total += 360 * MathUtils.signum(lastTotal);
        timelinesRotation[i2] = total;
      }
      timelinesRotation[i2 + 1] = diff;
      bone.rotation = r1 + total * alpha2;
    };
    AnimationState2.prototype.queueEvents = function(entry, animationTime) {
      var animationStart = entry.animationStart, animationEnd = entry.animationEnd;
      var duration = animationEnd - animationStart;
      var trackLastWrapped = entry.trackLast % duration;
      var events = this.events;
      var i2 = 0, n2 = events.length;
      for (; i2 < n2; i2++) {
        var event_1 = events[i2];
        if (event_1.time < trackLastWrapped)
          break;
        if (event_1.time > animationEnd)
          continue;
        this.queue.event(entry, event_1);
      }
      var complete = false;
      if (entry.loop)
        complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;
      else
        complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
      if (complete)
        this.queue.complete(entry);
      for (; i2 < n2; i2++) {
        var event_2 = events[i2];
        if (event_2.time < animationStart)
          continue;
        this.queue.event(entry, event_2);
      }
    };
    AnimationState2.prototype.clearTracks = function() {
      var oldDrainDisabled = this.queue.drainDisabled;
      this.queue.drainDisabled = true;
      for (var i2 = 0, n2 = this.tracks.length; i2 < n2; i2++)
        this.clearTrack(i2);
      this.tracks.length = 0;
      this.queue.drainDisabled = oldDrainDisabled;
      this.queue.drain();
    };
    AnimationState2.prototype.clearTrack = function(trackIndex) {
      if (trackIndex >= this.tracks.length)
        return;
      var current = this.tracks[trackIndex];
      if (!current)
        return;
      this.queue.end(current);
      this.clearNext(current);
      var entry = current;
      while (true) {
        var from2 = entry.mixingFrom;
        if (!from2)
          break;
        this.queue.end(from2);
        entry.mixingFrom = null;
        entry.mixingTo = null;
        entry = from2;
      }
      this.tracks[current.trackIndex] = null;
      this.queue.drain();
    };
    AnimationState2.prototype.setCurrent = function(index2, current, interrupt) {
      var from2 = this.expandToIndex(index2);
      this.tracks[index2] = current;
      current.previous = null;
      if (from2) {
        if (interrupt)
          this.queue.interrupt(from2);
        current.mixingFrom = from2;
        from2.mixingTo = current;
        current.mixTime = 0;
        if (from2.mixingFrom && from2.mixDuration > 0)
          current.interruptAlpha *= Math.min(1, from2.mixTime / from2.mixDuration);
        from2.timelinesRotation.length = 0;
      }
      this.queue.start(current);
    };
    AnimationState2.prototype.setAnimation = function(trackIndex, animationName, loop) {
      if (loop === void 0) {
        loop = false;
      }
      var animation2 = this.data.skeletonData.findAnimation(animationName);
      if (!animation2)
        throw new Error("Animation not found: " + animationName);
      return this.setAnimationWith(trackIndex, animation2, loop);
    };
    AnimationState2.prototype.setAnimationWith = function(trackIndex, animation2, loop) {
      if (loop === void 0) {
        loop = false;
      }
      if (!animation2)
        throw new Error("animation cannot be null.");
      var interrupt = true;
      var current = this.expandToIndex(trackIndex);
      if (current) {
        if (current.nextTrackLast == -1) {
          this.tracks[trackIndex] = current.mixingFrom;
          this.queue.interrupt(current);
          this.queue.end(current);
          this.clearNext(current);
          current = current.mixingFrom;
          interrupt = false;
        } else
          this.clearNext(current);
      }
      var entry = this.trackEntry(trackIndex, animation2, loop, current);
      this.setCurrent(trackIndex, entry, interrupt);
      this.queue.drain();
      return entry;
    };
    AnimationState2.prototype.addAnimation = function(trackIndex, animationName, loop, delay) {
      if (loop === void 0) {
        loop = false;
      }
      if (delay === void 0) {
        delay = 0;
      }
      var animation2 = this.data.skeletonData.findAnimation(animationName);
      if (!animation2)
        throw new Error("Animation not found: " + animationName);
      return this.addAnimationWith(trackIndex, animation2, loop, delay);
    };
    AnimationState2.prototype.addAnimationWith = function(trackIndex, animation2, loop, delay) {
      if (loop === void 0) {
        loop = false;
      }
      if (delay === void 0) {
        delay = 0;
      }
      if (!animation2)
        throw new Error("animation cannot be null.");
      var last = this.expandToIndex(trackIndex);
      if (last) {
        while (last.next)
          last = last.next;
      }
      var entry = this.trackEntry(trackIndex, animation2, loop, last);
      if (!last) {
        this.setCurrent(trackIndex, entry, true);
        this.queue.drain();
      } else {
        last.next = entry;
        entry.previous = last;
        if (delay <= 0)
          delay += last.getTrackComplete() - entry.mixDuration;
      }
      entry.delay = delay;
      return entry;
    };
    AnimationState2.prototype.setEmptyAnimation = function(trackIndex, mixDuration) {
      if (mixDuration === void 0) {
        mixDuration = 0;
      }
      var entry = this.setAnimationWith(trackIndex, AnimationState2.emptyAnimation(), false);
      entry.mixDuration = mixDuration;
      entry.trackEnd = mixDuration;
      return entry;
    };
    AnimationState2.prototype.addEmptyAnimation = function(trackIndex, mixDuration, delay) {
      if (mixDuration === void 0) {
        mixDuration = 0;
      }
      if (delay === void 0) {
        delay = 0;
      }
      var entry = this.addAnimationWith(trackIndex, AnimationState2.emptyAnimation(), false, delay);
      if (delay <= 0)
        entry.delay += entry.mixDuration - mixDuration;
      entry.mixDuration = mixDuration;
      entry.trackEnd = mixDuration;
      return entry;
    };
    AnimationState2.prototype.setEmptyAnimations = function(mixDuration) {
      if (mixDuration === void 0) {
        mixDuration = 0;
      }
      var oldDrainDisabled = this.queue.drainDisabled;
      this.queue.drainDisabled = true;
      for (var i2 = 0, n2 = this.tracks.length; i2 < n2; i2++) {
        var current = this.tracks[i2];
        if (current)
          this.setEmptyAnimation(current.trackIndex, mixDuration);
      }
      this.queue.drainDisabled = oldDrainDisabled;
      this.queue.drain();
    };
    AnimationState2.prototype.expandToIndex = function(index2) {
      if (index2 < this.tracks.length)
        return this.tracks[index2];
      Utils.ensureArrayCapacity(this.tracks, index2 + 1, null);
      this.tracks.length = index2 + 1;
      return null;
    };
    AnimationState2.prototype.trackEntry = function(trackIndex, animation2, loop, last) {
      var entry = this.trackEntryPool.obtain();
      entry.reset();
      entry.trackIndex = trackIndex;
      entry.animation = animation2;
      entry.loop = loop;
      entry.holdPrevious = false;
      entry.reverse = false;
      entry.shortestRotation = false;
      entry.eventThreshold = 0;
      entry.attachmentThreshold = 0;
      entry.drawOrderThreshold = 0;
      entry.animationStart = 0;
      entry.animationEnd = animation2.duration;
      entry.animationLast = -1;
      entry.nextAnimationLast = -1;
      entry.delay = 0;
      entry.trackTime = 0;
      entry.trackLast = -1;
      entry.nextTrackLast = -1;
      entry.trackEnd = Number.MAX_VALUE;
      entry.timeScale = 1;
      entry.alpha = 1;
      entry.mixTime = 0;
      entry.mixDuration = !last ? 0 : this.data.getMix(last.animation, animation2);
      entry.interruptAlpha = 1;
      entry.totalAlpha = 0;
      entry.mixBlend = MixBlend.replace;
      return entry;
    };
    AnimationState2.prototype.clearNext = function(entry) {
      var next2 = entry.next;
      while (next2) {
        this.queue.dispose(next2);
        next2 = next2.next;
      }
      entry.next = null;
    };
    AnimationState2.prototype._animationsChanged = function() {
      this.animationsChanged = false;
      this.propertyIDs.clear();
      var tracks = this.tracks;
      for (var i2 = 0, n2 = tracks.length; i2 < n2; i2++) {
        var entry = tracks[i2];
        if (!entry)
          continue;
        while (entry.mixingFrom)
          entry = entry.mixingFrom;
        do {
          if (!entry.mixingTo || entry.mixBlend != MixBlend.add)
            this.computeHold(entry);
          entry = entry.mixingTo;
        } while (entry);
      }
    };
    AnimationState2.prototype.computeHold = function(entry) {
      var to = entry.mixingTo;
      var timelines = entry.animation.timelines;
      var timelinesCount = entry.animation.timelines.length;
      var timelineMode = entry.timelineMode;
      timelineMode.length = timelinesCount;
      var timelineHoldMix = entry.timelineHoldMix;
      timelineHoldMix.length = 0;
      var propertyIDs = this.propertyIDs;
      if (to && to.holdPrevious) {
        for (var i2 = 0; i2 < timelinesCount; i2++)
          timelineMode[i2] = propertyIDs.addAll(timelines[i2].getPropertyIds()) ? HOLD_FIRST : HOLD_SUBSEQUENT;
        return;
      }
      outer:
        for (var i2 = 0; i2 < timelinesCount; i2++) {
          var timeline = timelines[i2];
          var ids = timeline.getPropertyIds();
          if (!propertyIDs.addAll(ids))
            timelineMode[i2] = SUBSEQUENT;
          else if (!to || timeline instanceof AttachmentTimeline || timeline instanceof DrawOrderTimeline || timeline instanceof EventTimeline || !to.animation.hasTimeline(ids)) {
            timelineMode[i2] = FIRST;
          } else {
            for (var next2 = to.mixingTo; next2; next2 = next2.mixingTo) {
              if (next2.animation.hasTimeline(ids))
                continue;
              if (entry.mixDuration > 0) {
                timelineMode[i2] = HOLD_MIX;
                timelineHoldMix[i2] = next2;
                continue outer;
              }
              break;
            }
            timelineMode[i2] = HOLD_FIRST;
          }
        }
    };
    AnimationState2.prototype.getCurrent = function(trackIndex) {
      if (trackIndex >= this.tracks.length)
        return null;
      return this.tracks[trackIndex];
    };
    AnimationState2.prototype.addListener = function(listener) {
      if (!listener)
        throw new Error("listener cannot be null.");
      this.listeners.push(listener);
    };
    AnimationState2.prototype.removeListener = function(listener) {
      var index2 = this.listeners.indexOf(listener);
      if (index2 >= 0)
        this.listeners.splice(index2, 1);
    };
    AnimationState2.prototype.clearListeners = function() {
      this.listeners.length = 0;
    };
    AnimationState2.prototype.clearListenerNotifications = function() {
      this.queue.clear();
    };
    AnimationState2.prototype.setAnimationByName = function(trackIndex, animationName, loop) {
      if (!AnimationState2.deprecatedWarning1) {
        AnimationState2.deprecatedWarning1 = true;
        console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.");
      }
      this.setAnimation(trackIndex, animationName, loop);
    };
    AnimationState2.prototype.addAnimationByName = function(trackIndex, animationName, loop, delay) {
      if (!AnimationState2.deprecatedWarning2) {
        AnimationState2.deprecatedWarning2 = true;
        console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.");
      }
      this.addAnimation(trackIndex, animationName, loop, delay);
    };
    AnimationState2.prototype.hasAnimation = function(animationName) {
      var animation2 = this.data.skeletonData.findAnimation(animationName);
      return animation2 !== null;
    };
    AnimationState2.prototype.hasAnimationByName = function(animationName) {
      if (!AnimationState2.deprecatedWarning3) {
        AnimationState2.deprecatedWarning3 = true;
        console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.");
      }
      return this.hasAnimation(animationName);
    };
    AnimationState2._emptyAnimation = new Animation("<empty>", [], 0);
    AnimationState2.deprecatedWarning1 = false;
    AnimationState2.deprecatedWarning2 = false;
    AnimationState2.deprecatedWarning3 = false;
    return AnimationState2;
  }()
);
var TrackEntry = (
  /** @class */
  function() {
    function TrackEntry2() {
      this.animation = null;
      this.previous = null;
      this.next = null;
      this.mixingFrom = null;
      this.mixingTo = null;
      this.listener = null;
      this.trackIndex = 0;
      this.loop = false;
      this.holdPrevious = false;
      this.reverse = false;
      this.shortestRotation = false;
      this.eventThreshold = 0;
      this.attachmentThreshold = 0;
      this.drawOrderThreshold = 0;
      this.animationStart = 0;
      this.animationEnd = 0;
      this.animationLast = 0;
      this.nextAnimationLast = 0;
      this.delay = 0;
      this.trackTime = 0;
      this.trackLast = 0;
      this.nextTrackLast = 0;
      this.trackEnd = 0;
      this.timeScale = 0;
      this.alpha = 0;
      this.mixTime = 0;
      this.mixDuration = 0;
      this.interruptAlpha = 0;
      this.totalAlpha = 0;
      this.mixBlend = MixBlend.replace;
      this.timelineMode = new Array();
      this.timelineHoldMix = new Array();
      this.timelinesRotation = new Array();
    }
    TrackEntry2.prototype.reset = function() {
      this.next = null;
      this.previous = null;
      this.mixingFrom = null;
      this.mixingTo = null;
      this.animation = null;
      this.listener = null;
      this.timelineMode.length = 0;
      this.timelineHoldMix.length = 0;
      this.timelinesRotation.length = 0;
    };
    TrackEntry2.prototype.getAnimationTime = function() {
      if (this.loop) {
        var duration = this.animationEnd - this.animationStart;
        if (duration == 0)
          return this.animationStart;
        return this.trackTime % duration + this.animationStart;
      }
      return Math.min(this.trackTime + this.animationStart, this.animationEnd);
    };
    TrackEntry2.prototype.setAnimationLast = function(animationLast) {
      this.animationLast = animationLast;
      this.nextAnimationLast = animationLast;
    };
    TrackEntry2.prototype.isComplete = function() {
      return this.trackTime >= this.animationEnd - this.animationStart;
    };
    TrackEntry2.prototype.resetRotationDirections = function() {
      this.timelinesRotation.length = 0;
    };
    TrackEntry2.prototype.getTrackComplete = function() {
      var duration = this.animationEnd - this.animationStart;
      if (duration != 0) {
        if (this.loop)
          return duration * (1 + (this.trackTime / duration | 0));
        if (this.trackTime < duration)
          return duration;
      }
      return this.trackTime;
    };
    Object.defineProperty(TrackEntry2.prototype, "time", {
      get: function() {
        if (!TrackEntry2.deprecatedWarning1) {
          TrackEntry2.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
        }
        return this.trackTime;
      },
      set: function(value) {
        if (!TrackEntry2.deprecatedWarning1) {
          TrackEntry2.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
        }
        this.trackTime = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TrackEntry2.prototype, "endTime", {
      get: function() {
        if (!TrackEntry2.deprecatedWarning2) {
          TrackEntry2.deprecatedWarning2 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
        }
        return this.trackTime;
      },
      set: function(value) {
        if (!TrackEntry2.deprecatedWarning2) {
          TrackEntry2.deprecatedWarning2 = true;
          console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
        }
        this.trackTime = value;
      },
      enumerable: false,
      configurable: true
    });
    TrackEntry2.prototype.loopsCount = function() {
      return Math.floor(this.trackTime / this.trackEnd);
    };
    TrackEntry2.deprecatedWarning1 = false;
    TrackEntry2.deprecatedWarning2 = false;
    return TrackEntry2;
  }()
);
var EventQueue = (
  /** @class */
  function() {
    function EventQueue2(animState) {
      this.objects = [];
      this.drainDisabled = false;
      this.animState = animState;
    }
    EventQueue2.prototype.start = function(entry) {
      this.objects.push(EventType.start);
      this.objects.push(entry);
      this.animState.animationsChanged = true;
    };
    EventQueue2.prototype.interrupt = function(entry) {
      this.objects.push(EventType.interrupt);
      this.objects.push(entry);
    };
    EventQueue2.prototype.end = function(entry) {
      this.objects.push(EventType.end);
      this.objects.push(entry);
      this.animState.animationsChanged = true;
    };
    EventQueue2.prototype.dispose = function(entry) {
      this.objects.push(EventType.dispose);
      this.objects.push(entry);
    };
    EventQueue2.prototype.complete = function(entry) {
      this.objects.push(EventType.complete);
      this.objects.push(entry);
    };
    EventQueue2.prototype.event = function(entry, event) {
      this.objects.push(EventType.event);
      this.objects.push(entry);
      this.objects.push(event);
    };
    EventQueue2.prototype.drain = function() {
      if (this.drainDisabled)
        return;
      this.drainDisabled = true;
      var objects = this.objects;
      var listeners = this.animState.listeners;
      for (var i2 = 0; i2 < objects.length; i2 += 2) {
        var type2 = objects[i2];
        var entry = objects[i2 + 1];
        switch (type2) {
          case EventType.start:
            if (entry.listener && entry.listener.start)
              entry.listener.start(entry);
            for (var ii2 = 0; ii2 < listeners.length; ii2++) {
              var listener = listeners[ii2];
              if (listener.start)
                listener.start(entry);
            }
            break;
          case EventType.interrupt:
            if (entry.listener && entry.listener.interrupt)
              entry.listener.interrupt(entry);
            for (var ii2 = 0; ii2 < listeners.length; ii2++) {
              var listener = listeners[ii2];
              if (listener.interrupt)
                listener.interrupt(entry);
            }
            break;
          case EventType.end:
            if (entry.listener && entry.listener.end)
              entry.listener.end(entry);
            for (var ii2 = 0; ii2 < listeners.length; ii2++) {
              var listener = listeners[ii2];
              if (listener.end)
                listener.end(entry);
            }
          case EventType.dispose:
            if (entry.listener && entry.listener.dispose)
              entry.listener.dispose(entry);
            for (var ii2 = 0; ii2 < listeners.length; ii2++) {
              var listener = listeners[ii2];
              if (listener.dispose)
                listener.dispose(entry);
            }
            this.animState.trackEntryPool.free(entry);
            break;
          case EventType.complete:
            if (entry.listener && entry.listener.complete)
              entry.listener.complete(entry);
            for (var ii2 = 0; ii2 < listeners.length; ii2++) {
              var listener = listeners[ii2];
              if (listener.complete)
                listener.complete(entry);
            }
            break;
          case EventType.event:
            var event_3 = objects[i2++ + 2];
            if (entry.listener && entry.listener.event)
              entry.listener.event(entry, event_3);
            for (var ii2 = 0; ii2 < listeners.length; ii2++) {
              var listener = listeners[ii2];
              if (listener.event)
                listener.event(entry, event_3);
            }
            break;
        }
      }
      this.clear();
      this.drainDisabled = false;
    };
    EventQueue2.prototype.clear = function() {
      this.objects.length = 0;
    };
    return EventQueue2;
  }()
);
var EventType;
(function(EventType2) {
  EventType2[EventType2["start"] = 0] = "start";
  EventType2[EventType2["interrupt"] = 1] = "interrupt";
  EventType2[EventType2["end"] = 2] = "end";
  EventType2[EventType2["dispose"] = 3] = "dispose";
  EventType2[EventType2["complete"] = 4] = "complete";
  EventType2[EventType2["event"] = 5] = "event";
})(EventType || (EventType = {}));
var AnimationStateAdapter = (
  /** @class */
  function() {
    function AnimationStateAdapter3() {
    }
    AnimationStateAdapter3.prototype.start = function(entry) {
    };
    AnimationStateAdapter3.prototype.interrupt = function(entry) {
    };
    AnimationStateAdapter3.prototype.end = function(entry) {
    };
    AnimationStateAdapter3.prototype.dispose = function(entry) {
    };
    AnimationStateAdapter3.prototype.complete = function(entry) {
    };
    AnimationStateAdapter3.prototype.event = function(entry, event) {
    };
    return AnimationStateAdapter3;
  }()
);
var SUBSEQUENT = 0;
var FIRST = 1;
var HOLD_SUBSEQUENT = 2;
var HOLD_FIRST = 3;
var HOLD_MIX = 4;
var SETUP = 1;
var CURRENT = 2;
var AnimationStateData = (
  /** @class */
  function() {
    function AnimationStateData2(skeletonData) {
      this.animationToMixTime = {};
      this.defaultMix = 0;
      if (!skeletonData)
        throw new Error("skeletonData cannot be null.");
      this.skeletonData = skeletonData;
    }
    AnimationStateData2.prototype.setMix = function(fromName, toName, duration) {
      var from2 = this.skeletonData.findAnimation(fromName);
      if (!from2)
        throw new Error("Animation not found: " + fromName);
      var to = this.skeletonData.findAnimation(toName);
      if (!to)
        throw new Error("Animation not found: " + toName);
      this.setMixWith(from2, to, duration);
    };
    AnimationStateData2.prototype.setMixWith = function(from2, to, duration) {
      if (!from2)
        throw new Error("from cannot be null.");
      if (!to)
        throw new Error("to cannot be null.");
      var key = from2.name + "." + to.name;
      this.animationToMixTime[key] = duration;
    };
    AnimationStateData2.prototype.getMix = function(from2, to) {
      var key = from2.name + "." + to.name;
      var value = this.animationToMixTime[key];
      return value === void 0 ? this.defaultMix : value;
    };
    return AnimationStateData2;
  }()
);
var AtlasAttachmentLoader = (
  /** @class */
  function() {
    function AtlasAttachmentLoader2(atlas) {
      this.atlas = atlas;
    }
    AtlasAttachmentLoader2.prototype.loadSequence = function(name, basePath, sequence) {
      var regions = sequence.regions;
      for (var i2 = 0, n2 = regions.length; i2 < n2; i2++) {
        var path = sequence.getPath(basePath, i2);
        var region = this.atlas.findRegion(path);
        if (region == null)
          throw new Error("Region not found in atlas: " + path + " (sequence: " + name + ")");
        regions[i2] = region;
        regions[i2].renderObject = regions[i2];
      }
    };
    AtlasAttachmentLoader2.prototype.newRegionAttachment = function(skin, name, path, sequence) {
      var attachment = new RegionAttachment(name, path);
      if (sequence != null) {
        this.loadSequence(name, path, sequence);
      } else {
        var region = this.atlas.findRegion(path);
        if (!region)
          throw new Error("Region not found in atlas: " + path + " (region attachment: " + name + ")");
        region.renderObject = region;
        attachment.region = region;
      }
      return attachment;
    };
    AtlasAttachmentLoader2.prototype.newMeshAttachment = function(skin, name, path, sequence) {
      var attachment = new MeshAttachment(name, path);
      if (sequence != null) {
        this.loadSequence(name, path, sequence);
      } else {
        var region = this.atlas.findRegion(path);
        if (!region)
          throw new Error("Region not found in atlas: " + path + " (mesh attachment: " + name + ")");
        region.renderObject = region;
        attachment.region = region;
      }
      return attachment;
    };
    AtlasAttachmentLoader2.prototype.newBoundingBoxAttachment = function(skin, name) {
      return new BoundingBoxAttachment(name);
    };
    AtlasAttachmentLoader2.prototype.newPathAttachment = function(skin, name) {
      return new PathAttachment(name);
    };
    AtlasAttachmentLoader2.prototype.newPointAttachment = function(skin, name) {
      return new PointAttachment(name);
    };
    AtlasAttachmentLoader2.prototype.newClippingAttachment = function(skin, name) {
      return new ClippingAttachment(name);
    };
    return AtlasAttachmentLoader2;
  }()
);
var Bone = (
  /** @class */
  function() {
    function Bone2(data2, skeleton, parent) {
      this.matrix = new Matrix();
      this.parent = null;
      this.children = new Array();
      this.x = 0;
      this.y = 0;
      this.rotation = 0;
      this.scaleX = 0;
      this.scaleY = 0;
      this.shearX = 0;
      this.shearY = 0;
      this.ax = 0;
      this.ay = 0;
      this.arotation = 0;
      this.ascaleX = 0;
      this.ascaleY = 0;
      this.ashearX = 0;
      this.ashearY = 0;
      this.sorted = false;
      this.active = false;
      if (!data2)
        throw new Error("data cannot be null.");
      if (!skeleton)
        throw new Error("skeleton cannot be null.");
      this.data = data2;
      this.skeleton = skeleton;
      this.parent = parent;
      this.setToSetupPose();
    }
    Object.defineProperty(Bone2.prototype, "worldX", {
      get: function() {
        return this.matrix.tx;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bone2.prototype, "worldY", {
      get: function() {
        return this.matrix.ty;
      },
      enumerable: false,
      configurable: true
    });
    Bone2.prototype.isActive = function() {
      return this.active;
    };
    Bone2.prototype.update = function() {
      this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY);
    };
    Bone2.prototype.updateWorldTransform = function() {
      this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
    };
    Bone2.prototype.updateWorldTransformWith = function(x, y2, rotation, scaleX, scaleY, shearX, shearY) {
      this.ax = x;
      this.ay = y2;
      this.arotation = rotation;
      this.ascaleX = scaleX;
      this.ascaleY = scaleY;
      this.ashearX = shearX;
      this.ashearY = shearY;
      var parent = this.parent;
      var m2 = this.matrix;
      var sx = this.skeleton.scaleX;
      var sy = -this.skeleton.scaleY;
      if (!parent) {
        var skeleton = this.skeleton;
        var rotationY = rotation + 90 + shearY;
        m2.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;
        m2.c = MathUtils.cosDeg(rotationY) * scaleY * sx;
        m2.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;
        m2.d = MathUtils.sinDeg(rotationY) * scaleY * sy;
        m2.tx = x * sx + skeleton.x;
        m2.ty = y2 * sy + skeleton.y;
        return;
      }
      var pa2 = parent.matrix.a, pb2 = parent.matrix.c, pc2 = parent.matrix.b, pd2 = parent.matrix.d;
      m2.tx = pa2 * x + pb2 * y2 + parent.matrix.tx;
      m2.ty = pc2 * x + pd2 * y2 + parent.matrix.ty;
      switch (this.data.transformMode) {
        case TransformMode.Normal: {
          var rotationY = rotation + 90 + shearY;
          var la2 = MathUtils.cosDeg(rotation + shearX) * scaleX;
          var lb2 = MathUtils.cosDeg(rotationY) * scaleY;
          var lc2 = MathUtils.sinDeg(rotation + shearX) * scaleX;
          var ld2 = MathUtils.sinDeg(rotationY) * scaleY;
          m2.a = pa2 * la2 + pb2 * lc2;
          m2.c = pa2 * lb2 + pb2 * ld2;
          m2.b = pc2 * la2 + pd2 * lc2;
          m2.d = pc2 * lb2 + pd2 * ld2;
          return;
        }
        case TransformMode.OnlyTranslation: {
          var rotationY = rotation + 90 + shearY;
          m2.a = MathUtils.cosDeg(rotation + shearX) * scaleX;
          m2.c = MathUtils.cosDeg(rotationY) * scaleY;
          m2.b = MathUtils.sinDeg(rotation + shearX) * scaleX;
          m2.d = MathUtils.sinDeg(rotationY) * scaleY;
          break;
        }
        case TransformMode.NoRotationOrReflection: {
          var s2 = pa2 * pa2 + pc2 * pc2;
          var prx = 0;
          if (s2 > 1e-4) {
            s2 = Math.abs(pa2 * pd2 - pb2 * pc2) / s2;
            pa2 /= sx;
            pc2 /= sy;
            pb2 = pc2 * s2;
            pd2 = pa2 * s2;
            prx = Math.atan2(pc2, pa2) * MathUtils.radDeg;
          } else {
            pa2 = 0;
            pc2 = 0;
            prx = 90 - Math.atan2(pd2, pb2) * MathUtils.radDeg;
          }
          var rx = rotation + shearX - prx;
          var ry = rotation + shearY - prx + 90;
          var la2 = MathUtils.cosDeg(rx) * scaleX;
          var lb2 = MathUtils.cosDeg(ry) * scaleY;
          var lc2 = MathUtils.sinDeg(rx) * scaleX;
          var ld2 = MathUtils.sinDeg(ry) * scaleY;
          m2.a = pa2 * la2 - pb2 * lc2;
          m2.c = pa2 * lb2 - pb2 * ld2;
          m2.b = pc2 * la2 + pd2 * lc2;
          m2.d = pc2 * lb2 + pd2 * ld2;
          break;
        }
        case TransformMode.NoScale:
        case TransformMode.NoScaleOrReflection: {
          var cos = MathUtils.cosDeg(rotation);
          var sin = MathUtils.sinDeg(rotation);
          var za2 = (pa2 * cos + pb2 * sin) / sx;
          var zc2 = (pc2 * cos + pd2 * sin) / sy;
          var s2 = Math.sqrt(za2 * za2 + zc2 * zc2);
          if (s2 > 1e-5)
            s2 = 1 / s2;
          za2 *= s2;
          zc2 *= s2;
          s2 = Math.sqrt(za2 * za2 + zc2 * zc2);
          if (this.data.transformMode == TransformMode.NoScale && pa2 * pd2 - pb2 * pc2 < 0 != (sx < 0 != sy < 0))
            s2 = -s2;
          var r2 = Math.PI / 2 + Math.atan2(zc2, za2);
          var zb2 = Math.cos(r2) * s2;
          var zd2 = Math.sin(r2) * s2;
          var la2 = MathUtils.cosDeg(shearX) * scaleX;
          var lb2 = MathUtils.cosDeg(90 + shearY) * scaleY;
          var lc2 = MathUtils.sinDeg(shearX) * scaleX;
          var ld2 = MathUtils.sinDeg(90 + shearY) * scaleY;
          m2.a = za2 * la2 + zb2 * lc2;
          m2.c = za2 * lb2 + zb2 * ld2;
          m2.b = zc2 * la2 + zd2 * lc2;
          m2.d = zc2 * lb2 + zd2 * ld2;
          break;
        }
      }
      m2.a *= sx;
      m2.c *= sx;
      m2.b *= sy;
      m2.d *= sy;
    };
    Bone2.prototype.setToSetupPose = function() {
      var data2 = this.data;
      this.x = data2.x;
      this.y = data2.y;
      this.rotation = data2.rotation;
      this.scaleX = data2.scaleX;
      this.scaleY = data2.scaleY;
      this.shearX = data2.shearX;
      this.shearY = data2.shearY;
    };
    Bone2.prototype.getWorldRotationX = function() {
      return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;
    };
    Bone2.prototype.getWorldRotationY = function() {
      return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;
    };
    Bone2.prototype.getWorldScaleX = function() {
      var m2 = this.matrix;
      return Math.sqrt(m2.a * m2.a + m2.b * m2.b);
    };
    Bone2.prototype.getWorldScaleY = function() {
      var m2 = this.matrix;
      return Math.sqrt(m2.c * m2.c + m2.d * m2.d);
    };
    Bone2.prototype.updateAppliedTransform = function() {
      var parent = this.parent;
      var m2 = this.matrix;
      if (!parent) {
        this.ax = m2.tx - this.skeleton.x;
        this.ay = m2.ty - this.skeleton.y;
        this.arotation = Math.atan2(m2.b, m2.a) * MathUtils.radDeg;
        this.ascaleX = Math.sqrt(m2.a * m2.a + m2.b * m2.b);
        this.ascaleY = Math.sqrt(m2.c * m2.c + m2.d * m2.d);
        this.ashearX = 0;
        this.ashearY = Math.atan2(m2.a * m2.c + m2.b * m2.d, m2.a * m2.d - m2.b * m2.c) * MathUtils.radDeg;
        return;
      }
      var pm = parent.matrix;
      var pid = 1 / (pm.a * pm.d - pm.b * pm.c);
      var dx = m2.tx - pm.tx, dy = m2.ty - pm.ty;
      this.ax = dx * pm.d * pid - dy * pm.c * pid;
      this.ay = dy * pm.a * pid - dx * pm.b * pid;
      var ia2 = pid * pm.d;
      var id2 = pid * pm.a;
      var ib2 = pid * pm.c;
      var ic2 = pid * pm.b;
      var ra2 = ia2 * m2.a - ib2 * m2.b;
      var rb2 = ia2 * m2.c - ib2 * m2.d;
      var rc2 = id2 * m2.b - ic2 * m2.a;
      var rd2 = id2 * m2.d - ic2 * m2.c;
      this.ashearX = 0;
      this.ascaleX = Math.sqrt(ra2 * ra2 + rc2 * rc2);
      if (this.ascaleX > 1e-4) {
        var det = ra2 * rd2 - rb2 * rc2;
        this.ascaleY = det / this.ascaleX;
        this.ashearY = Math.atan2(ra2 * rb2 + rc2 * rd2, det) * MathUtils.radDeg;
        this.arotation = Math.atan2(rc2, ra2) * MathUtils.radDeg;
      } else {
        this.ascaleX = 0;
        this.ascaleY = Math.sqrt(rb2 * rb2 + rd2 * rd2);
        this.ashearY = 0;
        this.arotation = 90 - Math.atan2(rd2, rb2) * MathUtils.radDeg;
      }
    };
    Bone2.prototype.worldToLocal = function(world) {
      var m2 = this.matrix;
      var a2 = m2.a, b2 = m2.c, c2 = m2.b, d2 = m2.d;
      var invDet = 1 / (a2 * d2 - b2 * c2);
      var x = world.x - m2.tx, y2 = world.y - m2.ty;
      world.x = x * d2 * invDet - y2 * b2 * invDet;
      world.y = y2 * a2 * invDet - x * c2 * invDet;
      return world;
    };
    Bone2.prototype.localToWorld = function(local) {
      var m2 = this.matrix;
      var x = local.x, y2 = local.y;
      local.x = x * m2.a + y2 * m2.c + m2.tx;
      local.y = x * m2.b + y2 * m2.d + m2.ty;
      return local;
    };
    Bone2.prototype.worldToLocalRotation = function(worldRotation) {
      var sin = MathUtils.sinDeg(worldRotation), cos = MathUtils.cosDeg(worldRotation);
      var mat = this.matrix;
      return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;
    };
    Bone2.prototype.localToWorldRotation = function(localRotation) {
      localRotation -= this.rotation - this.shearX;
      var sin = MathUtils.sinDeg(localRotation), cos = MathUtils.cosDeg(localRotation);
      var mat = this.matrix;
      return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;
    };
    Bone2.prototype.rotateWorld = function(degrees) {
      var mat = this.matrix;
      var a2 = mat.a, b2 = mat.c, c2 = mat.b, d2 = mat.d;
      var cos = MathUtils.cosDeg(degrees), sin = MathUtils.sinDeg(degrees);
      mat.a = cos * a2 - sin * c2;
      mat.c = cos * b2 - sin * d2;
      mat.b = sin * a2 + cos * c2;
      mat.d = sin * b2 + cos * d2;
    };
    return Bone2;
  }()
);
var BoneData = (
  /** @class */
  function() {
    function BoneData2(index2, name, parent) {
      this.index = 0;
      this.parent = null;
      this.length = 0;
      this.x = 0;
      this.y = 0;
      this.rotation = 0;
      this.scaleX = 1;
      this.scaleY = 1;
      this.shearX = 0;
      this.shearY = 0;
      this.transformMode = TransformMode.Normal;
      this.skinRequired = false;
      this.color = new Color();
      if (index2 < 0)
        throw new Error("index must be >= 0.");
      if (!name)
        throw new Error("name cannot be null.");
      this.index = index2;
      this.name = name;
      this.parent = parent;
    }
    return BoneData2;
  }()
);
var ConstraintData = (
  /** @class */
  function() {
    function ConstraintData2(name, order, skinRequired) {
      this.name = name;
      this.order = order;
      this.skinRequired = skinRequired;
    }
    return ConstraintData2;
  }()
);
var Event$1 = (
  /** @class */
  function() {
    function Event2(time, data2) {
      this.intValue = 0;
      this.floatValue = 0;
      this.stringValue = null;
      this.time = 0;
      this.volume = 0;
      this.balance = 0;
      if (!data2)
        throw new Error("data cannot be null.");
      this.time = time;
      this.data = data2;
    }
    return Event2;
  }()
);
var EventData = (
  /** @class */
  function() {
    function EventData2(name) {
      this.intValue = 0;
      this.floatValue = 0;
      this.stringValue = null;
      this.audioPath = null;
      this.volume = 0;
      this.balance = 0;
      this.name = name;
    }
    return EventData2;
  }()
);
var IkConstraint = (
  /** @class */
  function() {
    function IkConstraint2(data2, skeleton) {
      this.bendDirection = 0;
      this.compress = false;
      this.stretch = false;
      this.mix = 1;
      this.softness = 0;
      this.active = false;
      if (!data2)
        throw new Error("data cannot be null.");
      if (!skeleton)
        throw new Error("skeleton cannot be null.");
      this.data = data2;
      this.mix = data2.mix;
      this.softness = data2.softness;
      this.bendDirection = data2.bendDirection;
      this.compress = data2.compress;
      this.stretch = data2.stretch;
      this.bones = new Array();
      for (var i2 = 0; i2 < data2.bones.length; i2++) {
        var bone = skeleton.findBone(data2.bones[i2].name);
        if (!bone)
          throw new Error("Couldn't find bone " + data2.bones[i2].name);
        this.bones.push(bone);
      }
      var target = skeleton.findBone(data2.target.name);
      if (!target)
        throw new Error("Couldn't find bone " + data2.target.name);
      this.target = target;
    }
    IkConstraint2.prototype.isActive = function() {
      return this.active;
    };
    IkConstraint2.prototype.update = function() {
      if (this.mix == 0)
        return;
      var target = this.target;
      var bones = this.bones;
      switch (bones.length) {
        case 1:
          this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
          break;
        case 2:
          this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);
          break;
      }
    };
    IkConstraint2.prototype.apply1 = function(bone, targetX, targetY, compress, stretch, uniform, alpha2) {
      var p = bone.parent.matrix;
      if (!p)
        throw new Error("IK bone must have parent.");
      var pa2 = p.a, pb2 = p.c, pc2 = p.b, pd2 = p.d;
      var rotationIK = -bone.ashearX - bone.arotation, tx = 0, ty = 0;
      var skelX = bone.skeleton.scaleX;
      var skelY = -bone.skeleton.scaleY;
      switch (bone.data.transformMode) {
        case TransformMode.OnlyTranslation:
          tx = targetX - bone.worldX;
          ty = targetY - bone.worldY;
          {
            ty = -ty;
          }
          break;
        case TransformMode.NoRotationOrReflection:
          var s2 = Math.abs(pa2 * pd2 - pb2 * pc2) / (pa2 * pa2 + pc2 * pc2);
          var sa2 = pa2 / skelX;
          var sc2 = pc2 / skelY;
          pb2 = -sc2 * s2 * skelX;
          pd2 = sa2 * s2 * skelY;
          rotationIK += Math.atan2(sc2, sa2) * MathUtils.radDeg;
        default:
          var x = targetX - p.tx, y2 = targetY - p.ty;
          var d2 = pa2 * pd2 - pb2 * pc2;
          tx = (x * pd2 - y2 * pb2) / d2 - bone.ax;
          ty = (y2 * pa2 - x * pc2) / d2 - bone.ay;
      }
      rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;
      if (bone.ascaleX < 0)
        rotationIK += 180;
      if (rotationIK > 180)
        rotationIK -= 360;
      else if (rotationIK < -180)
        rotationIK += 360;
      var sx = bone.ascaleX, sy = bone.ascaleY;
      if (compress || stretch) {
        switch (bone.data.transformMode) {
          case TransformMode.NoScale:
          case TransformMode.NoScaleOrReflection:
            tx = targetX - bone.worldX;
            ty = targetY - bone.worldY;
        }
        var b2 = bone.data.length * sx, dd2 = Math.sqrt(tx * tx + ty * ty);
        if (compress && dd2 < b2 || stretch && dd2 > b2 && b2 > 1e-4) {
          var s2 = (dd2 / b2 - 1) * alpha2 + 1;
          sx *= s2;
          if (uniform)
            sy *= s2;
        }
      }
      bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha2, sx, sy, bone.ashearX, bone.ashearY);
    };
    IkConstraint2.prototype.apply2 = function(parent, child, targetX, targetY, bendDir, stretch, uniform, softness, alpha2) {
      var px = parent.ax, py = parent.ay, psx = parent.ascaleX, psy = parent.ascaleY, sx = psx, sy = psy, csx = child.ascaleX;
      var pmat = parent.matrix;
      var os1 = 0, os2 = 0, s2 = 0;
      if (psx < 0) {
        psx = -psx;
        os1 = 180;
        s2 = -1;
      } else {
        os1 = 0;
        s2 = 1;
      }
      if (psy < 0) {
        psy = -psy;
        s2 = -s2;
      }
      if (csx < 0) {
        csx = -csx;
        os2 = 180;
      } else
        os2 = 0;
      var cx = child.ax, cy = 0, cwx = 0, cwy = 0, a2 = pmat.a, b2 = pmat.c, c2 = pmat.b, d2 = pmat.d;
      var u2 = Math.abs(psx - psy) <= 1e-4;
      if (!u2 || stretch) {
        cy = 0;
        cwx = a2 * cx + pmat.tx;
        cwy = c2 * cx + pmat.ty;
      } else {
        cy = child.ay;
        cwx = a2 * cx + b2 * cy + pmat.tx;
        cwy = c2 * cx + d2 * cy + pmat.ty;
      }
      var pp = parent.parent.matrix;
      if (!pp)
        throw new Error("IK parent must itself have a parent.");
      a2 = pp.a;
      b2 = pp.c;
      c2 = pp.b;
      d2 = pp.d;
      var id2 = 1 / (a2 * d2 - b2 * c2), x = cwx - pp.tx, y2 = cwy - pp.ty;
      var dx = (x * d2 - y2 * b2) * id2 - px, dy = (y2 * a2 - x * c2) * id2 - py;
      var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a22;
      if (l1 < 1e-4) {
        this.apply1(parent, targetX, targetY, false, stretch, false, alpha2);
        child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
        return;
      }
      x = targetX - pp.tx;
      y2 = targetY - pp.ty;
      var tx = (x * d2 - y2 * b2) * id2 - px, ty = (y2 * a2 - x * c2) * id2 - py;
      var dd2 = tx * tx + ty * ty;
      if (softness != 0) {
        softness *= psx * (csx + 1) * 0.5;
        var td2 = Math.sqrt(dd2), sd2 = td2 - l1 - l2 * psx + softness;
        if (sd2 > 0) {
          var p = Math.min(1, sd2 / (softness * 2)) - 1;
          p = (sd2 - softness * (1 - p * p)) / td2;
          tx -= p * tx;
          ty -= p * ty;
          dd2 = tx * tx + ty * ty;
        }
      }
      outer:
        if (u2) {
          l2 *= psx;
          var cos = (dd2 - l1 * l1 - l2 * l2) / (2 * l1 * l2);
          if (cos < -1) {
            cos = -1;
            a22 = Math.PI * bendDir;
          } else if (cos > 1) {
            cos = 1;
            a22 = 0;
            if (stretch) {
              a2 = (Math.sqrt(dd2) / (l1 + l2) - 1) * alpha2 + 1;
              sx *= a2;
              if (uniform)
                sy *= a2;
            }
          } else
            a22 = Math.acos(cos) * bendDir;
          a2 = l1 + l2 * cos;
          b2 = l2 * Math.sin(a22);
          a1 = Math.atan2(ty * a2 - tx * b2, tx * a2 + ty * b2);
        } else {
          a2 = psx * l2;
          b2 = psy * l2;
          var aa2 = a2 * a2, bb2 = b2 * b2, ta2 = Math.atan2(ty, tx);
          c2 = bb2 * l1 * l1 + aa2 * dd2 - aa2 * bb2;
          var c1 = -2 * bb2 * l1, c22 = bb2 - aa2;
          d2 = c1 * c1 - 4 * c22 * c2;
          if (d2 >= 0) {
            var q2 = Math.sqrt(d2);
            if (c1 < 0)
              q2 = -q2;
            q2 = -(c1 + q2) * 0.5;
            var r0 = q2 / c22, r1 = c2 / q2;
            var r2 = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
            if (r2 * r2 <= dd2) {
              y2 = Math.sqrt(dd2 - r2 * r2) * bendDir;
              a1 = ta2 - Math.atan2(y2, r2);
              a22 = Math.atan2(y2 / psy, (r2 - l1) / psx);
              break outer;
            }
          }
          var minAngle = MathUtils.PI, minX = l1 - a2, minDist = minX * minX, minY = 0;
          var maxAngle = 0, maxX = l1 + a2, maxDist = maxX * maxX, maxY = 0;
          c2 = -a2 * l1 / (aa2 - bb2);
          if (c2 >= -1 && c2 <= 1) {
            c2 = Math.acos(c2);
            x = a2 * Math.cos(c2) + l1;
            y2 = b2 * Math.sin(c2);
            d2 = x * x + y2 * y2;
            if (d2 < minDist) {
              minAngle = c2;
              minDist = d2;
              minX = x;
              minY = y2;
            }
            if (d2 > maxDist) {
              maxAngle = c2;
              maxDist = d2;
              maxX = x;
              maxY = y2;
            }
          }
          if (dd2 <= (minDist + maxDist) * 0.5) {
            a1 = ta2 - Math.atan2(minY * bendDir, minX);
            a22 = minAngle * bendDir;
          } else {
            a1 = ta2 - Math.atan2(maxY * bendDir, maxX);
            a22 = maxAngle * bendDir;
          }
        }
      var os = Math.atan2(cy, cx) * s2;
      var rotation = parent.arotation;
      a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;
      if (a1 > 180)
        a1 -= 360;
      else if (a1 < -180)
        a1 += 360;
      parent.updateWorldTransformWith(px, py, rotation + a1 * alpha2, sx, sy, 0, 0);
      rotation = child.arotation;
      a22 = ((a22 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
      if (a22 > 180)
        a22 -= 360;
      else if (a22 < -180)
        a22 += 360;
      child.updateWorldTransformWith(cx, cy, rotation + a22 * alpha2, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
    };
    return IkConstraint2;
  }()
);
var IkConstraintData = (
  /** @class */
  function(_super) {
    __extends$2(IkConstraintData2, _super);
    function IkConstraintData2(name) {
      var _this = _super.call(this, name, 0, false) || this;
      _this.bones = new Array();
      _this._target = null;
      _this.bendDirection = 1;
      _this.compress = false;
      _this.stretch = false;
      _this.uniform = false;
      _this.mix = 1;
      _this.softness = 0;
      return _this;
    }
    Object.defineProperty(IkConstraintData2.prototype, "target", {
      get: function() {
        if (!this._target)
          throw new Error("BoneData not set.");
        else
          return this._target;
      },
      set: function(boneData) {
        this._target = boneData;
      },
      enumerable: false,
      configurable: true
    });
    return IkConstraintData2;
  }(ConstraintData)
);
var PathConstraintData = (
  /** @class */
  function(_super) {
    __extends$2(PathConstraintData2, _super);
    function PathConstraintData2(name) {
      var _this = _super.call(this, name, 0, false) || this;
      _this.bones = new Array();
      _this._target = null;
      _this.positionMode = PositionMode.Fixed;
      _this.spacingMode = SpacingMode.Fixed;
      _this.rotateMode = RotateMode.Chain;
      _this.offsetRotation = 0;
      _this.position = 0;
      _this.spacing = 0;
      _this.mixRotate = 0;
      _this.mixX = 0;
      _this.mixY = 0;
      return _this;
    }
    Object.defineProperty(PathConstraintData2.prototype, "target", {
      get: function() {
        if (!this._target)
          throw new Error("SlotData not set.");
        else
          return this._target;
      },
      set: function(slotData) {
        this._target = slotData;
      },
      enumerable: false,
      configurable: true
    });
    return PathConstraintData2;
  }(ConstraintData)
);
var SpacingMode;
(function(SpacingMode2) {
  SpacingMode2[SpacingMode2["Length"] = 0] = "Length";
  SpacingMode2[SpacingMode2["Fixed"] = 1] = "Fixed";
  SpacingMode2[SpacingMode2["Percent"] = 2] = "Percent";
  SpacingMode2[SpacingMode2["Proportional"] = 3] = "Proportional";
})(SpacingMode || (SpacingMode = {}));
var PathConstraint = (
  /** @class */
  function() {
    function PathConstraint2(data2, skeleton) {
      this.position = 0;
      this.spacing = 0;
      this.mixRotate = 0;
      this.mixX = 0;
      this.mixY = 0;
      this.spaces = new Array();
      this.positions = new Array();
      this.world = new Array();
      this.curves = new Array();
      this.lengths = new Array();
      this.segments = new Array();
      this.active = false;
      if (!data2)
        throw new Error("data cannot be null.");
      if (!skeleton)
        throw new Error("skeleton cannot be null.");
      this.data = data2;
      this.bones = new Array();
      for (var i2 = 0, n2 = data2.bones.length; i2 < n2; i2++) {
        var bone = skeleton.findBone(data2.bones[i2].name);
        if (!bone)
          throw new Error("Couldn't find bone " + data2.bones[i2].name + ".");
        this.bones.push(bone);
      }
      var target = skeleton.findSlot(data2.target.name);
      if (!target)
        throw new Error("Couldn't find target bone " + data2.target.name);
      this.target = target;
      this.position = data2.position;
      this.spacing = data2.spacing;
      this.mixRotate = data2.mixRotate;
      this.mixX = data2.mixX;
      this.mixY = data2.mixY;
    }
    PathConstraint2.prototype.isActive = function() {
      return this.active;
    };
    PathConstraint2.prototype.update = function() {
      var attachment = this.target.getAttachment();
      if (!(attachment instanceof PathAttachment))
        return;
      var mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY;
      if (mixRotate == 0 && mixX == 0 && mixY == 0)
        return;
      var data2 = this.data;
      var tangents = data2.rotateMode == RotateMode.Tangent, scale = data2.rotateMode == RotateMode.ChainScale;
      var bones = this.bones;
      var boneCount = bones.length, spacesCount = tangents ? boneCount : boneCount + 1;
      var spaces = Utils.setArraySize(this.spaces, spacesCount), lengths = scale ? this.lengths = Utils.setArraySize(this.lengths, boneCount) : [];
      var spacing = this.spacing;
      switch (data2.spacingMode) {
        case SpacingMode.Percent:
          if (scale) {
            for (var i2 = 0, n2 = spacesCount - 1; i2 < n2; i2++) {
              var bone = bones[i2];
              var setupLength = bone.data.length;
              if (setupLength < PathConstraint2.epsilon)
                lengths[i2] = 0;
              else {
                var x = setupLength * bone.matrix.a, y2 = setupLength * bone.matrix.b;
                lengths[i2] = Math.sqrt(x * x + y2 * y2);
              }
            }
          }
          Utils.arrayFill(spaces, 1, spacesCount, spacing);
          break;
        case SpacingMode.Proportional:
          var sum = 0;
          for (var i2 = 0, n2 = spacesCount - 1; i2 < n2; ) {
            var bone = bones[i2];
            var setupLength = bone.data.length;
            if (setupLength < PathConstraint2.epsilon) {
              if (scale)
                lengths[i2] = 0;
              spaces[++i2] = spacing;
            } else {
              var x = setupLength * bone.matrix.a, y2 = setupLength * bone.matrix.b;
              var length_1 = Math.sqrt(x * x + y2 * y2);
              if (scale)
                lengths[i2] = length_1;
              spaces[++i2] = length_1;
              sum += length_1;
            }
          }
          if (sum > 0) {
            sum = spacesCount / sum * spacing;
            for (var i2 = 1; i2 < spacesCount; i2++)
              spaces[i2] *= sum;
          }
          break;
        default:
          var lengthSpacing = data2.spacingMode == SpacingMode.Length;
          for (var i2 = 0, n2 = spacesCount - 1; i2 < n2; ) {
            var bone = bones[i2];
            var setupLength = bone.data.length;
            if (setupLength < PathConstraint2.epsilon) {
              if (scale)
                lengths[i2] = 0;
              spaces[++i2] = spacing;
            } else {
              var x = setupLength * bone.matrix.a, y2 = setupLength * bone.matrix.b;
              var length_2 = Math.sqrt(x * x + y2 * y2);
              if (scale)
                lengths[i2] = length_2;
              spaces[++i2] = (lengthSpacing ? setupLength + spacing : spacing) * length_2 / setupLength;
            }
          }
      }
      var positions = this.computeWorldPositions(attachment, spacesCount, tangents);
      var boneX = positions[0], boneY = positions[1], offsetRotation = data2.offsetRotation;
      var tip = false;
      if (offsetRotation == 0)
        tip = data2.rotateMode == RotateMode.Chain;
      else {
        tip = false;
        var p = this.target.bone.matrix;
        offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;
      }
      for (var i2 = 0, p = 3; i2 < boneCount; i2++, p += 3) {
        var bone = bones[i2];
        var mat = bone.matrix;
        mat.tx += (boneX - mat.tx) * mixX;
        mat.ty += (boneY - mat.ty) * mixY;
        var x = positions[p], y2 = positions[p + 1], dx = x - boneX, dy = y2 - boneY;
        if (scale) {
          var length_3 = lengths[i2];
          if (length_3 != 0) {
            var s2 = (Math.sqrt(dx * dx + dy * dy) / length_3 - 1) * mixRotate + 1;
            mat.a *= s2;
            mat.b *= s2;
          }
        }
        boneX = x;
        boneY = y2;
        if (mixRotate > 0) {
          var a2 = mat.a, b2 = mat.c, c2 = mat.b, d2 = mat.d, r2 = 0, cos = 0, sin = 0;
          if (tangents)
            r2 = positions[p - 1];
          else if (spaces[i2 + 1] == 0)
            r2 = positions[p + 2];
          else
            r2 = Math.atan2(dy, dx);
          r2 -= Math.atan2(c2, a2);
          if (tip) {
            cos = Math.cos(r2);
            sin = Math.sin(r2);
            var length_4 = bone.data.length;
            boneX += (length_4 * (cos * a2 - sin * c2) - dx) * mixRotate;
            boneY += (length_4 * (sin * a2 + cos * c2) - dy) * mixRotate;
          } else {
            r2 += offsetRotation;
          }
          if (r2 > MathUtils.PI)
            r2 -= MathUtils.PI2;
          else if (r2 < -MathUtils.PI)
            r2 += MathUtils.PI2;
          r2 *= mixRotate;
          cos = Math.cos(r2);
          sin = Math.sin(r2);
          mat.a = cos * a2 - sin * c2;
          mat.c = cos * b2 - sin * d2;
          mat.b = sin * a2 + cos * c2;
          mat.d = sin * b2 + cos * d2;
        }
        bone.updateAppliedTransform();
      }
    };
    PathConstraint2.prototype.computeWorldPositions = function(path, spacesCount, tangents) {
      var target = this.target;
      var position2 = this.position;
      var spaces = this.spaces, out = Utils.setArraySize(this.positions, spacesCount * 3 + 2), world = this.world;
      var closed2 = path.closed;
      var verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint2.NONE;
      if (!path.constantSpeed) {
        var lengths = path.lengths;
        curveCount -= closed2 ? 1 : 2;
        var pathLength_1 = lengths[curveCount];
        if (this.data.positionMode == PositionMode.Percent)
          position2 *= pathLength_1;
        var multiplier_1;
        switch (this.data.spacingMode) {
          case SpacingMode.Percent:
            multiplier_1 = pathLength_1;
            break;
          case SpacingMode.Proportional:
            multiplier_1 = pathLength_1 / spacesCount;
            break;
          default:
            multiplier_1 = 1;
        }
        world = Utils.setArraySize(this.world, 8);
        for (var i2 = 0, o2 = 0, curve = 0; i2 < spacesCount; i2++, o2 += 3) {
          var space = spaces[i2] * multiplier_1;
          position2 += space;
          var p = position2;
          if (closed2) {
            p %= pathLength_1;
            if (p < 0)
              p += pathLength_1;
            curve = 0;
          } else if (p < 0) {
            if (prevCurve != PathConstraint2.BEFORE) {
              prevCurve = PathConstraint2.BEFORE;
              path.computeWorldVertices(target, 2, 4, world, 0, 2);
            }
            this.addBeforePosition(p, world, 0, out, o2);
            continue;
          } else if (p > pathLength_1) {
            if (prevCurve != PathConstraint2.AFTER) {
              prevCurve = PathConstraint2.AFTER;
              path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);
            }
            this.addAfterPosition(p - pathLength_1, world, 0, out, o2);
            continue;
          }
          for (; ; curve++) {
            var length_5 = lengths[curve];
            if (p > length_5)
              continue;
            if (curve == 0)
              p /= length_5;
            else {
              var prev2 = lengths[curve - 1];
              p = (p - prev2) / (length_5 - prev2);
            }
            break;
          }
          if (curve != prevCurve) {
            prevCurve = curve;
            if (closed2 && curve == curveCount) {
              path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
              path.computeWorldVertices(target, 0, 4, world, 4, 2);
            } else
              path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);
          }
          this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o2, tangents || i2 > 0 && space == 0);
        }
        return out;
      }
      if (closed2) {
        verticesLength += 2;
        world = Utils.setArraySize(this.world, verticesLength);
        path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
        path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
        world[verticesLength - 2] = world[0];
        world[verticesLength - 1] = world[1];
      } else {
        curveCount--;
        verticesLength -= 4;
        world = Utils.setArraySize(this.world, verticesLength);
        path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);
      }
      var curves = Utils.setArraySize(this.curves, curveCount);
      var pathLength = 0;
      var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;
      var tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;
      for (var i2 = 0, w2 = 2; i2 < curveCount; i2++, w2 += 6) {
        cx1 = world[w2];
        cy1 = world[w2 + 1];
        cx2 = world[w2 + 2];
        cy2 = world[w2 + 3];
        x2 = world[w2 + 4];
        y2 = world[w2 + 5];
        tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
        tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
        ddfx = tmpx * 2 + dddfx;
        ddfy = tmpy * 2 + dddfy;
        dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
        dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        dfx += ddfx;
        dfy += ddfy;
        ddfx += dddfx;
        ddfy += dddfy;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        dfx += ddfx;
        dfy += ddfy;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        dfx += ddfx + dddfx;
        dfy += ddfy + dddfy;
        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
        curves[i2] = pathLength;
        x1 = x2;
        y1 = y2;
      }
      if (this.data.positionMode == PositionMode.Percent)
        position2 *= pathLength;
      var multiplier;
      switch (this.data.spacingMode) {
        case SpacingMode.Percent:
          multiplier = pathLength;
          break;
        case SpacingMode.Proportional:
          multiplier = pathLength / spacesCount;
          break;
        default:
          multiplier = 1;
      }
      var segments = this.segments;
      var curveLength = 0;
      for (var i2 = 0, o2 = 0, curve = 0, segment = 0; i2 < spacesCount; i2++, o2 += 3) {
        var space = spaces[i2] * multiplier;
        position2 += space;
        var p = position2;
        if (closed2) {
          p %= pathLength;
          if (p < 0)
            p += pathLength;
          curve = 0;
        } else if (p < 0) {
          this.addBeforePosition(p, world, 0, out, o2);
          continue;
        } else if (p > pathLength) {
          this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o2);
          continue;
        }
        for (; ; curve++) {
          var length_6 = curves[curve];
          if (p > length_6)
            continue;
          if (curve == 0)
            p /= length_6;
          else {
            var prev2 = curves[curve - 1];
            p = (p - prev2) / (length_6 - prev2);
          }
          break;
        }
        if (curve != prevCurve) {
          prevCurve = curve;
          var ii2 = curve * 6;
          x1 = world[ii2];
          y1 = world[ii2 + 1];
          cx1 = world[ii2 + 2];
          cy1 = world[ii2 + 3];
          cx2 = world[ii2 + 4];
          cy2 = world[ii2 + 5];
          x2 = world[ii2 + 6];
          y2 = world[ii2 + 7];
          tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
          tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
          dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;
          dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;
          ddfx = tmpx * 2 + dddfx;
          ddfy = tmpy * 2 + dddfy;
          dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
          dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
          curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
          segments[0] = curveLength;
          for (ii2 = 1; ii2 < 8; ii2++) {
            dfx += ddfx;
            dfy += ddfy;
            ddfx += dddfx;
            ddfy += dddfy;
            curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
            segments[ii2] = curveLength;
          }
          dfx += ddfx;
          dfy += ddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[8] = curveLength;
          dfx += ddfx + dddfx;
          dfy += ddfy + dddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[9] = curveLength;
          segment = 0;
        }
        p *= curveLength;
        for (; ; segment++) {
          var length_7 = segments[segment];
          if (p > length_7)
            continue;
          if (segment == 0)
            p /= length_7;
          else {
            var prev2 = segments[segment - 1];
            p = segment + (p - prev2) / (length_7 - prev2);
          }
          break;
        }
        this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o2, tangents || i2 > 0 && space == 0);
      }
      return out;
    };
    PathConstraint2.prototype.addBeforePosition = function(p, temp2, i2, out, o2) {
      var x1 = temp2[i2], y1 = temp2[i2 + 1], dx = temp2[i2 + 2] - x1, dy = temp2[i2 + 3] - y1, r2 = Math.atan2(dy, dx);
      out[o2] = x1 + p * Math.cos(r2);
      out[o2 + 1] = y1 + p * Math.sin(r2);
      out[o2 + 2] = r2;
    };
    PathConstraint2.prototype.addAfterPosition = function(p, temp2, i2, out, o2) {
      var x1 = temp2[i2 + 2], y1 = temp2[i2 + 3], dx = x1 - temp2[i2], dy = y1 - temp2[i2 + 1], r2 = Math.atan2(dy, dx);
      out[o2] = x1 + p * Math.cos(r2);
      out[o2 + 1] = y1 + p * Math.sin(r2);
      out[o2 + 2] = r2;
    };
    PathConstraint2.prototype.addCurvePosition = function(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o2, tangents) {
      if (p == 0 || isNaN(p)) {
        out[o2] = x1;
        out[o2 + 1] = y1;
        out[o2 + 2] = Math.atan2(cy1 - y1, cx1 - x1);
        return;
      }
      var tt = p * p, ttt = tt * p, u2 = 1 - p, uu = u2 * u2, uuu = uu * u2;
      var ut = u2 * p, ut3 = ut * 3, uut3 = u2 * ut3, utt3 = ut3 * p;
      var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y3 = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
      out[o2] = x;
      out[o2 + 1] = y3;
      if (tangents) {
        if (p < 1e-3)
          out[o2 + 2] = Math.atan2(cy1 - y1, cx1 - x1);
        else
          out[o2 + 2] = Math.atan2(y3 - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
      }
    };
    PathConstraint2.NONE = -1;
    PathConstraint2.BEFORE = -2;
    PathConstraint2.AFTER = -3;
    PathConstraint2.epsilon = 1e-5;
    return PathConstraint2;
  }()
);
var Slot = (
  /** @class */
  function() {
    function Slot2(data2, bone) {
      this.darkColor = null;
      this.attachment = null;
      this.attachmentState = 0;
      this.sequenceIndex = -1;
      this.deform = new Array();
      if (!data2)
        throw new Error("data cannot be null.");
      if (!bone)
        throw new Error("bone cannot be null.");
      this.data = data2;
      this.bone = bone;
      this.color = new Color();
      this.darkColor = !data2.darkColor ? null : new Color();
      this.setToSetupPose();
      this.blendMode = this.data.blendMode;
    }
    Slot2.prototype.getSkeleton = function() {
      return this.bone.skeleton;
    };
    Slot2.prototype.getAttachment = function() {
      return this.attachment;
    };
    Slot2.prototype.setAttachment = function(attachment) {
      if (this.attachment == attachment)
        return;
      if (!(attachment instanceof VertexAttachment) || !(this.attachment instanceof VertexAttachment) || attachment.timelineAttachment != this.attachment.timelineAttachment) {
        this.deform.length = 0;
      }
      this.attachment = attachment;
      this.sequenceIndex = -1;
    };
    Slot2.prototype.setToSetupPose = function() {
      this.color.setFromColor(this.data.color);
      if (this.darkColor)
        this.darkColor.setFromColor(this.data.darkColor);
      if (!this.data.attachmentName)
        this.attachment = null;
      else {
        this.attachment = null;
        this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
      }
    };
    return Slot2;
  }()
);
var TransformConstraint = (
  /** @class */
  function() {
    function TransformConstraint2(data2, skeleton) {
      this.mixRotate = 0;
      this.mixX = 0;
      this.mixY = 0;
      this.mixScaleX = 0;
      this.mixScaleY = 0;
      this.mixShearY = 0;
      this.temp = new Vector2();
      this.active = false;
      if (!data2)
        throw new Error("data cannot be null.");
      if (!skeleton)
        throw new Error("skeleton cannot be null.");
      this.data = data2;
      this.mixRotate = data2.mixRotate;
      this.mixX = data2.mixX;
      this.mixY = data2.mixY;
      this.mixScaleX = data2.mixScaleX;
      this.mixScaleY = data2.mixScaleY;
      this.mixShearY = data2.mixShearY;
      this.bones = new Array();
      for (var i2 = 0; i2 < data2.bones.length; i2++) {
        var bone = skeleton.findBone(data2.bones[i2].name);
        if (!bone)
          throw new Error("Couldn't find bone " + data2.bones[i2].name + ".");
        this.bones.push(bone);
      }
      var target = skeleton.findBone(data2.target.name);
      if (!target)
        throw new Error("Couldn't find target bone " + data2.target.name + ".");
      this.target = target;
    }
    TransformConstraint2.prototype.isActive = function() {
      return this.active;
    };
    TransformConstraint2.prototype.update = function() {
      if (this.mixRotate == 0 && this.mixX == 0 && this.mixY == 0 && this.mixScaleX == 0 && this.mixScaleX == 0 && this.mixShearY == 0)
        return;
      if (this.data.local) {
        if (this.data.relative)
          this.applyRelativeLocal();
        else
          this.applyAbsoluteLocal();
      } else {
        if (this.data.relative)
          this.applyRelativeWorld();
        else
          this.applyAbsoluteWorld();
      }
    };
    TransformConstraint2.prototype.applyAbsoluteWorld = function() {
      var mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX, mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;
      var translate = mixX != 0 || mixY != 0;
      var target = this.target;
      var targetMat = target.matrix;
      var ta2 = targetMat.a, tb2 = targetMat.c, tc2 = targetMat.b, td2 = targetMat.d;
      var degRadReflect = ta2 * td2 - tb2 * tc2 > 0 ? MathUtils.degRad : -MathUtils.degRad;
      var offsetRotation = this.data.offsetRotation * degRadReflect;
      var offsetShearY = this.data.offsetShearY * degRadReflect;
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        var mat = bone.matrix;
        if (mixRotate != 0) {
          var a2 = mat.a, b2 = mat.c, c2 = mat.b, d2 = mat.d;
          var r2 = Math.atan2(tc2, ta2) - Math.atan2(c2, a2) + offsetRotation;
          if (r2 > MathUtils.PI)
            r2 -= MathUtils.PI2;
          else if (r2 < -MathUtils.PI)
            r2 += MathUtils.PI2;
          r2 *= mixRotate;
          var cos = Math.cos(r2), sin = Math.sin(r2);
          mat.a = cos * a2 - sin * c2;
          mat.c = cos * b2 - sin * d2;
          mat.b = sin * a2 + cos * c2;
          mat.d = sin * b2 + cos * d2;
        }
        if (translate) {
          var temp2 = this.temp;
          target.localToWorld(temp2.set(this.data.offsetX, this.data.offsetY));
          mat.tx += (temp2.x - mat.tx) * mixX;
          mat.ty += (temp2.y - mat.ty) * mixY;
        }
        if (mixScaleX != 0) {
          var s2 = Math.sqrt(mat.a * mat.a + mat.b * mat.b);
          if (s2 != 0)
            s2 = (s2 + (Math.sqrt(ta2 * ta2 + tc2 * tc2) - s2 + this.data.offsetScaleX) * mixScaleX) / s2;
          mat.a *= s2;
          mat.b *= s2;
        }
        if (mixScaleY != 0) {
          var s2 = Math.sqrt(mat.c * mat.c + mat.d * mat.d);
          if (s2 != 0)
            s2 = (s2 + (Math.sqrt(tb2 * tb2 + td2 * td2) - s2 + this.data.offsetScaleY) * mixScaleY) / s2;
          mat.c *= s2;
          mat.d *= s2;
        }
        if (mixShearY > 0) {
          var b2 = mat.c, d2 = mat.d;
          var by = Math.atan2(d2, b2);
          var r2 = Math.atan2(td2, tb2) - Math.atan2(tc2, ta2) - (by - Math.atan2(mat.b, mat.a));
          if (r2 > MathUtils.PI)
            r2 -= MathUtils.PI2;
          else if (r2 < -MathUtils.PI)
            r2 += MathUtils.PI2;
          r2 = by + (r2 + offsetShearY) * mixShearY;
          var s2 = Math.sqrt(b2 * b2 + d2 * d2);
          mat.c = Math.cos(r2) * s2;
          mat.d = Math.sin(r2) * s2;
        }
        bone.updateAppliedTransform();
      }
    };
    TransformConstraint2.prototype.applyRelativeWorld = function() {
      var mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX, mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;
      var translate = mixX != 0 || mixY != 0;
      var target = this.target;
      var targetMat = target.matrix;
      var ta2 = targetMat.a, tb2 = targetMat.c, tc2 = targetMat.b, td2 = targetMat.d;
      var degRadReflect = ta2 * td2 - tb2 * tc2 > 0 ? MathUtils.degRad : -MathUtils.degRad;
      var offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        var mat = bone.matrix;
        if (mixRotate != 0) {
          var a2 = mat.a, b2 = mat.c, c2 = mat.b, d2 = mat.d;
          var r2 = Math.atan2(tc2, ta2) + offsetRotation;
          if (r2 > MathUtils.PI)
            r2 -= MathUtils.PI2;
          else if (r2 < -MathUtils.PI)
            r2 += MathUtils.PI2;
          r2 *= mixRotate;
          var cos = Math.cos(r2), sin = Math.sin(r2);
          mat.a = cos * a2 - sin * c2;
          mat.c = cos * b2 - sin * d2;
          mat.b = sin * a2 + cos * c2;
          mat.d = sin * b2 + cos * d2;
        }
        if (translate) {
          var temp2 = this.temp;
          target.localToWorld(temp2.set(this.data.offsetX, this.data.offsetY));
          mat.tx += temp2.x * mixX;
          mat.ty += temp2.y * mixY;
        }
        if (mixScaleX != 0) {
          var s2 = (Math.sqrt(ta2 * ta2 + tc2 * tc2) - 1 + this.data.offsetScaleX) * mixScaleX + 1;
          mat.a *= s2;
          mat.b *= s2;
        }
        if (mixScaleY != 0) {
          var s2 = (Math.sqrt(tb2 * tb2 + td2 * td2) - 1 + this.data.offsetScaleY) * mixScaleY + 1;
          mat.c *= s2;
          mat.d *= s2;
        }
        if (mixShearY > 0) {
          var r2 = Math.atan2(td2, tb2) - Math.atan2(tc2, ta2);
          if (r2 > MathUtils.PI)
            r2 -= MathUtils.PI2;
          else if (r2 < -MathUtils.PI)
            r2 += MathUtils.PI2;
          var b2 = mat.c, d2 = mat.d;
          r2 = Math.atan2(d2, b2) + (r2 - MathUtils.PI / 2 + offsetShearY) * mixShearY;
          var s2 = Math.sqrt(b2 * b2 + d2 * d2);
          mat.c = Math.cos(r2) * s2;
          mat.d = Math.sin(r2) * s2;
        }
        bone.updateAppliedTransform();
      }
    };
    TransformConstraint2.prototype.applyAbsoluteLocal = function() {
      var mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX, mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;
      var target = this.target;
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        var rotation = bone.arotation;
        if (mixRotate != 0) {
          var r2 = target.arotation - rotation + this.data.offsetRotation;
          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
          rotation += r2 * mixRotate;
        }
        var x = bone.ax, y2 = bone.ay;
        x += (target.ax - x + this.data.offsetX) * mixX;
        y2 += (target.ay - y2 + this.data.offsetY) * mixY;
        var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
        if (mixScaleX != 0 && scaleX != 0)
          scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * mixScaleX) / scaleX;
        if (mixScaleY != 0 && scaleY != 0)
          scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * mixScaleY) / scaleY;
        var shearY = bone.ashearY;
        if (mixShearY != 0) {
          var r2 = target.ashearY - shearY + this.data.offsetShearY;
          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
          shearY += r2 * mixShearY;
        }
        bone.updateWorldTransformWith(x, y2, rotation, scaleX, scaleY, bone.ashearX, shearY);
      }
    };
    TransformConstraint2.prototype.applyRelativeLocal = function() {
      var mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX, mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;
      var target = this.target;
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        var rotation = bone.arotation + (target.arotation + this.data.offsetRotation) * mixRotate;
        var x = bone.ax + (target.ax + this.data.offsetX) * mixX;
        var y2 = bone.ay + (target.ay + this.data.offsetY) * mixY;
        var scaleX = bone.ascaleX * ((target.ascaleX - 1 + this.data.offsetScaleX) * mixScaleX + 1);
        var scaleY = bone.ascaleY * ((target.ascaleY - 1 + this.data.offsetScaleY) * mixScaleY + 1);
        var shearY = bone.ashearY + (target.ashearY + this.data.offsetShearY) * mixShearY;
        bone.updateWorldTransformWith(x, y2, rotation, scaleX, scaleY, bone.ashearX, shearY);
      }
    };
    return TransformConstraint2;
  }()
);
var Skeleton = (
  /** @class */
  function() {
    function Skeleton2(data2) {
      this._updateCache = new Array();
      this.skin = null;
      this.scaleX = 1;
      this.scaleY = 1;
      this.x = 0;
      this.y = 0;
      if (!data2)
        throw new Error("data cannot be null.");
      this.data = data2;
      this.bones = new Array();
      for (var i2 = 0; i2 < data2.bones.length; i2++) {
        var boneData = data2.bones[i2];
        var bone = void 0;
        if (!boneData.parent)
          bone = new Bone(boneData, this, null);
        else {
          var parent_1 = this.bones[boneData.parent.index];
          bone = new Bone(boneData, this, parent_1);
          parent_1.children.push(bone);
        }
        this.bones.push(bone);
      }
      this.slots = new Array();
      this.drawOrder = new Array();
      for (var i2 = 0; i2 < data2.slots.length; i2++) {
        var slotData = data2.slots[i2];
        var bone = this.bones[slotData.boneData.index];
        var slot = new Slot(slotData, bone);
        this.slots.push(slot);
        this.drawOrder.push(slot);
      }
      this.ikConstraints = new Array();
      for (var i2 = 0; i2 < data2.ikConstraints.length; i2++) {
        var ikConstraintData = data2.ikConstraints[i2];
        this.ikConstraints.push(new IkConstraint(ikConstraintData, this));
      }
      this.transformConstraints = new Array();
      for (var i2 = 0; i2 < data2.transformConstraints.length; i2++) {
        var transformConstraintData = data2.transformConstraints[i2];
        this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));
      }
      this.pathConstraints = new Array();
      for (var i2 = 0; i2 < data2.pathConstraints.length; i2++) {
        var pathConstraintData = data2.pathConstraints[i2];
        this.pathConstraints.push(new PathConstraint(pathConstraintData, this));
      }
      this.color = new Color(1, 1, 1, 1);
      this.updateCache();
    }
    Skeleton2.prototype.updateCache = function() {
      var updateCache = this._updateCache;
      updateCache.length = 0;
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        bone.sorted = bone.data.skinRequired;
        bone.active = !bone.sorted;
      }
      if (this.skin) {
        var skinBones = this.skin.bones;
        for (var i2 = 0, n2 = this.skin.bones.length; i2 < n2; i2++) {
          var bone = this.bones[skinBones[i2].index];
          do {
            bone.sorted = false;
            bone.active = true;
            bone = bone.parent;
          } while (bone);
        }
      }
      var ikConstraints = this.ikConstraints;
      var transformConstraints = this.transformConstraints;
      var pathConstraints = this.pathConstraints;
      var ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;
      var constraintCount = ikCount + transformCount + pathCount;
      outer:
        for (var i2 = 0; i2 < constraintCount; i2++) {
          for (var ii2 = 0; ii2 < ikCount; ii2++) {
            var constraint = ikConstraints[ii2];
            if (constraint.data.order == i2) {
              this.sortIkConstraint(constraint);
              continue outer;
            }
          }
          for (var ii2 = 0; ii2 < transformCount; ii2++) {
            var constraint = transformConstraints[ii2];
            if (constraint.data.order == i2) {
              this.sortTransformConstraint(constraint);
              continue outer;
            }
          }
          for (var ii2 = 0; ii2 < pathCount; ii2++) {
            var constraint = pathConstraints[ii2];
            if (constraint.data.order == i2) {
              this.sortPathConstraint(constraint);
              continue outer;
            }
          }
        }
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++)
        this.sortBone(bones[i2]);
    };
    Skeleton2.prototype.sortIkConstraint = function(constraint) {
      constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));
      if (!constraint.active)
        return;
      var target = constraint.target;
      this.sortBone(target);
      var constrained = constraint.bones;
      var parent = constrained[0];
      this.sortBone(parent);
      if (constrained.length == 1) {
        this._updateCache.push(constraint);
        this.sortReset(parent.children);
      } else {
        var child = constrained[constrained.length - 1];
        this.sortBone(child);
        this._updateCache.push(constraint);
        this.sortReset(parent.children);
        child.sorted = true;
      }
    };
    Skeleton2.prototype.sortPathConstraint = function(constraint) {
      constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));
      if (!constraint.active)
        return;
      var slot = constraint.target;
      var slotIndex = slot.data.index;
      var slotBone = slot.bone;
      if (this.skin)
        this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
      if (this.data.defaultSkin && this.data.defaultSkin != this.skin)
        this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
      for (var i2 = 0, n2 = this.data.skins.length; i2 < n2; i2++)
        this.sortPathConstraintAttachment(this.data.skins[i2], slotIndex, slotBone);
      var attachment = slot.getAttachment();
      if (attachment instanceof PathAttachment)
        this.sortPathConstraintAttachmentWith(attachment, slotBone);
      var constrained = constraint.bones;
      var boneCount = constrained.length;
      for (var i2 = 0; i2 < boneCount; i2++)
        this.sortBone(constrained[i2]);
      this._updateCache.push(constraint);
      for (var i2 = 0; i2 < boneCount; i2++)
        this.sortReset(constrained[i2].children);
      for (var i2 = 0; i2 < boneCount; i2++)
        constrained[i2].sorted = true;
    };
    Skeleton2.prototype.sortTransformConstraint = function(constraint) {
      constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));
      if (!constraint.active)
        return;
      this.sortBone(constraint.target);
      var constrained = constraint.bones;
      var boneCount = constrained.length;
      if (constraint.data.local) {
        for (var i2 = 0; i2 < boneCount; i2++) {
          var child = constrained[i2];
          this.sortBone(child.parent);
          this.sortBone(child);
        }
      } else {
        for (var i2 = 0; i2 < boneCount; i2++) {
          this.sortBone(constrained[i2]);
        }
      }
      this._updateCache.push(constraint);
      for (var i2 = 0; i2 < boneCount; i2++)
        this.sortReset(constrained[i2].children);
      for (var i2 = 0; i2 < boneCount; i2++)
        constrained[i2].sorted = true;
    };
    Skeleton2.prototype.sortPathConstraintAttachment = function(skin, slotIndex, slotBone) {
      var attachments = skin.attachments[slotIndex];
      if (!attachments)
        return;
      for (var key in attachments) {
        this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
      }
    };
    Skeleton2.prototype.sortPathConstraintAttachmentWith = function(attachment, slotBone) {
      if (!(attachment instanceof PathAttachment))
        return;
      var pathBones = attachment.bones;
      if (!pathBones)
        this.sortBone(slotBone);
      else {
        var bones = this.bones;
        for (var i2 = 0, n2 = pathBones.length; i2 < n2; ) {
          var nn2 = pathBones[i2++];
          nn2 += i2;
          while (i2 < nn2)
            this.sortBone(bones[pathBones[i2++]]);
        }
      }
    };
    Skeleton2.prototype.sortBone = function(bone) {
      if (!bone)
        return;
      if (bone.sorted)
        return;
      var parent = bone.parent;
      if (parent)
        this.sortBone(parent);
      bone.sorted = true;
      this._updateCache.push(bone);
    };
    Skeleton2.prototype.sortReset = function(bones) {
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        if (!bone.active)
          continue;
        if (bone.sorted)
          this.sortReset(bone.children);
        bone.sorted = false;
      }
    };
    Skeleton2.prototype.updateWorldTransform = function() {
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        bone.ax = bone.x;
        bone.ay = bone.y;
        bone.arotation = bone.rotation;
        bone.ascaleX = bone.scaleX;
        bone.ascaleY = bone.scaleY;
        bone.ashearX = bone.shearX;
        bone.ashearY = bone.shearY;
      }
      var updateCache = this._updateCache;
      for (var i2 = 0, n2 = updateCache.length; i2 < n2; i2++)
        updateCache[i2].update();
    };
    Skeleton2.prototype.updateWorldTransformWith = function(parent) {
      var rootBone = this.getRootBone();
      var pa2 = parent.matrix.a, pb2 = parent.matrix.c, pc2 = parent.matrix.b, pd2 = parent.matrix.d;
      rootBone.matrix.tx = pa2 * this.x + pb2 * this.y + parent.worldX;
      rootBone.matrix.ty = pc2 * this.x + pd2 * this.y + parent.worldY;
      var rotationY = rootBone.rotation + 90 + rootBone.shearY;
      var la2 = MathUtils.cosDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;
      var lb2 = MathUtils.cosDeg(rotationY) * rootBone.scaleY;
      var lc2 = MathUtils.sinDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;
      var ld2 = MathUtils.sinDeg(rotationY) * rootBone.scaleY;
      var sx = this.scaleX;
      var sy = -this.scaleY;
      rootBone.matrix.a = (pa2 * la2 + pb2 * lc2) * sx;
      rootBone.matrix.c = (pa2 * lb2 + pb2 * ld2) * sx;
      rootBone.matrix.b = (pc2 * la2 + pd2 * lc2) * sy;
      rootBone.matrix.d = (pc2 * lb2 + pd2 * ld2) * sy;
      var updateCache = this._updateCache;
      for (var i2 = 0, n2 = updateCache.length; i2 < n2; i2++) {
        var updatable = updateCache[i2];
        if (updatable != rootBone)
          updatable.update();
      }
    };
    Skeleton2.prototype.setToSetupPose = function() {
      this.setBonesToSetupPose();
      this.setSlotsToSetupPose();
    };
    Skeleton2.prototype.setBonesToSetupPose = function() {
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++)
        bones[i2].setToSetupPose();
      var ikConstraints = this.ikConstraints;
      for (var i2 = 0, n2 = ikConstraints.length; i2 < n2; i2++) {
        var constraint = ikConstraints[i2];
        constraint.mix = constraint.data.mix;
        constraint.softness = constraint.data.softness;
        constraint.bendDirection = constraint.data.bendDirection;
        constraint.compress = constraint.data.compress;
        constraint.stretch = constraint.data.stretch;
      }
      var transformConstraints = this.transformConstraints;
      for (var i2 = 0, n2 = transformConstraints.length; i2 < n2; i2++) {
        var constraint = transformConstraints[i2];
        var data2 = constraint.data;
        constraint.mixRotate = data2.mixRotate;
        constraint.mixX = data2.mixX;
        constraint.mixY = data2.mixY;
        constraint.mixScaleX = data2.mixScaleX;
        constraint.mixScaleY = data2.mixScaleY;
        constraint.mixShearY = data2.mixShearY;
      }
      var pathConstraints = this.pathConstraints;
      for (var i2 = 0, n2 = pathConstraints.length; i2 < n2; i2++) {
        var constraint = pathConstraints[i2];
        var data2 = constraint.data;
        constraint.position = data2.position;
        constraint.spacing = data2.spacing;
        constraint.mixRotate = data2.mixRotate;
        constraint.mixX = data2.mixX;
        constraint.mixY = data2.mixY;
      }
    };
    Skeleton2.prototype.setSlotsToSetupPose = function() {
      var slots = this.slots;
      Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
      for (var i2 = 0, n2 = slots.length; i2 < n2; i2++)
        slots[i2].setToSetupPose();
    };
    Skeleton2.prototype.getRootBone = function() {
      if (this.bones.length == 0)
        return null;
      return this.bones[0];
    };
    Skeleton2.prototype.findBone = function(boneName) {
      if (!boneName)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        if (bone.data.name == boneName)
          return bone;
      }
      return null;
    };
    Skeleton2.prototype.findBoneIndex = function(boneName) {
      if (!boneName)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++)
        if (bones[i2].data.name == boneName)
          return i2;
      return -1;
    };
    Skeleton2.prototype.findSlot = function(slotName) {
      if (!slotName)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i2 = 0, n2 = slots.length; i2 < n2; i2++) {
        var slot = slots[i2];
        if (slot.data.name == slotName)
          return slot;
      }
      return null;
    };
    Skeleton2.prototype.findSlotIndex = function(slotName) {
      if (!slotName)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i2 = 0, n2 = slots.length; i2 < n2; i2++)
        if (slots[i2].data.name == slotName)
          return i2;
      return -1;
    };
    Skeleton2.prototype.setSkinByName = function(skinName) {
      var skin = this.data.findSkin(skinName);
      if (!skin)
        throw new Error("Skin not found: " + skinName);
      this.setSkin(skin);
    };
    Skeleton2.prototype.setSkin = function(newSkin) {
      if (newSkin == this.skin)
        return;
      if (newSkin) {
        if (this.skin)
          newSkin.attachAll(this, this.skin);
        else {
          var slots = this.slots;
          for (var i2 = 0, n2 = slots.length; i2 < n2; i2++) {
            var slot = slots[i2];
            var name_1 = slot.data.attachmentName;
            if (name_1) {
              var attachment = newSkin.getAttachment(i2, name_1);
              if (attachment)
                slot.setAttachment(attachment);
            }
          }
        }
      }
      this.skin = newSkin;
      this.updateCache();
    };
    Skeleton2.prototype.getAttachmentByName = function(slotName, attachmentName) {
      var slot = this.data.findSlot(slotName);
      if (!slot)
        throw new Error("Can't find slot with name " + slotName);
      return this.getAttachment(slot.index, attachmentName);
    };
    Skeleton2.prototype.getAttachment = function(slotIndex, attachmentName) {
      if (!attachmentName)
        throw new Error("attachmentName cannot be null.");
      if (this.skin) {
        var attachment = this.skin.getAttachment(slotIndex, attachmentName);
        if (attachment)
          return attachment;
      }
      if (this.data.defaultSkin)
        return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
      return null;
    };
    Skeleton2.prototype.setAttachment = function(slotName, attachmentName) {
      if (!slotName)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i2 = 0, n2 = slots.length; i2 < n2; i2++) {
        var slot = slots[i2];
        if (slot.data.name == slotName) {
          var attachment = null;
          if (attachmentName) {
            attachment = this.getAttachment(i2, attachmentName);
            if (!attachment)
              throw new Error("Attachment not found: " + attachmentName + ", for slot: " + slotName);
          }
          slot.setAttachment(attachment);
          return;
        }
      }
      throw new Error("Slot not found: " + slotName);
    };
    Skeleton2.prototype.findIkConstraint = function(constraintName) {
      if (!constraintName)
        throw new Error("constraintName cannot be null.");
      var ikConstraints = this.ikConstraints;
      for (var i2 = 0, n2 = ikConstraints.length; i2 < n2; i2++) {
        var ikConstraint = ikConstraints[i2];
        if (ikConstraint.data.name == constraintName)
          return ikConstraint;
      }
      return null;
    };
    Skeleton2.prototype.findTransformConstraint = function(constraintName) {
      if (!constraintName)
        throw new Error("constraintName cannot be null.");
      var transformConstraints = this.transformConstraints;
      for (var i2 = 0, n2 = transformConstraints.length; i2 < n2; i2++) {
        var constraint = transformConstraints[i2];
        if (constraint.data.name == constraintName)
          return constraint;
      }
      return null;
    };
    Skeleton2.prototype.findPathConstraint = function(constraintName) {
      if (!constraintName)
        throw new Error("constraintName cannot be null.");
      var pathConstraints = this.pathConstraints;
      for (var i2 = 0, n2 = pathConstraints.length; i2 < n2; i2++) {
        var constraint = pathConstraints[i2];
        if (constraint.data.name == constraintName)
          return constraint;
      }
      return null;
    };
    Skeleton2.prototype.getBoundsRect = function() {
      var offset = new Vector2();
      var size = new Vector2();
      this.getBounds(offset, size);
      return { x: offset.x, y: offset.y, width: size.x, height: size.y };
    };
    Skeleton2.prototype.getBounds = function(offset, size, temp2) {
      if (temp2 === void 0) {
        temp2 = new Array(2);
      }
      if (!offset)
        throw new Error("offset cannot be null.");
      if (!size)
        throw new Error("size cannot be null.");
      var drawOrder = this.drawOrder;
      var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
      for (var i2 = 0, n2 = drawOrder.length; i2 < n2; i2++) {
        var slot = drawOrder[i2];
        if (!slot.bone.active)
          continue;
        var verticesLength = 0;
        var vertices = null;
        var attachment = slot.getAttachment();
        if (attachment instanceof RegionAttachment) {
          verticesLength = 8;
          vertices = Utils.setArraySize(temp2, verticesLength, 0);
          attachment.computeWorldVertices(slot, vertices, 0, 2);
        } else if (attachment instanceof MeshAttachment) {
          var mesh = attachment;
          verticesLength = mesh.worldVerticesLength;
          vertices = Utils.setArraySize(temp2, verticesLength, 0);
          mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
        }
        if (vertices) {
          for (var ii2 = 0, nn2 = vertices.length; ii2 < nn2; ii2 += 2) {
            var x = vertices[ii2], y2 = vertices[ii2 + 1];
            minX = Math.min(minX, x);
            minY = Math.min(minY, y2);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y2);
          }
        }
      }
      offset.set(minX, minY);
      size.set(maxX - minX, maxY - minY);
    };
    Object.defineProperty(Skeleton2.prototype, "flipX", {
      get: function() {
        return this.scaleX == -1;
      },
      set: function(value) {
        if (!Skeleton2.deprecatedWarning1) {
          Skeleton2.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
        }
        this.scaleX = value ? 1 : -1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Skeleton2.prototype, "flipY", {
      get: function() {
        return this.scaleY == -1;
      },
      set: function(value) {
        if (!Skeleton2.deprecatedWarning1) {
          Skeleton2.deprecatedWarning1 = true;
          console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
        }
        this.scaleY = value ? 1 : -1;
      },
      enumerable: false,
      configurable: true
    });
    Skeleton2.deprecatedWarning1 = false;
    return Skeleton2;
  }()
);
var SkeletonData = (
  /** @class */
  function() {
    function SkeletonData2() {
      this.name = null;
      this.bones = new Array();
      this.slots = new Array();
      this.skins = new Array();
      this.defaultSkin = null;
      this.events = new Array();
      this.animations = new Array();
      this.ikConstraints = new Array();
      this.transformConstraints = new Array();
      this.pathConstraints = new Array();
      this.x = 0;
      this.y = 0;
      this.width = 0;
      this.height = 0;
      this.version = null;
      this.hash = null;
      this.fps = 0;
      this.imagesPath = null;
      this.audioPath = null;
    }
    SkeletonData2.prototype.findBone = function(boneName) {
      if (!boneName)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++) {
        var bone = bones[i2];
        if (bone.name == boneName)
          return bone;
      }
      return null;
    };
    SkeletonData2.prototype.findBoneIndex = function(boneName) {
      if (!boneName)
        throw new Error("boneName cannot be null.");
      var bones = this.bones;
      for (var i2 = 0, n2 = bones.length; i2 < n2; i2++)
        if (bones[i2].name == boneName)
          return i2;
      return -1;
    };
    SkeletonData2.prototype.findSlot = function(slotName) {
      if (!slotName)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i2 = 0, n2 = slots.length; i2 < n2; i2++) {
        var slot = slots[i2];
        if (slot.name == slotName)
          return slot;
      }
      return null;
    };
    SkeletonData2.prototype.findSlotIndex = function(slotName) {
      if (!slotName)
        throw new Error("slotName cannot be null.");
      var slots = this.slots;
      for (var i2 = 0, n2 = slots.length; i2 < n2; i2++)
        if (slots[i2].name == slotName)
          return i2;
      return -1;
    };
    SkeletonData2.prototype.findSkin = function(skinName) {
      if (!skinName)
        throw new Error("skinName cannot be null.");
      var skins = this.skins;
      for (var i2 = 0, n2 = skins.length; i2 < n2; i2++) {
        var skin = skins[i2];
        if (skin.name == skinName)
          return skin;
      }
      return null;
    };
    SkeletonData2.prototype.findEvent = function(eventDataName) {
      if (!eventDataName)
        throw new Error("eventDataName cannot be null.");
      var events = this.events;
      for (var i2 = 0, n2 = events.length; i2 < n2; i2++) {
        var event_1 = events[i2];
        if (event_1.name == eventDataName)
          return event_1;
      }
      return null;
    };
    SkeletonData2.prototype.findAnimation = function(animationName) {
      if (!animationName)
        throw new Error("animationName cannot be null.");
      var animations = this.animations;
      for (var i2 = 0, n2 = animations.length; i2 < n2; i2++) {
        var animation2 = animations[i2];
        if (animation2.name == animationName)
          return animation2;
      }
      return null;
    };
    SkeletonData2.prototype.findIkConstraint = function(constraintName) {
      if (!constraintName)
        throw new Error("constraintName cannot be null.");
      var ikConstraints = this.ikConstraints;
      for (var i2 = 0, n2 = ikConstraints.length; i2 < n2; i2++) {
        var constraint = ikConstraints[i2];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    };
    SkeletonData2.prototype.findTransformConstraint = function(constraintName) {
      if (!constraintName)
        throw new Error("constraintName cannot be null.");
      var transformConstraints = this.transformConstraints;
      for (var i2 = 0, n2 = transformConstraints.length; i2 < n2; i2++) {
        var constraint = transformConstraints[i2];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    };
    SkeletonData2.prototype.findPathConstraint = function(constraintName) {
      if (!constraintName)
        throw new Error("constraintName cannot be null.");
      var pathConstraints = this.pathConstraints;
      for (var i2 = 0, n2 = pathConstraints.length; i2 < n2; i2++) {
        var constraint = pathConstraints[i2];
        if (constraint.name == constraintName)
          return constraint;
      }
      return null;
    };
    SkeletonData2.prototype.findPathConstraintIndex = function(pathConstraintName) {
      if (pathConstraintName == null)
        throw new Error("pathConstraintName cannot be null.");
      var pathConstraints = this.pathConstraints;
      for (var i2 = 0, n2 = pathConstraints.length; i2 < n2; i2++)
        if (pathConstraints[i2].name == pathConstraintName)
          return i2;
      return -1;
    };
    return SkeletonData2;
  }()
);
var SlotData = (
  /** @class */
  function() {
    function SlotData2(index2, name, boneData) {
      this.index = 0;
      this.color = new Color(1, 1, 1, 1);
      this.darkColor = null;
      this.attachmentName = null;
      this.blendMode = BLEND_MODES$4.NORMAL;
      if (index2 < 0)
        throw new Error("index must be >= 0.");
      if (!name)
        throw new Error("name cannot be null.");
      if (!boneData)
        throw new Error("boneData cannot be null.");
      this.index = index2;
      this.name = name;
      this.boneData = boneData;
    }
    return SlotData2;
  }()
);
var TransformConstraintData = (
  /** @class */
  function(_super) {
    __extends$2(TransformConstraintData2, _super);
    function TransformConstraintData2(name) {
      var _this = _super.call(this, name, 0, false) || this;
      _this.bones = new Array();
      _this._target = null;
      _this.mixRotate = 0;
      _this.mixX = 0;
      _this.mixY = 0;
      _this.mixScaleX = 0;
      _this.mixScaleY = 0;
      _this.mixShearY = 0;
      _this.offsetRotation = 0;
      _this.offsetX = 0;
      _this.offsetY = 0;
      _this.offsetScaleX = 0;
      _this.offsetScaleY = 0;
      _this.offsetShearY = 0;
      _this.relative = false;
      _this.local = false;
      return _this;
    }
    Object.defineProperty(TransformConstraintData2.prototype, "target", {
      get: function() {
        if (!this._target)
          throw new Error("BoneData not set.");
        else
          return this._target;
      },
      set: function(boneData) {
        this._target = boneData;
      },
      enumerable: false,
      configurable: true
    });
    return TransformConstraintData2;
  }(ConstraintData)
);
var SkinEntry = (
  /** @class */
  function() {
    function SkinEntry2(slotIndex, name, attachment) {
      this.slotIndex = slotIndex;
      this.name = name;
      this.attachment = attachment;
    }
    return SkinEntry2;
  }()
);
var Skin = (
  /** @class */
  function() {
    function Skin2(name) {
      this.attachments = new Array();
      this.bones = Array();
      this.constraints = new Array();
      if (!name)
        throw new Error("name cannot be null.");
      this.name = name;
    }
    Skin2.prototype.setAttachment = function(slotIndex, name, attachment) {
      if (!attachment)
        throw new Error("attachment cannot be null.");
      var attachments = this.attachments;
      if (slotIndex >= attachments.length)
        attachments.length = slotIndex + 1;
      if (!attachments[slotIndex])
        attachments[slotIndex] = {};
      attachments[slotIndex][name] = attachment;
    };
    Skin2.prototype.addSkin = function(skin) {
      for (var i2 = 0; i2 < skin.bones.length; i2++) {
        var bone = skin.bones[i2];
        var contained = false;
        for (var ii2 = 0; ii2 < this.bones.length; ii2++) {
          if (this.bones[ii2] == bone) {
            contained = true;
            break;
          }
        }
        if (!contained)
          this.bones.push(bone);
      }
      for (var i2 = 0; i2 < skin.constraints.length; i2++) {
        var constraint = skin.constraints[i2];
        var contained = false;
        for (var ii2 = 0; ii2 < this.constraints.length; ii2++) {
          if (this.constraints[ii2] == constraint) {
            contained = true;
            break;
          }
        }
        if (!contained)
          this.constraints.push(constraint);
      }
      var attachments = skin.getAttachments();
      for (var i2 = 0; i2 < attachments.length; i2++) {
        var attachment = attachments[i2];
        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
      }
    };
    Skin2.prototype.copySkin = function(skin) {
      for (var i2 = 0; i2 < skin.bones.length; i2++) {
        var bone = skin.bones[i2];
        var contained = false;
        for (var ii2 = 0; ii2 < this.bones.length; ii2++) {
          if (this.bones[ii2] == bone) {
            contained = true;
            break;
          }
        }
        if (!contained)
          this.bones.push(bone);
      }
      for (var i2 = 0; i2 < skin.constraints.length; i2++) {
        var constraint = skin.constraints[i2];
        var contained = false;
        for (var ii2 = 0; ii2 < this.constraints.length; ii2++) {
          if (this.constraints[ii2] == constraint) {
            contained = true;
            break;
          }
        }
        if (!contained)
          this.constraints.push(constraint);
      }
      var attachments = skin.getAttachments();
      for (var i2 = 0; i2 < attachments.length; i2++) {
        var attachment = attachments[i2];
        if (!attachment.attachment)
          continue;
        if (attachment.attachment instanceof MeshAttachment) {
          attachment.attachment = attachment.attachment.newLinkedMesh();
          this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
        } else {
          attachment.attachment = attachment.attachment.copy();
          this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
        }
      }
    };
    Skin2.prototype.getAttachment = function(slotIndex, name) {
      var dictionary = this.attachments[slotIndex];
      return dictionary ? dictionary[name] : null;
    };
    Skin2.prototype.removeAttachment = function(slotIndex, name) {
      var dictionary = this.attachments[slotIndex];
      if (dictionary)
        delete dictionary[name];
    };
    Skin2.prototype.getAttachments = function() {
      var entries = new Array();
      for (var i2 = 0; i2 < this.attachments.length; i2++) {
        var slotAttachments = this.attachments[i2];
        if (slotAttachments) {
          for (var name_1 in slotAttachments) {
            var attachment = slotAttachments[name_1];
            if (attachment)
              entries.push(new SkinEntry(i2, name_1, attachment));
          }
        }
      }
      return entries;
    };
    Skin2.prototype.getAttachmentsForSlot = function(slotIndex, attachments) {
      var slotAttachments = this.attachments[slotIndex];
      if (slotAttachments) {
        for (var name_2 in slotAttachments) {
          var attachment = slotAttachments[name_2];
          if (attachment)
            attachments.push(new SkinEntry(slotIndex, name_2, attachment));
        }
      }
    };
    Skin2.prototype.clear = function() {
      this.attachments.length = 0;
      this.bones.length = 0;
      this.constraints.length = 0;
    };
    Skin2.prototype.attachAll = function(skeleton, oldSkin) {
      var slotIndex = 0;
      for (var i2 = 0; i2 < skeleton.slots.length; i2++) {
        var slot = skeleton.slots[i2];
        var slotAttachment = slot.getAttachment();
        if (slotAttachment && slotIndex < oldSkin.attachments.length) {
          var dictionary = oldSkin.attachments[slotIndex];
          for (var key in dictionary) {
            var skinAttachment = dictionary[key];
            if (slotAttachment == skinAttachment) {
              var attachment = this.getAttachment(slotIndex, key);
              if (attachment)
                slot.setAttachment(attachment);
              break;
            }
          }
        }
        slotIndex++;
      }
    };
    return Skin2;
  }()
);
var SkeletonBinary = (
  /** @class */
  function() {
    function SkeletonBinary2(attachmentLoader) {
      this.ver40 = false;
      this.scale = 1;
      this.linkedMeshes = new Array();
      this.attachmentLoader = attachmentLoader;
    }
    SkeletonBinary2.prototype.readSkeletonData = function(binary) {
      var scale = this.scale;
      var skeletonData = new SkeletonData();
      skeletonData.name = "";
      var input = new BinaryInput(binary);
      var lowHash = input.readInt32();
      var highHash = input.readInt32();
      skeletonData.hash = highHash == 0 && lowHash == 0 ? null : highHash.toString(16) + lowHash.toString(16);
      skeletonData.version = input.readString();
      var verShort = skeletonData.version.substr(0, 3);
      if (verShort !== "4.0" && verShort !== "4.1") {
        var error2 = "Spine 4.1 loader cant load version " + skeletonData.version + ". Please configure your pixi-spine bundle";
        console.error(error2);
      }
      this.ver40 = verShort === "4.0";
      skeletonData.x = input.readFloat();
      skeletonData.y = input.readFloat();
      skeletonData.width = input.readFloat();
      skeletonData.height = input.readFloat();
      var nonessential = input.readBoolean();
      if (nonessential) {
        skeletonData.fps = input.readFloat();
        skeletonData.imagesPath = input.readString();
        skeletonData.audioPath = input.readString();
      }
      var n2 = 0;
      n2 = input.readInt(true);
      for (var i2 = 0; i2 < n2; i2++) {
        var str = input.readString();
        if (!str)
          throw new Error("String in string table must not be null.");
        input.strings.push(str);
      }
      n2 = input.readInt(true);
      for (var i2 = 0; i2 < n2; i2++) {
        var name_1 = input.readString();
        if (!name_1)
          throw new Error("Bone name must not be null.");
        var parent_1 = i2 == 0 ? null : skeletonData.bones[input.readInt(true)];
        var data2 = new BoneData(i2, name_1, parent_1);
        data2.rotation = input.readFloat();
        data2.x = input.readFloat() * scale;
        data2.y = input.readFloat() * scale;
        data2.scaleX = input.readFloat();
        data2.scaleY = input.readFloat();
        data2.shearX = input.readFloat();
        data2.shearY = input.readFloat();
        data2.length = input.readFloat() * scale;
        data2.transformMode = input.readInt(true);
        data2.skinRequired = input.readBoolean();
        if (nonessential)
          Color.rgba8888ToColor(data2.color, input.readInt32());
        skeletonData.bones.push(data2);
      }
      n2 = input.readInt(true);
      for (var i2 = 0; i2 < n2; i2++) {
        var slotName = input.readString();
        if (!slotName)
          throw new Error("Slot name must not be null.");
        var boneData = skeletonData.bones[input.readInt(true)];
        var data2 = new SlotData(i2, slotName, boneData);
        Color.rgba8888ToColor(data2.color, input.readInt32());
        var darkColor = input.readInt32();
        if (darkColor != -1)
          Color.rgb888ToColor(data2.darkColor = new Color(), darkColor);
        data2.attachmentName = input.readStringRef();
        data2.blendMode = input.readInt(true);
        skeletonData.slots.push(data2);
      }
      n2 = input.readInt(true);
      for (var i2 = 0, nn2 = void 0; i2 < n2; i2++) {
        var name_2 = input.readString();
        if (!name_2)
          throw new Error("IK constraint data name must not be null.");
        var data2 = new IkConstraintData(name_2);
        data2.order = input.readInt(true);
        data2.skinRequired = input.readBoolean();
        nn2 = input.readInt(true);
        for (var ii2 = 0; ii2 < nn2; ii2++)
          data2.bones.push(skeletonData.bones[input.readInt(true)]);
        data2.target = skeletonData.bones[input.readInt(true)];
        data2.mix = input.readFloat();
        data2.softness = input.readFloat() * scale;
        data2.bendDirection = input.readByte();
        data2.compress = input.readBoolean();
        data2.stretch = input.readBoolean();
        data2.uniform = input.readBoolean();
        skeletonData.ikConstraints.push(data2);
      }
      n2 = input.readInt(true);
      for (var i2 = 0, nn2 = void 0; i2 < n2; i2++) {
        var name_3 = input.readString();
        if (!name_3)
          throw new Error("Transform constraint data name must not be null.");
        var data2 = new TransformConstraintData(name_3);
        data2.order = input.readInt(true);
        data2.skinRequired = input.readBoolean();
        nn2 = input.readInt(true);
        for (var ii2 = 0; ii2 < nn2; ii2++)
          data2.bones.push(skeletonData.bones[input.readInt(true)]);
        data2.target = skeletonData.bones[input.readInt(true)];
        data2.local = input.readBoolean();
        data2.relative = input.readBoolean();
        data2.offsetRotation = input.readFloat();
        data2.offsetX = input.readFloat() * scale;
        data2.offsetY = input.readFloat() * scale;
        data2.offsetScaleX = input.readFloat();
        data2.offsetScaleY = input.readFloat();
        data2.offsetShearY = input.readFloat();
        data2.mixRotate = input.readFloat();
        data2.mixX = input.readFloat();
        data2.mixY = input.readFloat();
        data2.mixScaleX = input.readFloat();
        data2.mixScaleY = input.readFloat();
        data2.mixShearY = input.readFloat();
        skeletonData.transformConstraints.push(data2);
      }
      n2 = input.readInt(true);
      for (var i2 = 0, nn2 = void 0; i2 < n2; i2++) {
        var name_4 = input.readString();
        if (!name_4)
          throw new Error("Path constraint data name must not be null.");
        var data2 = new PathConstraintData(name_4);
        data2.order = input.readInt(true);
        data2.skinRequired = input.readBoolean();
        nn2 = input.readInt(true);
        for (var ii2 = 0; ii2 < nn2; ii2++)
          data2.bones.push(skeletonData.bones[input.readInt(true)]);
        data2.target = skeletonData.slots[input.readInt(true)];
        data2.positionMode = input.readInt(true);
        data2.spacingMode = input.readInt(true);
        data2.rotateMode = input.readInt(true);
        data2.offsetRotation = input.readFloat();
        data2.position = input.readFloat();
        if (data2.positionMode == PositionMode.Fixed)
          data2.position *= scale;
        data2.spacing = input.readFloat();
        if (data2.spacingMode == SpacingMode.Length || data2.spacingMode == SpacingMode.Fixed)
          data2.spacing *= scale;
        data2.mixRotate = input.readFloat();
        data2.mixX = input.readFloat();
        data2.mixY = input.readFloat();
        skeletonData.pathConstraints.push(data2);
      }
      var defaultSkin = this.readSkin(input, skeletonData, true, nonessential);
      if (defaultSkin) {
        skeletonData.defaultSkin = defaultSkin;
        skeletonData.skins.push(defaultSkin);
      }
      {
        var i2 = skeletonData.skins.length;
        Utils.setArraySize(skeletonData.skins, n2 = i2 + input.readInt(true));
        for (; i2 < n2; i2++) {
          var skin = this.readSkin(input, skeletonData, false, nonessential);
          if (!skin)
            throw new Error("readSkin() should not have returned null.");
          skeletonData.skins[i2] = skin;
        }
      }
      n2 = this.linkedMeshes.length;
      for (var i2 = 0; i2 < n2; i2++) {
        var linkedMesh = this.linkedMeshes[i2];
        var skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
        if (!skin)
          throw new Error("Not skin found for linked mesh.");
        if (!linkedMesh.parent)
          throw new Error("Linked mesh parent must not be null");
        var parent_2 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
        if (!parent_2)
          throw new Error("Parent mesh not found: " + linkedMesh.parent);
        linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? parent_2 : linkedMesh.mesh;
        linkedMesh.mesh.setParentMesh(parent_2);
      }
      this.linkedMeshes.length = 0;
      n2 = input.readInt(true);
      for (var i2 = 0; i2 < n2; i2++) {
        var eventName = input.readStringRef();
        if (!eventName)
          throw new Error();
        var data2 = new EventData(eventName);
        data2.intValue = input.readInt(false);
        data2.floatValue = input.readFloat();
        data2.stringValue = input.readString();
        data2.audioPath = input.readString();
        if (data2.audioPath) {
          data2.volume = input.readFloat();
          data2.balance = input.readFloat();
        }
        skeletonData.events.push(data2);
      }
      n2 = input.readInt(true);
      for (var i2 = 0; i2 < n2; i2++) {
        var animationName = input.readString();
        if (!animationName)
          throw new Error("Animatio name must not be null.");
        skeletonData.animations.push(this.readAnimation(input, animationName, skeletonData));
      }
      return skeletonData;
    };
    SkeletonBinary2.prototype.readSkin = function(input, skeletonData, defaultSkin, nonessential) {
      var skin = null;
      var slotCount = 0;
      if (defaultSkin) {
        slotCount = input.readInt(true);
        if (slotCount == 0)
          return null;
        skin = new Skin("default");
      } else {
        var skinName = input.readStringRef();
        if (!skinName)
          throw new Error("Skin name must not be null.");
        skin = new Skin(skinName);
        skin.bones.length = input.readInt(true);
        for (var i2 = 0, n2 = skin.bones.length; i2 < n2; i2++)
          skin.bones[i2] = skeletonData.bones[input.readInt(true)];
        for (var i2 = 0, n2 = input.readInt(true); i2 < n2; i2++)
          skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);
        for (var i2 = 0, n2 = input.readInt(true); i2 < n2; i2++)
          skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);
        for (var i2 = 0, n2 = input.readInt(true); i2 < n2; i2++)
          skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);
        slotCount = input.readInt(true);
      }
      for (var i2 = 0; i2 < slotCount; i2++) {
        var slotIndex = input.readInt(true);
        for (var ii2 = 0, nn2 = input.readInt(true); ii2 < nn2; ii2++) {
          var name_5 = input.readStringRef();
          if (!name_5)
            throw new Error("Attachment name must not be null");
          var attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name_5, nonessential);
          if (attachment)
            skin.setAttachment(slotIndex, name_5, attachment);
        }
      }
      return skin;
    };
    SkeletonBinary2.prototype.readAttachment = function(input, skeletonData, skin, slotIndex, attachmentName, nonessential) {
      var scale = this.scale;
      var name = input.readStringRef();
      if (!name)
        name = attachmentName;
      switch (input.readByte()) {
        case AttachmentType.Region: {
          var path = input.readStringRef();
          var rotation = input.readFloat();
          var x = input.readFloat();
          var y2 = input.readFloat();
          var scaleX = input.readFloat();
          var scaleY = input.readFloat();
          var width = input.readFloat();
          var height = input.readFloat();
          var color2 = input.readInt32();
          var sequence = this.readSequence(input);
          if (!path)
            path = name;
          var region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);
          if (!region)
            return null;
          region.path = path;
          region.x = x * scale;
          region.y = y2 * scale;
          region.scaleX = scaleX;
          region.scaleY = scaleY;
          region.rotation = rotation;
          region.width = width * scale;
          region.height = height * scale;
          Color.rgba8888ToColor(region.color, color2);
          region.sequence = sequence;
          if (sequence == null)
            region.updateRegion();
          return region;
        }
        case AttachmentType.BoundingBox: {
          var vertexCount = input.readInt(true);
          var vertices = this.readVertices(input, vertexCount);
          var color2 = nonessential ? input.readInt32() : 0;
          var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
          if (!box)
            return null;
          box.worldVerticesLength = vertexCount << 1;
          box.vertices = vertices.vertices;
          box.bones = vertices.bones;
          if (nonessential)
            Color.rgba8888ToColor(box.color, color2);
          return box;
        }
        case AttachmentType.Mesh: {
          var path = input.readStringRef();
          var color2 = input.readInt32();
          var vertexCount = input.readInt(true);
          var uvs = this.readFloatArray(input, vertexCount << 1, 1);
          var triangles = this.readShortArray(input);
          var vertices = this.readVertices(input, vertexCount);
          var hullLength = input.readInt(true);
          var sequence = this.readSequence(input);
          var edges = [];
          var width = 0, height = 0;
          if (nonessential) {
            edges = this.readShortArray(input);
            width = input.readFloat();
            height = input.readFloat();
          }
          if (!path)
            path = name;
          var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);
          if (!mesh)
            return null;
          mesh.path = path;
          Color.rgba8888ToColor(mesh.color, color2);
          mesh.bones = vertices.bones;
          mesh.vertices = vertices.vertices;
          mesh.worldVerticesLength = vertexCount << 1;
          mesh.triangles = triangles;
          mesh.regionUVs = new Float32Array(uvs);
          mesh.hullLength = hullLength << 1;
          mesh.sequence = sequence;
          if (nonessential) {
            mesh.edges = edges;
            mesh.width = width * scale;
            mesh.height = height * scale;
          }
          return mesh;
        }
        case AttachmentType.LinkedMesh: {
          var path = input.readStringRef();
          var color2 = input.readInt32();
          var skinName = input.readStringRef();
          var parent_3 = input.readStringRef();
          var inheritTimelines = input.readBoolean();
          var sequence = this.readSequence(input);
          var width = 0, height = 0;
          if (nonessential) {
            width = input.readFloat();
            height = input.readFloat();
          }
          if (!path)
            path = name;
          var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);
          if (!mesh)
            return null;
          mesh.path = path;
          Color.rgba8888ToColor(mesh.color, color2);
          mesh.sequence = sequence;
          if (nonessential) {
            mesh.width = width * scale;
            mesh.height = height * scale;
          }
          this.linkedMeshes.push(new LinkedMesh$1(mesh, skinName, slotIndex, parent_3, inheritTimelines));
          return mesh;
        }
        case AttachmentType.Path: {
          var closed_1 = input.readBoolean();
          var constantSpeed = input.readBoolean();
          var vertexCount = input.readInt(true);
          var vertices = this.readVertices(input, vertexCount);
          var lengths = Utils.newArray(vertexCount / 3, 0);
          for (var i2 = 0, n2 = lengths.length; i2 < n2; i2++)
            lengths[i2] = input.readFloat() * scale;
          var color2 = nonessential ? input.readInt32() : 0;
          var path = this.attachmentLoader.newPathAttachment(skin, name);
          if (!path)
            return null;
          path.closed = closed_1;
          path.constantSpeed = constantSpeed;
          path.worldVerticesLength = vertexCount << 1;
          path.vertices = vertices.vertices;
          path.bones = vertices.bones;
          path.lengths = lengths;
          if (nonessential)
            Color.rgba8888ToColor(path.color, color2);
          return path;
        }
        case AttachmentType.Point: {
          var rotation = input.readFloat();
          var x = input.readFloat();
          var y2 = input.readFloat();
          var color2 = nonessential ? input.readInt32() : 0;
          var point = this.attachmentLoader.newPointAttachment(skin, name);
          if (!point)
            return null;
          point.x = x * scale;
          point.y = y2 * scale;
          point.rotation = rotation;
          if (nonessential)
            Color.rgba8888ToColor(point.color, color2);
          return point;
        }
        case AttachmentType.Clipping: {
          var endSlotIndex = input.readInt(true);
          var vertexCount = input.readInt(true);
          var vertices = this.readVertices(input, vertexCount);
          var color2 = nonessential ? input.readInt32() : 0;
          var clip = this.attachmentLoader.newClippingAttachment(skin, name);
          if (!clip)
            return null;
          clip.endSlot = skeletonData.slots[endSlotIndex];
          clip.worldVerticesLength = vertexCount << 1;
          clip.vertices = vertices.vertices;
          clip.bones = vertices.bones;
          if (nonessential)
            Color.rgba8888ToColor(clip.color, color2);
          return clip;
        }
      }
      return null;
    };
    SkeletonBinary2.prototype.readSequence = function(input) {
      if (this.ver40 || !input.readBoolean())
        return null;
      var sequence = new Sequence(input.readInt(true));
      sequence.start = input.readInt(true);
      sequence.digits = input.readInt(true);
      sequence.setupIndex = input.readInt(true);
      return sequence;
    };
    SkeletonBinary2.prototype.readDeformTimelineType = function(input) {
      if (this.ver40)
        return ATTACHMENT_DEFORM;
      return input.readByte();
    };
    SkeletonBinary2.prototype.readVertices = function(input, vertexCount) {
      var scale = this.scale;
      var verticesLength = vertexCount << 1;
      var vertices = new Vertices();
      if (!input.readBoolean()) {
        vertices.vertices = this.readFloatArray(input, verticesLength, scale);
        return vertices;
      }
      var weights = new Array();
      var bonesArray = new Array();
      for (var i2 = 0; i2 < vertexCount; i2++) {
        var boneCount = input.readInt(true);
        bonesArray.push(boneCount);
        for (var ii2 = 0; ii2 < boneCount; ii2++) {
          bonesArray.push(input.readInt(true));
          weights.push(input.readFloat() * scale);
          weights.push(input.readFloat() * scale);
          weights.push(input.readFloat());
        }
      }
      vertices.vertices = Utils.toFloatArray(weights);
      vertices.bones = bonesArray;
      return vertices;
    };
    SkeletonBinary2.prototype.readFloatArray = function(input, n2, scale) {
      var array = new Array(n2);
      if (scale == 1) {
        for (var i2 = 0; i2 < n2; i2++)
          array[i2] = input.readFloat();
      } else {
        for (var i2 = 0; i2 < n2; i2++)
          array[i2] = input.readFloat() * scale;
      }
      return array;
    };
    SkeletonBinary2.prototype.readShortArray = function(input) {
      var n2 = input.readInt(true);
      var array = new Array(n2);
      for (var i2 = 0; i2 < n2; i2++)
        array[i2] = input.readShort();
      return array;
    };
    SkeletonBinary2.prototype.readAnimation = function(input, name, skeletonData) {
      input.readInt(true);
      var timelines = new Array();
      var scale = this.scale;
      for (var i2 = 0, n2 = input.readInt(true); i2 < n2; i2++) {
        var slotIndex = input.readInt(true);
        for (var ii2 = 0, nn2 = input.readInt(true); ii2 < nn2; ii2++) {
          var timelineType = input.readByte();
          var frameCount = input.readInt(true);
          var frameLast = frameCount - 1;
          switch (timelineType) {
            case SLOT_ATTACHMENT: {
              var timeline = new AttachmentTimeline(frameCount, slotIndex);
              for (var frame2 = 0; frame2 < frameCount; frame2++)
                timeline.setFrame(frame2, input.readFloat(), input.readStringRef());
              timelines.push(timeline);
              break;
            }
            case SLOT_RGBA: {
              var bezierCount = input.readInt(true);
              var timeline = new RGBATimeline(frameCount, bezierCount, slotIndex);
              var time = input.readFloat();
              var r2 = input.readUnsignedByte() / 255;
              var g2 = input.readUnsignedByte() / 255;
              var b2 = input.readUnsignedByte() / 255;
              var a2 = input.readUnsignedByte() / 255;
              for (var frame2 = 0, bezier = 0; ; frame2++) {
                timeline.setFrame(frame2, time, r2, g2, b2, a2);
                if (frame2 == frameLast)
                  break;
                var time2 = input.readFloat();
                var r22 = input.readUnsignedByte() / 255;
                var g22 = input.readUnsignedByte() / 255;
                var b22 = input.readUnsignedByte() / 255;
                var a22 = input.readUnsignedByte() / 255;
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline.setStepped(frame2);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline, bezier++, frame2, 0, time, time2, r2, r22, 1);
                    setBezier(input, timeline, bezier++, frame2, 1, time, time2, g2, g22, 1);
                    setBezier(input, timeline, bezier++, frame2, 2, time, time2, b2, b22, 1);
                    setBezier(input, timeline, bezier++, frame2, 3, time, time2, a2, a22, 1);
                }
                time = time2;
                r2 = r22;
                g2 = g22;
                b2 = b22;
                a2 = a22;
              }
              timelines.push(timeline);
              break;
            }
            case SLOT_RGB: {
              var bezierCount = input.readInt(true);
              var timeline = new RGBTimeline(frameCount, bezierCount, slotIndex);
              var time = input.readFloat();
              var r2 = input.readUnsignedByte() / 255;
              var g2 = input.readUnsignedByte() / 255;
              var b2 = input.readUnsignedByte() / 255;
              for (var frame2 = 0, bezier = 0; ; frame2++) {
                timeline.setFrame(frame2, time, r2, g2, b2);
                if (frame2 == frameLast)
                  break;
                var time2 = input.readFloat();
                var r22 = input.readUnsignedByte() / 255;
                var g22 = input.readUnsignedByte() / 255;
                var b22 = input.readUnsignedByte() / 255;
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline.setStepped(frame2);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline, bezier++, frame2, 0, time, time2, r2, r22, 1);
                    setBezier(input, timeline, bezier++, frame2, 1, time, time2, g2, g22, 1);
                    setBezier(input, timeline, bezier++, frame2, 2, time, time2, b2, b22, 1);
                }
                time = time2;
                r2 = r22;
                g2 = g22;
                b2 = b22;
              }
              timelines.push(timeline);
              break;
            }
            case SLOT_RGBA2: {
              var bezierCount = input.readInt(true);
              var timeline = new RGBA2Timeline(frameCount, bezierCount, slotIndex);
              var time = input.readFloat();
              var r2 = input.readUnsignedByte() / 255;
              var g2 = input.readUnsignedByte() / 255;
              var b2 = input.readUnsignedByte() / 255;
              var a2 = input.readUnsignedByte() / 255;
              var r22 = input.readUnsignedByte() / 255;
              var g22 = input.readUnsignedByte() / 255;
              var b22 = input.readUnsignedByte() / 255;
              for (var frame2 = 0, bezier = 0; ; frame2++) {
                timeline.setFrame(frame2, time, r2, g2, b2, a2, r22, g22, b22);
                if (frame2 == frameLast)
                  break;
                var time2 = input.readFloat();
                var nr = input.readUnsignedByte() / 255;
                var ng2 = input.readUnsignedByte() / 255;
                var nb2 = input.readUnsignedByte() / 255;
                var na2 = input.readUnsignedByte() / 255;
                var nr2 = input.readUnsignedByte() / 255;
                var ng22 = input.readUnsignedByte() / 255;
                var nb22 = input.readUnsignedByte() / 255;
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline.setStepped(frame2);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline, bezier++, frame2, 0, time, time2, r2, nr, 1);
                    setBezier(input, timeline, bezier++, frame2, 1, time, time2, g2, ng2, 1);
                    setBezier(input, timeline, bezier++, frame2, 2, time, time2, b2, nb2, 1);
                    setBezier(input, timeline, bezier++, frame2, 3, time, time2, a2, na2, 1);
                    setBezier(input, timeline, bezier++, frame2, 4, time, time2, r22, nr2, 1);
                    setBezier(input, timeline, bezier++, frame2, 5, time, time2, g22, ng22, 1);
                    setBezier(input, timeline, bezier++, frame2, 6, time, time2, b22, nb22, 1);
                }
                time = time2;
                r2 = nr;
                g2 = ng2;
                b2 = nb2;
                a2 = na2;
                r22 = nr2;
                g22 = ng22;
                b22 = nb22;
              }
              timelines.push(timeline);
              break;
            }
            case SLOT_RGB2: {
              var bezierCount = input.readInt(true);
              var timeline = new RGB2Timeline(frameCount, bezierCount, slotIndex);
              var time = input.readFloat();
              var r2 = input.readUnsignedByte() / 255;
              var g2 = input.readUnsignedByte() / 255;
              var b2 = input.readUnsignedByte() / 255;
              var r22 = input.readUnsignedByte() / 255;
              var g22 = input.readUnsignedByte() / 255;
              var b22 = input.readUnsignedByte() / 255;
              for (var frame2 = 0, bezier = 0; ; frame2++) {
                timeline.setFrame(frame2, time, r2, g2, b2, r22, g22, b22);
                if (frame2 == frameLast)
                  break;
                var time2 = input.readFloat();
                var nr = input.readUnsignedByte() / 255;
                var ng2 = input.readUnsignedByte() / 255;
                var nb2 = input.readUnsignedByte() / 255;
                var nr2 = input.readUnsignedByte() / 255;
                var ng22 = input.readUnsignedByte() / 255;
                var nb22 = input.readUnsignedByte() / 255;
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline.setStepped(frame2);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline, bezier++, frame2, 0, time, time2, r2, nr, 1);
                    setBezier(input, timeline, bezier++, frame2, 1, time, time2, g2, ng2, 1);
                    setBezier(input, timeline, bezier++, frame2, 2, time, time2, b2, nb2, 1);
                    setBezier(input, timeline, bezier++, frame2, 3, time, time2, r22, nr2, 1);
                    setBezier(input, timeline, bezier++, frame2, 4, time, time2, g22, ng22, 1);
                    setBezier(input, timeline, bezier++, frame2, 5, time, time2, b22, nb22, 1);
                }
                time = time2;
                r2 = nr;
                g2 = ng2;
                b2 = nb2;
                r22 = nr2;
                g22 = ng22;
                b22 = nb22;
              }
              timelines.push(timeline);
              break;
            }
            case SLOT_ALPHA: {
              var timeline = new AlphaTimeline(frameCount, input.readInt(true), slotIndex);
              var time = input.readFloat(), a2 = input.readUnsignedByte() / 255;
              for (var frame2 = 0, bezier = 0; ; frame2++) {
                timeline.setFrame(frame2, time, a2);
                if (frame2 == frameLast)
                  break;
                var time2 = input.readFloat();
                var a22 = input.readUnsignedByte() / 255;
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline.setStepped(frame2);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline, bezier++, frame2, 0, time, time2, a2, a22, 1);
                }
                time = time2;
                a2 = a22;
              }
              timelines.push(timeline);
            }
          }
        }
      }
      for (var i2 = 0, n2 = input.readInt(true); i2 < n2; i2++) {
        var boneIndex = input.readInt(true);
        for (var ii2 = 0, nn2 = input.readInt(true); ii2 < nn2; ii2++) {
          var type2 = input.readByte(), frameCount = input.readInt(true), bezierCount = input.readInt(true);
          switch (type2) {
            case BONE_ROTATE:
              timelines.push(readTimeline1$1(input, new RotateTimeline(frameCount, bezierCount, boneIndex), 1));
              break;
            case BONE_TRANSLATE:
              timelines.push(readTimeline2$1(input, new TranslateTimeline(frameCount, bezierCount, boneIndex), scale));
              break;
            case BONE_TRANSLATEX:
              timelines.push(readTimeline1$1(input, new TranslateXTimeline(frameCount, bezierCount, boneIndex), scale));
              break;
            case BONE_TRANSLATEY:
              timelines.push(readTimeline1$1(input, new TranslateYTimeline(frameCount, bezierCount, boneIndex), scale));
              break;
            case BONE_SCALE:
              timelines.push(readTimeline2$1(input, new ScaleTimeline(frameCount, bezierCount, boneIndex), 1));
              break;
            case BONE_SCALEX:
              timelines.push(readTimeline1$1(input, new ScaleXTimeline(frameCount, bezierCount, boneIndex), 1));
              break;
            case BONE_SCALEY:
              timelines.push(readTimeline1$1(input, new ScaleYTimeline(frameCount, bezierCount, boneIndex), 1));
              break;
            case BONE_SHEAR:
              timelines.push(readTimeline2$1(input, new ShearTimeline(frameCount, bezierCount, boneIndex), 1));
              break;
            case BONE_SHEARX:
              timelines.push(readTimeline1$1(input, new ShearXTimeline(frameCount, bezierCount, boneIndex), 1));
              break;
            case BONE_SHEARY:
              timelines.push(readTimeline1$1(input, new ShearYTimeline(frameCount, bezierCount, boneIndex), 1));
          }
        }
      }
      for (var i2 = 0, n2 = input.readInt(true); i2 < n2; i2++) {
        var index2 = input.readInt(true), frameCount = input.readInt(true), frameLast = frameCount - 1;
        var timeline = new IkConstraintTimeline(frameCount, input.readInt(true), index2);
        var time = input.readFloat(), mix2 = input.readFloat(), softness = input.readFloat() * scale;
        for (var frame2 = 0, bezier = 0; ; frame2++) {
          timeline.setFrame(frame2, time, mix2, softness, input.readByte(), input.readBoolean(), input.readBoolean());
          if (frame2 == frameLast)
            break;
          var time2 = input.readFloat(), mix22 = input.readFloat(), softness2 = input.readFloat() * scale;
          switch (input.readByte()) {
            case CURVE_STEPPED:
              timeline.setStepped(frame2);
              break;
            case CURVE_BEZIER:
              setBezier(input, timeline, bezier++, frame2, 0, time, time2, mix2, mix22, 1);
              setBezier(input, timeline, bezier++, frame2, 1, time, time2, softness, softness2, scale);
          }
          time = time2;
          mix2 = mix22;
          softness = softness2;
        }
        timelines.push(timeline);
      }
      for (var i2 = 0, n2 = input.readInt(true); i2 < n2; i2++) {
        var index2 = input.readInt(true), frameCount = input.readInt(true), frameLast = frameCount - 1;
        var timeline = new TransformConstraintTimeline(frameCount, input.readInt(true), index2);
        var time = input.readFloat(), mixRotate = input.readFloat(), mixX = input.readFloat(), mixY = input.readFloat(), mixScaleX = input.readFloat(), mixScaleY = input.readFloat(), mixShearY = input.readFloat();
        for (var frame2 = 0, bezier = 0; ; frame2++) {
          timeline.setFrame(frame2, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);
          if (frame2 == frameLast)
            break;
          var time2 = input.readFloat(), mixRotate2 = input.readFloat(), mixX2 = input.readFloat(), mixY2 = input.readFloat(), mixScaleX2 = input.readFloat(), mixScaleY2 = input.readFloat(), mixShearY2 = input.readFloat();
          switch (input.readByte()) {
            case CURVE_STEPPED:
              timeline.setStepped(frame2);
              break;
            case CURVE_BEZIER:
              setBezier(input, timeline, bezier++, frame2, 0, time, time2, mixRotate, mixRotate2, 1);
              setBezier(input, timeline, bezier++, frame2, 1, time, time2, mixX, mixX2, 1);
              setBezier(input, timeline, bezier++, frame2, 2, time, time2, mixY, mixY2, 1);
              setBezier(input, timeline, bezier++, frame2, 3, time, time2, mixScaleX, mixScaleX2, 1);
              setBezier(input, timeline, bezier++, frame2, 4, time, time2, mixScaleY, mixScaleY2, 1);
              setBezier(input, timeline, bezier++, frame2, 5, time, time2, mixShearY, mixShearY2, 1);
          }
          time = time2;
          mixRotate = mixRotate2;
          mixX = mixX2;
          mixY = mixY2;
          mixScaleX = mixScaleX2;
          mixScaleY = mixScaleY2;
          mixShearY = mixShearY2;
        }
        timelines.push(timeline);
      }
      for (var i2 = 0, n2 = input.readInt(true); i2 < n2; i2++) {
        var index2 = input.readInt(true);
        var data2 = skeletonData.pathConstraints[index2];
        for (var ii2 = 0, nn2 = input.readInt(true); ii2 < nn2; ii2++) {
          switch (input.readByte()) {
            case PATH_POSITION:
              timelines.push(readTimeline1$1(input, new PathConstraintPositionTimeline(input.readInt(true), input.readInt(true), index2), data2.positionMode == PositionMode.Fixed ? scale : 1));
              break;
            case PATH_SPACING:
              timelines.push(readTimeline1$1(input, new PathConstraintSpacingTimeline(input.readInt(true), input.readInt(true), index2), data2.spacingMode == SpacingMode.Length || data2.spacingMode == SpacingMode.Fixed ? scale : 1));
              break;
            case PATH_MIX:
              var timeline = new PathConstraintMixTimeline(input.readInt(true), input.readInt(true), index2);
              var time = input.readFloat(), mixRotate = input.readFloat(), mixX = input.readFloat(), mixY = input.readFloat();
              for (var frame2 = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame2++) {
                timeline.setFrame(frame2, time, mixRotate, mixX, mixY);
                if (frame2 == frameLast)
                  break;
                var time2 = input.readFloat(), mixRotate2 = input.readFloat(), mixX2 = input.readFloat(), mixY2 = input.readFloat();
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline.setStepped(frame2);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline, bezier++, frame2, 0, time, time2, mixRotate, mixRotate2, 1);
                    setBezier(input, timeline, bezier++, frame2, 1, time, time2, mixX, mixX2, 1);
                    setBezier(input, timeline, bezier++, frame2, 2, time, time2, mixY, mixY2, 1);
                }
                time = time2;
                mixRotate = mixRotate2;
                mixX = mixX2;
                mixY = mixY2;
              }
              timelines.push(timeline);
          }
        }
      }
      for (var i2 = 0, n2 = input.readInt(true); i2 < n2; i2++) {
        var skin = skeletonData.skins[input.readInt(true)];
        for (var ii2 = 0, nn2 = input.readInt(true); ii2 < nn2; ii2++) {
          var slotIndex = input.readInt(true);
          for (var iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {
            var attachmentName = input.readStringRef();
            if (!attachmentName)
              throw new Error("attachmentName must not be null.");
            var attachment = skin.getAttachment(slotIndex, attachmentName);
            var timelineType = this.readDeformTimelineType(input);
            var frameCount = input.readInt(true);
            var frameLast = frameCount - 1;
            switch (timelineType) {
              case ATTACHMENT_DEFORM: {
                var vertexAttachment = attachment;
                var weighted = vertexAttachment.bones;
                var vertices = vertexAttachment.vertices;
                var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
                var bezierCount = input.readInt(true);
                var timeline = new DeformTimeline(frameCount, bezierCount, slotIndex, vertexAttachment);
                var time = input.readFloat();
                for (var frame2 = 0, bezier = 0; ; frame2++) {
                  var deform = void 0;
                  var end2 = input.readInt(true);
                  if (end2 == 0)
                    deform = weighted ? Utils.newFloatArray(deformLength) : vertices;
                  else {
                    deform = Utils.newFloatArray(deformLength);
                    var start = input.readInt(true);
                    end2 += start;
                    if (scale == 1) {
                      for (var v2 = start; v2 < end2; v2++)
                        deform[v2] = input.readFloat();
                    } else {
                      for (var v2 = start; v2 < end2; v2++)
                        deform[v2] = input.readFloat() * scale;
                    }
                    if (!weighted) {
                      for (var v2 = 0, vn = deform.length; v2 < vn; v2++)
                        deform[v2] += vertices[v2];
                    }
                  }
                  timeline.setFrame(frame2, time, deform);
                  if (frame2 == frameLast)
                    break;
                  var time2 = input.readFloat();
                  switch (input.readByte()) {
                    case CURVE_STEPPED:
                      timeline.setStepped(frame2);
                      break;
                    case CURVE_BEZIER:
                      setBezier(input, timeline, bezier++, frame2, 0, time, time2, 0, 1, 1);
                  }
                  time = time2;
                }
                timelines.push(timeline);
                break;
              }
              case ATTACHMENT_SEQUENCE: {
                var timeline = new SequenceTimeline(frameCount, slotIndex, attachment);
                for (var frame2 = 0; frame2 < frameCount; frame2++) {
                  var time = input.readFloat();
                  var modeAndIndex = input.readInt32();
                  timeline.setFrame(frame2, time, SequenceModeValues[modeAndIndex & 15], modeAndIndex >> 4, input.readFloat());
                }
                timelines.push(timeline);
                break;
              }
            }
          }
        }
      }
      var drawOrderCount = input.readInt(true);
      if (drawOrderCount > 0) {
        var timeline = new DrawOrderTimeline(drawOrderCount);
        var slotCount = skeletonData.slots.length;
        for (var i2 = 0; i2 < drawOrderCount; i2++) {
          var time = input.readFloat();
          var offsetCount = input.readInt(true);
          var drawOrder = Utils.newArray(slotCount, 0);
          for (var ii2 = slotCount - 1; ii2 >= 0; ii2--)
            drawOrder[ii2] = -1;
          var unchanged = Utils.newArray(slotCount - offsetCount, 0);
          var originalIndex = 0, unchangedIndex = 0;
          for (var ii2 = 0; ii2 < offsetCount; ii2++) {
            var slotIndex = input.readInt(true);
            while (originalIndex != slotIndex)
              unchanged[unchangedIndex++] = originalIndex++;
            drawOrder[originalIndex + input.readInt(true)] = originalIndex++;
          }
          while (originalIndex < slotCount)
            unchanged[unchangedIndex++] = originalIndex++;
          for (var ii2 = slotCount - 1; ii2 >= 0; ii2--)
            if (drawOrder[ii2] == -1)
              drawOrder[ii2] = unchanged[--unchangedIndex];
          timeline.setFrame(i2, time, drawOrder);
        }
        timelines.push(timeline);
      }
      var eventCount = input.readInt(true);
      if (eventCount > 0) {
        var timeline = new EventTimeline(eventCount);
        for (var i2 = 0; i2 < eventCount; i2++) {
          var time = input.readFloat();
          var eventData = skeletonData.events[input.readInt(true)];
          var event_1 = new Event$1(time, eventData);
          event_1.intValue = input.readInt(false);
          event_1.floatValue = input.readFloat();
          event_1.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;
          if (event_1.data.audioPath) {
            event_1.volume = input.readFloat();
            event_1.balance = input.readFloat();
          }
          timeline.setFrame(i2, event_1);
        }
        timelines.push(timeline);
      }
      var duration = 0;
      for (var i2 = 0, n2 = timelines.length; i2 < n2; i2++)
        duration = Math.max(duration, timelines[i2].getDuration());
      return new Animation(name, timelines, duration);
    };
    SkeletonBinary2.BlendModeValues = [BLEND_MODES$4.NORMAL, BLEND_MODES$4.ADD, BLEND_MODES$4.MULTIPLY, BLEND_MODES$4.SCREEN];
    return SkeletonBinary2;
  }()
);
var LinkedMesh$1 = (
  /** @class */
  function() {
    function LinkedMesh2(mesh, skin, slotIndex, parent, inheritDeform) {
      this.mesh = mesh;
      this.skin = skin;
      this.slotIndex = slotIndex;
      this.parent = parent;
      this.inheritTimeline = inheritDeform;
    }
    return LinkedMesh2;
  }()
);
var Vertices = (
  /** @class */
  function() {
    function Vertices2(bones, vertices) {
      if (bones === void 0) {
        bones = null;
      }
      if (vertices === void 0) {
        vertices = null;
      }
      this.bones = bones;
      this.vertices = vertices;
    }
    return Vertices2;
  }()
);
function readTimeline1$1(input, timeline, scale) {
  var time = input.readFloat(), value = input.readFloat() * scale;
  for (var frame2 = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame2++) {
    timeline.setFrame(frame2, time, value);
    if (frame2 == frameLast)
      break;
    var time2 = input.readFloat(), value2 = input.readFloat() * scale;
    switch (input.readByte()) {
      case CURVE_STEPPED:
        timeline.setStepped(frame2);
        break;
      case CURVE_BEZIER:
        setBezier(input, timeline, bezier++, frame2, 0, time, time2, value, value2, scale);
    }
    time = time2;
    value = value2;
  }
  return timeline;
}
function readTimeline2$1(input, timeline, scale) {
  var time = input.readFloat(), value1 = input.readFloat() * scale, value2 = input.readFloat() * scale;
  for (var frame2 = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame2++) {
    timeline.setFrame(frame2, time, value1, value2);
    if (frame2 == frameLast)
      break;
    var time2 = input.readFloat(), nvalue1 = input.readFloat() * scale, nvalue2 = input.readFloat() * scale;
    switch (input.readByte()) {
      case CURVE_STEPPED:
        timeline.setStepped(frame2);
        break;
      case CURVE_BEZIER:
        setBezier(input, timeline, bezier++, frame2, 0, time, time2, value1, nvalue1, scale);
        setBezier(input, timeline, bezier++, frame2, 1, time, time2, value2, nvalue2, scale);
    }
    time = time2;
    value1 = nvalue1;
    value2 = nvalue2;
  }
  return timeline;
}
function setBezier(input, timeline, bezier, frame2, value, time1, time2, value1, value2, scale) {
  timeline.setBezier(bezier, frame2, value, time1, value1, input.readFloat(), input.readFloat() * scale, input.readFloat(), input.readFloat() * scale, time2, value2);
}
var BONE_ROTATE = 0;
var BONE_TRANSLATE = 1;
var BONE_TRANSLATEX = 2;
var BONE_TRANSLATEY = 3;
var BONE_SCALE = 4;
var BONE_SCALEX = 5;
var BONE_SCALEY = 6;
var BONE_SHEAR = 7;
var BONE_SHEARX = 8;
var BONE_SHEARY = 9;
var SLOT_ATTACHMENT = 0;
var SLOT_RGBA = 1;
var SLOT_RGB = 2;
var SLOT_RGBA2 = 3;
var SLOT_RGB2 = 4;
var SLOT_ALPHA = 5;
var ATTACHMENT_DEFORM = 0;
var ATTACHMENT_SEQUENCE = 1;
var PATH_POSITION = 0;
var PATH_SPACING = 1;
var PATH_MIX = 2;
var CURVE_STEPPED = 1;
var CURVE_BEZIER = 2;
var SkeletonBounds = (
  /** @class */
  function(_super) {
    __extends$2(SkeletonBounds2, _super);
    function SkeletonBounds2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return SkeletonBounds2;
  }(SkeletonBoundsBase)
);
var SkeletonJson = (
  /** @class */
  function() {
    function SkeletonJson2(attachmentLoader) {
      this.scale = 1;
      this.linkedMeshes = new Array();
      this.attachmentLoader = attachmentLoader;
    }
    SkeletonJson2.prototype.readSkeletonData = function(json) {
      var scale = this.scale;
      var skeletonData = new SkeletonData();
      var root2 = typeof json === "string" ? JSON.parse(json) : json;
      var skeletonMap = root2.skeleton;
      if (skeletonMap) {
        skeletonData.hash = skeletonMap.hash;
        skeletonData.version = skeletonMap.spine;
        var verShort = skeletonData.version.substr(0, 3);
        if (verShort !== "4.0" && verShort !== "4.1") {
          var error2 = "Spine 4.1 loader cant load version " + skeletonMap.spine + ". Please configure your pixi-spine bundle";
          console.error(error2);
        }
        skeletonData.x = skeletonMap.x;
        skeletonData.y = skeletonMap.y;
        skeletonData.width = skeletonMap.width;
        skeletonData.height = skeletonMap.height;
        skeletonData.fps = skeletonMap.fps;
        skeletonData.imagesPath = skeletonMap.images;
      }
      if (root2.bones) {
        for (var i2 = 0; i2 < root2.bones.length; i2++) {
          var boneMap = root2.bones[i2];
          var parent_1 = null;
          var parentName = getValue(boneMap, "parent", null);
          if (parentName != null) {
            parent_1 = skeletonData.findBone(parentName);
            if (parent_1 == null)
              throw new Error("Parent bone not found: " + parentName);
          }
          var data2 = new BoneData(skeletonData.bones.length, boneMap.name, parent_1);
          data2.length = getValue(boneMap, "length", 0) * scale;
          data2.x = getValue(boneMap, "x", 0) * scale;
          data2.y = getValue(boneMap, "y", 0) * scale;
          data2.rotation = getValue(boneMap, "rotation", 0);
          data2.scaleX = getValue(boneMap, "scaleX", 1);
          data2.scaleY = getValue(boneMap, "scaleY", 1);
          data2.shearX = getValue(boneMap, "shearX", 0);
          data2.shearY = getValue(boneMap, "shearY", 0);
          data2.transformMode = Utils.enumValue(TransformMode, getValue(boneMap, "transform", "Normal"));
          data2.skinRequired = getValue(boneMap, "skin", false);
          var color2 = getValue(boneMap, "color", null);
          if (color2)
            data2.color.setFromString(color2);
          skeletonData.bones.push(data2);
        }
      }
      if (root2.slots) {
        for (var i2 = 0; i2 < root2.slots.length; i2++) {
          var slotMap = root2.slots[i2];
          var boneData = skeletonData.findBone(slotMap.bone);
          if (!boneData)
            throw new Error("Couldn't find bone " + slotMap.bone + " for slot " + slotMap.name);
          var data2 = new SlotData(skeletonData.slots.length, slotMap.name, boneData);
          var color2 = getValue(slotMap, "color", null);
          if (color2)
            data2.color.setFromString(color2);
          var dark = getValue(slotMap, "dark", null);
          if (dark)
            data2.darkColor = Color.fromString(dark);
          data2.attachmentName = getValue(slotMap, "attachment", null);
          data2.blendMode = SkeletonJson2.blendModeFromString(getValue(slotMap, "blend", "normal"));
          skeletonData.slots.push(data2);
        }
      }
      if (root2.ik) {
        for (var i2 = 0; i2 < root2.ik.length; i2++) {
          var constraintMap = root2.ik[i2];
          var data2 = new IkConstraintData(constraintMap.name);
          data2.order = getValue(constraintMap, "order", 0);
          data2.skinRequired = getValue(constraintMap, "skin", false);
          for (var ii2 = 0; ii2 < constraintMap.bones.length; ii2++) {
            var boneName = constraintMap.bones[ii2];
            var bone = skeletonData.findBone(boneName);
            if (bone == null)
              throw new Error("IK bone not found: " + boneName);
            data2.bones.push(bone);
          }
          data2.target = skeletonData.findBone(constraintMap.target);
          data2.mix = getValue(constraintMap, "mix", 1);
          data2.softness = getValue(constraintMap, "softness", 0) * scale;
          data2.bendDirection = getValue(constraintMap, "bendPositive", true) ? 1 : -1;
          data2.compress = getValue(constraintMap, "compress", false);
          data2.stretch = getValue(constraintMap, "stretch", false);
          data2.uniform = getValue(constraintMap, "uniform", false);
          skeletonData.ikConstraints.push(data2);
        }
      }
      if (root2.transform) {
        for (var i2 = 0; i2 < root2.transform.length; i2++) {
          var constraintMap = root2.transform[i2];
          var data2 = new TransformConstraintData(constraintMap.name);
          data2.order = getValue(constraintMap, "order", 0);
          data2.skinRequired = getValue(constraintMap, "skin", false);
          for (var ii2 = 0; ii2 < constraintMap.bones.length; ii2++) {
            var boneName = constraintMap.bones[ii2];
            var bone = skeletonData.findBone(boneName);
            if (!bone)
              throw new Error("Couldn't find bone " + boneName + " for transform constraint " + constraintMap.name + ".");
            data2.bones.push(bone);
          }
          var targetName = constraintMap.target;
          var target = skeletonData.findBone(targetName);
          if (!target)
            throw new Error("Couldn't find target bone " + targetName + " for transform constraint " + constraintMap.name + ".");
          data2.target = target;
          data2.local = getValue(constraintMap, "local", false);
          data2.relative = getValue(constraintMap, "relative", false);
          data2.offsetRotation = getValue(constraintMap, "rotation", 0);
          data2.offsetX = getValue(constraintMap, "x", 0) * scale;
          data2.offsetY = getValue(constraintMap, "y", 0) * scale;
          data2.offsetScaleX = getValue(constraintMap, "scaleX", 0);
          data2.offsetScaleY = getValue(constraintMap, "scaleY", 0);
          data2.offsetShearY = getValue(constraintMap, "shearY", 0);
          data2.mixRotate = getValue(constraintMap, "mixRotate", 1);
          data2.mixX = getValue(constraintMap, "mixX", 1);
          data2.mixY = getValue(constraintMap, "mixY", data2.mixX);
          data2.mixScaleX = getValue(constraintMap, "mixScaleX", 1);
          data2.mixScaleY = getValue(constraintMap, "mixScaleY", data2.mixScaleX);
          data2.mixShearY = getValue(constraintMap, "mixShearY", 1);
          skeletonData.transformConstraints.push(data2);
        }
      }
      if (root2.path) {
        for (var i2 = 0; i2 < root2.path.length; i2++) {
          var constraintMap = root2.path[i2];
          var data2 = new PathConstraintData(constraintMap.name);
          data2.order = getValue(constraintMap, "order", 0);
          data2.skinRequired = getValue(constraintMap, "skin", false);
          for (var ii2 = 0; ii2 < constraintMap.bones.length; ii2++) {
            var boneName = constraintMap.bones[ii2];
            var bone = skeletonData.findBone(boneName);
            if (!bone)
              throw new Error("Couldn't find bone " + boneName + " for path constraint " + constraintMap.name + ".");
            data2.bones.push(bone);
          }
          var targetName = constraintMap.target;
          var target = skeletonData.findSlot(targetName);
          if (!target)
            throw new Error("Couldn't find target slot " + targetName + " for path constraint " + constraintMap.name + ".");
          data2.target = target;
          data2.positionMode = Utils.enumValue(PositionMode, getValue(constraintMap, "positionMode", "Percent"));
          data2.spacingMode = Utils.enumValue(SpacingMode, getValue(constraintMap, "spacingMode", "Length"));
          data2.rotateMode = Utils.enumValue(RotateMode, getValue(constraintMap, "rotateMode", "Tangent"));
          data2.offsetRotation = getValue(constraintMap, "rotation", 0);
          data2.position = getValue(constraintMap, "position", 0);
          if (data2.positionMode == PositionMode.Fixed)
            data2.position *= scale;
          data2.spacing = getValue(constraintMap, "spacing", 0);
          if (data2.spacingMode == SpacingMode.Length || data2.spacingMode == SpacingMode.Fixed)
            data2.spacing *= scale;
          data2.mixRotate = getValue(constraintMap, "mixRotate", 1);
          data2.mixX = getValue(constraintMap, "mixX", 1);
          data2.mixY = getValue(constraintMap, "mixY", data2.mixX);
          skeletonData.pathConstraints.push(data2);
        }
      }
      if (root2.skins) {
        for (var i2 = 0; i2 < root2.skins.length; i2++) {
          var skinMap = root2.skins[i2];
          var skin = new Skin(skinMap.name);
          if (skinMap.bones) {
            for (var ii2 = 0; ii2 < skinMap.bones.length; ii2++) {
              var boneName = skinMap.bones[ii2];
              var bone = skeletonData.findBone(boneName);
              if (!bone)
                throw new Error("Couldn't find bone " + boneName + " for skin " + skinMap.name + ".");
              skin.bones.push(bone);
            }
          }
          if (skinMap.ik) {
            for (var ii2 = 0; ii2 < skinMap.ik.length; ii2++) {
              var constraintName = skinMap.ik[ii2];
              var constraint = skeletonData.findIkConstraint(constraintName);
              if (!constraint)
                throw new Error("Couldn't find IK constraint " + constraintName + " for skin " + skinMap.name + ".");
              skin.constraints.push(constraint);
            }
          }
          if (skinMap.transform) {
            for (var ii2 = 0; ii2 < skinMap.transform.length; ii2++) {
              var constraintName = skinMap.transform[ii2];
              var constraint = skeletonData.findTransformConstraint(constraintName);
              if (!constraint)
                throw new Error("Couldn't find transform constraint " + constraintName + " for skin " + skinMap.name + ".");
              skin.constraints.push(constraint);
            }
          }
          if (skinMap.path) {
            for (var ii2 = 0; ii2 < skinMap.path.length; ii2++) {
              var constraintName = skinMap.path[ii2];
              var constraint = skeletonData.findPathConstraint(constraintName);
              if (!constraint)
                throw new Error("Couldn't find path constraint " + constraintName + " for skin " + skinMap.name + ".");
              skin.constraints.push(constraint);
            }
          }
          for (var slotName in skinMap.attachments) {
            var slot = skeletonData.findSlot(slotName);
            if (!slot)
              throw new Error("Couldn't find slot " + slotName + " for skin " + skinMap.name + ".");
            var slotMap = skinMap.attachments[slotName];
            for (var entryName in slotMap) {
              var attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);
              if (attachment)
                skin.setAttachment(slot.index, entryName, attachment);
            }
          }
          skeletonData.skins.push(skin);
          if (skin.name == "default")
            skeletonData.defaultSkin = skin;
        }
      }
      for (var i2 = 0, n2 = this.linkedMeshes.length; i2 < n2; i2++) {
        var linkedMesh = this.linkedMeshes[i2];
        var skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
        if (!skin)
          throw new Error("Skin not found: " + linkedMesh.skin);
        var parent_2 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
        if (!parent_2)
          throw new Error("Parent mesh not found: " + linkedMesh.parent);
        linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? parent_2 : linkedMesh.mesh;
        linkedMesh.mesh.setParentMesh(parent_2);
      }
      this.linkedMeshes.length = 0;
      if (root2.events) {
        for (var eventName in root2.events) {
          var eventMap = root2.events[eventName];
          var data2 = new EventData(eventName);
          data2.intValue = getValue(eventMap, "int", 0);
          data2.floatValue = getValue(eventMap, "float", 0);
          data2.stringValue = getValue(eventMap, "string", "");
          data2.audioPath = getValue(eventMap, "audio", null);
          if (data2.audioPath) {
            data2.volume = getValue(eventMap, "volume", 1);
            data2.balance = getValue(eventMap, "balance", 0);
          }
          skeletonData.events.push(data2);
        }
      }
      if (root2.animations) {
        for (var animationName in root2.animations) {
          var animationMap = root2.animations[animationName];
          this.readAnimation(animationMap, animationName, skeletonData);
        }
      }
      return skeletonData;
    };
    SkeletonJson2.prototype.readAttachment = function(map2, skin, slotIndex, name, skeletonData) {
      var scale = this.scale;
      name = getValue(map2, "name", name);
      switch (getValue(map2, "type", "region")) {
        case "region": {
          var path = getValue(map2, "path", name);
          var sequence = this.readSequence(getValue(map2, "sequence", null));
          var region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);
          if (!region)
            return null;
          region.path = path;
          region.x = getValue(map2, "x", 0) * scale;
          region.y = getValue(map2, "y", 0) * scale;
          region.scaleX = getValue(map2, "scaleX", 1);
          region.scaleY = getValue(map2, "scaleY", 1);
          region.rotation = getValue(map2, "rotation", 0);
          region.width = map2.width * scale;
          region.height = map2.height * scale;
          region.sequence = sequence;
          var color2 = getValue(map2, "color", null);
          if (color2)
            region.color.setFromString(color2);
          return region;
        }
        case "boundingbox": {
          var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
          if (!box)
            return null;
          this.readVertices(map2, box, map2.vertexCount << 1);
          var color2 = getValue(map2, "color", null);
          if (color2)
            box.color.setFromString(color2);
          return box;
        }
        case "mesh":
        case "linkedmesh": {
          var path = getValue(map2, "path", name);
          var sequence = this.readSequence(getValue(map2, "sequence", null));
          var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);
          if (!mesh)
            return null;
          mesh.path = path;
          var color2 = getValue(map2, "color", null);
          if (color2)
            mesh.color.setFromString(color2);
          mesh.width = getValue(map2, "width", 0) * scale;
          mesh.height = getValue(map2, "height", 0) * scale;
          mesh.sequence = sequence;
          var parent_3 = getValue(map2, "parent", null);
          if (parent_3) {
            this.linkedMeshes.push(new LinkedMesh(mesh, getValue(map2, "skin", null), slotIndex, parent_3, getValue(map2, "timelines", true)));
            return mesh;
          }
          var uvs = map2.uvs;
          this.readVertices(map2, mesh, uvs.length);
          mesh.triangles = map2.triangles;
          mesh.regionUVs = new Float32Array(uvs);
          mesh.edges = getValue(map2, "edges", null);
          mesh.hullLength = getValue(map2, "hull", 0) * 2;
          return mesh;
        }
        case "path": {
          var path = this.attachmentLoader.newPathAttachment(skin, name);
          if (!path)
            return null;
          path.closed = getValue(map2, "closed", false);
          path.constantSpeed = getValue(map2, "constantSpeed", true);
          var vertexCount = map2.vertexCount;
          this.readVertices(map2, path, vertexCount << 1);
          var lengths = Utils.newArray(vertexCount / 3, 0);
          for (var i2 = 0; i2 < map2.lengths.length; i2++)
            lengths[i2] = map2.lengths[i2] * scale;
          path.lengths = lengths;
          var color2 = getValue(map2, "color", null);
          if (color2)
            path.color.setFromString(color2);
          return path;
        }
        case "point": {
          var point = this.attachmentLoader.newPointAttachment(skin, name);
          if (!point)
            return null;
          point.x = getValue(map2, "x", 0) * scale;
          point.y = getValue(map2, "y", 0) * scale;
          point.rotation = getValue(map2, "rotation", 0);
          var color2 = getValue(map2, "color", null);
          if (color2)
            point.color.setFromString(color2);
          return point;
        }
        case "clipping": {
          var clip = this.attachmentLoader.newClippingAttachment(skin, name);
          if (!clip)
            return null;
          var end2 = getValue(map2, "end", null);
          if (end2 != null) {
            var slot = skeletonData.findSlot(end2);
            if (slot == null)
              throw new Error("Clipping end slot not found: " + end2);
            clip.endSlot = slot;
          }
          var vertexCount = map2.vertexCount;
          this.readVertices(map2, clip, vertexCount << 1);
          var color2 = getValue(map2, "color", null);
          if (color2)
            clip.color.setFromString(color2);
          return clip;
        }
      }
      return null;
    };
    SkeletonJson2.prototype.readSequence = function(map2) {
      if (map2 == null)
        return null;
      var sequence = new Sequence(getValue(map2, "count", 0));
      sequence.start = getValue(map2, "start", 1);
      sequence.digits = getValue(map2, "digits", 0);
      sequence.setupIndex = getValue(map2, "setup", 0);
      return sequence;
    };
    SkeletonJson2.prototype.readVertices = function(map2, attachment, verticesLength) {
      var scale = this.scale;
      attachment.worldVerticesLength = verticesLength;
      var vertices = map2.vertices;
      if (verticesLength == vertices.length) {
        var scaledVertices = Utils.toFloatArray(vertices);
        if (scale != 1) {
          for (var i2 = 0, n2 = vertices.length; i2 < n2; i2++)
            scaledVertices[i2] *= scale;
        }
        attachment.vertices = scaledVertices;
        return;
      }
      var weights = new Array();
      var bones = new Array();
      for (var i2 = 0, n2 = vertices.length; i2 < n2; ) {
        var boneCount = vertices[i2++];
        bones.push(boneCount);
        for (var nn2 = i2 + boneCount * 4; i2 < nn2; i2 += 4) {
          bones.push(vertices[i2]);
          weights.push(vertices[i2 + 1] * scale);
          weights.push(vertices[i2 + 2] * scale);
          weights.push(vertices[i2 + 3]);
        }
      }
      attachment.bones = bones;
      attachment.vertices = Utils.toFloatArray(weights);
    };
    SkeletonJson2.prototype.readAnimation = function(map2, name, skeletonData) {
      var scale = this.scale;
      var timelines = new Array();
      if (map2.slots) {
        for (var slotName in map2.slots) {
          var slotMap = map2.slots[slotName];
          var slot = skeletonData.findSlot(slotName);
          if (!slot)
            throw new Error("Slot not found: " + slotName);
          var slotIndex = slot.index;
          for (var timelineName in slotMap) {
            var timelineMap = slotMap[timelineName];
            if (!timelineMap)
              continue;
            var frames_1 = timelineMap.length;
            if (timelineName == "attachment") {
              var timeline = new AttachmentTimeline(frames_1, slotIndex);
              for (var frame2 = 0; frame2 < frames_1; frame2++) {
                var keyMap = timelineMap[frame2];
                timeline.setFrame(frame2, getValue(keyMap, "time", 0), getValue(keyMap, "name", null));
              }
              timelines.push(timeline);
            } else if (timelineName == "rgba") {
              var timeline = new RGBATimeline(frames_1, frames_1 << 2, slotIndex);
              var keyMap = timelineMap[0];
              var time = getValue(keyMap, "time", 0);
              var color2 = Color.fromString(keyMap.color);
              for (var frame2 = 0, bezier = 0; ; frame2++) {
                timeline.setFrame(frame2, time, color2.r, color2.g, color2.b, color2.a);
                var nextMap = timelineMap[frame2 + 1];
                if (!nextMap) {
                  timeline.shrink(bezier);
                  break;
                }
                var time2 = getValue(nextMap, "time", 0);
                var newColor = Color.fromString(nextMap.color);
                var curve = keyMap.curve;
                if (curve) {
                  bezier = readCurve(curve, timeline, bezier, frame2, 0, time, time2, color2.r, newColor.r, 1);
                  bezier = readCurve(curve, timeline, bezier, frame2, 1, time, time2, color2.g, newColor.g, 1);
                  bezier = readCurve(curve, timeline, bezier, frame2, 2, time, time2, color2.b, newColor.b, 1);
                  bezier = readCurve(curve, timeline, bezier, frame2, 3, time, time2, color2.a, newColor.a, 1);
                }
                time = time2;
                color2 = newColor;
                keyMap = nextMap;
              }
              timelines.push(timeline);
            } else if (timelineName == "rgb") {
              var timeline = new RGBTimeline(frames_1, frames_1 * 3, slotIndex);
              var keyMap = timelineMap[0];
              var time = getValue(keyMap, "time", 0);
              var color2 = Color.fromString(keyMap.color);
              for (var frame2 = 0, bezier = 0; ; frame2++) {
                timeline.setFrame(frame2, time, color2.r, color2.g, color2.b);
                var nextMap = timelineMap[frame2 + 1];
                if (!nextMap) {
                  timeline.shrink(bezier);
                  break;
                }
                var time2 = getValue(nextMap, "time", 0);
                var newColor = Color.fromString(nextMap.color);
                var curve = keyMap.curve;
                if (curve) {
                  bezier = readCurve(curve, timeline, bezier, frame2, 0, time, time2, color2.r, newColor.r, 1);
                  bezier = readCurve(curve, timeline, bezier, frame2, 1, time, time2, color2.g, newColor.g, 1);
                  bezier = readCurve(curve, timeline, bezier, frame2, 2, time, time2, color2.b, newColor.b, 1);
                }
                time = time2;
                color2 = newColor;
                keyMap = nextMap;
              }
              timelines.push(timeline);
            } else if (timelineName == "alpha") {
              timelines.push(readTimeline1(timelineMap, new AlphaTimeline(frames_1, frames_1, slotIndex), 0, 1));
            } else if (timelineName == "rgba2") {
              var timeline = new RGBA2Timeline(frames_1, frames_1 * 7, slotIndex);
              var keyMap = timelineMap[0];
              var time = getValue(keyMap, "time", 0);
              var color2 = Color.fromString(keyMap.light);
              var color22 = Color.fromString(keyMap.dark);
              for (var frame2 = 0, bezier = 0; ; frame2++) {
                timeline.setFrame(frame2, time, color2.r, color2.g, color2.b, color2.a, color22.r, color22.g, color22.b);
                var nextMap = timelineMap[frame2 + 1];
                if (!nextMap) {
                  timeline.shrink(bezier);
                  break;
                }
                var time2 = getValue(nextMap, "time", 0);
                var newColor = Color.fromString(nextMap.light);
                var newColor2 = Color.fromString(nextMap.dark);
                var curve = keyMap.curve;
                if (curve) {
                  bezier = readCurve(curve, timeline, bezier, frame2, 0, time, time2, color2.r, newColor.r, 1);
                  bezier = readCurve(curve, timeline, bezier, frame2, 1, time, time2, color2.g, newColor.g, 1);
                  bezier = readCurve(curve, timeline, bezier, frame2, 2, time, time2, color2.b, newColor.b, 1);
                  bezier = readCurve(curve, timeline, bezier, frame2, 3, time, time2, color2.a, newColor.a, 1);
                  bezier = readCurve(curve, timeline, bezier, frame2, 4, time, time2, color22.r, newColor2.r, 1);
                  bezier = readCurve(curve, timeline, bezier, frame2, 5, time, time2, color22.g, newColor2.g, 1);
                  bezier = readCurve(curve, timeline, bezier, frame2, 6, time, time2, color22.b, newColor2.b, 1);
                }
                time = time2;
                color2 = newColor;
                color22 = newColor2;
                keyMap = nextMap;
              }
              timelines.push(timeline);
            } else if (timelineName == "rgb2") {
              var timeline = new RGB2Timeline(frames_1, frames_1 * 6, slotIndex);
              var keyMap = timelineMap[0];
              var time = getValue(keyMap, "time", 0);
              var color2 = Color.fromString(keyMap.light);
              var color22 = Color.fromString(keyMap.dark);
              for (var frame2 = 0, bezier = 0; ; frame2++) {
                timeline.setFrame(frame2, time, color2.r, color2.g, color2.b, color22.r, color22.g, color22.b);
                var nextMap = timelineMap[frame2 + 1];
                if (!nextMap) {
                  timeline.shrink(bezier);
                  break;
                }
                var time2 = getValue(nextMap, "time", 0);
                var newColor = Color.fromString(nextMap.light);
                var newColor2 = Color.fromString(nextMap.dark);
                var curve = keyMap.curve;
                if (curve) {
                  bezier = readCurve(curve, timeline, bezier, frame2, 0, time, time2, color2.r, newColor.r, 1);
                  bezier = readCurve(curve, timeline, bezier, frame2, 1, time, time2, color2.g, newColor.g, 1);
                  bezier = readCurve(curve, timeline, bezier, frame2, 2, time, time2, color2.b, newColor.b, 1);
                  bezier = readCurve(curve, timeline, bezier, frame2, 3, time, time2, color22.r, newColor2.r, 1);
                  bezier = readCurve(curve, timeline, bezier, frame2, 4, time, time2, color22.g, newColor2.g, 1);
                  bezier = readCurve(curve, timeline, bezier, frame2, 5, time, time2, color22.b, newColor2.b, 1);
                }
                time = time2;
                color2 = newColor;
                color22 = newColor2;
                keyMap = nextMap;
              }
              timelines.push(timeline);
            }
          }
        }
      }
      if (map2.bones) {
        for (var boneName in map2.bones) {
          var boneMap = map2.bones[boneName];
          var bone = skeletonData.findBone(boneName);
          if (!bone)
            throw new Error("Bone not found: " + boneName);
          var boneIndex = bone.index;
          for (var timelineName in boneMap) {
            var timelineMap = boneMap[timelineName];
            var frames_2 = timelineMap.length;
            if (frames_2 == 0)
              continue;
            if (timelineName === "rotate") {
              timelines.push(readTimeline1(timelineMap, new RotateTimeline(frames_2, frames_2, boneIndex), 0, 1));
            } else if (timelineName === "translate") {
              var timeline = new TranslateTimeline(frames_2, frames_2 << 1, boneIndex);
              timelines.push(readTimeline2(timelineMap, timeline, "x", "y", 0, scale));
            } else if (timelineName === "translatex") {
              var timeline = new TranslateXTimeline(frames_2, frames_2, boneIndex);
              timelines.push(readTimeline1(timelineMap, timeline, 0, scale));
            } else if (timelineName === "translatey") {
              var timeline = new TranslateYTimeline(frames_2, frames_2, boneIndex);
              timelines.push(readTimeline1(timelineMap, timeline, 0, scale));
            } else if (timelineName === "scale") {
              var timeline = new ScaleTimeline(frames_2, frames_2 << 1, boneIndex);
              timelines.push(readTimeline2(timelineMap, timeline, "x", "y", 1, 1));
            } else if (timelineName === "scalex") {
              var timeline = new ScaleXTimeline(frames_2, frames_2, boneIndex);
              timelines.push(readTimeline1(timelineMap, timeline, 1, 1));
            } else if (timelineName === "scaley") {
              var timeline = new ScaleYTimeline(frames_2, frames_2, boneIndex);
              timelines.push(readTimeline1(timelineMap, timeline, 1, 1));
            } else if (timelineName === "shear") {
              var timeline = new ShearTimeline(frames_2, frames_2 << 1, boneIndex);
              timelines.push(readTimeline2(timelineMap, timeline, "x", "y", 0, 1));
            } else if (timelineName === "shearx") {
              var timeline = new ShearXTimeline(frames_2, frames_2, boneIndex);
              timelines.push(readTimeline1(timelineMap, timeline, 0, 1));
            } else if (timelineName === "sheary") {
              var timeline = new ShearYTimeline(frames_2, frames_2, boneIndex);
              timelines.push(readTimeline1(timelineMap, timeline, 0, 1));
            }
          }
        }
      }
      if (map2.ik) {
        for (var constraintName in map2.ik) {
          var constraintMap = map2.ik[constraintName];
          var keyMap = constraintMap[0];
          if (!keyMap)
            continue;
          var constraint = skeletonData.findIkConstraint(constraintName);
          if (!constraint)
            throw new Error("IK Constraint not found: " + constraintName);
          var constraintIndex = skeletonData.ikConstraints.indexOf(constraint);
          var timeline = new IkConstraintTimeline(constraintMap.length, constraintMap.length << 1, constraintIndex);
          var time = getValue(keyMap, "time", 0);
          var mix2 = getValue(keyMap, "mix", 1);
          var softness = getValue(keyMap, "softness", 0) * scale;
          for (var frame2 = 0, bezier = 0; ; frame2++) {
            timeline.setFrame(frame2, time, mix2, softness, getValue(keyMap, "bendPositive", true) ? 1 : -1, getValue(keyMap, "compress", false), getValue(keyMap, "stretch", false));
            var nextMap = constraintMap[frame2 + 1];
            if (!nextMap) {
              timeline.shrink(bezier);
              break;
            }
            var time2 = getValue(nextMap, "time", 0);
            var mix22 = getValue(nextMap, "mix", 1);
            var softness2 = getValue(nextMap, "softness", 0) * scale;
            var curve = keyMap.curve;
            if (curve) {
              bezier = readCurve(curve, timeline, bezier, frame2, 0, time, time2, mix2, mix22, 1);
              bezier = readCurve(curve, timeline, bezier, frame2, 1, time, time2, softness, softness2, scale);
            }
            time = time2;
            mix2 = mix22;
            softness = softness2;
            keyMap = nextMap;
          }
          timelines.push(timeline);
        }
      }
      if (map2.transform) {
        for (var constraintName in map2.transform) {
          var timelineMap = map2.transform[constraintName];
          var keyMap = timelineMap[0];
          if (!keyMap)
            continue;
          var constraint = skeletonData.findTransformConstraint(constraintName);
          if (!constraint)
            throw new Error("Transform constraint not found: " + constraintName);
          var constraintIndex = skeletonData.transformConstraints.indexOf(constraint);
          var timeline = new TransformConstraintTimeline(timelineMap.length, timelineMap.length * 6, constraintIndex);
          var time = getValue(keyMap, "time", 0);
          var mixRotate = getValue(keyMap, "mixRotate", 1);
          var mixX = getValue(keyMap, "mixX", 1);
          var mixY = getValue(keyMap, "mixY", mixX);
          var mixScaleX = getValue(keyMap, "mixScaleX", 1);
          var mixScaleY = getValue(keyMap, "mixScaleY", mixScaleX);
          var mixShearY = getValue(keyMap, "mixShearY", 1);
          for (var frame2 = 0, bezier = 0; ; frame2++) {
            timeline.setFrame(frame2, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);
            var nextMap = timelineMap[frame2 + 1];
            if (!nextMap) {
              timeline.shrink(bezier);
              break;
            }
            var time2 = getValue(nextMap, "time", 0);
            var mixRotate2 = getValue(nextMap, "mixRotate", 1);
            var mixX2 = getValue(nextMap, "mixX", 1);
            var mixY2 = getValue(nextMap, "mixY", mixX2);
            var mixScaleX2 = getValue(nextMap, "mixScaleX", 1);
            var mixScaleY2 = getValue(nextMap, "mixScaleY", mixScaleX2);
            var mixShearY2 = getValue(nextMap, "mixShearY", 1);
            var curve = keyMap.curve;
            if (curve) {
              bezier = readCurve(curve, timeline, bezier, frame2, 0, time, time2, mixRotate, mixRotate2, 1);
              bezier = readCurve(curve, timeline, bezier, frame2, 1, time, time2, mixX, mixX2, 1);
              bezier = readCurve(curve, timeline, bezier, frame2, 2, time, time2, mixY, mixY2, 1);
              bezier = readCurve(curve, timeline, bezier, frame2, 3, time, time2, mixScaleX, mixScaleX2, 1);
              bezier = readCurve(curve, timeline, bezier, frame2, 4, time, time2, mixScaleY, mixScaleY2, 1);
              bezier = readCurve(curve, timeline, bezier, frame2, 5, time, time2, mixShearY, mixShearY2, 1);
            }
            time = time2;
            mixRotate = mixRotate2;
            mixX = mixX2;
            mixY = mixY2;
            mixScaleX = mixScaleX2;
            mixScaleY = mixScaleY2;
            mixScaleX = mixScaleX2;
            keyMap = nextMap;
          }
          timelines.push(timeline);
        }
      }
      if (map2.path) {
        for (var constraintName in map2.path) {
          var constraintMap = map2.path[constraintName];
          var constraint = skeletonData.findPathConstraint(constraintName);
          if (!constraint)
            throw new Error("Path constraint not found: " + constraintName);
          var constraintIndex = skeletonData.pathConstraints.indexOf(constraint);
          for (var timelineName in constraintMap) {
            var timelineMap = constraintMap[timelineName];
            var keyMap = timelineMap[0];
            if (!keyMap)
              continue;
            var frames_3 = timelineMap.length;
            if (timelineName === "position") {
              var timeline = new PathConstraintPositionTimeline(frames_3, frames_3, constraintIndex);
              timelines.push(readTimeline1(timelineMap, timeline, 0, constraint.positionMode == PositionMode.Fixed ? scale : 1));
            } else if (timelineName === "spacing") {
              var timeline = new PathConstraintSpacingTimeline(frames_3, frames_3, constraintIndex);
              timelines.push(readTimeline1(timelineMap, timeline, 0, constraint.spacingMode == SpacingMode.Length || constraint.spacingMode == SpacingMode.Fixed ? scale : 1));
            } else if (timelineName === "mix") {
              var timeline = new PathConstraintMixTimeline(frames_3, frames_3 * 3, constraintIndex);
              var time = getValue(keyMap, "time", 0);
              var mixRotate = getValue(keyMap, "mixRotate", 1);
              var mixX = getValue(keyMap, "mixX", 1);
              var mixY = getValue(keyMap, "mixY", mixX);
              for (var frame2 = 0, bezier = 0; ; frame2++) {
                timeline.setFrame(frame2, time, mixRotate, mixX, mixY);
                var nextMap = timelineMap[frame2 + 1];
                if (!nextMap) {
                  timeline.shrink(bezier);
                  break;
                }
                var time2 = getValue(nextMap, "time", 0);
                var mixRotate2 = getValue(nextMap, "mixRotate", 1);
                var mixX2 = getValue(nextMap, "mixX", 1);
                var mixY2 = getValue(nextMap, "mixY", mixX2);
                var curve = keyMap.curve;
                if (curve) {
                  bezier = readCurve(curve, timeline, bezier, frame2, 0, time, time2, mixRotate, mixRotate2, 1);
                  bezier = readCurve(curve, timeline, bezier, frame2, 1, time, time2, mixX, mixX2, 1);
                  bezier = readCurve(curve, timeline, bezier, frame2, 2, time, time2, mixY, mixY2, 1);
                }
                time = time2;
                mixRotate = mixRotate2;
                mixX = mixX2;
                mixY = mixY2;
                keyMap = nextMap;
              }
              timelines.push(timeline);
            }
          }
        }
      }
      if (map2.deform) {
        map2.attachments = {};
        for (var deformName in map2.deform) {
          var deformMap = map2.deform[deformName];
          var outMap = map2.attachments[deformName] = {};
          for (var slotName in deformMap) {
            var slotMap = deformMap[slotName];
            var outMap2 = outMap[slotName] = {};
            for (var innerMapName in slotMap) {
              outMap2[innerMapName] = {
                deform: slotMap[innerMapName]
              };
            }
          }
        }
      }
      if (map2.attachments) {
        for (var attachmentsName in map2.attachments) {
          var attachmentsMap = map2.attachments[attachmentsName];
          var skin = skeletonData.findSkin(attachmentsName);
          if (skin == null) {
            {
              continue;
            }
          }
          for (var slotMapName in attachmentsMap) {
            var slotMap = attachmentsMap[slotMapName];
            var slot = skeletonData.findSlot(slotMapName);
            if (!slot)
              throw new Error("Slot not found: " + slotMapName);
            var slotIndex = slot.index;
            for (var attachmentMapName in slotMap) {
              var attachmentMap = slotMap[attachmentMapName];
              var attachment = skin.getAttachment(slotIndex, attachmentMapName);
              for (var timelineMapName in attachmentMap) {
                var timelineMap = attachmentMap[timelineMapName];
                var keyMap = timelineMap[0];
                if (!keyMap)
                  continue;
                if (timelineMapName == "deform") {
                  var weighted = attachment.bones;
                  var vertices = attachment.vertices;
                  var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
                  var timeline = new DeformTimeline(timelineMap.length, timelineMap.length, slotIndex, attachment);
                  var time = getValue(keyMap, "time", 0);
                  for (var frame2 = 0, bezier = 0; ; frame2++) {
                    var deform = void 0;
                    var verticesValue = getValue(keyMap, "vertices", null);
                    if (!verticesValue)
                      deform = weighted ? Utils.newFloatArray(deformLength) : vertices;
                    else {
                      deform = Utils.newFloatArray(deformLength);
                      var start = getValue(keyMap, "offset", 0);
                      Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
                      if (scale != 1) {
                        for (var i2 = start, n2 = i2 + verticesValue.length; i2 < n2; i2++)
                          deform[i2] *= scale;
                      }
                      if (!weighted) {
                        for (var i2 = 0; i2 < deformLength; i2++)
                          deform[i2] += vertices[i2];
                      }
                    }
                    timeline.setFrame(frame2, time, deform);
                    var nextMap = timelineMap[frame2 + 1];
                    if (!nextMap) {
                      timeline.shrink(bezier);
                      break;
                    }
                    var time2 = getValue(nextMap, "time", 0);
                    var curve = keyMap.curve;
                    if (curve)
                      bezier = readCurve(curve, timeline, bezier, frame2, 0, time, time2, 0, 1, 1);
                    time = time2;
                    keyMap = nextMap;
                  }
                  timelines.push(timeline);
                } else if (timelineMapName == "sequence") {
                  var timeline = new SequenceTimeline(timelineMap.length, slotIndex, attachment);
                  var lastDelay = 0;
                  for (var frame2 = 0; frame2 < timelineMap.length; frame2++) {
                    var delay = getValue(keyMap, "delay", lastDelay);
                    var time = getValue(keyMap, "time", 0);
                    var mode = SequenceMode[getValue(keyMap, "mode", "hold")];
                    var index2 = getValue(keyMap, "index", 0);
                    timeline.setFrame(frame2, time, mode, index2, delay);
                    lastDelay = delay;
                    keyMap = timelineMap[frame2 + 1];
                  }
                  timelines.push(timeline);
                }
              }
            }
          }
        }
      }
      if (map2.drawOrder) {
        var timeline = new DrawOrderTimeline(map2.drawOrder.length);
        var slotCount = skeletonData.slots.length;
        var frame2 = 0;
        for (var i2 = 0; i2 < map2.drawOrder.length; i2++, frame2++) {
          var drawOrderMap = map2.drawOrder[i2];
          var drawOrder = null;
          var offsets = getValue(drawOrderMap, "offsets", null);
          if (offsets) {
            drawOrder = Utils.newArray(slotCount, -1);
            var unchanged = Utils.newArray(slotCount - offsets.length, 0);
            var originalIndex = 0, unchangedIndex = 0;
            for (var ii2 = 0; ii2 < offsets.length; ii2++) {
              var offsetMap = offsets[ii2];
              var slot = skeletonData.findSlot(offsetMap.slot);
              if (!slot)
                throw new Error("Slot not found: " + slot);
              var slotIndex = slot.index;
              while (originalIndex != slotIndex)
                unchanged[unchangedIndex++] = originalIndex++;
              drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
            }
            while (originalIndex < slotCount)
              unchanged[unchangedIndex++] = originalIndex++;
            for (var ii2 = slotCount - 1; ii2 >= 0; ii2--)
              if (drawOrder[ii2] == -1)
                drawOrder[ii2] = unchanged[--unchangedIndex];
          }
          timeline.setFrame(frame2, getValue(drawOrderMap, "time", 0), drawOrder);
        }
        timelines.push(timeline);
      }
      if (map2.events) {
        var timeline = new EventTimeline(map2.events.length);
        var frame2 = 0;
        for (var i2 = 0; i2 < map2.events.length; i2++, frame2++) {
          var eventMap = map2.events[i2];
          var eventData = skeletonData.findEvent(eventMap.name);
          if (!eventData)
            throw new Error("Event not found: " + eventMap.name);
          var event_1 = new Event$1(Utils.toSinglePrecision(getValue(eventMap, "time", 0)), eventData);
          event_1.intValue = getValue(eventMap, "int", eventData.intValue);
          event_1.floatValue = getValue(eventMap, "float", eventData.floatValue);
          event_1.stringValue = getValue(eventMap, "string", eventData.stringValue);
          if (event_1.data.audioPath) {
            event_1.volume = getValue(eventMap, "volume", 1);
            event_1.balance = getValue(eventMap, "balance", 0);
          }
          timeline.setFrame(frame2, event_1);
        }
        timelines.push(timeline);
      }
      var duration = 0;
      for (var i2 = 0, n2 = timelines.length; i2 < n2; i2++)
        duration = Math.max(duration, timelines[i2].getDuration());
      if (isNaN(duration)) {
        throw new Error("Error while parsing animation, duration is NaN");
      }
      skeletonData.animations.push(new Animation(name, timelines, duration));
    };
    SkeletonJson2.blendModeFromString = function(str) {
      str = str.toLowerCase();
      if (str == "normal")
        return BLEND_MODES$4.NORMAL;
      if (str == "additive")
        return BLEND_MODES$4.ADD;
      if (str == "multiply")
        return BLEND_MODES$4.MULTIPLY;
      if (str == "screen")
        return BLEND_MODES$4.SCREEN;
      throw new Error("Unknown blend mode: " + str);
    };
    return SkeletonJson2;
  }()
);
var LinkedMesh = (
  /** @class */
  function() {
    function LinkedMesh2(mesh, skin, slotIndex, parent, inheritDeform) {
      this.mesh = mesh;
      this.skin = skin;
      this.slotIndex = slotIndex;
      this.parent = parent;
      this.inheritTimeline = inheritDeform;
    }
    return LinkedMesh2;
  }()
);
function readTimeline1(keys2, timeline, defaultValue2, scale) {
  var keyMap = keys2[0];
  var time = getValue(keyMap, "time", 0);
  var value = getValue(keyMap, "value", defaultValue2) * scale;
  var bezier = 0;
  for (var frame2 = 0; ; frame2++) {
    timeline.setFrame(frame2, time, value);
    var nextMap = keys2[frame2 + 1];
    if (!nextMap) {
      timeline.shrink(bezier);
      return timeline;
    }
    var time2 = getValue(nextMap, "time", 0);
    var value2 = getValue(nextMap, "value", defaultValue2) * scale;
    if (keyMap.curve)
      bezier = readCurve(keyMap.curve, timeline, bezier, frame2, 0, time, time2, value, value2, scale);
    time = time2;
    value = value2;
    keyMap = nextMap;
  }
}
function readTimeline2(keys2, timeline, name1, name2, defaultValue2, scale) {
  var keyMap = keys2[0];
  var time = getValue(keyMap, "time", 0);
  var value1 = getValue(keyMap, name1, defaultValue2) * scale;
  var value2 = getValue(keyMap, name2, defaultValue2) * scale;
  var bezier = 0;
  for (var frame2 = 0; ; frame2++) {
    timeline.setFrame(frame2, time, value1, value2);
    var nextMap = keys2[frame2 + 1];
    if (!nextMap) {
      timeline.shrink(bezier);
      return timeline;
    }
    var time2 = getValue(nextMap, "time", 0);
    var nvalue1 = getValue(nextMap, name1, defaultValue2) * scale;
    var nvalue2 = getValue(nextMap, name2, defaultValue2) * scale;
    var curve = keyMap.curve;
    if (curve) {
      bezier = readCurve(curve, timeline, bezier, frame2, 0, time, time2, value1, nvalue1, scale);
      bezier = readCurve(curve, timeline, bezier, frame2, 1, time, time2, value2, nvalue2, scale);
    }
    time = time2;
    value1 = nvalue1;
    value2 = nvalue2;
    keyMap = nextMap;
  }
}
function readCurve(curve, timeline, bezier, frame2, value, time1, time2, value1, value2, scale) {
  if (curve == "stepped") {
    timeline.setStepped(frame2);
    return bezier;
  }
  var i2 = value << 2;
  var cx1 = curve[i2];
  var cy1 = curve[i2 + 1] * scale;
  var cx2 = curve[i2 + 2];
  var cy2 = curve[i2 + 3] * scale;
  timeline.setBezier(bezier, frame2, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
  return bezier + 1;
}
function getValue(map2, property2, defaultValue2) {
  return map2[property2] !== void 0 ? map2[property2] : defaultValue2;
}
var Spine$1 = (
  /** @class */
  function(_super) {
    __extends$2(Spine2, _super);
    function Spine2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Spine2.prototype.createSkeleton = function(spineData) {
      this.skeleton = new Skeleton(spineData);
      this.skeleton.updateWorldTransform();
      this.stateData = new AnimationStateData(spineData);
      this.state = new AnimationState(this.stateData);
    };
    return Spine2;
  }(SpineBase)
);
const spine41 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AlphaTimeline,
  Animation,
  AnimationState,
  AnimationStateAdapter,
  AnimationStateData,
  AtlasAttachmentLoader,
  Attachment,
  AttachmentTimeline,
  Bone,
  BoneData,
  BoundingBoxAttachment,
  ClippingAttachment,
  ConstraintData,
  CurveTimeline,
  CurveTimeline1,
  CurveTimeline2,
  DeformTimeline,
  DrawOrderTimeline,
  Event: Event$1,
  EventData,
  EventQueue,
  EventTimeline,
  get EventType() {
    return EventType;
  },
  IkConstraint,
  IkConstraintData,
  IkConstraintTimeline,
  MeshAttachment,
  PathAttachment,
  PathConstraint,
  PathConstraintData,
  PathConstraintMixTimeline,
  PathConstraintPositionTimeline,
  PathConstraintSpacingTimeline,
  PointAttachment,
  RGB2Timeline,
  RGBA2Timeline,
  RGBATimeline,
  RGBTimeline,
  RegionAttachment,
  RotateTimeline,
  ScaleTimeline,
  ScaleXTimeline,
  ScaleYTimeline,
  Sequence,
  get SequenceMode() {
    return SequenceMode;
  },
  SequenceModeValues,
  SequenceTimeline,
  ShearTimeline,
  ShearXTimeline,
  ShearYTimeline,
  Skeleton,
  SkeletonBinary,
  SkeletonBounds,
  SkeletonData,
  SkeletonJson,
  Skin,
  SkinEntry,
  Slot,
  SlotData,
  get SpacingMode() {
    return SpacingMode;
  },
  Spine: Spine$1,
  Timeline,
  TrackEntry,
  TransformConstraint,
  TransformConstraintData,
  TransformConstraintTimeline,
  TranslateTimeline,
  TranslateXTimeline,
  TranslateYTimeline,
  VertexAttachment
}, Symbol.toStringTag, { value: "Module" }));
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$1 = function(d2, b2) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p))
        d3[p] = b3[p];
  };
  return extendStatics$1(d2, b2);
};
function __extends$1(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics$1(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var SPINE_VERSION;
(function(SPINE_VERSION2) {
  SPINE_VERSION2[SPINE_VERSION2["UNKNOWN"] = 0] = "UNKNOWN";
  SPINE_VERSION2[SPINE_VERSION2["VER37"] = 37] = "VER37";
  SPINE_VERSION2[SPINE_VERSION2["VER38"] = 38] = "VER38";
  SPINE_VERSION2[SPINE_VERSION2["VER40"] = 40] = "VER40";
  SPINE_VERSION2[SPINE_VERSION2["VER41"] = 41] = "VER41";
})(SPINE_VERSION || (SPINE_VERSION = {}));
function detectSpineVersion(version) {
  var ver3 = version.substr(0, 3);
  var verNum = Math.floor(+ver3 * 10 + 1e-3);
  if (ver3 === "3.7") {
    return SPINE_VERSION.VER37;
  }
  if (ver3 === "3.8") {
    return SPINE_VERSION.VER38;
  }
  if (ver3 === "4.0") {
    return SPINE_VERSION.VER40;
  }
  if (ver3 === "4.1") {
    return SPINE_VERSION.VER41;
  }
  if (verNum < SPINE_VERSION.VER37) {
    return SPINE_VERSION.VER37;
  }
  return SPINE_VERSION.UNKNOWN;
}
var UniBinaryParser = (
  /** @class */
  function() {
    function UniBinaryParser2() {
      this.scale = 1;
    }
    UniBinaryParser2.prototype.readSkeletonData = function(atlas, dataToParse) {
      var parser = null;
      var version = this.readVersionOldFormat(dataToParse);
      var ver = detectSpineVersion(version);
      if (ver === SPINE_VERSION.VER38) {
        parser = new SkeletonBinary$1(new AtlasAttachmentLoader$2(atlas));
      }
      version = this.readVersionNewFormat(dataToParse);
      ver = detectSpineVersion(version);
      if (ver === SPINE_VERSION.VER40 || ver === SPINE_VERSION.VER41) {
        parser = new SkeletonBinary(new AtlasAttachmentLoader(atlas));
      }
      if (!parser) {
        var error2 = "Unsupported version of spine model " + version + ", please update pixi-spine";
        console.error(error2);
      }
      parser.scale = this.scale;
      return parser.readSkeletonData(dataToParse);
    };
    UniBinaryParser2.prototype.readVersionOldFormat = function(dataToParse) {
      var input = new BinaryInput(dataToParse);
      var version;
      try {
        input.readString();
        version = input.readString();
      } catch (e2) {
        version = "";
      }
      return version || "";
    };
    UniBinaryParser2.prototype.readVersionNewFormat = function(dataToParse) {
      var input = new BinaryInput(dataToParse);
      input.readInt32();
      input.readInt32();
      var version;
      try {
        version = input.readString();
      } catch (e2) {
        version = "";
      }
      return version || "";
    };
    return UniBinaryParser2;
  }()
);
var UniJsonParser = (
  /** @class */
  function() {
    function UniJsonParser2() {
      this.scale = 1;
    }
    UniJsonParser2.prototype.readSkeletonData = function(atlas, dataToParse) {
      var version = dataToParse.skeleton.spine;
      var ver = detectSpineVersion(version);
      var parser = null;
      if (ver === SPINE_VERSION.VER37) {
        parser = new SkeletonJson$1(new AtlasAttachmentLoader$1(atlas));
      }
      if (ver === SPINE_VERSION.VER38) {
        parser = new SkeletonJson$2(new AtlasAttachmentLoader$2(atlas));
      }
      if (ver === SPINE_VERSION.VER40 || ver === SPINE_VERSION.VER41) {
        parser = new SkeletonJson(new AtlasAttachmentLoader(atlas));
      }
      if (!parser) {
        var error2 = "Unsupported version of spine model " + version + ", please update pixi-spine";
        console.error(error2);
      }
      parser.scale = this.scale;
      return parser.readSkeletonData(dataToParse);
    };
    return UniJsonParser2;
  }()
);
var SpineParser = (
  /** @class */
  function(_super) {
    __extends$1(SpineParser2, _super);
    function SpineParser2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SpineParser2.prototype.createBinaryParser = function() {
      return new UniBinaryParser();
    };
    SpineParser2.prototype.createJsonParser = function() {
      return new UniJsonParser();
    };
    SpineParser2.prototype.parseData = function(resource, parser, atlas, dataToParse) {
      var parserCast = parser;
      resource.spineData = parserCast.readSkeletonData(atlas, dataToParse);
      resource.spineAtlas = atlas;
    };
    SpineParser2.registerLoaderPlugin = function() {
      Loader.registerPlugin(SpineParser2);
    };
    SpineParser2.use = new SpineParser2().genMiddleware().use;
    return SpineParser2;
  }(AbstractSpineParser)
);
var Spine = (
  /** @class */
  function(_super) {
    __extends$1(Spine2, _super);
    function Spine2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Spine2.prototype.createSkeleton = function(spineData) {
      var ver = detectSpineVersion(spineData.version);
      var spine = null;
      if (ver === SPINE_VERSION.VER37) {
        spine = spine37;
      }
      if (ver === SPINE_VERSION.VER38) {
        spine = spine38;
      }
      if (ver === SPINE_VERSION.VER40 || ver === SPINE_VERSION.VER41) {
        spine = spine41;
      }
      if (!spine) {
        var error2 = "Cant detect version of spine model " + spineData.version;
        console.error(error2);
      }
      this.skeleton = new spine.Skeleton(spineData);
      this.skeleton.updateWorldTransform();
      this.stateData = new spine.AnimationStateData(spineData);
      this.state = new spine.AnimationState(this.stateData);
    };
    return Spine2;
  }(SpineBase)
);
SpineParser.registerLoaderPlugin();
var UPNG$1 = { exports: {} };
var common = {};
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon)
    return common;
  hasRequiredCommon = 1;
  (function(exports) {
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i2 = 0; i2 < len; i2++) {
          dest[dest_offs + i2] = src[src_offs + i2];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i2, l2, len, pos, chunk, result;
        len = 0;
        for (i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
          len += chunks[i2].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
          chunk = chunks[i2];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i2 = 0; i2 < len; i2++) {
          dest[dest_offs + i2] = src[src_offs + i2];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on2) {
      if (on2) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  })(common);
  return common;
}
var deflate$1 = {};
var deflate = {};
var trees = {};
var hasRequiredTrees;
function requireTrees() {
  if (hasRequiredTrees)
    return trees;
  hasRequiredTrees = 1;
  var utils2 = requireCommon();
  var Z_FIXED = 4;
  var Z_BINARY = 0;
  var Z_TEXT = 1;
  var Z_UNKNOWN = 2;
  function zero2(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = (
    /* extra bits for each length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
  );
  var extra_dbits = (
    /* extra bits for each distance code */
    [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
  );
  var extra_blbits = (
    /* extra bits for each bit length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
  );
  var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES + 2) * 2);
  zero2(static_ltree);
  var static_dtree = new Array(D_CODES * 2);
  zero2(static_dtree);
  var _dist_code = new Array(DIST_CODE_LEN);
  zero2(_dist_code);
  var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero2(_length_code);
  var base_length = new Array(LENGTH_CODES);
  zero2(base_length);
  var base_dist = new Array(D_CODES);
  zero2(base_dist);
  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;
  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  function d_code(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
  }
  function put_short(s2, w2) {
    s2.pending_buf[s2.pending++] = w2 & 255;
    s2.pending_buf[s2.pending++] = w2 >>> 8 & 255;
  }
  function send_bits(s2, value, length2) {
    if (s2.bi_valid > Buf_size - length2) {
      s2.bi_buf |= value << s2.bi_valid & 65535;
      put_short(s2, s2.bi_buf);
      s2.bi_buf = value >> Buf_size - s2.bi_valid;
      s2.bi_valid += length2 - Buf_size;
    } else {
      s2.bi_buf |= value << s2.bi_valid & 65535;
      s2.bi_valid += length2;
    }
  }
  function send_code(s2, c2, tree) {
    send_bits(
      s2,
      tree[c2 * 2],
      tree[c2 * 2 + 1]
      /*.Len*/
    );
  }
  function bi_reverse(code, len) {
    var res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  function bi_flush(s2) {
    if (s2.bi_valid === 16) {
      put_short(s2, s2.bi_buf);
      s2.bi_buf = 0;
      s2.bi_valid = 0;
    } else if (s2.bi_valid >= 8) {
      s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
      s2.bi_buf >>= 8;
      s2.bi_valid -= 8;
    }
  }
  function gen_bitlen(s2, desc) {
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra2 = desc.stat_desc.extra_bits;
    var base = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h2;
    var n2, m2;
    var bits;
    var xbits;
    var f2;
    var overflow = 0;
    for (bits = 0; bits <= MAX_BITS; bits++) {
      s2.bl_count[bits] = 0;
    }
    tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
    for (h2 = s2.heap_max + 1; h2 < HEAP_SIZE; h2++) {
      n2 = s2.heap[h2];
      bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n2 * 2 + 1] = bits;
      if (n2 > max_code) {
        continue;
      }
      s2.bl_count[bits]++;
      xbits = 0;
      if (n2 >= base) {
        xbits = extra2[n2 - base];
      }
      f2 = tree[n2 * 2];
      s2.opt_len += f2 * (bits + xbits);
      if (has_stree) {
        s2.static_len += f2 * (stree[n2 * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s2.bl_count[bits] === 0) {
        bits--;
      }
      s2.bl_count[bits]--;
      s2.bl_count[bits + 1] += 2;
      s2.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length; bits !== 0; bits--) {
      n2 = s2.bl_count[bits];
      while (n2 !== 0) {
        m2 = s2.heap[--h2];
        if (m2 > max_code) {
          continue;
        }
        if (tree[m2 * 2 + 1] !== bits) {
          s2.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
          tree[m2 * 2 + 1] = bits;
        }
        n2--;
      }
    }
  }
  function gen_codes(tree, max_code, bl_count) {
    var next_code = new Array(MAX_BITS + 1);
    var code = 0;
    var bits;
    var n2;
    for (bits = 1; bits <= MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n2 = 0; n2 <= max_code; n2++) {
      var len = tree[n2 * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n2 * 2] = bi_reverse(next_code[len]++, len);
    }
  }
  function tr_static_init() {
    var n2;
    var bits;
    var length2;
    var code;
    var dist;
    var bl_count = new Array(MAX_BITS + 1);
    length2 = 0;
    for (code = 0; code < LENGTH_CODES - 1; code++) {
      base_length[code] = length2;
      for (n2 = 0; n2 < 1 << extra_lbits[code]; n2++) {
        _length_code[length2++] = code;
      }
    }
    _length_code[length2 - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      base_dist[code] = dist;
      for (n2 = 0; n2 < 1 << extra_dbits[code]; n2++) {
        _dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < D_CODES; code++) {
      base_dist[code] = dist << 7;
      for (n2 = 0; n2 < 1 << extra_dbits[code] - 7; n2++) {
        _dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n2 = 0;
    while (n2 <= 143) {
      static_ltree[n2 * 2 + 1] = 8;
      n2++;
      bl_count[8]++;
    }
    while (n2 <= 255) {
      static_ltree[n2 * 2 + 1] = 9;
      n2++;
      bl_count[9]++;
    }
    while (n2 <= 279) {
      static_ltree[n2 * 2 + 1] = 7;
      n2++;
      bl_count[7]++;
    }
    while (n2 <= 287) {
      static_ltree[n2 * 2 + 1] = 8;
      n2++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES + 1, bl_count);
    for (n2 = 0; n2 < D_CODES; n2++) {
      static_dtree[n2 * 2 + 1] = 5;
      static_dtree[n2 * 2] = bi_reverse(n2, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  }
  function init_block(s2) {
    var n2;
    for (n2 = 0; n2 < L_CODES; n2++) {
      s2.dyn_ltree[n2 * 2] = 0;
    }
    for (n2 = 0; n2 < D_CODES; n2++) {
      s2.dyn_dtree[n2 * 2] = 0;
    }
    for (n2 = 0; n2 < BL_CODES; n2++) {
      s2.bl_tree[n2 * 2] = 0;
    }
    s2.dyn_ltree[END_BLOCK * 2] = 1;
    s2.opt_len = s2.static_len = 0;
    s2.last_lit = s2.matches = 0;
  }
  function bi_windup(s2) {
    if (s2.bi_valid > 8) {
      put_short(s2, s2.bi_buf);
    } else if (s2.bi_valid > 0) {
      s2.pending_buf[s2.pending++] = s2.bi_buf;
    }
    s2.bi_buf = 0;
    s2.bi_valid = 0;
  }
  function copy_block(s2, buf, len, header) {
    bi_windup(s2);
    if (header) {
      put_short(s2, len);
      put_short(s2, ~len);
    }
    utils2.arraySet(s2.pending_buf, s2.window, buf, len, s2.pending);
    s2.pending += len;
  }
  function smaller(tree, n2, m2, depth) {
    var _n2 = n2 * 2;
    var _m2 = m2 * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m2];
  }
  function pqdownheap(s2, tree, k2) {
    var v2 = s2.heap[k2];
    var j2 = k2 << 1;
    while (j2 <= s2.heap_len) {
      if (j2 < s2.heap_len && smaller(tree, s2.heap[j2 + 1], s2.heap[j2], s2.depth)) {
        j2++;
      }
      if (smaller(tree, v2, s2.heap[j2], s2.depth)) {
        break;
      }
      s2.heap[k2] = s2.heap[j2];
      k2 = j2;
      j2 <<= 1;
    }
    s2.heap[k2] = v2;
  }
  function compress_block(s2, ltree, dtree) {
    var dist;
    var lc2;
    var lx = 0;
    var code;
    var extra2;
    if (s2.last_lit !== 0) {
      do {
        dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
        lc2 = s2.pending_buf[s2.l_buf + lx];
        lx++;
        if (dist === 0) {
          send_code(s2, lc2, ltree);
        } else {
          code = _length_code[lc2];
          send_code(s2, code + LITERALS + 1, ltree);
          extra2 = extra_lbits[code];
          if (extra2 !== 0) {
            lc2 -= base_length[code];
            send_bits(s2, lc2, extra2);
          }
          dist--;
          code = d_code(dist);
          send_code(s2, code, dtree);
          extra2 = extra_dbits[code];
          if (extra2 !== 0) {
            dist -= base_dist[code];
            send_bits(s2, dist, extra2);
          }
        }
      } while (lx < s2.last_lit);
    }
    send_code(s2, END_BLOCK, ltree);
  }
  function build_tree(s2, desc) {
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n2, m2;
    var max_code = -1;
    var node2;
    s2.heap_len = 0;
    s2.heap_max = HEAP_SIZE;
    for (n2 = 0; n2 < elems; n2++) {
      if (tree[n2 * 2] !== 0) {
        s2.heap[++s2.heap_len] = max_code = n2;
        s2.depth[n2] = 0;
      } else {
        tree[n2 * 2 + 1] = 0;
      }
    }
    while (s2.heap_len < 2) {
      node2 = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node2 * 2] = 1;
      s2.depth[node2] = 0;
      s2.opt_len--;
      if (has_stree) {
        s2.static_len -= stree[node2 * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n2 = s2.heap_len >> 1; n2 >= 1; n2--) {
      pqdownheap(s2, tree, n2);
    }
    node2 = elems;
    do {
      n2 = s2.heap[
        1
        /*SMALLEST*/
      ];
      s2.heap[
        1
        /*SMALLEST*/
      ] = s2.heap[s2.heap_len--];
      pqdownheap(
        s2,
        tree,
        1
        /*SMALLEST*/
      );
      m2 = s2.heap[
        1
        /*SMALLEST*/
      ];
      s2.heap[--s2.heap_max] = n2;
      s2.heap[--s2.heap_max] = m2;
      tree[node2 * 2] = tree[n2 * 2] + tree[m2 * 2];
      s2.depth[node2] = (s2.depth[n2] >= s2.depth[m2] ? s2.depth[n2] : s2.depth[m2]) + 1;
      tree[n2 * 2 + 1] = tree[m2 * 2 + 1] = node2;
      s2.heap[
        1
        /*SMALLEST*/
      ] = node2++;
      pqdownheap(
        s2,
        tree,
        1
        /*SMALLEST*/
      );
    } while (s2.heap_len >= 2);
    s2.heap[--s2.heap_max] = s2.heap[
      1
      /*SMALLEST*/
    ];
    gen_bitlen(s2, desc);
    gen_codes(tree, max_code, s2.bl_count);
  }
  function scan_tree(s2, tree, max_code) {
    var n2;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n2 = 0; n2 <= max_code; n2++) {
      curlen = nextlen;
      nextlen = tree[(n2 + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s2.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s2.bl_tree[curlen * 2]++;
        }
        s2.bl_tree[REP_3_6 * 2]++;
      } else if (count <= 10) {
        s2.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s2.bl_tree[REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function send_tree(s2, tree, max_code) {
    var n2;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n2 = 0; n2 <= max_code; n2++) {
      curlen = nextlen;
      nextlen = tree[(n2 + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code(s2, curlen, s2.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s2, curlen, s2.bl_tree);
          count--;
        }
        send_code(s2, REP_3_6, s2.bl_tree);
        send_bits(s2, count - 3, 2);
      } else if (count <= 10) {
        send_code(s2, REPZ_3_10, s2.bl_tree);
        send_bits(s2, count - 3, 3);
      } else {
        send_code(s2, REPZ_11_138, s2.bl_tree);
        send_bits(s2, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function build_bl_tree(s2) {
    var max_blindex;
    scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
    scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
    build_tree(s2, s2.bl_desc);
    for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  function send_all_trees(s2, lcodes, dcodes, blcodes) {
    var rank;
    send_bits(s2, lcodes - 257, 5);
    send_bits(s2, dcodes - 1, 5);
    send_bits(s2, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      send_bits(s2, s2.bl_tree[bl_order[rank] * 2 + 1], 3);
    }
    send_tree(s2, s2.dyn_ltree, lcodes - 1);
    send_tree(s2, s2.dyn_dtree, dcodes - 1);
  }
  function detect_data_type(s2) {
    var black_mask = 4093624447;
    var n2;
    for (n2 = 0; n2 <= 31; n2++, black_mask >>>= 1) {
      if (black_mask & 1 && s2.dyn_ltree[n2 * 2] !== 0) {
        return Z_BINARY;
      }
    }
    if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT;
    }
    for (n2 = 32; n2 < LITERALS; n2++) {
      if (s2.dyn_ltree[n2 * 2] !== 0) {
        return Z_TEXT;
      }
    }
    return Z_BINARY;
  }
  var static_init_done = false;
  function _tr_init(s2) {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
    s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
    s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
    s2.bi_buf = 0;
    s2.bi_valid = 0;
    init_block(s2);
  }
  function _tr_stored_block(s2, buf, stored_len, last) {
    send_bits(s2, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    copy_block(s2, buf, stored_len, true);
  }
  function _tr_align(s2) {
    send_bits(s2, STATIC_TREES << 1, 3);
    send_code(s2, END_BLOCK, static_ltree);
    bi_flush(s2);
  }
  function _tr_flush_block(s2, buf, stored_len, last) {
    var opt_lenb, static_lenb;
    var max_blindex = 0;
    if (s2.level > 0) {
      if (s2.strm.data_type === Z_UNKNOWN) {
        s2.strm.data_type = detect_data_type(s2);
      }
      build_tree(s2, s2.l_desc);
      build_tree(s2, s2.d_desc);
      max_blindex = build_bl_tree(s2);
      opt_lenb = s2.opt_len + 3 + 7 >>> 3;
      static_lenb = s2.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block(s2, buf, stored_len, last);
    } else if (s2.strategy === Z_FIXED || static_lenb === opt_lenb) {
      send_bits(s2, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s2, static_ltree, static_dtree);
    } else {
      send_bits(s2, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
    }
    init_block(s2);
    if (last) {
      bi_windup(s2);
    }
  }
  function _tr_tally(s2, dist, lc2) {
    s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
    s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
    s2.pending_buf[s2.l_buf + s2.last_lit] = lc2 & 255;
    s2.last_lit++;
    if (dist === 0) {
      s2.dyn_ltree[lc2 * 2]++;
    } else {
      s2.matches++;
      dist--;
      s2.dyn_ltree[(_length_code[lc2] + LITERALS + 1) * 2]++;
      s2.dyn_dtree[d_code(dist) * 2]++;
    }
    return s2.last_lit === s2.lit_bufsize - 1;
  }
  trees._tr_init = _tr_init;
  trees._tr_stored_block = _tr_stored_block;
  trees._tr_flush_block = _tr_flush_block;
  trees._tr_tally = _tr_tally;
  trees._tr_align = _tr_align;
  return trees;
}
var adler32_1;
var hasRequiredAdler32;
function requireAdler32() {
  if (hasRequiredAdler32)
    return adler32_1;
  hasRequiredAdler32 = 1;
  function adler32(adler, buf, len, pos) {
    var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
    while (len !== 0) {
      n2 = len > 2e3 ? 2e3 : len;
      len -= n2;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n2);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
  adler32_1 = adler32;
  return adler32_1;
}
var crc32_1;
var hasRequiredCrc32;
function requireCrc32() {
  if (hasRequiredCrc32)
    return crc32_1;
  hasRequiredCrc32 = 1;
  function makeTable() {
    var c2, table = [];
    for (var n2 = 0; n2 < 256; n2++) {
      c2 = n2;
      for (var k2 = 0; k2 < 8; k2++) {
        c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
      }
      table[n2] = c2;
    }
    return table;
  }
  var crcTable = makeTable();
  function crc32(crc, buf, len, pos) {
    var t2 = crcTable, end2 = pos + len;
    crc ^= -1;
    for (var i2 = pos; i2 < end2; i2++) {
      crc = crc >>> 8 ^ t2[(crc ^ buf[i2]) & 255];
    }
    return crc ^ -1;
  }
  crc32_1 = crc32;
  return crc32_1;
}
var messages;
var hasRequiredMessages;
function requireMessages() {
  if (hasRequiredMessages)
    return messages;
  hasRequiredMessages = 1;
  messages = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  };
  return messages;
}
var hasRequiredDeflate$1;
function requireDeflate$1() {
  if (hasRequiredDeflate$1)
    return deflate;
  hasRequiredDeflate$1 = 1;
  var utils2 = requireCommon();
  var trees2 = requireTrees();
  var adler32 = requireAdler32();
  var crc32 = requireCrc32();
  var msg = requireMessages();
  var Z_NO_FLUSH = 0;
  var Z_PARTIAL_FLUSH = 1;
  var Z_FULL_FLUSH = 3;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_BUF_ERROR = -5;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_FILTERED = 1;
  var Z_HUFFMAN_ONLY = 2;
  var Z_RLE = 3;
  var Z_FIXED = 4;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_UNKNOWN = 2;
  var Z_DEFLATED = 8;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 32;
  var INIT_STATE = 42;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 3;
  function err(strm, errorCode) {
    strm.msg = msg[errorCode];
    return errorCode;
  }
  function rank(f2) {
    return (f2 << 1) - (f2 > 4 ? 9 : 0);
  }
  function zero2(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  function flush_pending(strm) {
    var s2 = strm.state;
    var len = s2.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    utils2.arraySet(strm.output, s2.pending_buf, s2.pending_out, len, strm.next_out);
    strm.next_out += len;
    s2.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s2.pending -= len;
    if (s2.pending === 0) {
      s2.pending_out = 0;
    }
  }
  function flush_block_only(s2, last) {
    trees2._tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last);
    s2.block_start = s2.strstart;
    flush_pending(s2.strm);
  }
  function put_byte(s2, b2) {
    s2.pending_buf[s2.pending++] = b2;
  }
  function putShortMSB(s2, b2) {
    s2.pending_buf[s2.pending++] = b2 >>> 8 & 255;
    s2.pending_buf[s2.pending++] = b2 & 255;
  }
  function read_buf(strm, buf, start, size) {
    var len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    utils2.arraySet(buf, strm.input, strm.next_in, len, start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  function longest_match(s2, cur_match) {
    var chain_length = s2.max_chain_length;
    var scan = s2.strstart;
    var match2;
    var len;
    var best_len = s2.prev_length;
    var nice_match = s2.nice_match;
    var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
    var _win = s2.window;
    var wmask = s2.w_mask;
    var prev2 = s2.prev;
    var strend = s2.strstart + MAX_MATCH;
    var scan_end1 = _win[scan + best_len - 1];
    var scan_end = _win[scan + best_len];
    if (s2.prev_length >= s2.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s2.lookahead) {
      nice_match = s2.lookahead;
    }
    do {
      match2 = cur_match;
      if (_win[match2 + best_len] !== scan_end || _win[match2 + best_len - 1] !== scan_end1 || _win[match2] !== _win[scan] || _win[++match2] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match2++;
      do {
      } while (_win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && scan < strend);
      len = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;
      if (len > best_len) {
        s2.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev2[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s2.lookahead) {
      return best_len;
    }
    return s2.lookahead;
  }
  function fill_window(s2) {
    var _w_size = s2.w_size;
    var p, n2, m2, more, str;
    do {
      more = s2.window_size - s2.lookahead - s2.strstart;
      if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        utils2.arraySet(s2.window, s2.window, _w_size, _w_size, 0);
        s2.match_start -= _w_size;
        s2.strstart -= _w_size;
        s2.block_start -= _w_size;
        n2 = s2.hash_size;
        p = n2;
        do {
          m2 = s2.head[--p];
          s2.head[p] = m2 >= _w_size ? m2 - _w_size : 0;
        } while (--n2);
        n2 = _w_size;
        p = n2;
        do {
          m2 = s2.prev[--p];
          s2.prev[p] = m2 >= _w_size ? m2 - _w_size : 0;
        } while (--n2);
        more += _w_size;
      }
      if (s2.strm.avail_in === 0) {
        break;
      }
      n2 = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
      s2.lookahead += n2;
      if (s2.lookahead + s2.insert >= MIN_MATCH) {
        str = s2.strstart - s2.insert;
        s2.ins_h = s2.window[str];
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + 1]) & s2.hash_mask;
        while (s2.insert) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
          s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = str;
          str++;
          s2.insert--;
          if (s2.lookahead + s2.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
  }
  function deflate_stored(s2, flush) {
    var max_block_size = 65535;
    if (max_block_size > s2.pending_buf_size - 5) {
      max_block_size = s2.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s2.lookahead <= 1) {
        fill_window(s2);
        if (s2.lookahead === 0 && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      s2.strstart += s2.lookahead;
      s2.lookahead = 0;
      var max_start = s2.block_start + max_block_size;
      if (s2.strstart === 0 || s2.strstart >= max_start) {
        s2.lookahead = s2.strstart - max_start;
        s2.strstart = max_start;
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s2.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.strstart > s2.block_start) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_NEED_MORE;
  }
  function deflate_fast(s2, flush) {
    var hash_head;
    var bflush;
    for (; ; ) {
      if (s2.lookahead < MIN_LOOKAHEAD) {
        fill_window(s2);
        if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s2.lookahead >= MIN_MATCH) {
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
        hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = s2.strstart;
      }
      if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
        s2.match_length = longest_match(s2, hash_head);
      }
      if (s2.match_length >= MIN_MATCH) {
        bflush = trees2._tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
        s2.lookahead -= s2.match_length;
        if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
          s2.match_length--;
          do {
            s2.strstart++;
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
            hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = s2.strstart;
          } while (--s2.match_length !== 0);
          s2.strstart++;
        } else {
          s2.strstart += s2.match_length;
          s2.match_length = 0;
          s2.ins_h = s2.window[s2.strstart];
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + 1]) & s2.hash_mask;
        }
      } else {
        bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
      }
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.last_lit) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_slow(s2, flush) {
    var hash_head;
    var bflush;
    var max_insert;
    for (; ; ) {
      if (s2.lookahead < MIN_LOOKAHEAD) {
        fill_window(s2);
        if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s2.lookahead >= MIN_MATCH) {
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
        hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = s2.strstart;
      }
      s2.prev_length = s2.match_length;
      s2.prev_match = s2.match_start;
      s2.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
        s2.match_length = longest_match(s2, hash_head);
        if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
          s2.match_length = MIN_MATCH - 1;
        }
      }
      if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
        max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
        bflush = trees2._tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
        s2.lookahead -= s2.prev_length - 1;
        s2.prev_length -= 2;
        do {
          if (++s2.strstart <= max_insert) {
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
            hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = s2.strstart;
          }
        } while (--s2.prev_length !== 0);
        s2.match_available = 0;
        s2.match_length = MIN_MATCH - 1;
        s2.strstart++;
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s2.match_available) {
        bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
        if (bflush) {
          flush_block_only(s2, false);
        }
        s2.strstart++;
        s2.lookahead--;
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s2.match_available = 1;
        s2.strstart++;
        s2.lookahead--;
      }
    }
    if (s2.match_available) {
      bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
      s2.match_available = 0;
    }
    s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.last_lit) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_rle(s2, flush) {
    var bflush;
    var prev2;
    var scan, strend;
    var _win = s2.window;
    for (; ; ) {
      if (s2.lookahead <= MAX_MATCH) {
        fill_window(s2);
        if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      s2.match_length = 0;
      if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
        scan = s2.strstart - 1;
        prev2 = _win[scan];
        if (prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan]) {
          strend = s2.strstart + MAX_MATCH;
          do {
          } while (prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && scan < strend);
          s2.match_length = MAX_MATCH - (strend - scan);
          if (s2.match_length > s2.lookahead) {
            s2.match_length = s2.lookahead;
          }
        }
      }
      if (s2.match_length >= MIN_MATCH) {
        bflush = trees2._tr_tally(s2, 1, s2.match_length - MIN_MATCH);
        s2.lookahead -= s2.match_length;
        s2.strstart += s2.match_length;
        s2.match_length = 0;
      } else {
        bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
      }
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s2.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.last_lit) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_huff(s2, flush) {
    var bflush;
    for (; ; ) {
      if (s2.lookahead === 0) {
        fill_window(s2);
        if (s2.lookahead === 0) {
          if (flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s2.match_length = 0;
      bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s2.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.last_lit) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
  var configuration_table;
  configuration_table = [
    /*      good lazy nice chain */
    new Config(0, 0, 0, 0, deflate_stored),
    /* 0 store only */
    new Config(4, 4, 8, 4, deflate_fast),
    /* 1 max speed, no lazy matches */
    new Config(4, 5, 16, 8, deflate_fast),
    /* 2 */
    new Config(4, 6, 32, 32, deflate_fast),
    /* 3 */
    new Config(4, 4, 16, 16, deflate_slow),
    /* 4 lazy matches */
    new Config(8, 16, 32, 32, deflate_slow),
    /* 5 */
    new Config(8, 16, 128, 128, deflate_slow),
    /* 6 */
    new Config(8, 32, 128, 256, deflate_slow),
    /* 7 */
    new Config(32, 128, 258, 1024, deflate_slow),
    /* 8 */
    new Config(32, 258, 258, 4096, deflate_slow)
    /* 9 max compression */
  ];
  function lm_init(s2) {
    s2.window_size = 2 * s2.w_size;
    zero2(s2.head);
    s2.max_lazy_match = configuration_table[s2.level].max_lazy;
    s2.good_match = configuration_table[s2.level].good_length;
    s2.nice_match = configuration_table[s2.level].nice_length;
    s2.max_chain_length = configuration_table[s2.level].max_chain;
    s2.strstart = 0;
    s2.block_start = 0;
    s2.lookahead = 0;
    s2.insert = 0;
    s2.match_length = s2.prev_length = MIN_MATCH - 1;
    s2.match_available = 0;
    s2.ins_h = 0;
  }
  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new utils2.Buf16(HEAP_SIZE * 2);
    this.dyn_dtree = new utils2.Buf16((2 * D_CODES + 1) * 2);
    this.bl_tree = new utils2.Buf16((2 * BL_CODES + 1) * 2);
    zero2(this.dyn_ltree);
    zero2(this.dyn_dtree);
    zero2(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new utils2.Buf16(MAX_BITS + 1);
    this.heap = new utils2.Buf16(2 * L_CODES + 1);
    zero2(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new utils2.Buf16(2 * L_CODES + 1);
    zero2(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  function deflateResetKeep(strm) {
    var s2;
    if (!strm || !strm.state) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    s2 = strm.state;
    s2.pending = 0;
    s2.pending_out = 0;
    if (s2.wrap < 0) {
      s2.wrap = -s2.wrap;
    }
    s2.status = s2.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s2.wrap === 2 ? 0 : 1;
    s2.last_flush = Z_NO_FLUSH;
    trees2._tr_init(s2);
    return Z_OK;
  }
  function deflateReset(strm) {
    var ret = deflateResetKeep(strm);
    if (ret === Z_OK) {
      lm_init(strm.state);
    }
    return ret;
  }
  function deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return Z_OK;
  }
  function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    var wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
      return err(strm, Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    var s2 = new DeflateState();
    strm.state = s2;
    s2.strm = strm;
    s2.wrap = wrap;
    s2.gzhead = null;
    s2.w_bits = windowBits;
    s2.w_size = 1 << s2.w_bits;
    s2.w_mask = s2.w_size - 1;
    s2.hash_bits = memLevel + 7;
    s2.hash_size = 1 << s2.hash_bits;
    s2.hash_mask = s2.hash_size - 1;
    s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s2.window = new utils2.Buf8(s2.w_size * 2);
    s2.head = new utils2.Buf16(s2.hash_size);
    s2.prev = new utils2.Buf16(s2.w_size);
    s2.lit_bufsize = 1 << memLevel + 6;
    s2.pending_buf_size = s2.lit_bufsize * 4;
    s2.pending_buf = new utils2.Buf8(s2.pending_buf_size);
    s2.d_buf = 1 * s2.lit_bufsize;
    s2.l_buf = (1 + 2) * s2.lit_bufsize;
    s2.level = level;
    s2.strategy = strategy;
    s2.method = method;
    return deflateReset(strm);
  }
  function deflateInit(strm, level) {
    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
  }
  function deflate$12(strm, flush) {
    var old_flush, s2;
    var beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
    }
    s2 = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE && flush !== Z_FINISH) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
    }
    s2.strm = strm;
    old_flush = s2.last_flush;
    s2.last_flush = flush;
    if (s2.status === INIT_STATE) {
      if (s2.wrap === 2) {
        strm.adler = 0;
        put_byte(s2, 31);
        put_byte(s2, 139);
        put_byte(s2, 8);
        if (!s2.gzhead) {
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
          put_byte(s2, OS_CODE);
          s2.status = BUSY_STATE;
        } else {
          put_byte(
            s2,
            (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16)
          );
          put_byte(s2, s2.gzhead.time & 255);
          put_byte(s2, s2.gzhead.time >> 8 & 255);
          put_byte(s2, s2.gzhead.time >> 16 & 255);
          put_byte(s2, s2.gzhead.time >> 24 & 255);
          put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
          put_byte(s2, s2.gzhead.os & 255);
          if (s2.gzhead.extra && s2.gzhead.extra.length) {
            put_byte(s2, s2.gzhead.extra.length & 255);
            put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
          }
          if (s2.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending, 0);
          }
          s2.gzindex = 0;
          s2.status = EXTRA_STATE;
        }
      } else {
        var header = Z_DEFLATED + (s2.w_bits - 8 << 4) << 8;
        var level_flags = -1;
        if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
          level_flags = 0;
        } else if (s2.level < 6) {
          level_flags = 1;
        } else if (s2.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s2.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        s2.status = BUSY_STATE;
        putShortMSB(s2, header);
        if (s2.strstart !== 0) {
          putShortMSB(s2, strm.adler >>> 16);
          putShortMSB(s2, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s2.status === EXTRA_STATE) {
      if (s2.gzhead.extra) {
        beg = s2.pending;
        while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
          if (s2.pending === s2.pending_buf_size) {
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s2.pending;
            if (s2.pending === s2.pending_buf_size) {
              break;
            }
          }
          put_byte(s2, s2.gzhead.extra[s2.gzindex] & 255);
          s2.gzindex++;
        }
        if (s2.gzhead.hcrc && s2.pending > beg) {
          strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
        }
        if (s2.gzindex === s2.gzhead.extra.length) {
          s2.gzindex = 0;
          s2.status = NAME_STATE;
        }
      } else {
        s2.status = NAME_STATE;
      }
    }
    if (s2.status === NAME_STATE) {
      if (s2.gzhead.name) {
        beg = s2.pending;
        do {
          if (s2.pending === s2.pending_buf_size) {
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s2.pending;
            if (s2.pending === s2.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s2.gzindex < s2.gzhead.name.length) {
            val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s2, val);
        } while (val !== 0);
        if (s2.gzhead.hcrc && s2.pending > beg) {
          strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
        }
        if (val === 0) {
          s2.gzindex = 0;
          s2.status = COMMENT_STATE;
        }
      } else {
        s2.status = COMMENT_STATE;
      }
    }
    if (s2.status === COMMENT_STATE) {
      if (s2.gzhead.comment) {
        beg = s2.pending;
        do {
          if (s2.pending === s2.pending_buf_size) {
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s2.pending;
            if (s2.pending === s2.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s2.gzindex < s2.gzhead.comment.length) {
            val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s2, val);
        } while (val !== 0);
        if (s2.gzhead.hcrc && s2.pending > beg) {
          strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
        }
        if (val === 0) {
          s2.status = HCRC_STATE;
        }
      } else {
        s2.status = HCRC_STATE;
      }
    }
    if (s2.status === HCRC_STATE) {
      if (s2.gzhead.hcrc) {
        if (s2.pending + 2 > s2.pending_buf_size) {
          flush_pending(strm);
        }
        if (s2.pending + 2 <= s2.pending_buf_size) {
          put_byte(s2, strm.adler & 255);
          put_byte(s2, strm.adler >> 8 & 255);
          strm.adler = 0;
          s2.status = BUSY_STATE;
        }
      } else {
        s2.status = BUSY_STATE;
      }
    }
    if (s2.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
        return Z_OK;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
      return err(strm, Z_BUF_ERROR);
    }
    if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH && s2.status !== FINISH_STATE) {
      var bstate = s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s2.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
        }
        return Z_OK;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH) {
          trees2._tr_align(s2);
        } else if (flush !== Z_BLOCK) {
          trees2._tr_stored_block(s2, 0, 0, false);
          if (flush === Z_FULL_FLUSH) {
            zero2(s2.head);
            if (s2.lookahead === 0) {
              s2.strstart = 0;
              s2.block_start = 0;
              s2.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
          return Z_OK;
        }
      }
    }
    if (flush !== Z_FINISH) {
      return Z_OK;
    }
    if (s2.wrap <= 0) {
      return Z_STREAM_END;
    }
    if (s2.wrap === 2) {
      put_byte(s2, strm.adler & 255);
      put_byte(s2, strm.adler >> 8 & 255);
      put_byte(s2, strm.adler >> 16 & 255);
      put_byte(s2, strm.adler >> 24 & 255);
      put_byte(s2, strm.total_in & 255);
      put_byte(s2, strm.total_in >> 8 & 255);
      put_byte(s2, strm.total_in >> 16 & 255);
      put_byte(s2, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s2, strm.adler >>> 16);
      putShortMSB(s2, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s2.wrap > 0) {
      s2.wrap = -s2.wrap;
    }
    return s2.pending !== 0 ? Z_OK : Z_STREAM_END;
  }
  function deflateEnd(strm) {
    var status;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    status = strm.state.status;
    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
  }
  function deflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var s2;
    var str, n2;
    var wrap;
    var avail;
    var next2;
    var input;
    var tmpDict;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    s2 = strm.state;
    wrap = s2.wrap;
    if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
      return Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    }
    s2.wrap = 0;
    if (dictLength >= s2.w_size) {
      if (wrap === 0) {
        zero2(s2.head);
        s2.strstart = 0;
        s2.block_start = 0;
        s2.insert = 0;
      }
      tmpDict = new utils2.Buf8(s2.w_size);
      utils2.arraySet(tmpDict, dictionary, dictLength - s2.w_size, s2.w_size, 0);
      dictionary = tmpDict;
      dictLength = s2.w_size;
    }
    avail = strm.avail_in;
    next2 = strm.next_in;
    input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s2);
    while (s2.lookahead >= MIN_MATCH) {
      str = s2.strstart;
      n2 = s2.lookahead - (MIN_MATCH - 1);
      do {
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
        s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = str;
        str++;
      } while (--n2);
      s2.strstart = str;
      s2.lookahead = MIN_MATCH - 1;
      fill_window(s2);
    }
    s2.strstart += s2.lookahead;
    s2.block_start = s2.strstart;
    s2.insert = s2.lookahead;
    s2.lookahead = 0;
    s2.match_length = s2.prev_length = MIN_MATCH - 1;
    s2.match_available = 0;
    strm.next_in = next2;
    strm.input = input;
    strm.avail_in = avail;
    s2.wrap = wrap;
    return Z_OK;
  }
  deflate.deflateInit = deflateInit;
  deflate.deflateInit2 = deflateInit2;
  deflate.deflateReset = deflateReset;
  deflate.deflateResetKeep = deflateResetKeep;
  deflate.deflateSetHeader = deflateSetHeader;
  deflate.deflate = deflate$12;
  deflate.deflateEnd = deflateEnd;
  deflate.deflateSetDictionary = deflateSetDictionary;
  deflate.deflateInfo = "pako deflate (from Nodeca project)";
  return deflate;
}
var strings = {};
var hasRequiredStrings;
function requireStrings() {
  if (hasRequiredStrings)
    return strings;
  hasRequiredStrings = 1;
  var utils2 = requireCommon();
  var STR_APPLY_OK = true;
  var STR_APPLY_UIA_OK = true;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch (__) {
    STR_APPLY_OK = false;
  }
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (__) {
    STR_APPLY_UIA_OK = false;
  }
  var _utf8len = new utils2.Buf8(256);
  for (var q2 = 0; q2 < 256; q2++) {
    _utf8len[q2] = q2 >= 252 ? 6 : q2 >= 248 ? 5 : q2 >= 240 ? 4 : q2 >= 224 ? 3 : q2 >= 192 ? 2 : 1;
  }
  _utf8len[254] = _utf8len[254] = 1;
  strings.string2buf = function(str) {
    var buf, c2, c22, m_pos, i2, str_len = str.length, buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c2 = str.charCodeAt(m_pos);
      if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
    }
    buf = new utils2.Buf8(buf_len);
    for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
      c2 = str.charCodeAt(m_pos);
      if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      if (c2 < 128) {
        buf[i2++] = c2;
      } else if (c2 < 2048) {
        buf[i2++] = 192 | c2 >>> 6;
        buf[i2++] = 128 | c2 & 63;
      } else if (c2 < 65536) {
        buf[i2++] = 224 | c2 >>> 12;
        buf[i2++] = 128 | c2 >>> 6 & 63;
        buf[i2++] = 128 | c2 & 63;
      } else {
        buf[i2++] = 240 | c2 >>> 18;
        buf[i2++] = 128 | c2 >>> 12 & 63;
        buf[i2++] = 128 | c2 >>> 6 & 63;
        buf[i2++] = 128 | c2 & 63;
      }
    }
    return buf;
  };
  function buf2binstring(buf, len) {
    if (len < 65534) {
      if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
        return String.fromCharCode.apply(null, utils2.shrinkBuf(buf, len));
      }
    }
    var result = "";
    for (var i2 = 0; i2 < len; i2++) {
      result += String.fromCharCode(buf[i2]);
    }
    return result;
  }
  strings.buf2binstring = function(buf) {
    return buf2binstring(buf, buf.length);
  };
  strings.binstring2buf = function(str) {
    var buf = new utils2.Buf8(str.length);
    for (var i2 = 0, len = buf.length; i2 < len; i2++) {
      buf[i2] = str.charCodeAt(i2);
    }
    return buf;
  };
  strings.buf2string = function(buf, max2) {
    var i2, out, c2, c_len;
    var len = max2 || buf.length;
    var utf16buf = new Array(len * 2);
    for (out = 0, i2 = 0; i2 < len; ) {
      c2 = buf[i2++];
      if (c2 < 128) {
        utf16buf[out++] = c2;
        continue;
      }
      c_len = _utf8len[c2];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i2 += c_len - 1;
        continue;
      }
      c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i2 < len) {
        c2 = c2 << 6 | buf[i2++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c2 < 65536) {
        utf16buf[out++] = c2;
      } else {
        c2 -= 65536;
        utf16buf[out++] = 55296 | c2 >> 10 & 1023;
        utf16buf[out++] = 56320 | c2 & 1023;
      }
    }
    return buf2binstring(utf16buf, out);
  };
  strings.utf8border = function(buf, max2) {
    var pos;
    max2 = max2 || buf.length;
    if (max2 > buf.length) {
      max2 = buf.length;
    }
    pos = max2 - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max2;
    }
    if (pos === 0) {
      return max2;
    }
    return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
  };
  return strings;
}
var zstream;
var hasRequiredZstream;
function requireZstream() {
  if (hasRequiredZstream)
    return zstream;
  hasRequiredZstream = 1;
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  zstream = ZStream;
  return zstream;
}
var hasRequiredDeflate;
function requireDeflate() {
  if (hasRequiredDeflate)
    return deflate$1;
  hasRequiredDeflate = 1;
  var zlib_deflate = requireDeflate$1();
  var utils2 = requireCommon();
  var strings2 = requireStrings();
  var msg = requireMessages();
  var ZStream = requireZstream();
  var toString3 = Object.prototype.toString;
  var Z_NO_FLUSH = 0;
  var Z_FINISH = 4;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_SYNC_FLUSH = 2;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_DEFLATED = 8;
  function Deflate(options) {
    if (!(this instanceof Deflate))
      return new Deflate(options);
    this.options = utils2.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY,
      to: ""
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream();
    this.strm.avail_out = 0;
    var status = zlib_deflate.deflateInit2(
      this.strm,
      opt.level,
      opt.method,
      opt.windowBits,
      opt.memLevel,
      opt.strategy
    );
    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      var dict;
      if (typeof opt.dictionary === "string") {
        dict = strings2.string2buf(opt.dictionary);
      } else if (toString3.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this._dict_set = true;
    }
  }
  Deflate.prototype.push = function(data2, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var status, _mode;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (typeof data2 === "string") {
      strm.input = strings2.string2buf(data2);
    } else if (toString3.call(data2) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data2);
    } else {
      strm.input = data2;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils2.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_deflate.deflate(strm, _mode);
      if (status !== Z_STREAM_END && status !== Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
        if (this.options.to === "string") {
          this.onData(strings2.buf2binstring(utils2.shrinkBuf(strm.output, strm.next_out)));
        } else {
          this.onData(utils2.shrinkBuf(strm.output, strm.next_out));
        }
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
    if (_mode === Z_FINISH) {
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }
    if (_mode === Z_SYNC_FLUSH) {
      this.onEnd(Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Deflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Deflate.prototype.onEnd = function(status) {
    if (status === Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils2.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function deflate2(input, options) {
    var deflator = new Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || msg[deflator.err];
    }
    return deflator.result;
  }
  function deflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return deflate2(input, options);
  }
  function gzip(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate2(input, options);
  }
  deflate$1.Deflate = Deflate;
  deflate$1.deflate = deflate2;
  deflate$1.deflateRaw = deflateRaw;
  deflate$1.gzip = gzip;
  return deflate$1;
}
var inflate$1 = {};
var inflate = {};
var inffast;
var hasRequiredInffast;
function requireInffast() {
  if (hasRequiredInffast)
    return inffast;
  hasRequiredInffast = 1;
  var BAD = 30;
  var TYPE = 12;
  inffast = function inflate_fast(strm, start) {
    var state;
    var _in;
    var last;
    var _out;
    var beg;
    var end2;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist;
    var from2;
    var from_source;
    var input, output2;
    state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output2 = strm.output;
    beg = _out - (start - strm.avail_out);
    end2 = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output2[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    if (dist > dmax) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                      }
                      from2 = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from2 += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output2[_out++] = s_window[from2++];
                          } while (--op);
                          from2 = _out - dist;
                          from_source = output2;
                        }
                      } else if (wnext < op) {
                        from2 += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output2[_out++] = s_window[from2++];
                          } while (--op);
                          from2 = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output2[_out++] = s_window[from2++];
                            } while (--op);
                            from2 = _out - dist;
                            from_source = output2;
                          }
                        }
                      } else {
                        from2 += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output2[_out++] = s_window[from2++];
                          } while (--op);
                          from2 = _out - dist;
                          from_source = output2;
                        }
                      }
                      while (len > 2) {
                        output2[_out++] = from_source[from2++];
                        output2[_out++] = from_source[from2++];
                        output2[_out++] = from_source[from2++];
                        len -= 3;
                      }
                      if (len) {
                        output2[_out++] = from_source[from2++];
                        if (len > 1) {
                          output2[_out++] = from_source[from2++];
                        }
                      }
                    } else {
                      from2 = _out - dist;
                      do {
                        output2[_out++] = output2[from2++];
                        output2[_out++] = output2[from2++];
                        output2[_out++] = output2[from2++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output2[_out++] = output2[from2++];
                        if (len > 1) {
                          output2[_out++] = output2[from2++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end2);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end2 ? 257 + (end2 - _out) : 257 - (_out - end2);
    state.hold = hold;
    state.bits = bits;
    return;
  };
  return inffast;
}
var inftrees;
var hasRequiredInftrees;
function requireInftrees() {
  if (hasRequiredInftrees)
    return inftrees;
  hasRequiredInftrees = 1;
  var utils2 = requireCommon();
  var MAXBITS = 15;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var lbase = [
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ];
  var lext = [
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ];
  var dbase = [
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ];
  var dext = [
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  inftrees = function inflate_table(type2, lens, lens_index, codes, table, table_index, work, opts) {
    var bits = opts.bits;
    var len = 0;
    var sym = 0;
    var min = 0, max2 = 0;
    var root2 = 0;
    var curr = 0;
    var drop = 0;
    var left = 0;
    var used = 0;
    var huff = 0;
    var incr;
    var fill;
    var low;
    var mask2;
    var next2;
    var base = null;
    var base_index = 0;
    var end2;
    var count = new utils2.Buf16(MAXBITS + 1);
    var offs = new utils2.Buf16(MAXBITS + 1);
    var extra2 = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;
    for (len = 0; len <= MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root2 = bits;
    for (max2 = MAXBITS; max2 >= 1; max2--) {
      if (count[max2] !== 0) {
        break;
      }
    }
    if (root2 > max2) {
      root2 = max2;
    }
    if (max2 === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max2; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root2 < min) {
      root2 = min;
    }
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type2 === CODES || max2 !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type2 === CODES) {
      base = extra2 = work;
      end2 = 19;
    } else if (type2 === LENS) {
      base = lbase;
      base_index -= 257;
      extra2 = lext;
      extra_index -= 257;
      end2 = 256;
    } else {
      base = dbase;
      extra2 = dext;
      end2 = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next2 = table_index;
    curr = root2;
    drop = 0;
    low = -1;
    used = 1 << root2;
    mask2 = used - 1;
    if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end2) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end2) {
        here_op = extra2[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next2 + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max2) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root2 && (huff & mask2) !== low) {
        if (drop === 0) {
          drop = root2;
        }
        next2 += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max2) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask2;
        table[low] = root2 << 24 | curr << 16 | next2 - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next2 + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root2;
    return 0;
  };
  return inftrees;
}
var hasRequiredInflate$1;
function requireInflate$1() {
  if (hasRequiredInflate$1)
    return inflate;
  hasRequiredInflate$1 = 1;
  var utils2 = requireCommon();
  var adler32 = requireAdler32();
  var crc32 = requireCrc32();
  var inflate_fast = requireInffast();
  var inflate_table = requireInftrees();
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_TREES = 6;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_NEED_DICT = 2;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_MEM_ERROR = -4;
  var Z_BUF_ERROR = -5;
  var Z_DEFLATED = 8;
  var HEAD = 1;
  var FLAGS = 2;
  var TIME = 3;
  var OS = 4;
  var EXLEN = 5;
  var EXTRA = 6;
  var NAME = 7;
  var COMMENT2 = 8;
  var HCRC = 9;
  var DICTID = 10;
  var DICT = 11;
  var TYPE = 12;
  var TYPEDO = 13;
  var STORED = 14;
  var COPY_ = 15;
  var COPY = 16;
  var TABLE = 17;
  var LENLENS = 18;
  var CODELENS = 19;
  var LEN_ = 20;
  var LEN = 21;
  var LENEXT = 22;
  var DIST = 23;
  var DISTEXT = 24;
  var MATCH = 25;
  var LIT = 26;
  var CHECK = 27;
  var LENGTH = 28;
  var DONE = 29;
  var BAD = 30;
  var MEM = 31;
  var SYNC = 32;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;
  function zswap32(q2) {
    return (q2 >>> 24 & 255) + (q2 >>> 8 & 65280) + ((q2 & 65280) << 8) + ((q2 & 255) << 24);
  }
  function InflateState() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new utils2.Buf16(320);
    this.work = new utils2.Buf16(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  function inflateResetKeep(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new utils2.Buf32(ENOUGH_LENS);
    state.distcode = state.distdyn = new utils2.Buf32(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK;
  }
  function inflateReset(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  }
  function inflateReset2(strm, windowBits) {
    var wrap;
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  }
  function inflateInit2(strm, windowBits) {
    var ret;
    var state;
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    state = new InflateState();
    strm.state = state;
    state.window = null;
    ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  function inflateInit(strm) {
    return inflateInit2(strm, DEF_WBITS);
  }
  var virgin = true;
  var lenfix, distfix;
  function fixedtables(state) {
    if (virgin) {
      var sym;
      lenfix = new utils2.Buf32(512);
      distfix = new utils2.Buf32(32);
      sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
      virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  }
  function updatewindow(strm, src, end2, copy2) {
    var dist;
    var state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new utils2.Buf8(state.wsize);
    }
    if (copy2 >= state.wsize) {
      utils2.arraySet(state.window, src, end2 - state.wsize, state.wsize, 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy2) {
        dist = copy2;
      }
      utils2.arraySet(state.window, src, end2 - copy2, dist, state.wnext);
      copy2 -= dist;
      if (copy2) {
        utils2.arraySet(state.window, src, end2 - copy2, copy2, 0);
        state.wnext = copy2;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  function inflate$12(strm, flush) {
    var state;
    var input, output2;
    var next2;
    var put;
    var have, left;
    var hold;
    var bits;
    var _in, _out;
    var copy2;
    var from2;
    var from_source;
    var here = 0;
    var here_bits, here_op, here_val;
    var last_bits, last_op, last_val;
    var len;
    var ret;
    var hbuf = new utils2.Buf8(4);
    var opts;
    var n2;
    var order = (
      /* permutation of code lengths */
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
    );
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === TYPE) {
      state.mode = TYPEDO;
    }
    put = strm.next_out;
    output2 = strm.output;
    left = strm.avail_out;
    next2 = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || /* check if zlib header allowed */
            (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 1024) {
              copy2 = state.length;
              if (copy2 > have) {
                copy2 = have;
              }
              if (copy2) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils2.arraySet(
                    state.head.extra,
                    input,
                    next2,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    copy2,
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    len
                  );
                }
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy2, next2);
                }
                have -= copy2;
                next2 += copy2;
                state.length -= copy2;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy2 = 0;
              do {
                len = input[next2 + copy2++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy2 < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy2, next2);
              }
              have -= copy2;
              next2 += copy2;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT2;
          case COMMENT2:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy2 = 0;
              do {
                len = input[next2 + copy2++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy2 < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy2, next2);
              }
              have -= copy2;
              next2 += copy2;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next2;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy2 = state.length;
            if (copy2) {
              if (copy2 > have) {
                copy2 = have;
              }
              if (copy2 > left) {
                copy2 = left;
              }
              if (copy2 === 0) {
                break inf_leave;
              }
              utils2.arraySet(output2, input, next2, copy2, put);
              have -= copy2;
              next2 += copy2;
              left -= copy2;
              put += copy2;
              state.length -= copy2;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = { bits: state.lenbits };
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n2 = here_bits + 2;
                  while (bits < n2) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy2 = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n2 = here_bits + 3;
                  while (bits < n2) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy2 = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n2 = here_bits + 7;
                  while (bits < n2) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy2 = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy2 > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy2--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = { bits: state.lenbits };
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next2;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output2 = strm.output;
              left = strm.avail_out;
              next2 = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n2 = state.extra;
              while (bits < n2) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n2 = state.extra;
              while (bits < n2) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy2 = _out - left;
            if (state.offset > copy2) {
              copy2 = state.offset - copy2;
              if (copy2 > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy2 > state.wnext) {
                copy2 -= state.wnext;
                from2 = state.wsize - copy2;
              } else {
                from2 = state.wnext - copy2;
              }
              if (copy2 > state.length) {
                copy2 = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output2;
              from2 = put - state.offset;
              copy2 = state.length;
            }
            if (copy2 > left) {
              copy2 = left;
            }
            left -= copy2;
            state.length -= copy2;
            do {
              output2[put++] = from_source[from2++];
            } while (--copy2);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output2[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next2++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                state.flags ? crc32(state.check, output2, _out, put - _out) : adler32(state.check, output2, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          default:
            return Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next2;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
        ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      state.flags ? crc32(state.check, output2, _out, strm.next_out - _out) : adler32(state.check, output2, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  }
  function inflateEnd(strm) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    var state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK;
  }
  function inflateGetHeader(strm, head) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return Z_OK;
  }
  function inflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var state;
    var dictid;
    var ret;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR;
    }
    if (state.mode === DICT) {
      dictid = 1;
      dictid = adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
    state.havedict = 1;
    return Z_OK;
  }
  inflate.inflateReset = inflateReset;
  inflate.inflateReset2 = inflateReset2;
  inflate.inflateResetKeep = inflateResetKeep;
  inflate.inflateInit = inflateInit;
  inflate.inflateInit2 = inflateInit2;
  inflate.inflate = inflate$12;
  inflate.inflateEnd = inflateEnd;
  inflate.inflateGetHeader = inflateGetHeader;
  inflate.inflateSetDictionary = inflateSetDictionary;
  inflate.inflateInfo = "pako inflate (from Nodeca project)";
  return inflate;
}
var constants;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants)
    return constants;
  hasRequiredConstants = 1;
  constants = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  };
  return constants;
}
var gzheader;
var hasRequiredGzheader;
function requireGzheader() {
  if (hasRequiredGzheader)
    return gzheader;
  hasRequiredGzheader = 1;
  function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
  gzheader = GZheader;
  return gzheader;
}
var hasRequiredInflate;
function requireInflate() {
  if (hasRequiredInflate)
    return inflate$1;
  hasRequiredInflate = 1;
  var zlib_inflate = requireInflate$1();
  var utils2 = requireCommon();
  var strings2 = requireStrings();
  var c2 = requireConstants();
  var msg = requireMessages();
  var ZStream = requireZstream();
  var GZheader = requireGzheader();
  var toString3 = Object.prototype.toString;
  function Inflate(options) {
    if (!(this instanceof Inflate))
      return new Inflate(options);
    this.options = utils2.assign({
      chunkSize: 16384,
      windowBits: 0,
      to: ""
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream();
    this.strm.avail_out = 0;
    var status = zlib_inflate.inflateInit2(
      this.strm,
      opt.windowBits
    );
    if (status !== c2.Z_OK) {
      throw new Error(msg[status]);
    }
    this.header = new GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = strings2.string2buf(opt.dictionary);
      } else if (toString3.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== c2.Z_OK) {
          throw new Error(msg[status]);
        }
      }
    }
  }
  Inflate.prototype.push = function(data2, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var dictionary = this.options.dictionary;
    var status, _mode;
    var next_out_utf8, tail, utf8str;
    var allowBufError = false;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? c2.Z_FINISH : c2.Z_NO_FLUSH;
    if (typeof data2 === "string") {
      strm.input = strings2.binstring2buf(data2);
    } else if (toString3.call(data2) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data2);
    } else {
      strm.input = data2;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils2.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, c2.Z_NO_FLUSH);
      if (status === c2.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
      }
      if (status === c2.Z_BUF_ERROR && allowBufError === true) {
        status = c2.Z_OK;
        allowBufError = false;
      }
      if (status !== c2.Z_STREAM_END && status !== c2.Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === c2.Z_STREAM_END || strm.avail_in === 0 && (_mode === c2.Z_FINISH || _mode === c2.Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            next_out_utf8 = strings2.utf8border(strm.output, strm.next_out);
            tail = strm.next_out - next_out_utf8;
            utf8str = strings2.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail) {
              utils2.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
            }
            this.onData(utf8str);
          } else {
            this.onData(utils2.shrinkBuf(strm.output, strm.next_out));
          }
        }
      }
      if (strm.avail_in === 0 && strm.avail_out === 0) {
        allowBufError = true;
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c2.Z_STREAM_END);
    if (status === c2.Z_STREAM_END) {
      _mode = c2.Z_FINISH;
    }
    if (_mode === c2.Z_FINISH) {
      status = zlib_inflate.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === c2.Z_OK;
    }
    if (_mode === c2.Z_SYNC_FLUSH) {
      this.onEnd(c2.Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Inflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Inflate.prototype.onEnd = function(status) {
    if (status === c2.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils2.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function inflate2(input, options) {
    var inflator = new Inflate(options);
    inflator.push(input, true);
    if (inflator.err) {
      throw inflator.msg || msg[inflator.err];
    }
    return inflator.result;
  }
  function inflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return inflate2(input, options);
  }
  inflate$1.Inflate = Inflate;
  inflate$1.inflate = inflate2;
  inflate$1.inflateRaw = inflateRaw;
  inflate$1.ungzip = inflate2;
  return inflate$1;
}
var pako_1;
var hasRequiredPako;
function requirePako() {
  if (hasRequiredPako)
    return pako_1;
  hasRequiredPako = 1;
  var assign2 = requireCommon().assign;
  var deflate2 = requireDeflate();
  var inflate2 = requireInflate();
  var constants2 = requireConstants();
  var pako = {};
  assign2(pako, deflate2, inflate2, constants2);
  pako_1 = pako;
  return pako_1;
}
(function(module) {
  (function() {
    var UPNG2 = {};
    var pako;
    {
      module.exports = UPNG2;
    }
    if (typeof commonjsRequire == "function") {
      pako = requirePako();
    } else {
      pako = window.pako;
    }
    (function(UPNG3, pako2) {
      UPNG3.toRGBA8 = function(out) {
        var w2 = out.width, h2 = out.height;
        if (out.tabs.acTL == null)
          return [UPNG3.toRGBA8.decodeImage(out.data, w2, h2, out).buffer];
        var frms = [];
        if (out.frames[0].data == null)
          out.frames[0].data = out.data;
        var img, empty = new Uint8Array(w2 * h2 * 4);
        for (var i2 = 0; i2 < out.frames.length; i2++) {
          var frm = out.frames[i2];
          var fx = frm.rect.x, fy = frm.rect.y, fw = frm.rect.width, fh2 = frm.rect.height;
          var fdata = UPNG3.toRGBA8.decodeImage(frm.data, fw, fh2, out);
          if (i2 == 0)
            img = fdata;
          else if (frm.blend == 0)
            UPNG3._copyTile(fdata, fw, fh2, img, w2, h2, fx, fy, 0);
          else if (frm.blend == 1)
            UPNG3._copyTile(fdata, fw, fh2, img, w2, h2, fx, fy, 1);
          frms.push(img.buffer);
          img = img.slice(0);
          if (frm.dispose == 0)
            ;
          else if (frm.dispose == 1)
            UPNG3._copyTile(empty, fw, fh2, img, w2, h2, fx, fy, 0);
          else if (frm.dispose == 2) {
            var pi2 = i2 - 1;
            while (out.frames[pi2].dispose == 2)
              pi2--;
            img = new Uint8Array(frms[pi2]).slice(0);
          }
        }
        return frms;
      };
      UPNG3.toRGBA8.decodeImage = function(data2, w2, h2, out) {
        var area2 = w2 * h2, bpp = UPNG3.decode._getBPP(out);
        var bpl = Math.ceil(w2 * bpp / 8);
        var bf2 = new Uint8Array(area2 * 4), bf32 = new Uint32Array(bf2.buffer);
        var ctype = out.ctype, depth = out.depth;
        var rs = UPNG3._bin.readUshort;
        if (ctype == 6) {
          var qarea = area2 << 2;
          if (depth == 8)
            for (var i2 = 0; i2 < qarea; i2++) {
              bf2[i2] = data2[i2];
            }
          if (depth == 16)
            for (var i2 = 0; i2 < qarea; i2++) {
              bf2[i2] = data2[i2 << 1];
            }
        } else if (ctype == 2) {
          var ts = out.tabs["tRNS"], tr = -1, tg2 = -1, tb2 = -1;
          if (ts) {
            tr = ts[0];
            tg2 = ts[1];
            tb2 = ts[2];
          }
          if (depth == 8)
            for (var i2 = 0; i2 < area2; i2++) {
              var qi2 = i2 << 2, ti2 = i2 * 3;
              bf2[qi2] = data2[ti2];
              bf2[qi2 + 1] = data2[ti2 + 1];
              bf2[qi2 + 2] = data2[ti2 + 2];
              bf2[qi2 + 3] = 255;
              if (tr != -1 && data2[ti2] == tr && data2[ti2 + 1] == tg2 && data2[ti2 + 2] == tb2)
                bf2[qi2 + 3] = 0;
            }
          if (depth == 16)
            for (var i2 = 0; i2 < area2; i2++) {
              var qi2 = i2 << 2, ti2 = i2 * 6;
              bf2[qi2] = data2[ti2];
              bf2[qi2 + 1] = data2[ti2 + 2];
              bf2[qi2 + 2] = data2[ti2 + 4];
              bf2[qi2 + 3] = 255;
              if (tr != -1 && rs(data2, ti2) == tr && rs(data2, ti2 + 2) == tg2 && rs(data2, ti2 + 4) == tb2)
                bf2[qi2 + 3] = 0;
            }
        } else if (ctype == 3) {
          var p = out.tabs["PLTE"], ap = out.tabs["tRNS"], tl = ap ? ap.length : 0;
          if (depth == 1)
            for (var y2 = 0; y2 < h2; y2++) {
              var s0 = y2 * bpl, t0 = y2 * w2;
              for (var i2 = 0; i2 < w2; i2++) {
                var qi2 = t0 + i2 << 2, j2 = data2[s0 + (i2 >> 3)] >> 7 - ((i2 & 7) << 0) & 1, cj2 = 3 * j2;
                bf2[qi2] = p[cj2];
                bf2[qi2 + 1] = p[cj2 + 1];
                bf2[qi2 + 2] = p[cj2 + 2];
                bf2[qi2 + 3] = j2 < tl ? ap[j2] : 255;
              }
            }
          if (depth == 2)
            for (var y2 = 0; y2 < h2; y2++) {
              var s0 = y2 * bpl, t0 = y2 * w2;
              for (var i2 = 0; i2 < w2; i2++) {
                var qi2 = t0 + i2 << 2, j2 = data2[s0 + (i2 >> 2)] >> 6 - ((i2 & 3) << 1) & 3, cj2 = 3 * j2;
                bf2[qi2] = p[cj2];
                bf2[qi2 + 1] = p[cj2 + 1];
                bf2[qi2 + 2] = p[cj2 + 2];
                bf2[qi2 + 3] = j2 < tl ? ap[j2] : 255;
              }
            }
          if (depth == 4)
            for (var y2 = 0; y2 < h2; y2++) {
              var s0 = y2 * bpl, t0 = y2 * w2;
              for (var i2 = 0; i2 < w2; i2++) {
                var qi2 = t0 + i2 << 2, j2 = data2[s0 + (i2 >> 1)] >> 4 - ((i2 & 1) << 2) & 15, cj2 = 3 * j2;
                bf2[qi2] = p[cj2];
                bf2[qi2 + 1] = p[cj2 + 1];
                bf2[qi2 + 2] = p[cj2 + 2];
                bf2[qi2 + 3] = j2 < tl ? ap[j2] : 255;
              }
            }
          if (depth == 8)
            for (var i2 = 0; i2 < area2; i2++) {
              var qi2 = i2 << 2, j2 = data2[i2], cj2 = 3 * j2;
              bf2[qi2] = p[cj2];
              bf2[qi2 + 1] = p[cj2 + 1];
              bf2[qi2 + 2] = p[cj2 + 2];
              bf2[qi2 + 3] = j2 < tl ? ap[j2] : 255;
            }
        } else if (ctype == 4) {
          if (depth == 8)
            for (var i2 = 0; i2 < area2; i2++) {
              var qi2 = i2 << 2, di2 = i2 << 1, gr = data2[di2];
              bf2[qi2] = gr;
              bf2[qi2 + 1] = gr;
              bf2[qi2 + 2] = gr;
              bf2[qi2 + 3] = data2[di2 + 1];
            }
          if (depth == 16)
            for (var i2 = 0; i2 < area2; i2++) {
              var qi2 = i2 << 2, di2 = i2 << 2, gr = data2[di2];
              bf2[qi2] = gr;
              bf2[qi2 + 1] = gr;
              bf2[qi2 + 2] = gr;
              bf2[qi2 + 3] = data2[di2 + 2];
            }
        } else if (ctype == 0) {
          var tr = out.tabs["tRNS"] ? out.tabs["tRNS"] : -1;
          if (depth == 1)
            for (var i2 = 0; i2 < area2; i2++) {
              var gr = 255 * (data2[i2 >> 3] >> 7 - (i2 & 7) & 1), al = gr == tr * 255 ? 0 : 255;
              bf32[i2] = al << 24 | gr << 16 | gr << 8 | gr;
            }
          if (depth == 2)
            for (var i2 = 0; i2 < area2; i2++) {
              var gr = 85 * (data2[i2 >> 2] >> 6 - ((i2 & 3) << 1) & 3), al = gr == tr * 85 ? 0 : 255;
              bf32[i2] = al << 24 | gr << 16 | gr << 8 | gr;
            }
          if (depth == 4)
            for (var i2 = 0; i2 < area2; i2++) {
              var gr = 17 * (data2[i2 >> 1] >> 4 - ((i2 & 1) << 2) & 15), al = gr == tr * 17 ? 0 : 255;
              bf32[i2] = al << 24 | gr << 16 | gr << 8 | gr;
            }
          if (depth == 8)
            for (var i2 = 0; i2 < area2; i2++) {
              var gr = data2[i2], al = gr == tr ? 0 : 255;
              bf32[i2] = al << 24 | gr << 16 | gr << 8 | gr;
            }
          if (depth == 16)
            for (var i2 = 0; i2 < area2; i2++) {
              var gr = data2[i2 << 1], al = rs(data2, i2 << 1) == tr ? 0 : 255;
              bf32[i2] = al << 24 | gr << 16 | gr << 8 | gr;
            }
        }
        return bf2;
      };
      UPNG3.decode = function(buff) {
        var data2 = new Uint8Array(buff), offset = 8, bin = UPNG3._bin, rUs = bin.readUshort, rUi = bin.readUint;
        var out = { tabs: {}, frames: [] };
        var dd2 = new Uint8Array(data2.length), doff = 0;
        var fd2, foff = 0;
        var mgck = [137, 80, 78, 71, 13, 10, 26, 10];
        for (var i2 = 0; i2 < 8; i2++)
          if (data2[i2] != mgck[i2])
            throw "The input is not a PNG file!";
        while (offset < data2.length) {
          var len = bin.readUint(data2, offset);
          offset += 4;
          var type2 = bin.readASCII(data2, offset, 4);
          offset += 4;
          if (type2 == "IHDR") {
            UPNG3.decode._IHDR(data2, offset, out);
          } else if (type2 == "IDAT") {
            for (var i2 = 0; i2 < len; i2++)
              dd2[doff + i2] = data2[offset + i2];
            doff += len;
          } else if (type2 == "acTL") {
            out.tabs[type2] = { num_frames: rUi(data2, offset), num_plays: rUi(data2, offset + 4) };
            fd2 = new Uint8Array(data2.length);
          } else if (type2 == "fcTL") {
            if (foff != 0) {
              var fr2 = out.frames[out.frames.length - 1];
              fr2.data = UPNG3.decode._decompress(out, fd2.slice(0, foff), fr2.rect.width, fr2.rect.height);
              foff = 0;
            }
            var rct = { x: rUi(data2, offset + 12), y: rUi(data2, offset + 16), width: rUi(data2, offset + 4), height: rUi(data2, offset + 8) };
            var del = rUs(data2, offset + 22);
            del = rUs(data2, offset + 20) / (del == 0 ? 100 : del);
            var frm = { rect: rct, delay: Math.round(del * 1e3), dispose: data2[offset + 24], blend: data2[offset + 25] };
            out.frames.push(frm);
          } else if (type2 == "fdAT") {
            for (var i2 = 0; i2 < len - 4; i2++)
              fd2[foff + i2] = data2[offset + i2 + 4];
            foff += len - 4;
          } else if (type2 == "pHYs") {
            out.tabs[type2] = [bin.readUint(data2, offset), bin.readUint(data2, offset + 4), data2[offset + 8]];
          } else if (type2 == "cHRM") {
            out.tabs[type2] = [];
            for (var i2 = 0; i2 < 8; i2++)
              out.tabs[type2].push(bin.readUint(data2, offset + i2 * 4));
          } else if (type2 == "tEXt") {
            if (out.tabs[type2] == null)
              out.tabs[type2] = {};
            var nz = bin.nextZero(data2, offset);
            var keyw = bin.readASCII(data2, offset, nz - offset);
            var text2 = bin.readASCII(data2, nz + 1, offset + len - nz - 1);
            out.tabs[type2][keyw] = text2;
          } else if (type2 == "iTXt") {
            if (out.tabs[type2] == null)
              out.tabs[type2] = {};
            var nz = 0, off = offset;
            nz = bin.nextZero(data2, off);
            var keyw = bin.readASCII(data2, off, nz - off);
            off = nz + 1;
            data2[off];
            data2[off + 1];
            off += 2;
            nz = bin.nextZero(data2, off);
            bin.readASCII(data2, off, nz - off);
            off = nz + 1;
            nz = bin.nextZero(data2, off);
            bin.readUTF8(data2, off, nz - off);
            off = nz + 1;
            var text2 = bin.readUTF8(data2, off, len - (off - offset));
            out.tabs[type2][keyw] = text2;
          } else if (type2 == "PLTE") {
            out.tabs[type2] = bin.readBytes(data2, offset, len);
          } else if (type2 == "hIST") {
            var pl = out.tabs["PLTE"].length / 3;
            out.tabs[type2] = [];
            for (var i2 = 0; i2 < pl; i2++)
              out.tabs[type2].push(rUs(data2, offset + i2 * 2));
          } else if (type2 == "tRNS") {
            if (out.ctype == 3)
              out.tabs[type2] = bin.readBytes(data2, offset, len);
            else if (out.ctype == 0)
              out.tabs[type2] = rUs(data2, offset);
            else if (out.ctype == 2)
              out.tabs[type2] = [rUs(data2, offset), rUs(data2, offset + 2), rUs(data2, offset + 4)];
          } else if (type2 == "gAMA")
            out.tabs[type2] = bin.readUint(data2, offset) / 1e5;
          else if (type2 == "sRGB")
            out.tabs[type2] = data2[offset];
          else if (type2 == "bKGD") {
            if (out.ctype == 0 || out.ctype == 4)
              out.tabs[type2] = [rUs(data2, offset)];
            else if (out.ctype == 2 || out.ctype == 6)
              out.tabs[type2] = [rUs(data2, offset), rUs(data2, offset + 2), rUs(data2, offset + 4)];
            else if (out.ctype == 3)
              out.tabs[type2] = data2[offset];
          } else if (type2 == "IEND") {
            if (foff != 0) {
              var fr2 = out.frames[out.frames.length - 1];
              fr2.data = UPNG3.decode._decompress(out, fd2.slice(0, foff), fr2.rect.width, fr2.rect.height);
              foff = 0;
            }
            out.data = UPNG3.decode._decompress(out, dd2, out.width, out.height);
            break;
          }
          offset += len;
          bin.readUint(data2, offset);
          offset += 4;
        }
        delete out.compress;
        delete out.interlace;
        delete out.filter;
        return out;
      };
      UPNG3.decode._decompress = function(out, dd2, w2, h2) {
        if (out.compress == 0)
          dd2 = UPNG3.decode._inflate(dd2);
        if (out.interlace == 0)
          dd2 = UPNG3.decode._filterZero(dd2, out, 0, w2, h2);
        else if (out.interlace == 1)
          dd2 = UPNG3.decode._readInterlace(dd2, out);
        return dd2;
      };
      UPNG3.decode._inflate = function(data2) {
        return pako2["inflate"](data2);
      };
      UPNG3.decode._readInterlace = function(data2, out) {
        var w2 = out.width, h2 = out.height;
        var bpp = UPNG3.decode._getBPP(out), cbpp = bpp >> 3, bpl = Math.ceil(w2 * bpp / 8);
        var img = new Uint8Array(h2 * bpl);
        var di2 = 0;
        var starting_row = [0, 0, 4, 0, 2, 0, 1];
        var starting_col = [0, 4, 0, 2, 0, 1, 0];
        var row_increment = [8, 8, 8, 4, 4, 2, 2];
        var col_increment = [8, 8, 4, 4, 2, 2, 1];
        var pass = 0;
        while (pass < 7) {
          var ri2 = row_increment[pass], ci2 = col_increment[pass];
          var sw = 0, sh2 = 0;
          var cr = starting_row[pass];
          while (cr < h2) {
            cr += ri2;
            sh2++;
          }
          var cc2 = starting_col[pass];
          while (cc2 < w2) {
            cc2 += ci2;
            sw++;
          }
          var bpll = Math.ceil(sw * bpp / 8);
          UPNG3.decode._filterZero(data2, out, di2, sw, sh2);
          var y2 = 0, row = starting_row[pass];
          while (row < h2) {
            var col = starting_col[pass];
            var cdi = di2 + y2 * bpll << 3;
            while (col < w2) {
              if (bpp == 1) {
                var val = data2[cdi >> 3];
                val = val >> 7 - (cdi & 7) & 1;
                img[row * bpl + (col >> 3)] |= val << 7 - ((col & 3) << 0);
              }
              if (bpp == 2) {
                var val = data2[cdi >> 3];
                val = val >> 6 - (cdi & 7) & 3;
                img[row * bpl + (col >> 2)] |= val << 6 - ((col & 3) << 1);
              }
              if (bpp == 4) {
                var val = data2[cdi >> 3];
                val = val >> 4 - (cdi & 7) & 15;
                img[row * bpl + (col >> 1)] |= val << 4 - ((col & 1) << 2);
              }
              if (bpp >= 8) {
                var ii2 = row * bpl + col * cbpp;
                for (var j2 = 0; j2 < cbpp; j2++)
                  img[ii2 + j2] = data2[(cdi >> 3) + j2];
              }
              cdi += bpp;
              col += ci2;
            }
            y2++;
            row += ri2;
          }
          if (sw * sh2 != 0)
            di2 += sh2 * (1 + bpll);
          pass = pass + 1;
        }
        return img;
      };
      UPNG3.decode._getBPP = function(out) {
        var noc = [1, null, 3, 1, 2, null, 4][out.ctype];
        return noc * out.depth;
      };
      UPNG3.decode._filterZero = function(data2, out, off, w2, h2) {
        var bpp = UPNG3.decode._getBPP(out), bpl = Math.ceil(w2 * bpp / 8), paeth = UPNG3.decode._paeth;
        bpp = Math.ceil(bpp / 8);
        for (var y2 = 0; y2 < h2; y2++) {
          var i2 = off + y2 * bpl, di2 = i2 + y2 + 1;
          var type2 = data2[di2 - 1];
          if (type2 == 0)
            for (var x = 0; x < bpl; x++)
              data2[i2 + x] = data2[di2 + x];
          else if (type2 == 1) {
            for (var x = 0; x < bpp; x++)
              data2[i2 + x] = data2[di2 + x];
            for (var x = bpp; x < bpl; x++)
              data2[i2 + x] = data2[di2 + x] + data2[i2 + x - bpp] & 255;
          } else if (y2 == 0) {
            for (var x = 0; x < bpp; x++)
              data2[i2 + x] = data2[di2 + x];
            if (type2 == 2)
              for (var x = bpp; x < bpl; x++)
                data2[i2 + x] = data2[di2 + x] & 255;
            if (type2 == 3)
              for (var x = bpp; x < bpl; x++)
                data2[i2 + x] = data2[di2 + x] + (data2[i2 + x - bpp] >> 1) & 255;
            if (type2 == 4)
              for (var x = bpp; x < bpl; x++)
                data2[i2 + x] = data2[di2 + x] + paeth(data2[i2 + x - bpp], 0, 0) & 255;
          } else {
            if (type2 == 2) {
              for (var x = 0; x < bpl; x++)
                data2[i2 + x] = data2[di2 + x] + data2[i2 + x - bpl] & 255;
            }
            if (type2 == 3) {
              for (var x = 0; x < bpp; x++)
                data2[i2 + x] = data2[di2 + x] + (data2[i2 + x - bpl] >> 1) & 255;
              for (var x = bpp; x < bpl; x++)
                data2[i2 + x] = data2[di2 + x] + (data2[i2 + x - bpl] + data2[i2 + x - bpp] >> 1) & 255;
            }
            if (type2 == 4) {
              for (var x = 0; x < bpp; x++)
                data2[i2 + x] = data2[di2 + x] + paeth(0, data2[i2 + x - bpl], 0) & 255;
              for (var x = bpp; x < bpl; x++)
                data2[i2 + x] = data2[di2 + x] + paeth(data2[i2 + x - bpp], data2[i2 + x - bpl], data2[i2 + x - bpp - bpl]) & 255;
            }
          }
        }
        return data2;
      };
      UPNG3.decode._paeth = function(a2, b2, c2) {
        var p = a2 + b2 - c2, pa2 = Math.abs(p - a2), pb2 = Math.abs(p - b2), pc2 = Math.abs(p - c2);
        if (pa2 <= pb2 && pa2 <= pc2)
          return a2;
        else if (pb2 <= pc2)
          return b2;
        return c2;
      };
      UPNG3.decode._IHDR = function(data2, offset, out) {
        var bin = UPNG3._bin;
        out.width = bin.readUint(data2, offset);
        offset += 4;
        out.height = bin.readUint(data2, offset);
        offset += 4;
        out.depth = data2[offset];
        offset++;
        out.ctype = data2[offset];
        offset++;
        out.compress = data2[offset];
        offset++;
        out.filter = data2[offset];
        offset++;
        out.interlace = data2[offset];
        offset++;
      };
      UPNG3._bin = {
        nextZero: function(data2, p) {
          while (data2[p] != 0)
            p++;
          return p;
        },
        readUshort: function(buff, p) {
          return buff[p] << 8 | buff[p + 1];
        },
        writeUshort: function(buff, p, n2) {
          buff[p] = n2 >> 8 & 255;
          buff[p + 1] = n2 & 255;
        },
        readUint: function(buff, p) {
          return buff[p] * (256 * 256 * 256) + (buff[p + 1] << 16 | buff[p + 2] << 8 | buff[p + 3]);
        },
        writeUint: function(buff, p, n2) {
          buff[p] = n2 >> 24 & 255;
          buff[p + 1] = n2 >> 16 & 255;
          buff[p + 2] = n2 >> 8 & 255;
          buff[p + 3] = n2 & 255;
        },
        readASCII: function(buff, p, l2) {
          var s2 = "";
          for (var i2 = 0; i2 < l2; i2++)
            s2 += String.fromCharCode(buff[p + i2]);
          return s2;
        },
        writeASCII: function(data2, p, s2) {
          for (var i2 = 0; i2 < s2.length; i2++)
            data2[p + i2] = s2.charCodeAt(i2);
        },
        readBytes: function(buff, p, l2) {
          var arr = [];
          for (var i2 = 0; i2 < l2; i2++)
            arr.push(buff[p + i2]);
          return arr;
        },
        pad: function(n2) {
          return n2.length < 2 ? "0" + n2 : n2;
        },
        readUTF8: function(buff, p, l2) {
          var s2 = "", ns;
          for (var i2 = 0; i2 < l2; i2++)
            s2 += "%" + UPNG3._bin.pad(buff[p + i2].toString(16));
          try {
            ns = decodeURIComponent(s2);
          } catch (e2) {
            return UPNG3._bin.readASCII(buff, p, l2);
          }
          return ns;
        }
      };
      UPNG3._copyTile = function(sb2, sw, sh2, tb2, tw, th2, xoff, yoff, mode) {
        var w2 = Math.min(sw, tw), h2 = Math.min(sh2, th2);
        var si2 = 0, ti2 = 0;
        for (var y2 = 0; y2 < h2; y2++)
          for (var x = 0; x < w2; x++) {
            if (xoff >= 0 && yoff >= 0) {
              si2 = y2 * sw + x << 2;
              ti2 = (yoff + y2) * tw + xoff + x << 2;
            } else {
              si2 = (-yoff + y2) * sw - xoff + x << 2;
              ti2 = y2 * tw + x << 2;
            }
            if (mode == 0) {
              tb2[ti2] = sb2[si2];
              tb2[ti2 + 1] = sb2[si2 + 1];
              tb2[ti2 + 2] = sb2[si2 + 2];
              tb2[ti2 + 3] = sb2[si2 + 3];
            } else if (mode == 1) {
              var fa2 = sb2[si2 + 3] * (1 / 255), fr2 = sb2[si2] * fa2, fg2 = sb2[si2 + 1] * fa2, fb2 = sb2[si2 + 2] * fa2;
              var ba2 = tb2[ti2 + 3] * (1 / 255), br = tb2[ti2] * ba2, bg2 = tb2[ti2 + 1] * ba2, bb2 = tb2[ti2 + 2] * ba2;
              var ifa = 1 - fa2, oa2 = fa2 + ba2 * ifa, ioa = oa2 == 0 ? 0 : 1 / oa2;
              tb2[ti2 + 3] = 255 * oa2;
              tb2[ti2 + 0] = (fr2 + br * ifa) * ioa;
              tb2[ti2 + 1] = (fg2 + bg2 * ifa) * ioa;
              tb2[ti2 + 2] = (fb2 + bb2 * ifa) * ioa;
            } else if (mode == 2) {
              var fa2 = sb2[si2 + 3], fr2 = sb2[si2], fg2 = sb2[si2 + 1], fb2 = sb2[si2 + 2];
              var ba2 = tb2[ti2 + 3], br = tb2[ti2], bg2 = tb2[ti2 + 1], bb2 = tb2[ti2 + 2];
              if (fa2 == ba2 && fr2 == br && fg2 == bg2 && fb2 == bb2) {
                tb2[ti2] = 0;
                tb2[ti2 + 1] = 0;
                tb2[ti2 + 2] = 0;
                tb2[ti2 + 3] = 0;
              } else {
                tb2[ti2] = fr2;
                tb2[ti2 + 1] = fg2;
                tb2[ti2 + 2] = fb2;
                tb2[ti2 + 3] = fa2;
              }
            } else if (mode == 3) {
              var fa2 = sb2[si2 + 3], fr2 = sb2[si2], fg2 = sb2[si2 + 1], fb2 = sb2[si2 + 2];
              var ba2 = tb2[ti2 + 3], br = tb2[ti2], bg2 = tb2[ti2 + 1], bb2 = tb2[ti2 + 2];
              if (fa2 == ba2 && fr2 == br && fg2 == bg2 && fb2 == bb2)
                continue;
              if (fa2 < 220 && ba2 > 20)
                return false;
            }
          }
        return true;
      };
      UPNG3.encode = function(bufs, w2, h2, ps, dels, forbidPlte) {
        if (ps == null)
          ps = 0;
        if (forbidPlte == null)
          forbidPlte = false;
        var data2 = new Uint8Array(bufs[0].byteLength * bufs.length + 100);
        var wr = [137, 80, 78, 71, 13, 10, 26, 10];
        for (var i2 = 0; i2 < 8; i2++)
          data2[i2] = wr[i2];
        var offset = 8, bin = UPNG3._bin, crc = UPNG3.crc.crc, wUi = bin.writeUint, wUs = bin.writeUshort, wAs = bin.writeASCII;
        var nimg = UPNG3.encode.compressPNG(bufs, w2, h2, ps, forbidPlte);
        wUi(data2, offset, 13);
        offset += 4;
        wAs(data2, offset, "IHDR");
        offset += 4;
        wUi(data2, offset, w2);
        offset += 4;
        wUi(data2, offset, h2);
        offset += 4;
        data2[offset] = nimg.depth;
        offset++;
        data2[offset] = nimg.ctype;
        offset++;
        data2[offset] = 0;
        offset++;
        data2[offset] = 0;
        offset++;
        data2[offset] = 0;
        offset++;
        wUi(data2, offset, crc(data2, offset - 17, 17));
        offset += 4;
        wUi(data2, offset, 1);
        offset += 4;
        wAs(data2, offset, "sRGB");
        offset += 4;
        data2[offset] = 1;
        offset++;
        wUi(data2, offset, crc(data2, offset - 5, 5));
        offset += 4;
        var anim = bufs.length > 1;
        if (anim) {
          wUi(data2, offset, 8);
          offset += 4;
          wAs(data2, offset, "acTL");
          offset += 4;
          wUi(data2, offset, bufs.length);
          offset += 4;
          wUi(data2, offset, 0);
          offset += 4;
          wUi(data2, offset, crc(data2, offset - 12, 12));
          offset += 4;
        }
        if (nimg.ctype == 3) {
          var dl = nimg.plte.length;
          wUi(data2, offset, dl * 3);
          offset += 4;
          wAs(data2, offset, "PLTE");
          offset += 4;
          for (var i2 = 0; i2 < dl; i2++) {
            var ti2 = i2 * 3, c2 = nimg.plte[i2], r2 = c2 & 255, g2 = c2 >> 8 & 255, b2 = c2 >> 16 & 255;
            data2[offset + ti2 + 0] = r2;
            data2[offset + ti2 + 1] = g2;
            data2[offset + ti2 + 2] = b2;
          }
          offset += dl * 3;
          wUi(data2, offset, crc(data2, offset - dl * 3 - 4, dl * 3 + 4));
          offset += 4;
          if (nimg.gotAlpha) {
            wUi(data2, offset, dl);
            offset += 4;
            wAs(data2, offset, "tRNS");
            offset += 4;
            for (var i2 = 0; i2 < dl; i2++)
              data2[offset + i2] = nimg.plte[i2] >> 24 & 255;
            offset += dl;
            wUi(data2, offset, crc(data2, offset - dl - 4, dl + 4));
            offset += 4;
          }
        }
        var fi2 = 0;
        for (var j2 = 0; j2 < nimg.frames.length; j2++) {
          var fr2 = nimg.frames[j2];
          if (anim) {
            wUi(data2, offset, 26);
            offset += 4;
            wAs(data2, offset, "fcTL");
            offset += 4;
            wUi(data2, offset, fi2++);
            offset += 4;
            wUi(data2, offset, fr2.rect.width);
            offset += 4;
            wUi(data2, offset, fr2.rect.height);
            offset += 4;
            wUi(data2, offset, fr2.rect.x);
            offset += 4;
            wUi(data2, offset, fr2.rect.y);
            offset += 4;
            wUs(data2, offset, dels[j2]);
            offset += 2;
            wUs(data2, offset, 1e3);
            offset += 2;
            data2[offset] = fr2.dispose;
            offset++;
            data2[offset] = fr2.blend;
            offset++;
            wUi(data2, offset, crc(data2, offset - 30, 30));
            offset += 4;
          }
          var imgd = fr2.cimg, dl = imgd.length;
          wUi(data2, offset, dl + (j2 == 0 ? 0 : 4));
          offset += 4;
          var ioff = offset;
          wAs(data2, offset, j2 == 0 ? "IDAT" : "fdAT");
          offset += 4;
          if (j2 != 0) {
            wUi(data2, offset, fi2++);
            offset += 4;
          }
          for (var i2 = 0; i2 < dl; i2++)
            data2[offset + i2] = imgd[i2];
          offset += dl;
          wUi(data2, offset, crc(data2, ioff, offset - ioff));
          offset += 4;
        }
        wUi(data2, offset, 0);
        offset += 4;
        wAs(data2, offset, "IEND");
        offset += 4;
        wUi(data2, offset, crc(data2, offset - 4, 4));
        offset += 4;
        return data2.buffer.slice(0, offset);
      };
      UPNG3.encode.compressPNG = function(bufs, w2, h2, ps, forbidPlte) {
        var out = UPNG3.encode.compress(bufs, w2, h2, ps, false, forbidPlte);
        for (var i2 = 0; i2 < bufs.length; i2++) {
          var frm = out.frames[i2];
          frm.rect.width;
          var nh2 = frm.rect.height, bpl = frm.bpl, bpp = frm.bpp;
          var fdata = new Uint8Array(nh2 * bpl + nh2);
          frm.cimg = UPNG3.encode._filterZero(frm.img, nh2, bpp, bpl, fdata);
        }
        return out;
      };
      UPNG3.encode.compress = function(bufs, w2, h2, ps, forGIF, forbidPlte) {
        if (forbidPlte == null)
          forbidPlte = false;
        var ctype = 6, depth = 8, bpp = 4, alphaAnd = 255;
        for (var j2 = 0; j2 < bufs.length; j2++) {
          var img = new Uint8Array(bufs[j2]), ilen = img.length;
          for (var i2 = 0; i2 < ilen; i2 += 4)
            alphaAnd &= img[i2 + 3];
        }
        var gotAlpha = alphaAnd != 255;
        var cmap = {}, plte = [];
        if (bufs.length != 0) {
          cmap[0] = 0;
          plte.push(0);
          if (ps != 0)
            ps--;
        }
        if (ps != 0) {
          var qres = UPNG3.quantize(bufs, ps, forGIF);
          bufs = qres.bufs;
          for (var i2 = 0; i2 < qres.plte.length; i2++) {
            var c2 = qres.plte[i2].est.rgba;
            if (cmap[c2] == null) {
              cmap[c2] = plte.length;
              plte.push(c2);
            }
          }
        } else {
          for (var j2 = 0; j2 < bufs.length; j2++) {
            var img32 = new Uint32Array(bufs[j2]), ilen = img32.length;
            for (var i2 = 0; i2 < ilen; i2++) {
              var c2 = img32[i2];
              if ((i2 < w2 || c2 != img32[i2 - 1] && c2 != img32[i2 - w2]) && cmap[c2] == null) {
                cmap[c2] = plte.length;
                plte.push(c2);
                if (plte.length >= 300)
                  break;
              }
            }
          }
        }
        var brute = gotAlpha ? forGIF : false;
        var cc2 = plte.length;
        if (cc2 <= 256 && forbidPlte == false) {
          if (cc2 <= 2)
            depth = 1;
          else if (cc2 <= 4)
            depth = 2;
          else if (cc2 <= 16)
            depth = 4;
          else
            depth = 8;
          if (forGIF)
            depth = 8;
          gotAlpha = true;
        }
        var frms = [];
        for (var j2 = 0; j2 < bufs.length; j2++) {
          var cimg = new Uint8Array(bufs[j2]), cimg32 = new Uint32Array(cimg.buffer);
          var nx = 0, ny = 0, nw = w2, nh2 = h2, blend = 0;
          if (j2 != 0 && !brute) {
            var tlim = forGIF || j2 == 1 || frms[frms.length - 2].dispose == 2 ? 1 : 2, tstp = 0, tarea = 1e9;
            for (var it = 0; it < tlim; it++) {
              var pimg = new Uint8Array(bufs[j2 - 1 - it]), p32 = new Uint32Array(bufs[j2 - 1 - it]);
              var mix2 = w2, miy = h2, max2 = -1, may = -1;
              for (var y2 = 0; y2 < h2; y2++)
                for (var x = 0; x < w2; x++) {
                  var i2 = y2 * w2 + x;
                  if (cimg32[i2] != p32[i2]) {
                    if (x < mix2)
                      mix2 = x;
                    if (x > max2)
                      max2 = x;
                    if (y2 < miy)
                      miy = y2;
                    if (y2 > may)
                      may = y2;
                  }
                }
              var sarea = max2 == -1 ? 1 : (max2 - mix2 + 1) * (may - miy + 1);
              if (sarea < tarea) {
                tarea = sarea;
                tstp = it;
                if (max2 == -1) {
                  nx = ny = 0;
                  nw = nh2 = 1;
                } else {
                  nx = mix2;
                  ny = miy;
                  nw = max2 - mix2 + 1;
                  nh2 = may - miy + 1;
                }
              }
            }
            var pimg = new Uint8Array(bufs[j2 - 1 - tstp]);
            if (tstp == 1)
              frms[frms.length - 1].dispose = 2;
            var nimg = new Uint8Array(nw * nh2 * 4);
            new Uint32Array(nimg.buffer);
            UPNG3._copyTile(pimg, w2, h2, nimg, nw, nh2, -nx, -ny, 0);
            if (UPNG3._copyTile(cimg, w2, h2, nimg, nw, nh2, -nx, -ny, 3)) {
              UPNG3._copyTile(cimg, w2, h2, nimg, nw, nh2, -nx, -ny, 2);
              blend = 1;
            } else {
              UPNG3._copyTile(cimg, w2, h2, nimg, nw, nh2, -nx, -ny, 0);
              blend = 0;
            }
            cimg = nimg;
            cimg32 = new Uint32Array(cimg.buffer);
          }
          var bpl = 4 * nw;
          if (cc2 <= 256 && forbidPlte == false) {
            bpl = Math.ceil(depth * nw / 8);
            var nimg = new Uint8Array(bpl * nh2);
            for (var y2 = 0; y2 < nh2; y2++) {
              var i2 = y2 * bpl, ii2 = y2 * nw;
              if (depth == 8)
                for (var x = 0; x < nw; x++)
                  nimg[i2 + x] = cmap[cimg32[ii2 + x]];
              else if (depth == 4)
                for (var x = 0; x < nw; x++)
                  nimg[i2 + (x >> 1)] |= cmap[cimg32[ii2 + x]] << 4 - (x & 1) * 4;
              else if (depth == 2)
                for (var x = 0; x < nw; x++)
                  nimg[i2 + (x >> 2)] |= cmap[cimg32[ii2 + x]] << 6 - (x & 3) * 2;
              else if (depth == 1)
                for (var x = 0; x < nw; x++)
                  nimg[i2 + (x >> 3)] |= cmap[cimg32[ii2 + x]] << 7 - (x & 7) * 1;
            }
            cimg = nimg;
            ctype = 3;
            bpp = 1;
          } else if (gotAlpha == false && bufs.length == 1) {
            var nimg = new Uint8Array(nw * nh2 * 3), area2 = nw * nh2;
            for (var i2 = 0; i2 < area2; i2++) {
              var ti2 = i2 * 3, qi2 = i2 * 4;
              nimg[ti2] = cimg[qi2];
              nimg[ti2 + 1] = cimg[qi2 + 1];
              nimg[ti2 + 2] = cimg[qi2 + 2];
            }
            cimg = nimg;
            ctype = 2;
            bpp = 3;
            bpl = 3 * nw;
          }
          frms.push({ rect: { x: nx, y: ny, width: nw, height: nh2 }, img: cimg, bpl, bpp, blend, dispose: brute ? 1 : 0 });
        }
        return { ctype, depth, plte, gotAlpha, frames: frms };
      };
      UPNG3.encode._filterZero = function(img, h2, bpp, bpl, data2) {
        var fls = [];
        for (var t2 = 0; t2 < 5; t2++) {
          if (h2 * bpl > 5e5 && (t2 == 2 || t2 == 3 || t2 == 4))
            continue;
          for (var y2 = 0; y2 < h2; y2++)
            UPNG3.encode._filterLine(data2, img, y2, bpl, bpp, t2);
          fls.push(pako2["deflate"](data2));
          if (bpp == 1)
            break;
        }
        var ti2, tsize = 1e9;
        for (var i2 = 0; i2 < fls.length; i2++)
          if (fls[i2].length < tsize) {
            ti2 = i2;
            tsize = fls[i2].length;
          }
        return fls[ti2];
      };
      UPNG3.encode._filterLine = function(data2, img, y2, bpl, bpp, type2) {
        var i2 = y2 * bpl, di2 = i2 + y2, paeth = UPNG3.decode._paeth;
        data2[di2] = type2;
        di2++;
        if (type2 == 0)
          for (var x = 0; x < bpl; x++)
            data2[di2 + x] = img[i2 + x];
        else if (type2 == 1) {
          for (var x = 0; x < bpp; x++)
            data2[di2 + x] = img[i2 + x];
          for (var x = bpp; x < bpl; x++)
            data2[di2 + x] = img[i2 + x] - img[i2 + x - bpp] + 256 & 255;
        } else if (y2 == 0) {
          for (var x = 0; x < bpp; x++)
            data2[di2 + x] = img[i2 + x];
          if (type2 == 2)
            for (var x = bpp; x < bpl; x++)
              data2[di2 + x] = img[i2 + x];
          if (type2 == 3)
            for (var x = bpp; x < bpl; x++)
              data2[di2 + x] = img[i2 + x] - (img[i2 + x - bpp] >> 1) + 256 & 255;
          if (type2 == 4)
            for (var x = bpp; x < bpl; x++)
              data2[di2 + x] = img[i2 + x] - paeth(img[i2 + x - bpp], 0, 0) + 256 & 255;
        } else {
          if (type2 == 2) {
            for (var x = 0; x < bpl; x++)
              data2[di2 + x] = img[i2 + x] + 256 - img[i2 + x - bpl] & 255;
          }
          if (type2 == 3) {
            for (var x = 0; x < bpp; x++)
              data2[di2 + x] = img[i2 + x] + 256 - (img[i2 + x - bpl] >> 1) & 255;
            for (var x = bpp; x < bpl; x++)
              data2[di2 + x] = img[i2 + x] + 256 - (img[i2 + x - bpl] + img[i2 + x - bpp] >> 1) & 255;
          }
          if (type2 == 4) {
            for (var x = 0; x < bpp; x++)
              data2[di2 + x] = img[i2 + x] + 256 - paeth(0, img[i2 + x - bpl], 0) & 255;
            for (var x = bpp; x < bpl; x++)
              data2[di2 + x] = img[i2 + x] + 256 - paeth(img[i2 + x - bpp], img[i2 + x - bpl], img[i2 + x - bpp - bpl]) & 255;
          }
        }
      };
      UPNG3.crc = {
        table: function() {
          var tab = new Uint32Array(256);
          for (var n2 = 0; n2 < 256; n2++) {
            var c2 = n2;
            for (var k2 = 0; k2 < 8; k2++) {
              if (c2 & 1)
                c2 = 3988292384 ^ c2 >>> 1;
              else
                c2 = c2 >>> 1;
            }
            tab[n2] = c2;
          }
          return tab;
        }(),
        update: function(c2, buf, off, len) {
          for (var i2 = 0; i2 < len; i2++)
            c2 = UPNG3.crc.table[(c2 ^ buf[off + i2]) & 255] ^ c2 >>> 8;
          return c2;
        },
        crc: function(b2, o2, l2) {
          return UPNG3.crc.update(4294967295, b2, o2, l2) ^ 4294967295;
        }
      };
      UPNG3.quantize = function(bufs, ps, roundAlpha) {
        var imgs = [], totl = 0;
        for (var i2 = 0; i2 < bufs.length; i2++) {
          imgs.push(UPNG3.encode.alphaMul(new Uint8Array(bufs[i2]), roundAlpha));
          totl += bufs[i2].byteLength;
        }
        var nimg = new Uint8Array(totl), nimg32 = new Uint32Array(nimg.buffer), noff = 0;
        for (var i2 = 0; i2 < imgs.length; i2++) {
          var img = imgs[i2], il = img.length;
          for (var j2 = 0; j2 < il; j2++)
            nimg[noff + j2] = img[j2];
          noff += il;
        }
        var root2 = { i0: 0, i1: nimg.length, bst: null, est: null, tdst: 0, left: null, right: null };
        root2.bst = UPNG3.quantize.stats(nimg, root2.i0, root2.i1);
        root2.est = UPNG3.quantize.estats(root2.bst);
        var leafs = [root2];
        while (leafs.length < ps) {
          var maxL = 0, mi2 = 0;
          for (var i2 = 0; i2 < leafs.length; i2++)
            if (leafs[i2].est.L > maxL) {
              maxL = leafs[i2].est.L;
              mi2 = i2;
            }
          if (maxL < 1e-3)
            break;
          var node2 = leafs[mi2];
          var s0 = UPNG3.quantize.splitPixels(nimg, nimg32, node2.i0, node2.i1, node2.est.e, node2.est.eMq255);
          var ln = { i0: node2.i0, i1: s0, bst: null, est: null, tdst: 0, left: null, right: null };
          ln.bst = UPNG3.quantize.stats(nimg, ln.i0, ln.i1);
          ln.est = UPNG3.quantize.estats(ln.bst);
          var rn2 = { i0: s0, i1: node2.i1, bst: null, est: null, tdst: 0, left: null, right: null };
          rn2.bst = { R: [], m: [], N: node2.bst.N - ln.bst.N };
          for (var i2 = 0; i2 < 16; i2++)
            rn2.bst.R[i2] = node2.bst.R[i2] - ln.bst.R[i2];
          for (var i2 = 0; i2 < 4; i2++)
            rn2.bst.m[i2] = node2.bst.m[i2] - ln.bst.m[i2];
          rn2.est = UPNG3.quantize.estats(rn2.bst);
          node2.left = ln;
          node2.right = rn2;
          leafs[mi2] = ln;
          leafs.push(rn2);
        }
        leafs.sort(function(a3, b3) {
          return b3.bst.N - a3.bst.N;
        });
        for (var ii2 = 0; ii2 < imgs.length; ii2++) {
          var planeDst = UPNG3.quantize.planeDst;
          var sb2 = new Uint8Array(imgs[ii2].buffer), tb2 = new Uint32Array(imgs[ii2].buffer), len = sb2.length;
          for (var i2 = 0; i2 < len; i2 += 4) {
            var r2 = sb2[i2] * (1 / 255), g2 = sb2[i2 + 1] * (1 / 255), b2 = sb2[i2 + 2] * (1 / 255), a2 = sb2[i2 + 3] * (1 / 255);
            var nd2 = root2;
            while (nd2.left)
              nd2 = planeDst(nd2.est, r2, g2, b2, a2) <= 0 ? nd2.left : nd2.right;
            tb2[i2 >> 2] = nd2.est.rgba;
          }
          imgs[ii2] = tb2.buffer;
        }
        return { bufs: imgs, plte: leafs };
      };
      UPNG3.quantize.getNearest = function(nd2, r2, g2, b2, a2) {
        if (nd2.left == null) {
          nd2.tdst = UPNG3.quantize.dist(nd2.est.q, r2, g2, b2, a2);
          return nd2;
        }
        var planeDst = UPNG3.quantize.planeDst(nd2.est, r2, g2, b2, a2);
        var node0 = nd2.left, node1 = nd2.right;
        if (planeDst > 0) {
          node0 = nd2.right;
          node1 = nd2.left;
        }
        var ln = UPNG3.quantize.getNearest(node0, r2, g2, b2, a2);
        if (ln.tdst <= planeDst * planeDst)
          return ln;
        var rn2 = UPNG3.quantize.getNearest(node1, r2, g2, b2, a2);
        return rn2.tdst < ln.tdst ? rn2 : ln;
      };
      UPNG3.quantize.planeDst = function(est, r2, g2, b2, a2) {
        var e2 = est.e;
        return e2[0] * r2 + e2[1] * g2 + e2[2] * b2 + e2[3] * a2 - est.eMq;
      };
      UPNG3.quantize.dist = function(q2, r2, g2, b2, a2) {
        var d0 = r2 - q2[0], d1 = g2 - q2[1], d2 = b2 - q2[2], d3 = a2 - q2[3];
        return d0 * d0 + d1 * d1 + d2 * d2 + d3 * d3;
      };
      UPNG3.quantize.splitPixels = function(nimg, nimg32, i0, i1, e2, eMq) {
        var vecDot = UPNG3.quantize.vecDot;
        i1 -= 4;
        while (i0 < i1) {
          while (vecDot(nimg, i0, e2) <= eMq)
            i0 += 4;
          while (vecDot(nimg, i1, e2) > eMq)
            i1 -= 4;
          if (i0 >= i1)
            break;
          var t2 = nimg32[i0 >> 2];
          nimg32[i0 >> 2] = nimg32[i1 >> 2];
          nimg32[i1 >> 2] = t2;
          i0 += 4;
          i1 -= 4;
        }
        while (vecDot(nimg, i0, e2) > eMq)
          i0 -= 4;
        return i0 + 4;
      };
      UPNG3.quantize.vecDot = function(nimg, i2, e2) {
        return nimg[i2] * e2[0] + nimg[i2 + 1] * e2[1] + nimg[i2 + 2] * e2[2] + nimg[i2 + 3] * e2[3];
      };
      UPNG3.quantize.stats = function(nimg, i0, i1) {
        var R2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        var m2 = [0, 0, 0, 0];
        var N2 = i1 - i0 >> 2;
        for (var i2 = i0; i2 < i1; i2 += 4) {
          var r2 = nimg[i2] * (1 / 255), g2 = nimg[i2 + 1] * (1 / 255), b2 = nimg[i2 + 2] * (1 / 255), a2 = nimg[i2 + 3] * (1 / 255);
          m2[0] += r2;
          m2[1] += g2;
          m2[2] += b2;
          m2[3] += a2;
          R2[0] += r2 * r2;
          R2[1] += r2 * g2;
          R2[2] += r2 * b2;
          R2[3] += r2 * a2;
          R2[5] += g2 * g2;
          R2[6] += g2 * b2;
          R2[7] += g2 * a2;
          R2[10] += b2 * b2;
          R2[11] += b2 * a2;
          R2[15] += a2 * a2;
        }
        R2[4] = R2[1];
        R2[8] = R2[2];
        R2[12] = R2[3];
        R2[9] = R2[6];
        R2[13] = R2[7];
        R2[14] = R2[11];
        return { R: R2, m: m2, N: N2 };
      };
      UPNG3.quantize.estats = function(stats) {
        var R2 = stats.R, m2 = stats.m, N2 = stats.N;
        var m0 = m2[0], m1 = m2[1], m22 = m2[2], m3 = m2[3], iN = N2 == 0 ? 0 : 1 / N2;
        var Rj2 = [
          R2[0] - m0 * m0 * iN,
          R2[1] - m0 * m1 * iN,
          R2[2] - m0 * m22 * iN,
          R2[3] - m0 * m3 * iN,
          R2[4] - m1 * m0 * iN,
          R2[5] - m1 * m1 * iN,
          R2[6] - m1 * m22 * iN,
          R2[7] - m1 * m3 * iN,
          R2[8] - m22 * m0 * iN,
          R2[9] - m22 * m1 * iN,
          R2[10] - m22 * m22 * iN,
          R2[11] - m22 * m3 * iN,
          R2[12] - m3 * m0 * iN,
          R2[13] - m3 * m1 * iN,
          R2[14] - m3 * m22 * iN,
          R2[15] - m3 * m3 * iN
        ];
        var A2 = Rj2, M2 = UPNG3.M4;
        var b2 = [0.5, 0.5, 0.5, 0.5], mi2 = 0, tmi = 0;
        if (N2 != 0)
          for (var i2 = 0; i2 < 10; i2++) {
            b2 = M2.multVec(A2, b2);
            tmi = Math.sqrt(M2.dot(b2, b2));
            b2 = M2.sml(1 / tmi, b2);
            if (Math.abs(tmi - mi2) < 1e-9)
              break;
            mi2 = tmi;
          }
        var q2 = [m0 * iN, m1 * iN, m22 * iN, m3 * iN];
        var eMq255 = M2.dot(M2.sml(255, q2), b2);
        var ia2 = q2[3] < 1e-3 ? 0 : 1 / q2[3];
        return {
          Cov: Rj2,
          q: q2,
          e: b2,
          L: mi2,
          eMq255,
          eMq: M2.dot(b2, q2),
          rgba: (Math.round(255 * q2[3]) << 24 | Math.round(255 * q2[2] * ia2) << 16 | Math.round(255 * q2[1] * ia2) << 8 | Math.round(255 * q2[0] * ia2) << 0) >>> 0
        };
      };
      UPNG3.M4 = {
        multVec: function(m2, v2) {
          return [
            m2[0] * v2[0] + m2[1] * v2[1] + m2[2] * v2[2] + m2[3] * v2[3],
            m2[4] * v2[0] + m2[5] * v2[1] + m2[6] * v2[2] + m2[7] * v2[3],
            m2[8] * v2[0] + m2[9] * v2[1] + m2[10] * v2[2] + m2[11] * v2[3],
            m2[12] * v2[0] + m2[13] * v2[1] + m2[14] * v2[2] + m2[15] * v2[3]
          ];
        },
        dot: function(x, y2) {
          return x[0] * y2[0] + x[1] * y2[1] + x[2] * y2[2] + x[3] * y2[3];
        },
        sml: function(a2, y2) {
          return [a2 * y2[0], a2 * y2[1], a2 * y2[2], a2 * y2[3]];
        }
      };
      UPNG3.encode.alphaMul = function(img, roundA) {
        var nimg = new Uint8Array(img.length), area2 = img.length >> 2;
        for (var i2 = 0; i2 < area2; i2++) {
          var qi2 = i2 << 2, ia2 = img[qi2 + 3];
          if (roundA)
            ia2 = ia2 < 128 ? 0 : 255;
          var a2 = ia2 * (1 / 255);
          nimg[qi2 + 0] = img[qi2 + 0] * a2;
          nimg[qi2 + 1] = img[qi2 + 1] * a2;
          nimg[qi2 + 2] = img[qi2 + 2] * a2;
          nimg[qi2 + 3] = ia2;
        }
        return nimg;
      };
    })(UPNG2, pako);
  })();
})(UPNG$1);
var UPNGExports = UPNG$1.exports;
const UPNG = /* @__PURE__ */ getDefaultExportFromCjs(UPNGExports);
/*!
 * @tbminiapp/pixi-apng-textures - v6.2.1-beta.9
 * Compiled Thu, 17 Mar 2022 08:24:35 UTC
 *
 * @tbminiapp/pixi-apng-textures is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p in b3) {
      if (Object.prototype.hasOwnProperty.call(b3, p)) {
        d3[p] = b3[p];
      }
    }
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null) {
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  }
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var APNGTextureResource = (
  /** @class */
  function(_super) {
    __extends(APNGTextureResource2, _super);
    function APNGTextureResource2(source, options) {
      if (options === void 0) {
        options = { width: 1, height: 1, delay: 16 };
      }
      var _this = this;
      var origin;
      var data2;
      if (typeof source === "string") {
        origin = source;
        data2 = new Uint8Array();
      } else {
        origin = null;
        data2 = source;
      }
      _this = _super.call(this, data2, options) || this;
      _this.loaded = true;
      var delay = options.delay;
      _this._delay = delay || 0;
      _this.origin = origin;
      _this.buffer = data2.buffer ? new ViewableBuffer(data2.buffer) : null;
      return _this;
    }
    Object.defineProperty(APNGTextureResource2.prototype, "delay", {
      get: function() {
        return this._delay;
      },
      enumerable: false,
      configurable: true
    });
    return APNGTextureResource2;
  }(BufferResource)
);
function registerAPNGTextures(url2, resources2, metadata) {
  var result = {
    textures: {},
    texture: null,
    frameCount: 0,
    frameTextureKeys: [],
    frameDelay: []
  };
  if (!resources2) {
    return result;
  }
  var textures = resources2.map(function(resource) {
    return new Texture(new BaseTexture(resource, Object.assign({
      mipmap: MIPMAP_MODES$4.OFF,
      alphaMode: ALPHA_MODES$4.NO_PREMULTIPLIED_ALPHA
    }, metadata)));
  });
  textures.forEach(function(texture, i2) {
    var baseTexture = texture.baseTexture;
    var cacheID = url2 + "-" + (i2 + 1);
    BaseTexture.addToCache(baseTexture, cacheID);
    Texture.addToCache(texture, cacheID);
    if (i2 === 0) {
      BaseTexture.addToCache(baseTexture, url2);
      Texture.addToCache(texture, url2);
      result.texture = texture;
    }
    result.frameTextureKeys.push(cacheID);
    result.frameDelay.push(baseTexture.resource.delay);
    result.textures[cacheID] = texture;
  });
  PIXI.utils.TextureCache.abcd = "efg";
  result.frameCount = textures.length;
  return result;
}
LoaderResource.setExtensionXhrType("apng", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
var FILE_IDENTIFIER = [97, 99, 84, 76];
var APNGLoader = (
  /** @class */
  function() {
    function APNGLoader2() {
    }
    APNGLoader2.use = async function(resource, next2) {
      if (resource.extension === "png" && resource.data) {
        try {
          var url2 = resource.url;
          var name = resource.name || url2;
          async function fetchFileAsArrayBuffer2(url3) {
            const response = await fetch(url3);
            if (!response.ok) {
              throw new Error(`Failed to fetch file: ${response.status} ${response.statusText}`);
            }
            const arrayBuffer = await response.arrayBuffer();
            const buffer = new Uint8Array(arrayBuffer);
            if (APNGLoader2.validate(url3, buffer)) {
              Object.assign(resource, registerAPNGTextures(name, APNGLoader2.parse(name, buffer), resource.metadata));
            } else {
              next2();
              return;
            }
          }
          await fetchFileAsArrayBuffer2(url2);
        } catch (err) {
          next2(err);
          return;
        }
      }
      next2();
    };
    APNGLoader2.parse = function(url2, buffer) {
      var upngObj = UPNG.decode(buffer);
      var width = upngObj.width, height = upngObj.height, frames = upngObj.frames;
      var rgba2 = UPNG.toRGBA8(upngObj);
      var framesImageData = [];
      rgba2.forEach(function(item, index2) {
        var frameData = frames[index2];
        var delay = frameData.delay;
        framesImageData.push({ data: new Uint8Array(item), delay });
      });
      var returnArray = framesImageData.map(function(item) {
        return new APNGTextureResource(item.data, {
          width,
          height,
          framesCount: framesImageData.length,
          delay: item.delay
        });
      });
      return returnArray;
    };
    APNGLoader2.validate = function(url2, buffer) {
      const actLBuffer = buffer.slice(37, 41);
      for (var i2 = 0; i2 < FILE_IDENTIFIER.length; i2++) {
        if (actLBuffer[i2] !== FILE_IDENTIFIER[i2]) {
          return false;
        }
      }
      return true;
    };
    return APNGLoader2;
  }()
);
const SCREEN_CONSTANTS = {
  height: 1440,
  width: 2560
};
window.PIXI = PIXI$1;
Loader.registerPlugin(APNGLoader);
class PixiStage {
  constructor() {
    /**
     *  PIXI App
     */
    __publicField(this, "currentApp", null);
    __publicField(this, "effectsContainer");
    __publicField(this, "frameDuration", 16.67);
    __publicField(this, "notUpdateBacklogEffects", false);
    __publicField(this, "figureContainer");
    __publicField(this, "figureObjects", []);
    __publicField(this, "backgroundContainer");
    __publicField(this, "backgroundObjects", []);
    //  Ticker 
    __publicField(this, "stageAnimations", []);
    __publicField(this, "assetLoader", new Loader());
    __publicField(this, "loadQueue", []);
    __publicField(this, "live2dFigureRecorder", []);
    // 
    __publicField(this, "lockTransformTarget", []);
    __publicField(this, "stageWidth", SCREEN_CONSTANTS.width);
    __publicField(this, "stageHeight", SCREEN_CONSTANTS.height);
    /**
     * 
     * @private
     */
    __publicField(this, "MAX_TEX_COUNT", 10);
    const app = new Application({
      backgroundAlpha: 0,
      preserveDrawingBuffer: true
    });
    window.PIXIapp = this;
    window.__PIXI_APP__ = app;
    const pixiContainer2 = document.getElementById("pixiContianer");
    if (pixiContainer2) {
      pixiContainer2.innerHTML = "";
      pixiContainer2.appendChild(app.view);
    }
    app.renderer.view.style.position = "absolute";
    app.renderer.view.style.display = "block";
    app.renderer.view.id = "pixiCanvas";
    app.renderer.autoResize = true;
    const appRoot = document.getElementById("root");
    if (appRoot) {
      app.renderer.resize(appRoot.clientWidth, appRoot.clientHeight);
    }
    if (isIOS) {
      app.renderer.view.style.zIndex = "-5";
    }
    app.stage.sortableChildren = true;
    this.effectsContainer = new Container$1();
    this.effectsContainer.zIndex = 3;
    this.figureContainer = new Container$1();
    this.figureContainer.zIndex = 2;
    this.backgroundContainer = new Container$1();
    this.backgroundContainer.zIndex = 0;
    app.stage.addChild(this.effectsContainer, this.figureContainer, this.backgroundContainer);
    this.currentApp = app;
    const update = () => {
      this.updateFps();
      setTimeout(update, 1e4);
    };
    update();
    const reload = () => {
      setTimeout(reload, 500);
      this.callLoader();
    };
    reload();
  }
  getFigureObjects() {
    return this.figureObjects;
  }
  getAllLockedObject() {
    return this.lockTransformTarget;
  }
  /**
   * 
   * @param animationObject
   * @param key
   * @param target
   */
  registerAnimation(animationObject, key, target = "default") {
    var _a2;
    if (!animationObject)
      return;
    this.stageAnimations.push({ uuid: v4(), animationObject, key, targetKey: target, type: "common" });
    this.lockStageObject(target);
    animationObject.setStartState();
    (_a2 = this.currentApp) == null ? void 0 : _a2.ticker.add(animationObject.tickerFunc);
  }
  /**
   * 
   * @param animationObject
   * @param key
   * @param target
   * @param currentEffects
   */
  // eslint-disable-next-line max-params
  registerPresetAnimation(animationObject, key, target = "default", currentEffects) {
    var _a2;
    if (!animationObject)
      return;
    const effect = currentEffects.find((effect2) => effect2.target === target);
    if (effect) {
      const targetPixiContainer = this.getStageObjByKey(target);
      if (targetPixiContainer) {
        const container2 = targetPixiContainer.pixiContainer;
        Object.assign(container2, effect.transform);
      }
      return;
    }
    this.stageAnimations.push({ uuid: v4(), animationObject, key, targetKey: target, type: "preset" });
    this.lockStageObject(target);
    animationObject.setStartState();
    (_a2 = this.currentApp) == null ? void 0 : _a2.ticker.add(animationObject.tickerFunc);
  }
  stopPresetAnimationOnTarget(target) {
    const targetPresetAnimations = this.stageAnimations.find((e2) => e2.targetKey === target && e2.type === "preset");
    if (targetPresetAnimations) {
      this.removeAnimation(targetPresetAnimations.key);
    }
  }
  /**
   * 
   * @param key
   */
  removeAnimation(key) {
    var _a2;
    const index2 = this.stageAnimations.findIndex((e2) => e2.key === key);
    if (index2 >= 0) {
      const thisTickerFunc = this.stageAnimations[index2];
      (_a2 = this.currentApp) == null ? void 0 : _a2.ticker.remove(thisTickerFunc.animationObject.tickerFunc);
      thisTickerFunc.animationObject.setEndState();
      this.unlockStageObject(thisTickerFunc.targetKey ?? "default");
      this.stageAnimations.splice(index2, 1);
    }
  }
  removeAnimationWithSetEffects(key) {
    var _a2, _b2, _c2;
    const index2 = this.stageAnimations.findIndex((e2) => e2.key === key);
    if (index2 >= 0) {
      const thisTickerFunc = this.stageAnimations[index2];
      (_a2 = this.currentApp) == null ? void 0 : _a2.ticker.remove(thisTickerFunc.animationObject.tickerFunc);
      thisTickerFunc.animationObject.setEndState();
      const webgalFilters = ((_c2 = (_b2 = thisTickerFunc.animationObject).getEndFilterEffect) == null ? void 0 : _c2.call(_b2)) ?? {};
      this.unlockStageObject(thisTickerFunc.targetKey ?? "default");
      if (thisTickerFunc.targetKey) {
        const target = this.getStageObjByKey(thisTickerFunc.targetKey);
        if (target) {
          const targetTransform = {
            alpha: target.pixiContainer.alpha,
            scale: {
              x: target.pixiContainer.scale.x,
              y: target.pixiContainer.scale.y
            },
            // pivot: {
            //   x: target.pixiContainer.pivot.x,
            //   y: target.pixiContainer.pivot.y,
            // },
            position: {
              x: target.pixiContainer.x,
              y: target.pixiContainer.y
            },
            rotation: target.pixiContainer.rotation,
            // @ts-ignore
            blur: target.pixiContainer.blur,
            ...webgalFilters
          };
          let effect = {
            target: thisTickerFunc.targetKey,
            transform: targetTransform
          };
          webgalStore.dispatch(stageActions.updateEffect(effect));
        }
      }
      this.stageAnimations.splice(index2, 1);
    }
  }
  // eslint-disable-next-line max-params
  performMouthSyncAnimation(key, targetAnimation, mouthState, presetPosition) {
    var _a2;
    const currentFigure = (_a2 = this.getStageObjByKey(key)) == null ? void 0 : _a2.pixiContainer;
    if (!currentFigure) {
      return;
    }
    const mouthTextureUrls = {
      open: targetAnimation.mouthAnimation.open,
      half_open: targetAnimation.mouthAnimation.halfOpen,
      closed: targetAnimation.mouthAnimation.close
    };
    this.loadAsset(mouthTextureUrls[mouthState], () => {
      const texture = this.assetLoader.resources[mouthTextureUrls[mouthState]].texture;
      if (!texture) {
        return;
      }
      const originalWidth = texture.width;
      const originalHeight = texture.height;
      const scaleX = this.stageWidth / originalWidth;
      const scaleY = this.stageHeight / originalHeight;
      const targetScale = Math.min(scaleX, scaleY);
      const figureSprite = new Sprite(texture);
      figureSprite.scale.x = targetScale;
      figureSprite.scale.y = targetScale;
      figureSprite.anchor.set(0.5);
      figureSprite.position.y = this.stageHeight / 2;
      const targetWidth = originalWidth * targetScale;
      const targetHeight = originalHeight * targetScale;
      currentFigure.setBaseY(this.stageHeight / 2);
      if (targetHeight < this.stageHeight) {
        currentFigure.setBaseY(this.stageHeight / 2 + this.stageHeight - targetHeight / 2);
      }
      if (presetPosition === "center") {
        currentFigure.setBaseX(this.stageWidth / 2);
      }
      if (presetPosition === "left") {
        currentFigure.setBaseX(targetWidth / 2);
      }
      if (presetPosition === "right") {
        currentFigure.setBaseX(this.stageWidth - targetWidth / 2);
      }
      currentFigure.pivot.set(0, this.stageHeight / 2);
      currentFigure.addChild(figureSprite);
    });
  }
  // eslint-disable-next-line max-params
  performBlinkAnimation(key, targetAnimation, blinkState, presetPosition) {
    var _a2;
    const currentFigure = (_a2 = this.getStageObjByKey(key)) == null ? void 0 : _a2.pixiContainer;
    if (!currentFigure) {
      return;
    }
    const blinkTextureUrls = {
      open: targetAnimation.blinkAnimation.open,
      closed: targetAnimation.blinkAnimation.close
    };
    this.loadAsset(blinkTextureUrls[blinkState], () => {
      const texture = this.assetLoader.resources[blinkTextureUrls[blinkState]].texture;
      if (!texture) {
        return;
      }
      const originalWidth = texture.width;
      const originalHeight = texture.height;
      const scaleX = this.stageWidth / originalWidth;
      const scaleY = this.stageHeight / originalHeight;
      const targetScale = Math.min(scaleX, scaleY);
      const figureSprite = new Sprite(texture);
      figureSprite.scale.x = targetScale;
      figureSprite.scale.y = targetScale;
      figureSprite.anchor.set(0.5);
      figureSprite.position.y = this.stageHeight / 2;
      const targetWidth = originalWidth * targetScale;
      const targetHeight = originalHeight * targetScale;
      currentFigure.setBaseY(this.stageHeight / 2);
      if (targetHeight < this.stageHeight) {
        currentFigure.setBaseY(this.stageHeight / 2 + this.stageHeight - targetHeight / 2);
      }
      if (presetPosition === "center") {
        currentFigure.setBaseX(this.stageWidth / 2);
      }
      if (presetPosition === "left") {
        currentFigure.setBaseX(targetWidth / 2);
      }
      if (presetPosition === "right") {
        currentFigure.setBaseX(this.stageWidth - targetWidth / 2);
      }
      currentFigure.pivot.set(0, this.stageHeight / 2);
      currentFigure.addChild(figureSprite);
    });
  }
  /**
   * 
   * @param key 
   * @param url url
   */
  addBg(key, url2) {
    var _a2, _b2;
    const loader = this.assetLoader;
    const thisBgContainer = new WebGALPixiContainer();
    const setBgIndex = this.backgroundObjects.findIndex((e2) => e2.key === key);
    const isBgSet = setBgIndex >= 0;
    if (isBgSet) {
      this.removeStageObjectByKey(key);
    }
    this.backgroundContainer.addChild(thisBgContainer);
    const bgUuid = v4();
    this.backgroundObjects.push({
      uuid: bgUuid,
      key,
      pixiContainer: thisBgContainer,
      sourceUrl: url2,
      sourceType: "img",
      sourceExt: this.getExtName(url2)
    });
    const setup = () => {
      setTimeout(() => {
        var _a3, _b3;
        const texture = (_b3 = (_a3 = loader.resources) == null ? void 0 : _a3[url2]) == null ? void 0 : _b3.texture;
        if (texture && this.getStageObjByUuid(bgUuid)) {
          const originalWidth = texture.width;
          const originalHeight = texture.height;
          const scaleX = this.stageWidth / originalWidth;
          const scaleY = this.stageHeight / originalHeight;
          const targetScale = Math.max(scaleX, scaleY);
          const bgSprite = new Sprite(texture);
          bgSprite.scale.x = targetScale;
          bgSprite.scale.y = targetScale;
          bgSprite.anchor.set(0.5);
          bgSprite.position.y = this.stageHeight / 2;
          thisBgContainer.setBaseX(this.stageWidth / 2);
          thisBgContainer.setBaseY(this.stageHeight / 2);
          thisBgContainer.pivot.set(0, this.stageHeight / 2);
          thisBgContainer.addChild(bgSprite);
        }
      }, 0);
    };
    this.cacheGC();
    if (!((_b2 = (_a2 = loader.resources) == null ? void 0 : _a2[url2]) == null ? void 0 : _b2.texture)) {
      this.loadAsset(url2, setup);
    } else {
      setup();
    }
  }
  /**
   * 
   * @param key 
   * @param url url
   * @param presetPosition
   * @param isApng
   */
  // eslint-disable-next-line max-params
  addFigure(key, url2, presetPosition = "center", isApng = false) {
    var _a2, _b2;
    const loader = this.assetLoader;
    const thisFigureContainer = new WebGALPixiContainer();
    const setFigIndex = this.figureObjects.findIndex((e2) => e2.key === key);
    const isFigSet = setFigIndex >= 0;
    if (isFigSet) {
      this.removeStageObjectByKey(key);
    }
    this.figureContainer.addChild(thisFigureContainer);
    const figureUuid = v4();
    this.figureObjects.push({
      uuid: figureUuid,
      key,
      pixiContainer: thisFigureContainer,
      sourceUrl: url2,
      sourceType: "img",
      sourceExt: this.getExtName(url2)
    });
    const setup = () => {
      setTimeout(() => {
        var _a3, _b3;
        const texture = (_b3 = (_a3 = loader.resources) == null ? void 0 : _a3[url2]) == null ? void 0 : _b3.texture;
        let delays = [];
        if (texture && this.getStageObjByUuid(figureUuid)) {
          const resource = loader.resources[url2];
          const explosionTextures = [];
          if (isApng) {
            const { frameDelay, textures, frameCount } = resource;
            delays = frameDelay;
            Object.values(textures || []).forEach((v2) => {
              explosionTextures.push(v2);
            });
          }
          const showAndPlay = (textures) => {
            const originalWidth = texture.width;
            const originalHeight = texture.height;
            const scaleX = this.stageWidth / originalWidth;
            const scaleY = this.stageHeight / originalHeight;
            const targetScale = Math.min(scaleX, scaleY);
            const figureSprite = isApng ? new AnimatedSprite(textures) : new Sprite(texture);
            figureSprite.scale.x = targetScale;
            figureSprite.scale.y = targetScale;
            figureSprite.anchor.set(0.5);
            figureSprite.position.y = this.stageHeight / 2;
            const targetWidth = originalWidth * targetScale;
            const targetHeight = originalHeight * targetScale;
            thisFigureContainer.setBaseY(this.stageHeight / 2);
            if (targetHeight < this.stageHeight) {
              thisFigureContainer.setBaseY(this.stageHeight / 2 + this.stageHeight - targetHeight / 2);
            }
            if (presetPosition === "center") {
              thisFigureContainer.setBaseX(this.stageWidth / 2);
            }
            if (presetPosition === "left") {
              thisFigureContainer.setBaseX(targetWidth / 2);
            }
            if (presetPosition === "right") {
              thisFigureContainer.setBaseX(this.stageWidth - targetWidth / 2);
            }
            if (isApng) {
              const sprite = figureSprite;
              let currentFrame = 0;
              let direction = 1;
              const updateFrame = () => {
                sprite.gotoAndStop(currentFrame);
                setTimeout(() => {
                  if (currentFrame === textures.length - 1) {
                    direction = -1;
                  }
                  if (currentFrame === 0) {
                    direction = 1;
                  }
                  currentFrame += direction;
                  updateFrame();
                }, delays[currentFrame]);
              };
              updateFrame();
            }
            thisFigureContainer.pivot.set(0, this.stageHeight / 2);
            thisFigureContainer.addChild(figureSprite);
          };
          showAndPlay(explosionTextures);
        }
      }, 32);
    };
    this.cacheGC();
    if (!((_b2 = (_a2 = loader.resources) == null ? void 0 : _a2[url2]) == null ? void 0 : _b2.texture)) {
      this.loadAsset(url2, setup, "", isApng);
    } else {
      setup();
    }
  }
  /**
   *  Spine 
   * @param key 
   * @param url url
   * @param presetPosition
   */
  addSpineFigure(key, url2, presetPosition = "center") {
    var _a2;
    const spineId = `spine-${url2}`;
    const loader = this.assetLoader;
    const thisFigureContainer = new WebGALPixiContainer();
    const setFigIndex = this.figureObjects.findIndex((e2) => e2.key === key);
    const isFigSet = setFigIndex >= 0;
    if (isFigSet) {
      this.removeStageObjectByKey(key);
    }
    this.figureContainer.addChild(thisFigureContainer);
    const figureUuid = v4();
    this.figureObjects.push({
      uuid: figureUuid,
      key,
      pixiContainer: thisFigureContainer,
      sourceUrl: url2,
      sourceType: "live2d",
      sourceExt: this.getExtName(url2)
    });
    const setup = () => {
      var _a3;
      console.log(this.assetLoader.resources);
      const spineResource = (_a3 = this.assetLoader.resources) == null ? void 0 : _a3[spineId];
      setTimeout(() => {
        var _a4;
        if (spineResource && this.getStageObjByUuid(figureUuid)) {
          const figureSpine = new Spine(spineResource.spineData);
          const transY = ((_a4 = spineResource == null ? void 0 : spineResource.spineData) == null ? void 0 : _a4.y) ?? 0;
          console.log(figureSpine);
          const originalWidth = figureSpine.width;
          const originalHeight = figureSpine.height;
          const scaleX = this.stageWidth / originalWidth;
          const scaleY = this.stageHeight / originalHeight;
          figureSpine.y = -(scaleY * transY) / 2;
          console.log(figureSpine.state);
          figureSpine.state.setAnimation(0, "07", true);
          const targetScale = Math.min(scaleX, scaleY);
          const figureSprite = new Sprite();
          figureSprite.addChild(figureSpine);
          figureSprite.scale.x = targetScale;
          figureSprite.scale.y = targetScale;
          figureSprite.anchor.set(0.5);
          figureSprite.position.y = this.stageHeight / 2;
          const targetWidth = originalWidth * targetScale;
          const targetHeight = originalHeight * targetScale;
          thisFigureContainer.setBaseY(this.stageHeight / 2);
          if (targetHeight < this.stageHeight) {
            thisFigureContainer.setBaseY(this.stageHeight / 2 + this.stageHeight - targetHeight / 2);
          }
          if (presetPosition === "center") {
            thisFigureContainer.setBaseX(this.stageWidth / 2);
          }
          if (presetPosition === "left") {
            thisFigureContainer.setBaseX(targetWidth / 2);
          }
          if (presetPosition === "right") {
            thisFigureContainer.setBaseX(this.stageWidth - targetWidth / 2);
          }
          thisFigureContainer.pivot.set(0, this.stageHeight / 2);
          thisFigureContainer.addChild(figureSprite);
        }
      }, 0);
    };
    this.cacheGC();
    if (!((_a2 = loader.resources) == null ? void 0 : _a2[url2])) {
      this.loadAsset(url2, setup, spineId);
    } else {
      setup();
    }
  }
  /**
   * Live2d Live2D
   * @param jsonPath
   */
  // eslint-disable-next-line max-params
  // public addLive2dFigure(key: string, jsonPath: string, pos: string, motion: string, expression: string) {
  //   let stageWidth = this.stageWidth;
  //   let stageHeight = this.stageHeight;
  //   logger.debug('Using motion:', motion);
  //
  //   figureCash.push(jsonPath);
  //
  //   const loader = this.assetLoader;
  //   //  Container
  //   const thisFigureContainer = new WebGALPixiContainer();
  //
  //   //  key 
  //   const setFigIndex = this.figureObjects.findIndex((e) => e.key === key);
  //   const isFigSet = setFigIndex >= 0;
  //
  //   //  key 
  //   if (isFigSet) {
  //     this.removeStageObjectByKey(key);
  //   }
  //
  //   // 
  //   this.figureContainer.addChild(thisFigureContainer);
  //   this.figureObjects.push({
  //     uuid: uuid(),
  //     key: key,
  //     pixiContainer: thisFigureContainer,
  //     sourceUrl: jsonPath,
  //   });
  //   // eslint-disable-next-line @typescript-eslint/no-this-alias
  //   const instance = this;
  //
  //   const setup = () => {
  //     if (thisFigureContainer) {
  //       (async function () {
  //         const models = await Promise.all([Live2DModel.from(jsonPath, { autoInteract: false })]);
  //
  //         models.forEach((model) => {
  //           const scaleX = stageWidth / model.width;
  //           const scaleY = stageHeight / model.height;
  //           const targetScale = Math.min(scaleX, scaleY) * 1.5;
  //           const targetWidth = model.width * targetScale;
  //           // const targetHeight = model.height * targetScale;
  //
  //           model.scale.set(targetScale);
  //           model.anchor.set(0.5);
  //           model.position.x = stageWidth / 2;
  //           model.position.y = stageHeight / 1.2;
  //
  //           if (pos === 'left') {
  //             model.position.x = targetWidth / 2;
  //           }
  //           if (pos === 'right') {
  //             model.position.x = stageWidth - targetWidth / 2;
  //           }
  //
  //           let motionToSet = motion;
  //           let animation_index = 0;
  //           let priority_number = 3;
  //           // var audio_link = voiceCash.pop();
  //
  //           // model.motion(category_name, animation_index, priority_number,location.href + audio_link);
  //           /**
  //            *  Motion  Expression
  //            */
  //           const motionFromState = webgalStore.getState().stage.live2dMotion.find((e) => e.target === key);
  //           const expressionFromState = webgalStore.getState().stage.live2dExpression.find((e) => e.target === key);
  //           if (motionFromState) {
  //             motionToSet = motionFromState.motion;
  //           }
  //           instance.updateL2dMotionByKey(key, motionToSet);
  //           model.motion(motionToSet, animation_index, priority_number);
  //           let expressionToSet = expression;
  //           if (expressionFromState) {
  //             expressionToSet = expressionFromState.expression;
  //           }
  //           instance.updateL2dExpressionByKey(key, expressionToSet);
  //           model.expression(expressionToSet);
  //
  //           // lip-sync is still a problem and you can not.
  //           SoundManager.volume = 0;
  //           thisFigureContainer.addChild(model);
  //         });
  //       })();
  //     }
  //   };
  //
  //   /**
  //    * 
  //    */
  //   const resourses = Object.keys(loader.resources);
  //   this.cacheGC();
  //   if (!resourses.includes(jsonPath)) {
  //     this.loadAsset(jsonPath, setup);
  //   } else {
  //     // 
  //     setup();
  //   }
  // }
  changeModelMotionByKey(key, motion) {
    var _a2, _b2;
    const target = this.figureObjects.find((e2) => e2.key === key);
    if ((target == null ? void 0 : target.sourceType) !== "live2d")
      return;
    const figureRecordTarget = this.live2dFigureRecorder.find((e2) => e2.target === key);
    if (target && (figureRecordTarget == null ? void 0 : figureRecordTarget.motion) !== motion) {
      const container2 = target.pixiContainer;
      const children = container2.children;
      for (const model of children) {
        let category_name = motion;
        let animation_index = 0;
        let priority_number = 3;
        const internalModel = (model == null ? void 0 : model.internalModel) ?? void 0;
        (_b2 = (_a2 = internalModel == null ? void 0 : internalModel.motionManager) == null ? void 0 : _a2.stopAllMotions) == null ? void 0 : _b2.call(_a2);
        model.motion(category_name, animation_index, priority_number);
      }
      this.updateL2dMotionByKey(key, motion);
    }
  }
  changeModelExpressionByKey(key, expression) {
    const target = this.figureObjects.find((e2) => e2.key === key);
    if ((target == null ? void 0 : target.sourceType) !== "live2d")
      return;
    const figureRecordTarget = this.live2dFigureRecorder.find((e2) => e2.target === key);
    if (target && (figureRecordTarget == null ? void 0 : figureRecordTarget.expression) !== expression) {
      const container2 = target.pixiContainer;
      const children = container2.children;
      for (const model of children) {
        model.expression(expression);
      }
      this.updateL2dExpressionByKey(key, expression);
    }
  }
  setModelMouthY(key, y2) {
    var _a2, _b2, _c2, _d, _e, _f, _g, _h, _i;
    function mapToZeroOne(value) {
      return value < 50 ? 0 : (value - 50) / 50;
    }
    const paramY = mapToZeroOne(y2);
    const target = this.figureObjects.find((e2) => e2.key === key);
    if (target) {
      const container2 = target.pixiContainer;
      const children = container2.children;
      for (const model of children) {
        if (model == null ? void 0 : model.internalModel) {
          if ((_b2 = (_a2 = model == null ? void 0 : model.internalModel) == null ? void 0 : _a2.coreModel) == null ? void 0 : _b2.setParamFloat)
            (_e = (_d = (_c2 = model == null ? void 0 : model.internalModel) == null ? void 0 : _c2.coreModel) == null ? void 0 : _d.setParamFloat) == null ? void 0 : _e.call(_d, "PARAM_MOUTH_OPEN_Y", paramY);
          if ((_g = (_f = model == null ? void 0 : model.internalModel) == null ? void 0 : _f.coreModel) == null ? void 0 : _g.setParameterValueById)
            (_i = (_h = model == null ? void 0 : model.internalModel) == null ? void 0 : _h.coreModel) == null ? void 0 : _i.setParameterValueById("ParamMouthOpenY", paramY);
        }
      }
    }
  }
  /**
   *  key 
   * @param key
   */
  getStageObjByKey(key) {
    return [...this.figureObjects, ...this.backgroundObjects].find((e2) => e2.key === key);
  }
  getStageObjByUuid(objUuid) {
    return [...this.figureObjects, ...this.backgroundObjects].find((e2) => e2.uuid === objUuid);
  }
  getAllStageObj() {
    return [...this.figureObjects, ...this.backgroundObjects];
  }
  /**
   *  key 
   * @param key
   */
  removeStageObjectByKey(key) {
    const indexFig = this.figureObjects.findIndex((e2) => e2.key === key);
    const indexBg = this.backgroundObjects.findIndex((e2) => e2.key === key);
    if (indexFig >= 0) {
      const bgSprite = this.figureObjects[indexFig];
      for (const element of bgSprite.pixiContainer.children) {
        element.destroy();
      }
      bgSprite.pixiContainer.destroy();
      this.figureContainer.removeChild(bgSprite.pixiContainer);
      this.figureObjects.splice(indexFig, 1);
    }
    if (indexBg >= 0) {
      const bgSprite = this.backgroundObjects[indexBg];
      for (const element of bgSprite.pixiContainer.children) {
        element.destroy();
      }
      bgSprite.pixiContainer.destroy();
      this.backgroundContainer.removeChild(bgSprite.pixiContainer);
      this.backgroundObjects.splice(indexBg, 1);
    }
  }
  cacheGC() {
    clearTextureCache();
  }
  updateL2dMotionByKey(target, motion) {
    const figureTargetIndex = this.live2dFigureRecorder.findIndex((e2) => e2.target === target);
    if (figureTargetIndex >= 0) {
      this.live2dFigureRecorder[figureTargetIndex].motion = motion;
    } else {
      this.live2dFigureRecorder.push({ target, motion, expression: "" });
    }
  }
  updateL2dExpressionByKey(target, expression) {
    const figureTargetIndex = this.live2dFigureRecorder.findIndex((e2) => e2.target === target);
    if (figureTargetIndex >= 0) {
      this.live2dFigureRecorder[figureTargetIndex].expression = expression;
    } else {
      this.live2dFigureRecorder.push({ target, motion: "", expression });
    }
  }
  // eslint-disable-next-line max-params
  loadAsset(url2, callback, name, isApng) {
    this.loadQueue.unshift({ url: url2, callback, name, extraInfo: { isApng: isApng ?? false } });
    this.callLoader();
  }
  callLoader() {
    if (!this.assetLoader.loading) {
      const front = this.loadQueue.shift();
      if (front) {
        try {
          if (this.assetLoader.resources[front.url]) {
            front.callback();
            this.callLoader();
          } else {
            if (front.name) {
              this.assetLoader.add(front.name, front.url).load(() => {
                front.callback();
                this.callLoader();
              });
            } else {
              this.assetLoader.add(front.url).load(() => {
                front.callback();
                this.callLoader();
              });
            }
          }
        } catch (error2) {
          logger.fatal("PIXI Loader ", error2);
          front.callback();
          this.callLoader();
        }
      }
    }
  }
  updateFps() {
    getScreenFps == null ? void 0 : getScreenFps(120).then((fps) => {
      this.frameDuration = 1e3 / fps;
    });
  }
  lockStageObject(targetName) {
    this.lockTransformTarget.push(targetName);
  }
  unlockStageObject(targetName) {
    const index2 = this.lockTransformTarget.findIndex((name) => name === targetName);
    if (index2 >= 0)
      this.lockTransformTarget.splice(index2, 1);
  }
  getExtName(url2) {
    return url2.split(".").pop() ?? "png";
  }
}
const getScreenFps = (() => {
  const nextFrame = [
    window.requestAnimationFrame,
    // @ts-ignore
    window.webkitRequestAnimationFrame,
    // @ts-ignore
    window.mozRequestAnimationFrame
  ].find((fn2) => fn2);
  if (!nextFrame) {
    console.error("requestAnimationFrame is not supported!");
    return;
  }
  return (targetCount = 60) => {
    if (targetCount < 1)
      throw new Error("targetCount cannot be less than 1.");
    const beginDate = Date.now();
    let count = 0;
    return new Promise((resolve2) => {
      (function log3() {
        nextFrame(() => {
          if (++count >= targetCount) {
            const diffDate = Date.now() - beginDate;
            const fps = count / diffDate * 1e3;
            return resolve2(fps);
          }
          log3();
        });
      })();
    });
  };
})();
const __INFO = {
  version: "IdolTime 1.0.0"
};
const u = navigator.userAgent;
const isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
const initializeScript = () => {
  logger.info(__INFO.version);
  logger.info("Made with  by IdolTime");
  if (isIOS) {
    alert(
      `iOS 
| Please use landscape mode on iOS for the best experience
| iOS `
    );
  }
  loadStyle("./game/userStyleSheet.css");
  getUserAnimation();
  infoFetcher("./game/config.txt");
  const sceneUrl = assetSetter("start.txt", fileType$1.scene);
  sceneFetcher(sceneUrl).then(async (rawScene) => {
    const scene = await WebGAL.sceneManager.setCurrentScene(rawScene, "start.txt", sceneUrl);
    if (!scene)
      return;
    const subSceneList = WebGAL.sceneManager.sceneData.currentScene.subSceneList;
    WebGAL.sceneManager.settledScenes.push(sceneUrl);
    const subSceneListUniq = uniqWith$1(subSceneList);
    scenePrefetcher(subSceneListUniq);
  });
  WebGAL.gameplay.pixiStage = new PixiStage();
  bindExtraFunc();
  webSocketFunc();
};
function loadStyle(url2) {
  const link = document.createElement("link");
  link.type = "text/css";
  link.rel = "stylesheet";
  link.href = url2;
  const head = document.getElementsByTagName("head")[0];
  head.appendChild(link);
}
function getUserAnimation() {
  axios$1.get("./game/animation/animationTable.json").then((res) => {
    const animations = res.data;
    for (const animationName of animations) {
      axios$1.get(`./game/animation/${animationName}.json`).then((res2) => {
        if (res2.data) {
          const userAnimation = {
            name: animationName,
            effects: res2.data
          };
          WebGAL.animationManager.addAnimation(userAnimation);
        }
      });
    }
  });
}
const Menu_main = "_Menu_main_1a7i6_1";
const Menu_ShowSoftly = "_Menu_ShowSoftly_1a7i6_1";
const Menu_TagContent = "_Menu_TagContent_1a7i6_10";
const styles$f = {
  Menu_main,
  Menu_ShowSoftly,
  Menu_TagContent
};
const MenuPanel_main = "_MenuPanel_main_1c9ky_1";
const MenuPanel_button = "_MenuPanel_button_1c9ky_10";
const MenuPanel_button_icon = "_MenuPanel_button_icon_1c9ky_38";
const MenuPanel_button_hl = "_MenuPanel_button_hl_1c9ky_44";
const styles$e = {
  MenuPanel_main,
  MenuPanel_button,
  MenuPanel_button_icon,
  MenuPanel_button_hl
};
var _excluded = ["size", "strokeWidth", "strokeLinecap", "strokeLinejoin", "theme", "fill", "className", "spin"];
function ownKeys$7(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$7(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$7(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var DEFAULT_ICON_CONFIGS = {
  size: "1em",
  strokeWidth: 4,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  rtl: false,
  theme: "outline",
  colors: {
    outline: {
      fill: "#333",
      background: "transparent"
    },
    filled: {
      fill: "#333",
      background: "#FFF"
    },
    twoTone: {
      fill: "#333",
      twoTone: "#2F88FF"
    },
    multiColor: {
      outStrokeColor: "#333",
      outFillColor: "#2F88FF",
      innerStrokeColor: "#FFF",
      innerFillColor: "#43CCF8"
    }
  },
  prefix: "i"
};
function guid() {
  return "icon-" + ((1 + Math.random()) * 4294967296 | 0).toString(16).substring(1);
}
function IconConverter(id2, icon, config) {
  var fill = typeof icon.fill === "string" ? [icon.fill] : icon.fill || [];
  var colors = [];
  var theme = icon.theme || config.theme;
  switch (theme) {
    case "outline":
      colors.push(typeof fill[0] === "string" ? fill[0] : "currentColor");
      colors.push("none");
      colors.push(typeof fill[0] === "string" ? fill[0] : "currentColor");
      colors.push("none");
      break;
    case "filled":
      colors.push(typeof fill[0] === "string" ? fill[0] : "currentColor");
      colors.push(typeof fill[0] === "string" ? fill[0] : "currentColor");
      colors.push("#FFF");
      colors.push("#FFF");
      break;
    case "two-tone":
      colors.push(typeof fill[0] === "string" ? fill[0] : "currentColor");
      colors.push(typeof fill[1] === "string" ? fill[1] : config.colors.twoTone.twoTone);
      colors.push(typeof fill[0] === "string" ? fill[0] : "currentColor");
      colors.push(typeof fill[1] === "string" ? fill[1] : config.colors.twoTone.twoTone);
      break;
    case "multi-color":
      colors.push(typeof fill[0] === "string" ? fill[0] : "currentColor");
      colors.push(typeof fill[1] === "string" ? fill[1] : config.colors.multiColor.outFillColor);
      colors.push(typeof fill[2] === "string" ? fill[2] : config.colors.multiColor.innerStrokeColor);
      colors.push(typeof fill[3] === "string" ? fill[3] : config.colors.multiColor.innerFillColor);
      break;
  }
  return {
    size: icon.size || config.size,
    strokeWidth: icon.strokeWidth || config.strokeWidth,
    strokeLinecap: icon.strokeLinecap || config.strokeLinecap,
    strokeLinejoin: icon.strokeLinejoin || config.strokeLinejoin,
    colors,
    id: id2
  };
}
var IconContext = /* @__PURE__ */ reactExports.createContext(DEFAULT_ICON_CONFIGS);
IconContext.Provider;
function IconWrapper(name, rtl, render) {
  return function(props) {
    var size = props.size, strokeWidth = props.strokeWidth, strokeLinecap = props.strokeLinecap, strokeLinejoin = props.strokeLinejoin, theme = props.theme, fill = props.fill, className = props.className, spin2 = props.spin, extra2 = _objectWithoutProperties(props, _excluded);
    var ICON_CONFIGS = reactExports.useContext(IconContext);
    var id2 = reactExports.useMemo(guid, []);
    var svgProps = IconConverter(id2, {
      size,
      strokeWidth,
      strokeLinecap,
      strokeLinejoin,
      theme,
      fill
    }, ICON_CONFIGS);
    var cls = [ICON_CONFIGS.prefix + "-icon"];
    cls.push(ICON_CONFIGS.prefix + "-icon-" + name);
    if (rtl && ICON_CONFIGS.rtl) {
      cls.push(ICON_CONFIGS.prefix + "-icon-rtl");
    }
    if (spin2) {
      cls.push(ICON_CONFIGS.prefix + "-icon-spin");
    }
    if (className) {
      cls.push(className);
    }
    return /* @__PURE__ */ React.createElement("span", _objectSpread$7(_objectSpread$7({}, extra2), {}, {
      className: cls.join(" ")
    }), render(svgProps));
  };
}
const FolderOpen = IconWrapper("folder-open", true, function(props) {
  return /* @__PURE__ */ React.createElement("svg", {
    width: props.size,
    height: props.size,
    viewBox: "0 0 48 48",
    fill: "none"
  }, /* @__PURE__ */ React.createElement("path", {
    d: "M4 9V41L9 21H39.5V15C39.5 13.8954 38.6046 13 37.5 13H24L19 7H6C4.89543 7 4 7.89543 4 9Z",
    stroke: props.colors[0],
    strokeWidth: props.strokeWidth,
    strokeLinecap: props.strokeLinecap,
    strokeLinejoin: props.strokeLinejoin
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M40 41L44 21H8.8125L4 41H40Z",
    fill: props.colors[1],
    stroke: props.colors[0],
    strokeWidth: props.strokeWidth,
    strokeLinecap: props.strokeLinecap,
    strokeLinejoin: props.strokeLinejoin
  }));
});
const HamburgerButton = IconWrapper("hamburger-button", false, function(props) {
  return /* @__PURE__ */ React.createElement("svg", {
    width: props.size,
    height: props.size,
    viewBox: "0 0 48 48",
    fill: "none"
  }, /* @__PURE__ */ React.createElement("path", {
    d: "M7.94971 11.9497H39.9497",
    stroke: props.colors[0],
    strokeWidth: props.strokeWidth,
    strokeLinecap: props.strokeLinecap,
    strokeLinejoin: props.strokeLinejoin
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M7.94971 23.9497H39.9497",
    stroke: props.colors[0],
    strokeWidth: props.strokeWidth,
    strokeLinecap: props.strokeLinecap,
    strokeLinejoin: props.strokeLinejoin
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M7.94971 35.9497H39.9497",
    stroke: props.colors[0],
    strokeWidth: props.strokeWidth,
    strokeLinecap: props.strokeLinecap,
    strokeLinejoin: props.strokeLinejoin
  }));
});
const Home = IconWrapper("home", false, function(props) {
  return /* @__PURE__ */ React.createElement("svg", {
    width: props.size,
    height: props.size,
    viewBox: "0 0 48 48",
    fill: "none"
  }, /* @__PURE__ */ React.createElement("path", {
    d: "M9 18V42H39V18L24 6L9 18Z",
    fill: props.colors[1],
    stroke: props.colors[0],
    strokeWidth: props.strokeWidth,
    strokeLinecap: props.strokeLinecap,
    strokeLinejoin: props.strokeLinejoin
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M19 29V42H29V29H19Z",
    fill: props.colors[3],
    stroke: props.colors[2],
    strokeWidth: props.strokeWidth,
    strokeLinejoin: props.strokeLinejoin
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M9 42H39",
    stroke: props.colors[0],
    strokeWidth: props.strokeWidth,
    strokeLinecap: props.strokeLinecap
  }));
});
const Logout = IconWrapper("logout", true, function(props) {
  return /* @__PURE__ */ React.createElement("svg", {
    width: props.size,
    height: props.size,
    viewBox: "0 0 48 48",
    fill: "none"
  }, /* @__PURE__ */ React.createElement("path", {
    d: "M23.9917 6H6V42H24",
    stroke: props.colors[0],
    strokeWidth: props.strokeWidth,
    strokeLinecap: props.strokeLinecap,
    strokeLinejoin: props.strokeLinejoin
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M33 33L42 24L33 15",
    stroke: props.colors[0],
    strokeWidth: props.strokeWidth,
    strokeLinecap: props.strokeLinecap,
    strokeLinejoin: props.strokeLinejoin
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M16 23.9917H42",
    stroke: props.colors[0],
    strokeWidth: props.strokeWidth,
    strokeLinecap: props.strokeLinecap,
    strokeLinejoin: props.strokeLinejoin
  }));
});
const Save$1 = IconWrapper("save", true, function(props) {
  return /* @__PURE__ */ React.createElement("svg", {
    width: props.size,
    height: props.size,
    viewBox: "0 0 48 48",
    fill: "none"
  }, /* @__PURE__ */ React.createElement("path", {
    d: "M6 9C6 7.34315 7.34315 6 9 6H34.2814L42 13.2065V39C42 40.6569 40.6569 42 39 42H9C7.34315 42 6 40.6569 6 39V9Z",
    fill: props.colors[1],
    stroke: props.colors[0],
    strokeWidth: props.strokeWidth,
    strokeLinejoin: props.strokeLinejoin
  }), /* @__PURE__ */ React.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M24.0083 6L24 13.3846C24 13.7245 23.5523 14 23 14H15C14.4477 14 14 13.7245 14 13.3846L14 6",
    fill: props.colors[3]
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M24.0083 6L24 13.3846C24 13.7245 23.5523 14 23 14H15C14.4477 14 14 13.7245 14 13.3846L14 6H24.0083Z",
    stroke: props.colors[2],
    strokeWidth: props.strokeWidth,
    strokeLinejoin: props.strokeLinejoin
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M9 6H34.2814",
    stroke: props.colors[0],
    strokeWidth: props.strokeWidth,
    strokeLinecap: props.strokeLinecap,
    strokeLinejoin: props.strokeLinejoin
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M14 26H34",
    stroke: props.colors[2],
    strokeWidth: props.strokeWidth,
    strokeLinecap: props.strokeLinecap,
    strokeLinejoin: props.strokeLinejoin
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M14 34H24.0083",
    stroke: props.colors[2],
    strokeWidth: props.strokeWidth,
    strokeLinecap: props.strokeLinecap,
    strokeLinejoin: props.strokeLinejoin
  }));
});
const SettingTwo = IconWrapper("setting-two", false, function(props) {
  return /* @__PURE__ */ React.createElement("svg", {
    width: props.size,
    height: props.size,
    viewBox: "0 0 48 48",
    fill: "none"
  }, /* @__PURE__ */ React.createElement("path", {
    d: "M18.2838 43.1713C14.9327 42.1736 11.9498 40.3213 9.58787 37.867C10.469 36.8227 11 35.4734 11 34.0001C11 30.6864 8.31371 28.0001 5 28.0001C4.79955 28.0001 4.60139 28.01 4.40599 28.0292C4.13979 26.7277 4 25.3803 4 24.0001C4 21.9095 4.32077 19.8938 4.91579 17.9995C4.94381 17.9999 4.97188 18.0001 5 18.0001C8.31371 18.0001 11 15.3138 11 12.0001C11 11.0488 10.7786 10.1493 10.3846 9.35011C12.6975 7.1995 15.5205 5.59002 18.6521 4.72314C19.6444 6.66819 21.6667 8.00013 24 8.00013C26.3333 8.00013 28.3556 6.66819 29.3479 4.72314C32.4795 5.59002 35.3025 7.1995 37.6154 9.35011C37.2214 10.1493 37 11.0488 37 12.0001C37 15.3138 39.6863 18.0001 43 18.0001C43.0281 18.0001 43.0562 17.9999 43.0842 17.9995C43.6792 19.8938 44 21.9095 44 24.0001C44 25.3803 43.8602 26.7277 43.594 28.0292C43.3986 28.01 43.2005 28.0001 43 28.0001C39.6863 28.0001 37 30.6864 37 34.0001C37 35.4734 37.531 36.8227 38.4121 37.867C36.0502 40.3213 33.0673 42.1736 29.7162 43.1713C28.9428 40.752 26.676 39.0001 24 39.0001C21.324 39.0001 19.0572 40.752 18.2838 43.1713Z",
    fill: props.colors[1],
    stroke: props.colors[0],
    strokeWidth: props.strokeWidth,
    strokeLinejoin: props.strokeLinejoin
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M24 31C27.866 31 31 27.866 31 24C31 20.134 27.866 17 24 17C20.134 17 17 20.134 17 24C17 27.866 20.134 31 24 31Z",
    fill: props.colors[3],
    stroke: props.colors[2],
    strokeWidth: props.strokeWidth,
    strokeLinejoin: props.strokeLinejoin
  }));
});
const MenuIconMap = (props) => {
  let returnIcon;
  switch (props.iconName) {
    case "save":
      returnIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(Save$1, { theme: "outline", size: "1.2em", fill: props.iconColor, strokeWidth: 2 });
      break;
    case "load":
      returnIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(FolderOpen, { theme: "outline", size: "1.2em", fill: props.iconColor, strokeWidth: 2 });
      break;
    case "option":
      returnIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(SettingTwo, { theme: "outline", size: "1.2em", fill: props.iconColor, strokeWidth: 2 });
      break;
    case "title":
      returnIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(Home, { theme: "outline", size: "1.2em", fill: props.iconColor, strokeWidth: 2 });
      break;
    case "exit":
      returnIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(Logout, { theme: "outline", size: "1.2em", fill: props.iconColor, strokeWidth: 2 });
      break;
    default:
      returnIcon = /* @__PURE__ */ jsxRuntimeExports.jsx("div", {});
  }
  return returnIcon;
};
const MenuPanelButton = (props) => {
  const { playSePageChange, playSeEnter } = useSoundEffect();
  let buttonClassName = styles$e.MenuPanel_button;
  if (props.hasOwnProperty("buttonOnClassName")) {
    buttonClassName = buttonClassName + props.buttonOnClassName;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: buttonClassName,
      onClick: () => {
        props.clickFunc();
      },
      onMouseEnter: playSeEnter,
      style: { ...props.style, color: props.tagColor },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$e.MenuPanel_button_icon, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuIconMap, { iconName: props.iconName, iconColor: props.iconColor }) }),
        props.tagName
      ]
    }
  );
};
const backToTitle = () => {
  const dispatch = webgalStore.dispatch;
  stopAllPerform();
  stopAuto();
  stopFast();
  dispatch(setStage({ key: "playVocal", value: "" }));
  dispatch(setVisibility({ component: "showTitle", visibility: true }));
  setEbg(webgalStore.getState().GUI.titleBg);
};
const GlobalDialog_main = "_GlobalDialog_main_1f69h_2";
const showGlobalDialog = "_showGlobalDialog_1f69h_1";
const glabalDialog_container_inner = "_glabalDialog_container_inner_1f69h_17";
const glabalDialog_container = "_glabalDialog_container_1f69h_17";
const title = "_title_1f69h_38";
const button_list = "_button_list_1f69h_49";
const button_confirm = "_button_confirm_1f69h_55";
const button_cancel = "_button_cancel_1f69h_71";
const button$1 = "_button_1f69h_49";
const styles$d = {
  GlobalDialog_main,
  showGlobalDialog,
  glabalDialog_container_inner,
  glabalDialog_container,
  title,
  button_list,
  button_confirm,
  button_cancel,
  button: button$1
};
function GlobalDialog() {
  const isGlobalDialogShow = useSelector((state) => state.GUI.showGlobalDialog);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: isGlobalDialogShow && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "globalDialogContainer" }) });
}
function showGlogalDialog(props) {
  const { playSeClick, playSeEnter } = useSEByWebgalStore();
  webgalStore.dispatch(setVisibility({ component: "showGlobalDialog", visibility: true }));
  const handleLeft = () => {
    playSeClick();
    props.leftFunc();
    hideGlobalDialog();
  };
  const handleRight = () => {
    playSeClick();
    props.rightFunc();
    hideGlobalDialog();
  };
  const renderElement = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$d.GlobalDialog_main, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$d.glabalDialog_container, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$d.glabalDialog_container_inner, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$d.title, children: props.title }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$d.button_list, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$d.button_confirm, onClick: handleLeft, onMouseEnter: playSeEnter, children: props.leftText }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$d.button_cancel, onClick: handleRight, onMouseEnter: playSeEnter, children: props.rightText })
    ] })
  ] }) }) });
  setTimeout(() => {
    ReactDOM.render(renderElement, document.getElementById("globalDialogContainer"));
  }, 100);
}
function hideGlobalDialog() {
  webgalStore.dispatch(setVisibility({ component: "showGlobalDialog", visibility: false }));
}
const MenuPanel = () => {
  const t2 = useTrans("menu.");
  const { playSeClick, playSeDialogOpen, playSePageChange } = useSoundEffect();
  const GUIState = useSelector((state) => state.GUI);
  const dispatch = useDispatch();
  const SaveTagOn = GUIState.currentMenuTag === MenuPanelTag.Save ? ` ${styles$e.MenuPanel_button_hl}` : ``;
  const LoadTagOn = GUIState.currentMenuTag === MenuPanelTag.Load ? ` ${styles$e.MenuPanel_button_hl}` : ``;
  const OptionTagOn = GUIState.currentMenuTag === MenuPanelTag.Option ? ` ${styles$e.MenuPanel_button_hl}` : ``;
  const SaveTagColor = GUIState.currentMenuTag === MenuPanelTag.Save ? `rgba(74, 34, 93, 0.9)` : `rgba(123,144,169,1)`;
  const LoadTagColor = GUIState.currentMenuTag === MenuPanelTag.Load ? `rgba(11, 52, 110, 0.9)` : `rgba(123,144,169,1)`;
  const OptionTagColor = GUIState.currentMenuTag === MenuPanelTag.Option ? `rgba(81, 110, 65, 0.9)` : `rgba(123,144,169,1)`;
  const SaveIconColor = GUIState.currentMenuTag === MenuPanelTag.Save ? `rgba(74, 34, 93, 0.9)` : `rgba(123,144,169,1)`;
  const LoadIconColor = GUIState.currentMenuTag === MenuPanelTag.Load ? `rgba(11, 52, 110, 0.9)` : `rgba(123,144,169,1)`;
  const OptionIconColor = GUIState.currentMenuTag === MenuPanelTag.Option ? `rgba(81, 110, 65, 0.9)` : `rgba(123,144,169,1)`;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$e.MenuPanel_main, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuPanelButton,
      {
        iconName: "save",
        buttonOnClassName: SaveTagOn,
        iconColor: SaveIconColor,
        tagColor: SaveTagColor,
        clickFunc: () => {
          playSePageChange();
          if (GUIState.showTitle)
            return;
          dispatch(setMenuPanelTag(MenuPanelTag.Save));
        },
        tagName: t2("saving.title")
      },
      "saveButton"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuPanelButton,
      {
        iconName: "load",
        buttonOnClassName: LoadTagOn,
        iconColor: LoadIconColor,
        tagColor: LoadTagColor,
        clickFunc: () => {
          playSePageChange();
          dispatch(setMenuPanelTag(MenuPanelTag.Load));
        },
        tagName: t2("loadSaving.title")
      },
      "loadButton"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuPanelButton,
      {
        iconName: "title",
        iconColor: "rgba(123,144,169,1)",
        tagColor: "rgba(123,144,169,1)",
        clickFunc: () => {
          playSeDialogOpen();
          showGlogalDialog({
            title: t2("$gaming.buttons.titleTips"),
            leftText: t2("$common.yes"),
            rightText: t2("$common.no"),
            leftFunc: () => {
              backToTitle();
              dispatch(setVisibility({ component: "showMenuPanel", visibility: false }));
            },
            rightFunc: () => {
            }
          });
        },
        tagName: t2("title.title")
      },
      "titleIcon"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuPanelButton,
      {
        iconName: "option",
        style: { marginLeft: "auto" },
        buttonOnClassName: OptionTagOn,
        iconColor: OptionIconColor,
        tagColor: OptionTagColor,
        clickFunc: () => {
          playSePageChange();
          dispatch(setMenuPanelTag(MenuPanelTag.Option));
        },
        tagName: t2("options.title")
      },
      "optionButton"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuPanelButton,
      {
        iconName: "exit",
        iconColor: "rgba(123,144,169,1)",
        tagColor: "rgba(123,144,169,1)",
        clickFunc: () => {
          playSeClick();
          dispatch(setVisibility({ component: "showMenuPanel", visibility: false }));
        },
        tagName: t2("exit.title")
      },
      "exitIcon"
    )
  ] });
};
const Save_Load_main = "_Save_Load_main_1npjb_2";
const Save_Load_top = "_Save_Load_top_1npjb_13";
const Elements_in = "_Elements_in_1npjb_1";
const Save_Load_title_save = "_Save_Load_title_save_1npjb_21";
const Save_back$1 = "_Save_back_1npjb_34";
const Save_title = "_Save_title_1npjb_48";
const Load_title = "_Load_title_1npjb_61";
const Save_Load_title = "_Save_Load_title_1npjb_21";
const Save_Load_top_buttonList = "_Save_Load_top_buttonList_1npjb_92";
const Save_Load_top_button = "_Save_Load_top_button_1npjb_92";
const Save_Load_top_button_on = "_Save_Load_top_button_on_1npjb_120";
const Load_top_button_on = "_Load_top_button_on_1npjb_135";
const Load_top_button = "_Load_top_button_1npjb_135";
const Save_Load_content = "_Save_Load_content_1npjb_146";
const Save_Load_content_element = "_Save_Load_content_element_1npjb_160";
const Elements_in_transform = "_Elements_in_transform_1npjb_1";
const Save_Load_border = "_Save_Load_border_1npjb_175";
const Save_Load_info_box = "_Save_Load_info_box_1npjb_183";
const Save_Load_content_miniRen = "_Save_Load_content_miniRen_1npjb_186";
const Save_Load_content_element_top = "_Save_Load_content_element_top_1npjb_190";
const Save_Load_content_element_top_index = "_Save_Load_content_element_top_index_1npjb_197";
const Load_content_elememt_top_index = "_Load_content_elememt_top_index_1npjb_208";
const Save_Load_content_element_top_date = "_Save_Load_content_element_top_date_1npjb_219";
const Load_content_element_top_date = "_Load_content_element_top_date_1npjb_233";
const Save_Load_content_text = "_Save_Load_content_text_1npjb_237";
const Save_Load_info = "_Save_Load_info_1npjb_183";
const Save_Load_content_text_padding = "_Save_Load_content_text_padding_1npjb_262";
const Save_Load_content_speaker = "_Save_Load_content_speaker_1npjb_266";
const Load_content_speaker = "_Load_content_speaker_1npjb_275";
const Load_content_text = "_Load_content_text_1npjb_279";
const Save_Load_content_space = "_Save_Load_content_space_1npjb_296";
const Save_Load_content_miniRen_bg = "_Save_Load_content_miniRen_bg_1npjb_307";
const Save_Load_content_miniRen_figure = "_Save_Load_content_miniRen_figure_1npjb_314";
const Save_Load_content_miniRen_figLeft = "_Save_Load_content_miniRen_figLeft_1npjb_322";
const Save_Load_content_miniRen_figRight = "_Save_Load_content_miniRen_figRight_1npjb_327";
const Btn_l = "_Btn_l_1npjb_346";
const Btn_r = "_Btn_r_1npjb_356";
const styles$c = {
  Save_Load_main,
  Save_Load_top,
  Elements_in,
  Save_Load_title_save,
  Save_back: Save_back$1,
  Save_title,
  Load_title,
  Save_Load_title,
  Save_Load_top_buttonList,
  Save_Load_top_button,
  Save_Load_top_button_on,
  Load_top_button_on,
  Load_top_button,
  Save_Load_content,
  Save_Load_content_element,
  Elements_in_transform,
  Save_Load_border,
  Save_Load_info_box,
  Save_Load_content_miniRen,
  Save_Load_content_element_top,
  Save_Load_content_element_top_index,
  Load_content_elememt_top_index,
  Save_Load_content_element_top_date,
  Load_content_element_top_date,
  Save_Load_content_text,
  Save_Load_info,
  Save_Load_content_text_padding,
  Save_Load_content_speaker,
  Load_content_speaker,
  Load_content_text,
  Save_Load_content_space,
  Save_Load_content_miniRen_bg,
  Save_Load_content_miniRen_figure,
  Save_Load_content_miniRen_figLeft,
  Save_Load_content_miniRen_figRight,
  Btn_l,
  Btn_r
};
const Save = () => {
  const { playSeClick, playSePageChange, playSeEnter, playSeDialogOpen } = useSoundEffect();
  const userDataState = useSelector((state) => state.userData);
  const savesDataState = useSelector((state) => state.saveData);
  const dispatch = useDispatch();
  const page = [];
  for (let i2 = 1; i2 <= 4; i2++) {
    let classNameOfElement = styles$c.Save_Load_top_button;
    if (i2 === userDataState.optionData.slPage) {
      classNameOfElement = classNameOfElement + " " + styles$c.Save_Load_top_button_on;
    }
    const element = /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        onClick: () => {
          dispatch(setSlPage(i2));
          setStorage();
          playSePageChange();
        },
        onMouseEnter: playSeEnter,
        className: classNameOfElement,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Save_Load_top_button_text })
      },
      "Save_element_page" + i2
    );
    page.push(element);
  }
  const tCommon = useTrans("common.");
  const showSaves = [];
  const start = (userDataState.optionData.slPage - 1) * 6 + 1;
  const end2 = start + 5;
  reactExports.useEffect(() => {
    getSavesFromStorage(start, end2);
  }, [start, end2]);
  let animationIndex = 0;
  for (let i2 = start; i2 <= end2; i2++) {
    animationIndex++;
    const saveData = savesDataState.saveData[i2];
    let saveElementContent = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Save_Load_content_space });
    if (saveData) {
      saveData.nowStageState.showName === "" ? "" : `${saveData.nowStageState.showName}`;
      saveElementContent = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Save_Load_border }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Save_Load_content_miniRen, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: styles$c.Save_Load_content_miniRen_bg, alt: "Save_img_preview", src: saveData.previewImage }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Save_Load_info, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$c.Save_Load_info_box, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Save_Load_content_element_top_date, children: saveData.saveTime }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Save_Load_content_element_top_date, children: saveData.nowStageState.showText })
        ] }) })
      ] });
    }
    const saveElement = /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        onClick: () => {
          if (savesDataState.saveData[i2]) {
            playSeDialogOpen();
            showGlogalDialog({
              title: t2("saving.isOverwrite"),
              leftText: tCommon("yes"),
              rightText: tCommon("no"),
              leftFunc: () => {
                saveGame(i2);
                setStorage();
              },
              rightFunc: () => {
              }
            });
          } else {
            playSePageChange();
            saveGame(i2);
          }
        },
        onMouseEnter: playSeEnter,
        className: styles$c.Save_Load_content_element,
        style: { animationDelay: `${animationIndex * 30}ms` },
        children: saveElementContent
      },
      "saveElement_" + i2
    );
    showSaves.push(saveElement);
  }
  const t2 = useTrans("menu.");
  const handleBtnClick = (dir) => {
    const slPage = userDataState.optionData.slPage;
    let index2 = slPage;
    if (dir === "left") {
      index2 = index2 > 1 ? index2 - 1 : 4;
    } else {
      index2 = index2 < 4 ? index2 + 1 : 1;
    }
    dispatch(setSlPage(index2));
    setStorage();
    playSePageChange();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$c.Save_Load_main, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$c.Save_Load_top, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: styles$c.Save_back,
          onClick: () => {
            playSeClick();
            dispatch(setVisibility({ component: "showMenuPanel", visibility: false }));
          },
          onMouseEnter: playSeEnter
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Save_title })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Save_Load_content, id: "Save_content_page_" + userDataState.optionData.slPage, children: showSaves }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$c.Save_Load_top_buttonList, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Btn_l, onClick: () => handleBtnClick("left") }),
      page,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Btn_r, onClick: () => handleBtnClick("right") })
    ] })
  ] });
};
const Load = () => {
  const { playSeClick, playSeEnter, playSePageChange } = useSoundEffect();
  const userDataState = useSelector((state) => state.userData);
  const saveDataState = useSelector((state) => state.saveData);
  const dispatch = useDispatch();
  const page = [];
  for (let i2 = 1; i2 <= 4; i2++) {
    let classNameOfElement = styles$c.Save_Load_top_button + " " + styles$c.Load_top_button;
    if (i2 === userDataState.optionData.slPage) {
      classNameOfElement = classNameOfElement + " " + styles$c.Save_Load_top_button_on;
    }
    const element = /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        onClick: () => {
          dispatch(setSlPage(i2));
          setStorage();
          playSePageChange();
        },
        onMouseEnter: playSeEnter,
        className: classNameOfElement,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Save_Load_top_button_text })
      },
      "Load_element_page" + i2
    );
    page.push(element);
  }
  const showSaves = [];
  const start = (userDataState.optionData.slPage - 1) * 6 + 1;
  const end2 = start + 5;
  reactExports.useEffect(() => {
    getSavesFromStorage(start, end2);
  }, [start, end2]);
  let animationIndex = 0;
  for (let i2 = start; i2 <= end2; i2++) {
    animationIndex++;
    const saveData = saveDataState.saveData[i2];
    let saveElementContent = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Save_Load_content_space });
    if (saveData) {
      saveData.nowStageState.showName === "" ? "" : `${saveData.nowStageState.showName}`;
      saveElementContent = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Save_Load_border }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Save_Load_content_miniRen, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: styles$c.Save_Load_content_miniRen_bg, alt: "Save_img_preview", src: saveData.previewImage }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Save_Load_info, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$c.Save_Load_info_box, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Save_Load_content_element_top_date, children: saveData.saveTime }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Save_Load_content_element_top_date, children: saveData.nowStageState.showText })
        ] }) })
      ] });
    }
    const saveElement = /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        onClick: () => {
          loadGame(i2);
          playSeClick();
        },
        onMouseEnter: playSeEnter,
        className: styles$c.Save_Load_content_element,
        style: { animationDelay: `${animationIndex * 30}ms` },
        children: saveElementContent
      },
      "loadElement_" + i2
    );
    showSaves.push(saveElement);
  }
  useTrans("menu.");
  const handleBtnClick = (dir) => {
    const slPage = userDataState.optionData.slPage;
    let index2 = slPage;
    if (dir === "left") {
      index2 = index2 > 1 ? index2 - 1 : 4;
    } else {
      index2 = index2 < 4 ? index2 + 1 : 1;
    }
    dispatch(setSlPage(index2));
    setStorage();
    playSePageChange();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$c.Save_Load_main, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$c.Save_Load_top, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: styles$c.Save_back,
          onClick: () => {
            playSeClick();
            dispatch(setVisibility({ component: "showMenuPanel", visibility: false }));
          },
          onMouseEnter: playSeEnter
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Load_title })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Save_Load_content, id: "Load_content_page_" + userDataState.optionData.slPage, children: showSaves }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$c.Save_Load_top_buttonList, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Btn_l, onClick: () => handleBtnClick("left") }),
      page,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$c.Btn_r, onClick: () => handleBtnClick("right") })
    ] })
  ] });
};
const Options_main = "_Options_main_e7j3v_1";
const Options_top = "_Options_top_e7j3v_12";
const Options_page_container = "_Options_page_container_e7j3v_25";
const Options_left = "_Options_left_e7j3v_37";
const title_base = "_title_base_e7j3v_40";
const Check_line = "_Check_line_e7j3v_49";
const Options_right = "_Options_right_e7j3v_65";
const title_voice = "_title_voice_e7j3v_68";
const Line = "_Line_e7j3v_78";
const Label = "_Label_e7j3v_83";
const Check_item = "_Check_item_e7j3v_91";
const Check_name = "_Check_name_e7j3v_96";
const Check_box = "_Check_box_e7j3v_107";
const Checked_box = "_Checked_box_e7j3v_118";
const Bar_line = "_Bar_line_e7j3v_130";
const Label_text_speed = "_Label_text_speed_e7j3v_148";
const Bar = "_Bar_e7j3v_130";
const Save_back = "_Save_back_e7j3v_165";
const LabelLine = "_LabelLine_e7j3v_179";
const styles$b = {
  Options_main,
  Options_top,
  Options_page_container,
  Options_left,
  title_base,
  Check_line,
  Options_right,
  title_voice,
  Line,
  Label,
  Check_item,
  Check_name,
  Check_box,
  Checked_box,
  Bar_line,
  Label_text_speed,
  Bar,
  Save_back,
  LabelLine
};
const slider = "";
const OptionSlider = (props) => {
  const { playSeEnter } = useSoundEffect();
  reactExports.useEffect(() => {
    setTimeout(() => {
      const input = document.getElementById(props.uniqueID);
      if (input !== null)
        input.setAttribute("value", props.initValue.toString());
      calcSlideBg();
    }, 1);
  }, []);
  reactExports.useEffect(() => {
    calcSlideBg();
  }, [props.initValue]);
  function calcSlideBg() {
    const inputBg = document.getElementById(`${props.uniqueID}-bg`);
    if (inputBg !== null) {
      inputBg.style.width = Number(props.initValue.toString()) / 100 * 207 / 0.75 + "px";
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "Option_WebGAL_slider", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        className: "Rang_input",
        id: props.uniqueID,
        type: "range",
        onChange: props.onChange,
        onFocus: playSeEnter,
        onMouseEnter: playSeEnter
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "Slider_bg", id: `${props.uniqueID}-bg` }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "Slider_bg_under" })
  ] });
};
const Options = () => {
  reactExports.useEffect(getStorage, []);
  const { playSeClick, playSeEnter } = useSoundEffect();
  const userDataState = useSelector((state) => state.userData);
  const dispatch = useDispatch();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$b.Options_main, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: styles$b.Save_back,
        onClick: () => {
          playSeClick();
          dispatch(setVisibility({ component: "showMenuPanel", visibility: false }));
        },
        onMouseEnter: playSeEnter
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$b.Options_top }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$b.Options_page_container, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$b.Options_left, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$b.title_base }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$b.Line, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$b.Label, children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$b.Check_line, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$b.Check_item, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$b.Check_name, children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: styles$b.Check_box,
                  onClick: () => {
                    dispatch(setOptionData({ key: "fullScreen", value: fullScreenOption.on }));
                    setStorage();
                  },
                  children: !userDataState.optionData.fullScreen ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$b.Checked_box }) : null
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$b.Check_item, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$b.Check_name, children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: styles$b.Check_box,
                  onClick: () => {
                    dispatch(setOptionData({ key: "fullScreen", value: fullScreenOption.off }));
                    setStorage();
                  },
                  children: userDataState.optionData.fullScreen ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$b.Checked_box }) : null
                }
              )
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$b.LabelLine }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${styles$b.Bar_line} ${styles$b.Check_line}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$b.Label_text_speed, children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            OptionSlider,
            {
              initValue: userDataState.optionData.textSpeed,
              uniqueID: "",
              onChange: (event) => {
                const newValue = event.target.value;
                dispatch(setOptionData({ key: "textSpeed", value: Number(newValue) }));
                setStorage();
              }
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$b.Options_right, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$b.title_voice }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$b.Bar_line, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$b.Label, children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            OptionSlider,
            {
              initValue: userDataState.optionData.volumeMain,
              uniqueID: "",
              onChange: (event) => {
                const newValue = event.target.value;
                dispatch(setOptionData({ key: "volumeMain", value: Number(newValue) }));
                setStorage();
              }
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$b.Bar_line, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$b.Label, children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            OptionSlider,
            {
              initValue: userDataState.optionData.bgmVolume,
              uniqueID: "",
              onChange: (event) => {
                const newValue = event.target.value;
                dispatch(setOptionData({ key: "bgmVolume", value: Number(newValue) }));
                setStorage();
              }
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$b.Bar_line, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$b.Label, children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            OptionSlider,
            {
              initValue: userDataState.optionData.seVolume,
              uniqueID: "",
              onChange: (event) => {
                const newValue = event.target.value;
                dispatch(setOptionData({ key: "seVolume", value: Number(newValue) }));
                dispatch(setOptionData({ key: "uiSeVolume", value: Number(newValue) }));
                setStorage();
              }
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$b.Bar_line, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$b.Label, children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            OptionSlider,
            {
              initValue: userDataState.optionData.vocalVolume,
              uniqueID: "",
              onChange: (event) => {
                const newValue = event.target.value;
                dispatch(setOptionData({ key: "vocalVolume", value: Number(newValue) }));
                setStorage();
              }
            }
          )
        ] })
      ] })
    ] })
  ] });
};
const Menu = () => {
  const GUIState = useSelector((state) => state.GUI);
  let currentTag;
  switch (GUIState.currentMenuTag) {
    case MenuPanelTag.Save:
      currentTag = /* @__PURE__ */ jsxRuntimeExports.jsx(Save, {});
      break;
    case MenuPanelTag.Load:
      currentTag = /* @__PURE__ */ jsxRuntimeExports.jsx(Load, {});
      break;
    case MenuPanelTag.Option:
      currentTag = /* @__PURE__ */ jsxRuntimeExports.jsx(Options, {});
      break;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: GUIState.showMenuPanel && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$f.Menu_main, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$f.Menu_TagContent, children: currentTag }),
    !MenuPanelTag.Option ? /* @__PURE__ */ jsxRuntimeExports.jsx(MenuPanel, {}) : null
  ] }) });
};
const MainStage_main = "_MainStage_main_9enex_1";
const MainStage_main_container = "_MainStage_main_container_9enex_10";
const MainStage_bgContainer = "_MainStage_bgContainer_9enex_17";
const MainStage_showBgSoftly = "_MainStage_showBgSoftly_9enex_1";
const MainStage_bgContainer_Settled = "_MainStage_bgContainer_Settled_9enex_27";
const MainStage_oldBgContainer = "_MainStage_oldBgContainer_9enex_37";
const MainStage_oldBgFadeout = "_MainStage_oldBgFadeout_9enex_1";
const MainStage_oldBgContainer_Settled = "_MainStage_oldBgContainer_Settled_9enex_47";
const pixiContainer = "_pixiContainer_9enex_72";
const chooseContainer = "_chooseContainer_9enex_77";
const styles$a = {
  MainStage_main,
  MainStage_main_container,
  MainStage_bgContainer,
  MainStage_showBgSoftly,
  MainStage_bgContainer_Settled,
  MainStage_oldBgContainer,
  MainStage_oldBgFadeout,
  MainStage_oldBgContainer_Settled,
  pixiContainer,
  chooseContainer
};
function useFontFamily() {
  const fontFamily = useSelector((state) => state.userData.optionData.textboxFont);
  function getFont() {
    return match$1(fontFamily).with(textFont.song, () => '"", serif').with(textFont.lxgw, () => '"LXGW", serif').with(textFont.hei, () => '"WebgalUI", serif').default(() => '"WebgalUI", serif');
  }
  return getFont();
}
function getTextSize(size) {
  switch (size) {
    case 0:
      return 150;
    case 1:
      return 205;
    case 2:
      return 240;
    default:
      return 205;
  }
}
const TextBox_EventHandler$1 = "_TextBox_EventHandler_bok8c_1";
const TextBox_Container = "_TextBox_Container_bok8c_9";
const showSoftly$1 = "_showSoftly_bok8c_1";
const TextBox_main$1 = "_TextBox_main_bok8c_22";
const TextBox_avatarDialogue_bg = "_TextBox_avatarDialogue_bg_bok8c_46";
const TextBox_dialogue_bg = "_TextBox_dialogue_bg_bok8c_51";
const TextBox_Background = "_TextBox_Background_bok8c_56";
const TextBox_textElement_start$1 = "_TextBox_textElement_start_bok8c_68";
const TextDelayShow$1 = "_TextDelayShow_bok8c_1";
const outer = "_outer_bok8c_74";
const inner = "_inner_bok8c_83";
const zhanwei = "_zhanwei_bok8c_92";
const TextBox_textElement_Settled$1 = "_TextBox_textElement_Settled_bok8c_97";
const TextBox_showName$1 = "_TextBox_showName_bok8c_102";
const outerName = "_outerName_bok8c_115";
const TextBox_ShowName_Background = "_TextBox_ShowName_Background_bok8c_119";
const miniAvatarContainer$1 = "_miniAvatarContainer_bok8c_131";
const miniAvatarImg$1 = "_miniAvatarImg_bok8c_141";
const nameContainer = "_nameContainer_bok8c_149";
const innerName = "_innerName_bok8c_162";
const text = "_text_bok8c_169";
const styles$9 = {
  TextBox_EventHandler: TextBox_EventHandler$1,
  TextBox_Container,
  showSoftly: showSoftly$1,
  TextBox_main: TextBox_main$1,
  TextBox_avatarDialogue_bg,
  TextBox_dialogue_bg,
  TextBox_Background,
  TextBox_textElement_start: TextBox_textElement_start$1,
  TextDelayShow: TextDelayShow$1,
  outer,
  inner,
  zhanwei,
  TextBox_textElement_Settled: TextBox_textElement_Settled$1,
  TextBox_showName: TextBox_showName$1,
  outerName,
  TextBox_ShowName_Background,
  miniAvatarContainer: miniAvatarContainer$1,
  miniAvatarImg: miniAvatarImg$1,
  nameContainer,
  innerName,
  text
};
function IMSSTextbox(props) {
  const {
    textArray,
    textDelay,
    currentConcatDialogPrev,
    currentDialogKey,
    isText,
    isSafari: isSafari2,
    isFirefox: boolean,
    fontSize,
    miniAvatar: miniAvatar2,
    showName,
    font,
    textDuration,
    isUseStroke,
    textboxOpacity
  } = props;
  const applyStyle2 = useApplyStyle("Stage/TextBox/textbox.scss");
  reactExports.useEffect(() => {
    function settleText() {
      const textElements = document.querySelectorAll(".Textelement_start");
      const textArray2 = [...textElements];
      textArray2.forEach((e2) => {
        e2.className = applyStyle2("TextBox_textElement_Settled", styles$9.TextBox_textElement_Settled);
      });
    }
    WebGAL.events.textSettle.on(settleText);
    return () => {
      WebGAL.events.textSettle.off(settleText);
    };
  }, []);
  let allTextIndex = 0;
  const textElementList = textArray.map((line2, index2) => {
    const textLine = line2.map((e2, index22) => {
      let delay = allTextIndex * textDelay;
      allTextIndex++;
      let prevLength = currentConcatDialogPrev.length;
      if (currentConcatDialogPrev !== "" && index22 >= prevLength) {
        delay = delay - prevLength * textDelay;
      }
      if (index22 < prevLength) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            id: `${delay}`,
            className: applyStyle2("TextBox_textElement_Settled", styles$9.TextBox_textElement_Settled),
            style: { animationDelay: `${delay}ms`, animationDuration: `${textDuration}ms` },
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$9.zhanwei, children: [
              e2,
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: applyStyle2("outer", styles$9.outer), children: e2 }),
              isUseStroke && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: applyStyle2("inner", styles$9.inner), children: e2 })
            ] })
          },
          currentDialogKey + index22
        );
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          "data-text": e2,
          id: `${delay}`,
          className: `${applyStyle2("TextBox_textElement_start", styles$9.TextBox_textElement_start)} Textelement_start`,
          style: { animationDelay: `${delay}ms`, position: "relative" },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$9.zhanwei, children: [
            e2,
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: applyStyle2("outer", styles$9.outer), children: e2 }),
            isUseStroke && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: applyStyle2("inner", styles$9.inner), children: e2 })
          ] })
        },
        currentDialogKey + index22
      );
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          wordBreak: isSafari2 || props.isFirefox ? "break-all" : void 0,
          display: isSafari2 ? "flex" : void 0,
          flexWrap: isSafari2 ? "wrap" : void 0
        },
        children: textLine
      },
      `text-line-${index2}`
    );
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: isText && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$9.TextBox_Container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: applyStyle2("TextBox_main", styles$9.TextBox_main),
        style: {
          opacity: `${textboxOpacity / 100}`,
          left: miniAvatar2 === "" ? 25 : void 0
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        id: "textBoxMain",
        className: `${styles$9.TextBox_main} ${miniAvatar2 !== "" ? styles$9.TextBox_avatarDialogue_bg : styles$9.TextBox_dialogue_bg} `,
        style: {
          fontFamily: font,
          left: miniAvatar2 === "" ? 25 : void 0
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "miniAvatar", className: applyStyle2("miniAvatarContainer", styles$9.miniAvatarContainer), children: miniAvatar2 !== "" && /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: applyStyle2("miniAvatarImg", styles$9.miniAvatarImg), alt: "miniAvatar", src: miniAvatar2 }) }),
          showName !== "" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: applyStyle2("TextBox_showName", styles$9.TextBox_showName),
                style: {
                  opacity: `${textboxOpacity / 100}`,
                  fontSize: "200%"
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { opacity: 0 }, children: showName.split("").map((e2, i2) => {
                  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { position: "relative" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$9.zhanwei, children: [
                    e2,
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: applyStyle2("outerName", styles$9.outerName), children: e2 }),
                    isUseStroke && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: applyStyle2("innerName", styles$9.innerName), children: e2 })
                  ] }) }, e2 + i2);
                }) })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: applyStyle2("TextBox_showName", styles$9.TextBox_showName),
                children: showName.split("").map((e2, i2) => {
                  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { position: "relative" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$9.zhanwei, children: [
                    e2,
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: applyStyle2("outerName", styles$9.outerName), children: e2 }),
                    isUseStroke && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: applyStyle2("innerName", styles$9.innerName), children: e2 })
                  ] }) }, e2 + i2);
                })
              },
              showName
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: applyStyle2("text", styles$9.text),
              style: {
                flexFlow: "column",
                overflow: "hidden",
                paddingLeft: "0.1em"
              },
              children: textElementList
            }
          )
        ]
      }
    )
  ] }) });
}
const userAgent = navigator.userAgent;
const isFirefox = /firefox/i.test(userAgent);
const isSafari = /^((?!chrome|android).)*safari/i.test(userAgent);
const TextBox = () => {
  const [isShowStroke, setIsShowStroke] = reactExports.useState(true);
  reactExports.useEffect(() => {
    const handleResize = () => {
      const targetHeight = SCREEN_CONSTANTS.height;
      const targetWidth = SCREEN_CONSTANTS.width;
      const h2 = window.innerHeight;
      const w2 = window.innerWidth;
      const zoomH = h2 / targetHeight;
      const zoomW = w2 / targetWidth;
      const zoomH2 = w2 / targetHeight;
      const zoomW2 = h2 / targetWidth;
      [zoomH, zoomW, zoomH2, zoomW2].forEach((e2) => {
        if (e2 <= 0.2) {
          setIsShowStroke(false);
        } else {
          setIsShowStroke(true);
        }
      });
    };
    window.addEventListener("resize", handleResize);
    handleResize();
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, []);
  const stageState = useSelector((state) => state.stage);
  const userDataState = useSelector((state) => state.userData);
  const textDelay = useTextDelay(userDataState.optionData.textSpeed);
  const textDuration = useTextAnimationDuration(userDataState.optionData.textSpeed);
  let size = getTextSize(userDataState.optionData.textSize) + "%";
  const font = useFontFamily();
  const isText = stageState.showText !== "" || stageState.showName !== "";
  let textSizeState = userDataState.optionData.textSize;
  if (isText && stageState.showTextSize !== -1) {
    size = getTextSize(stageState.showTextSize) + "%";
    textSizeState = stageState.showTextSize;
  }
  const lineLimit = match$1(userDataState.optionData.textSize).with(textSize.small, () => 3).with(textSize.medium, () => 2).with(textSize.large, () => 2).default(() => 2);
  const textArray = compileSentence(stageState.showText, lineLimit);
  const showName = stageState.showName;
  const currentConcatDialogPrev = stageState.currentConcatDialogPrev;
  const currentDialogKey = stageState.currentDialogKey;
  const miniAvatar2 = stageState.miniAvatar;
  const textboxOpacity = userDataState.optionData.textboxOpacity;
  const Textbox = IMSSTextbox;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Textbox,
    {
      textArray,
      isText,
      textDelay,
      showName,
      currentConcatDialogPrev,
      fontSize: size,
      currentDialogKey,
      isSafari,
      isFirefox,
      miniAvatar: miniAvatar2,
      textDuration,
      font,
      textSizeState,
      lineLimit,
      isUseStroke: isShowStroke,
      textboxOpacity
    }
  );
};
function isCJK(character2) {
  return !!character2.match(/[\u4e00-\u9fa5]|[\u0800-\u4e00]|[\uac00-\ud7ff]/);
}
function compileSentence(sentence, lineLimit, ignoreLineLimit) {
  const lines = sentence.split("|");
  const rubyLines = lines.map((line2) => parseString(line2));
  const nodeLines = rubyLines.map((line2) => {
    const ln = [];
    line2.forEach((node2, index2) => {
      match$1(node2.type).with("SegmentType.String", () => {
        const chars2 = splitChars(node2.value);
        ln.push(...chars2);
      }).endsWith("SegmentType.Link", () => {
        const val = node2.value;
        const rubyNode = /* @__PURE__ */ jsxRuntimeExports.jsxs("ruby", { children: [
          val.text,
          /* @__PURE__ */ jsxRuntimeExports.jsx("rt", { children: val.link })
        ] }, index2 + val.text);
        ln.push(rubyNode);
      });
    });
    return ln;
  });
  return nodeLines.slice(0, ignoreLineLimit ? void 0 : lineLimit);
}
function splitChars(sentence) {
  if (!sentence)
    return [];
  const words = [];
  let word = "";
  let cjkFlag = isCJK(sentence[0]);
  const isPunctuation = (ch2) => {
    const regex = /[!-\/:-@\[-`{-~\u2000-\u206F\u3000-\u303F\uff00-\uffef]/g;
    return regex.test(ch2);
  };
  for (const character2 of sentence) {
    if (character2 === " ") {
      if (word) {
        words.push(word);
        word = "";
      }
      words.push("");
      cjkFlag = false;
    } else if (isCJK(character2) && !isPunctuation(character2)) {
      if (!cjkFlag && word) {
        words.push(word);
        word = "";
      }
      words.push(character2);
      cjkFlag = true;
    } else {
      if (isPunctuation(character2)) {
        if (word) {
          word += character2;
          words.push(word);
          word = "";
        } else if (words.length > 0) {
          words[words.length - 1] += character2;
        } else {
          words.push(character2);
        }
        continue;
      }
      if (cjkFlag && word) {
        words.push(word);
        word = "";
      }
      word += character2;
      cjkFlag = false;
    }
  }
  if (word) {
    words.push(word);
  }
  return words;
}
function parseString(input) {
  const regex = /(\[(.*?)\]\((.*?)\))|([^\[\]]+)/g;
  const result = [];
  let match2;
  while ((match2 = regex.exec(input)) !== null) {
    if (match2[1]) {
      const text2 = match2[2];
      const link = match2[3];
      result.push({ type: "SegmentType.Link", value: { text: text2, link } });
    } else {
      const text2 = match2[0];
      result.push({ type: "SegmentType.String", value: text2 });
    }
  }
  return result;
}
const AudioContainer = () => {
  var _a2;
  const stageStore = useSelector((webgalStore2) => webgalStore2.stage);
  const titleBgm = useSelector((webgalStore2) => webgalStore2.GUI.titleBgm);
  const isShowTitle = useSelector((webgalStore2) => webgalStore2.GUI.showTitle);
  const userDataState = useSelector((state) => state.userData);
  const mainVol = userDataState.optionData.volumeMain;
  const vocalVol = mainVol * 0.01 * userDataState.optionData.vocalVolume * 0.01 * stageStore.vocalVolume * 0.01;
  const bgmVol = mainVol * 0.01 * userDataState.optionData.bgmVolume * 0.01 * stageStore.bgm.volume * 0.01;
  const bgmEnter = stageStore.bgm.enter;
  const uiSoundEffects = stageStore.uiSe;
  const seVol = mainVol * 0.01 * (((_a2 = userDataState.optionData) == null ? void 0 : _a2.seVolume) ?? 100) * 0.01;
  const uiSeVol = mainVol * 0.01 * (userDataState.optionData.uiSeVolume ?? 50) * 0.01;
  const isEnterGame = useSelector((state) => state.GUI.isEnterGame);
  const [fadeTimer, setFadeTimer] = reactExports.useState(setTimeout(() => {
  }, 0));
  const bgmFadeIn = (bgm2, maxVol, time) => {
    time >= 0 ? bgm2.volume = 0 : bgm2.volume = maxVol;
    const duration = 10;
    const volumeStep = maxVol / time * duration;
    const fade = () => {
      const timer = setTimeout(() => {
        if (bgm2.volume + volumeStep >= maxVol) {
          bgm2.volume = maxVol;
        } else if (bgm2.volume + volumeStep <= 0) {
          bgm2.volume = 0;
          webgalStore.dispatch(setStage({ key: "bgm", value: { src: "", enter: 0, volume: 100 } }));
        } else {
          bgm2.volume += volumeStep;
          fade();
        }
      }, duration);
      setFadeTimer(timer);
    };
    fade();
  };
  reactExports.useEffect(() => {
    clearTimeout(fadeTimer);
    const bgmElement2 = document.getElementById("currentBgm");
    if (bgmElement2) {
      bgmEnter === 0 ? bgmElement2.volume = bgmVol : bgmFadeIn(bgmElement2, bgmVol, bgmEnter);
    }
  }, [isShowTitle, titleBgm, stageStore.bgm.src, bgmVol, bgmEnter]);
  reactExports.useEffect(() => {
    logger.debug(`${bgmVol}`);
  }, [bgmVol]);
  reactExports.useEffect(() => {
    logger.debug(`: ${bgmEnter}`);
  }, [bgmEnter]);
  reactExports.useEffect(() => {
    logger.debug(`${vocalVol}`);
    const vocalElement = document.getElementById("currentVocal");
    if (vocalElement) {
      vocalElement.volume = vocalVol.toString();
    }
  }, [vocalVol]);
  reactExports.useEffect(() => {
    if (uiSoundEffects === "")
      return;
    const uiSeAudioElement = document.createElement("audio");
    uiSeAudioElement.src = uiSoundEffects;
    uiSeAudioElement.loop = false;
    if (!isNaN(uiSeVol)) {
      uiSeAudioElement.volume = uiSeVol;
    } else {
      logger.error("UI SE Vol is NaN");
      uiSeAudioElement.volume = isNaN(seVol) ? mainVol / 100 : seVol / 100;
    }
    uiSeAudioElement.play();
    uiSeAudioElement.addEventListener("ended", () => {
      uiSeAudioElement.remove();
    });
    webgalStore.dispatch(setStage({ key: "uiSe", value: "" }));
  }, [uiSoundEffects]);
  reactExports.useEffect(() => {
    logger.debug(`: ${seVol}`);
  }, [seVol]);
  reactExports.useEffect(() => {
    logger.debug(`: ${uiSeVol}`);
  }, [uiSeVol]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "audio",
      {
        id: "currentBgm",
        src: isShowTitle ? titleBgm : stageStore.bgm.src,
        loop: true,
        autoPlay: isEnterGame
      },
      isShowTitle.toString() + titleBgm
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("audio", { id: "currentVocal", src: stageStore.playVocal })
  ] });
};
const FullScreenPerform = () => {
  const stageState = useSelector((state) => state.stage);
  let stageWidth = "100%";
  let stageHeight = "100%";
  let top = "0";
  if (stageState.enableFilm !== "") {
    stageHeight = "76%";
    top = "12%";
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$j.FullScreenPerform_main, style: { width: stageWidth, height: stageHeight, top }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "videoContainer" }) });
};
const TextBox_EventHandler = "_TextBox_EventHandler_449dq_2";
const TextBox_main = "_TextBox_main_449dq_10";
const showSoftly = "_showSoftly_449dq_1";
const TextBox_textElement = "_TextBox_textElement_449dq_38";
const TextBox_textElement_start = "_TextBox_textElement_start_449dq_43";
const TextDelayShow = "_TextDelayShow_449dq_1";
const TextBox_textElement_Settled = "_TextBox_textElement_Settled_449dq_48";
const TextBox_showName = "_TextBox_showName_449dq_52";
const miniAvatarContainer = "_miniAvatarContainer_449dq_68";
const miniAvatarImg = "_miniAvatarImg_449dq_76";
const styles$8 = {
  TextBox_EventHandler,
  TextBox_main,
  showSoftly,
  TextBox_textElement,
  TextBox_textElement_start,
  TextDelayShow,
  TextBox_textElement_Settled,
  TextBox_showName,
  miniAvatarContainer,
  miniAvatarImg
};
const TextBoxFilm = () => {
  const stageState = useSelector((state) => state.stage);
  const userDataState = useSelector((state) => state.userData);
  reactExports.useEffect(() => {
  });
  const textDelay = PERFORM_CONFIG.textInitialDelay - 20 * userDataState.optionData.textSpeed;
  const size = userDataState.optionData.textSize * 50 + 200 + "%";
  const textArray = stageState.showText.split("");
  const textElementList = textArray.map((e2, index2) => {
    let delay = index2 * textDelay;
    let prevLength = stageState.currentConcatDialogPrev.length;
    if (stageState.currentConcatDialogPrev !== "" && index2 >= prevLength) {
      delay = delay - prevLength * textDelay;
    }
    if (index2 < prevLength) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          id: `${delay}`,
          className: styles$8.TextBox_textElement_Settled,
          style: { animationDelay: `${delay}ms` },
          children: e2
        },
        stageState.currentDialogKey + index2
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        id: `${delay}`,
        className: styles$8.TextBox_textElement_start,
        style: { animationDelay: `${delay}ms` },
        children: e2
      },
      stageState.currentDialogKey + index2
    );
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "textBoxMain", className: styles$8.TextBox_main, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: size }, children: textElementList }) });
};
function useSetBg(stageState) {
  const bgName = stageState.bgName;
  reactExports.useEffect(() => {
    var _a2, _b2, _c2;
    const thisBgKey = "bg-main";
    if (bgName !== "") {
      const currentBg = (_a2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a2.getStageObjByKey(thisBgKey);
      if (currentBg) {
        if (currentBg.sourceUrl !== bgName) {
          removeBg(currentBg);
        }
      }
      (_b2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _b2.addBg(thisBgKey, bgName);
      setEbg(bgName);
      logger.debug("");
      const { duration, animation: animation2 } = getEnterExitAnimation("bg-main", "enter", true);
      WebGAL.gameplay.pixiStage.registerPresetAnimation(animation2, "bg-main-softin", thisBgKey, stageState.effects);
      setTimeout(() => WebGAL.gameplay.pixiStage.removeAnimationWithSetEffects("bg-main-softin"), duration);
    } else {
      const currentBg = (_c2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _c2.getStageObjByKey(thisBgKey);
      if (currentBg) {
        removeBg(currentBg);
      }
    }
  }, [bgName]);
}
function removeBg(bgObject) {
  var _a2, _b2;
  (_a2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a2.removeAnimationWithSetEffects("bg-main-softin");
  const oldBgKey = bgObject.key;
  bgObject.key = "bg-main-off";
  (_b2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _b2.removeStageObjectByKey(oldBgKey);
  const { duration, animation: animation2 } = getEnterExitAnimation("bg-main-off", "exit", true);
  WebGAL.gameplay.pixiStage.registerAnimation(animation2, "bg-main-softoff", "bg-main-off");
  setTimeout(() => {
    var _a3, _b3;
    (_a3 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a3.removeAnimation("bg-main-softoff");
    (_b3 = WebGAL.gameplay.pixiStage) == null ? void 0 : _b3.removeStageObjectByKey("bg-main-off");
  }, duration);
}
async function fetchFileAsArrayBuffer(url2) {
  const response = await fetch(url2);
  if (!response.ok) {
    throw new Error(`Failed to fetch file: ${response.status} ${response.statusText}`);
  }
  const arrayBuffer = await response.arrayBuffer();
  return new Uint8Array(arrayBuffer);
}
function useSetFigure(stageState) {
  const { figNameLeft, figName, figNameRight, freeFigure, live2dMotion, live2dExpression } = stageState;
  reactExports.useEffect(() => {
    var _a2;
    for (const motion of live2dMotion) {
      (_a2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a2.changeModelMotionByKey(motion.target, motion.motion);
    }
  }, [live2dMotion]);
  reactExports.useEffect(() => {
    var _a2;
    for (const expression of live2dExpression) {
      (_a2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a2.changeModelExpressionByKey(expression.target, expression.expression);
    }
  }, [live2dExpression]);
  reactExports.useEffect(() => {
    var _a2, _b2;
    const thisFigKey = "fig-center";
    const softInAniKey = "fig-center-softin";
    if (figName !== "") {
      const currentFigCenter = (_a2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a2.getStageObjByKey(thisFigKey);
      if (currentFigCenter) {
        if (currentFigCenter.sourceUrl !== figName) {
          removeFig(currentFigCenter, softInAniKey, stageState.effects);
        }
      }
      addFigure(void 0, thisFigKey, figName, "center");
      logger.debug("");
      const { duration, animation: animation2 } = getEnterExitAnimation(thisFigKey, "enter");
      WebGAL.gameplay.pixiStage.registerPresetAnimation(animation2, softInAniKey, thisFigKey, stageState.effects);
      setTimeout(() => WebGAL.gameplay.pixiStage.removeAnimationWithSetEffects(softInAniKey), duration);
    } else {
      logger.debug("");
      const currentFigCenter = (_b2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _b2.getStageObjByKey(thisFigKey);
      if (currentFigCenter) {
        if (currentFigCenter.sourceUrl !== figName) {
          removeFig(currentFigCenter, softInAniKey, stageState.effects);
        }
      }
    }
  }, [figName]);
  reactExports.useEffect(() => {
    var _a2, _b2;
    const thisFigKey = "fig-left";
    const softInAniKey = "fig-left-softin";
    if (figNameLeft !== "") {
      const currentFigLeft = (_a2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a2.getStageObjByKey(thisFigKey);
      if (currentFigLeft) {
        if (currentFigLeft.sourceUrl !== figNameLeft) {
          removeFig(currentFigLeft, softInAniKey, stageState.effects);
        }
      }
      addFigure(void 0, thisFigKey, figNameLeft, "left");
      logger.debug("");
      const { duration, animation: animation2 } = getEnterExitAnimation(thisFigKey, "enter");
      WebGAL.gameplay.pixiStage.registerPresetAnimation(animation2, softInAniKey, thisFigKey, stageState.effects);
      setTimeout(() => WebGAL.gameplay.pixiStage.removeAnimationWithSetEffects(softInAniKey), duration);
    } else {
      logger.debug("");
      const currentFigLeft = (_b2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _b2.getStageObjByKey(thisFigKey);
      if (currentFigLeft) {
        if (currentFigLeft.sourceUrl !== figNameLeft) {
          removeFig(currentFigLeft, softInAniKey, stageState.effects);
        }
      }
    }
  }, [figNameLeft]);
  reactExports.useEffect(() => {
    var _a2, _b2;
    const thisFigKey = "fig-right";
    const softInAniKey = "fig-right-softin";
    if (figNameRight !== "") {
      const currentFigRight = (_a2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a2.getStageObjByKey(thisFigKey);
      if (currentFigRight) {
        if (currentFigRight.sourceUrl !== figNameRight) {
          removeFig(currentFigRight, softInAniKey, stageState.effects);
        }
      }
      addFigure(void 0, thisFigKey, figNameRight, "right");
      logger.debug("");
      const { duration, animation: animation2 } = getEnterExitAnimation(thisFigKey, "enter");
      WebGAL.gameplay.pixiStage.registerPresetAnimation(animation2, softInAniKey, thisFigKey, stageState.effects);
      setTimeout(() => WebGAL.gameplay.pixiStage.removeAnimationWithSetEffects(softInAniKey), duration);
    } else {
      const currentFigRight = (_b2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _b2.getStageObjByKey(thisFigKey);
      if (currentFigRight) {
        if (currentFigRight.sourceUrl !== figNameRight) {
          removeFig(currentFigRight, softInAniKey, stageState.effects);
        }
      }
    }
  }, [figNameRight]);
  reactExports.useEffect(() => {
    var _a2, _b2, _c2;
    for (const fig of freeFigure) {
      const thisFigKey = `${fig.key}`;
      const softInAniKey = `${fig.key}-softin`;
      if (fig.name !== "") {
        const currentFigThisKey = (_a2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a2.getStageObjByKey(thisFigKey);
        if (currentFigThisKey) {
          if (currentFigThisKey.sourceUrl !== fig.name) {
            removeFig(currentFigThisKey, softInAniKey, stageState.effects);
            addFigure(void 0, thisFigKey, fig.name, fig.basePosition);
            logger.debug(`${fig.key}`);
            const { duration, animation: animation2 } = getEnterExitAnimation(thisFigKey, "enter");
            WebGAL.gameplay.pixiStage.registerPresetAnimation(animation2, softInAniKey, thisFigKey, stageState.effects);
            setTimeout(() => WebGAL.gameplay.pixiStage.removeAnimationWithSetEffects(softInAniKey), duration);
          }
        } else {
          addFigure(void 0, thisFigKey, fig.name, fig.basePosition);
          logger.debug(`${fig.key}`);
          const { duration, animation: animation2 } = getEnterExitAnimation(thisFigKey, "enter");
          WebGAL.gameplay.pixiStage.registerPresetAnimation(animation2, softInAniKey, thisFigKey, stageState.effects);
          setTimeout(() => WebGAL.gameplay.pixiStage.removeAnimationWithSetEffects(softInAniKey), duration);
        }
      } else {
        const currentFigThisKey = (_b2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _b2.getStageObjByKey(thisFigKey);
        if (currentFigThisKey) {
          if (currentFigThisKey.sourceUrl !== fig.name) {
            removeFig(currentFigThisKey, softInAniKey, stageState.effects);
          }
        }
      }
    }
    const currentFigures = (_c2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _c2.getFigureObjects();
    if (currentFigures) {
      for (const existFigure of currentFigures) {
        if (existFigure.key === "fig-left" || existFigure.key === "fig-center" || existFigure.key === "fig-right" || existFigure.key.endsWith("-off"))
          ;
        else {
          const existKey = existFigure.key;
          const existFigInState = freeFigure.findIndex((fig) => fig.key === existKey);
          if (existFigInState < 0) {
            const softInAniKey = `${existFigure.key}-softin`;
            removeFig(existFigure, softInAniKey, stageState.effects);
          }
        }
      }
    }
  }, [freeFigure]);
}
function removeFig(figObj, enterTikerKey, effects) {
  var _a2, _b2, _c2;
  (_a2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a2.removeAnimationWithSetEffects(enterTikerKey);
  if (WebGAL.gameplay.isFast) {
    logger.info("");
    (_b2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _b2.removeStageObjectByKey(figObj.key);
    return;
  }
  const oldFigKey = figObj.key;
  figObj.key = figObj.key + "-off";
  (_c2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _c2.removeStageObjectByKey(oldFigKey);
  const figKey = figObj.key;
  const leaveKey = figKey + "-softoff";
  const { duration, animation: animation2 } = getEnterExitAnimation(figKey, "exit");
  WebGAL.gameplay.pixiStage.registerPresetAnimation(animation2, leaveKey, figKey, effects);
  setTimeout(() => {
    var _a3, _b3;
    (_a3 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a3.removeAnimation(leaveKey);
    (_b3 = WebGAL.gameplay.pixiStage) == null ? void 0 : _b3.removeStageObjectByKey(figKey);
  }, duration);
}
function addFigure(type2, ...args) {
  var _a2, _b2;
  const url2 = args[1];
  if (url2.endsWith(".json")) {
    return addLive2dFigure(...args);
  } else if (url2.endsWith(".skel")) {
    return (_a2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a2.addSpineFigure(...args);
  } else if (url2.endsWith(".png")) {
    fetchFileAsArrayBuffer(url2).then((arrayBuffer) => {
      var _a3;
      return (_a3 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a3.addFigure(...args, isAnimatedPNG(arrayBuffer));
    });
  } else {
    return (_b2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _b2.addFigure(...args);
  }
}
function addLive2dFigure(...args) {
}
function isAnimatedPNG(bytes) {
  const magic = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);
  if (!bytes.slice(0, 8).every((v2, i2) => v2 === magic[i2])) {
    return false;
  }
  const apngSignature = new Uint8Array([97, 99, 84, 76]);
  const apngSignatureOffset = 37;
  if (!bytes.slice(apngSignatureOffset, apngSignatureOffset + 4).every((v2, i2) => v2 === apngSignature[i2])) {
    return false;
  }
  return true;
}
function setStageObjectEffects(stageState) {
  const effects = stageState.effects;
  setTimeout(() => {
    setStageEffects(effects);
  }, 10);
}
function setStageEffects(effects) {
  var _a2, _b2, _c2, _d;
  const stageObjects = ((_a2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a2.getAllStageObj()) ?? [];
  for (const stageObj of stageObjects) {
    const key = stageObj.key;
    const effect = effects.find((effect2) => effect2.target === key);
    const lockedStageTargets = ((_b2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _b2.getAllLockedObject()) ?? [];
    if (!lockedStageTargets.includes(key)) {
      if (effect) {
        const targetPixiContainer = (_c2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _c2.getStageObjByKey(key);
        if (targetPixiContainer) {
          const container2 = targetPixiContainer.pixiContainer;
          Object.assign(container2, convertTransform(effect.transform));
        }
      } else {
        const targetPixiContainer = (_d = WebGAL.gameplay.pixiStage) == null ? void 0 : _d.getStageObjByKey(key);
        if (targetPixiContainer) {
          const container2 = targetPixiContainer.pixiContainer;
          Object.assign(container2, convertTransform(baseTransform));
        }
      }
    }
  }
}
function convertTransform(transform) {
  if (!transform) {
    return {};
  }
  const { position: position2, ...rest } = transform;
  return { ...rest, x: position2.x, y: position2.y };
}
function MainStage() {
  const stageState = useSelector((state) => state.stage);
  useSetBg(stageState);
  useSetFigure(stageState);
  setStageObjectEffects(stageState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "none" } });
}
const introContainer = "_introContainer_119k8_1";
const styles$7 = {
  introContainer
};
function IntroContainer() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$7.introContainer, id: "introContainer" });
}
function inTextBox(event) {
  const tb2 = document.getElementById("textBoxMain");
  if (!tb2) {
    return false;
  }
  let bounds = tb2.getBoundingClientRect();
  return event.clientX > bounds.left && event.clientX < bounds.right && event.clientY > bounds.top && event.clientY < bounds.bottom;
}
function checkMousePosition(event, GUIState, dispatch) {
  if (!GUIState.controlsVisibility && inTextBox(event)) {
    dispatch(setVisibility({ component: "controlsVisibility", visibility: true }));
  }
  if (GUIState.controlsVisibility && !inTextBox(event)) {
    dispatch(setVisibility({ component: "controlsVisibility", visibility: false }));
  }
}
function isTextboxHidden(stageState, GUIState) {
  var _a2;
  if (!GUIState.showTextBox) {
    return true;
  }
  if (stageState.isDisableTextbox) {
    return true;
  }
  const isText = stageState.showText !== "" || stageState.showName !== "";
  if (!isText) {
    return true;
  }
  const isInIntro = ((_a2 = document.getElementById("introContainer")) == null ? void 0 : _a2.style.display) === "block";
  if (isInIntro) {
    return true;
  }
  return false;
}
let timeoutEventHandle = null;
function updateControlsVisibility(event, stageState, GUIState, dispatch) {
  if (isTextboxHidden(stageState, GUIState)) {
    if (timeoutEventHandle) {
      clearTimeout(timeoutEventHandle);
    }
    dispatch(setVisibility({ component: "controlsVisibility", visibility: true }));
    timeoutEventHandle = setTimeout(() => {
      dispatch(setVisibility({ component: "controlsVisibility", visibility: false }));
    }, 1e3);
  } else {
    checkMousePosition(event, GUIState, dispatch);
  }
}
const Stage = () => {
  const stageState = useSelector((state) => state.stage);
  const GUIState = useSelector((state) => state.GUI);
  const dispatch = useDispatch();
  useHotkey();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$a.MainStage_main, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(FullScreenPerform, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(MainStage, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "pixiContianer", className: styles$a.pixiContainer, style: { zIndex: isIOS ? "-5" : void 0 } }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "chooseContainer", className: styles$a.chooseContainer }),
    GUIState.showTextBox && stageState.enableFilm === "" && !stageState.isDisableTextbox && /* @__PURE__ */ jsxRuntimeExports.jsx(TextBox, {}),
    GUIState.showTextBox && stageState.enableFilm !== "" && /* @__PURE__ */ jsxRuntimeExports.jsx(TextBoxFilm, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AudioContainer, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        onClick: () => {
          if (!GUIState.showTextBox) {
            dispatch(setVisibility({ component: "showTextBox", visibility: true }));
            return;
          }
          stopAll();
          nextSentence();
        },
        onDoubleClick: () => {
          WebGAL.events.fullscreenDbClick.emit();
        },
        id: "FullScreenClick",
        style: { width: "100%", height: "100%", position: "absolute", zIndex: "12", top: "0" },
        onMouseMove: (e2) => !GUIState.showControls && updateControlsVisibility(e2, stageState, GUIState, dispatch)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(IntroContainer, {})
  ] });
};
const BottomControlPanel = () => {
  const t2 = useTrans("gaming.");
  const { i18n } = useTranslation();
  const { playSeEnter, playSeClick, playSeDialogOpen } = useSoundEffect();
  const lang2 = i18n.language;
  const isFr = lang2 === "fr";
  let fontSize = "150%";
  if (isFr) {
    fontSize = "125%";
  }
  const GUIStore = useSelector((state) => state.GUI);
  const stageState = useSelector((state) => state.stage);
  const dispatch = useDispatch();
  const setComponentVisibility = (component, visibility) => {
    dispatch(setVisibility({ component, visibility }));
  };
  const saveData = useSelector((state) => state.saveData.saveData);
  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: "100%", width: "100%", display: "flex", justifyContent: "center", alignItems: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "125%" }, children: t2("noSaving") }) });
  if (saveData[0]) {
    const data2 = saveData[0];
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$i.slPreviewMain, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$i.imgContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { style: { height: "100%" }, alt: "q-save-preview image", src: data2.previewImage }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$i.textContainer, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: data2.nowStageState.showName }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "75%", color: "rgb(55,60,56)" }, children: data2.nowStageState.showText })
      ] })
    ] });
  }
  return (
    // <div className={styles.ToCenter}>
    /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: GUIStore.showTextBox && stageState.enableFilm === "" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$i.main, style: { visibility: GUIStore.controlsVisibility ? "visible" : "hidden" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          id: "Button_ControlPanel_fast",
          className: `${styles$i.singleButton} ${styles$i.fastForwardButton}`,
          style: { fontSize },
          title: "",
          onClick: () => {
            switchFast();
            playSeClick();
          },
          onMouseEnter: playSeEnter
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          id: "Button_ControlPanel_auto",
          className: `${styles$i.singleButton} ${styles$i.autoButton}`,
          style: { fontSize },
          title: "",
          onClick: () => {
            switchAuto();
            playSeClick();
          },
          onMouseEnter: playSeEnter
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: `${styles$i.singleButton} ${styles$i.flashbackButton}`,
          style: { fontSize },
          title: "",
          onClick: () => {
            setComponentVisibility("showBacklog", true);
            setComponentVisibility("showTextBox", false);
            playSeClick();
          },
          onMouseEnter: playSeEnter
        }
      )
    ] }) })
  );
};
const Backlog = () => {
  var _a2, _b2;
  useTrans("gaming.");
  const { playSeEnter, playSeClick } = useSoundEffect();
  const GUIStore = useSelector((state) => state.GUI);
  const dispatch = useDispatch();
  const [indexHide, setIndexHide] = reactExports.useState(false);
  const [isDisableScroll, setIsDisableScroll] = reactExports.useState(false);
  let timeRef = reactExports.useRef();
  const backlogList = reactExports.useMemo(() => {
    let backlogs = [];
    for (let i2 = 0; i2 < WebGAL.backlogManager.getBacklog().length; i2++) {
      const backlogItem = WebGAL.backlogManager.getBacklog()[i2];
      const showTextArray = compileSentence(backlogItem.currentStageState.showText, 3, true);
      const showTextArrayReduced = mergeStringsAndKeepObjects(showTextArray);
      const showTextElementList = showTextArrayReduced.map((line2, index2) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: line2.map((e2, index22) => {
          if (e2 === "<br />") {
            return /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}, `br${index22}`);
          } else {
            return e2;
          }
        }) }, `backlog-line-${index2}`);
      });
      const singleBacklogView = /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: styles$h.backlog_item,
          style: { animationDelay: `${20 * (WebGAL.backlogManager.getBacklog().length - i2)}ms` },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$h.backlog_func_area, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$h.backlog_item_button_list, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$h.backlog_item_content_name, children: backlogItem.currentStageState.showName && `${backlogItem.currentStageState.showName}` || "" }),
              backlogItem.currentStageState.vocal ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  onClick: () => {
                    playSeClick();
                    const backlog_audio_element = document.getElementById("backlog_audio_play_element_" + i2);
                    if (backlog_audio_element) {
                      backlog_audio_element.currentTime = 0;
                      const userDataStore = webgalStore.getState().userData;
                      const mainVol = userDataStore.optionData.volumeMain;
                      backlog_audio_element.volume = mainVol * 0.01 * userDataStore.optionData.vocalVolume * 0.01;
                      backlog_audio_element == null ? void 0 : backlog_audio_element.play();
                    }
                  },
                  onMouseEnter: playSeEnter,
                  className: styles$h.backlog_item_button_element,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$h.sound_icon })
                }
              ) : null
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$h.backlog_item_content, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$h.backlog_item_content_text, children: showTextElementList }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("audio", { id: "backlog_audio_play_element_" + i2, src: backlogItem.currentStageState.vocal })
          ]
        },
        "backlogItem" + backlogItem.currentStageState.showText + backlogItem.saveScene.currentSentenceId
      );
      backlogs.unshift(singleBacklogView);
    }
    return backlogs;
  }, [
    ((_b2 = (_a2 = WebGAL.backlogManager.getBacklog()[WebGAL.backlogManager.getBacklog().length - 1]) == null ? void 0 : _a2.saveScene) == null ? void 0 : _b2.currentSentenceId) ?? 0
  ]);
  reactExports.useEffect(() => {
    if (GUIStore.showBacklog) {
      if (timeRef.current) {
        clearTimeout(timeRef.current);
      }
      setIndexHide(false);
      setIsDisableScroll(true);
      setTimeout(() => {
        setIsDisableScroll(false);
      }, 0);
    } else {
      timeRef.current = setTimeout(() => {
        setIndexHide(true);
        timeRef.current = void 0;
      }, 700 + 80);
    }
  }, [GUIStore.showBacklog]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    // ${indexHide ? styles.Backlog_main_out_IndexHide : ''}
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `
          ${GUIStore.showBacklog ? styles$h.Backlog_main : styles$h.Backlog_main_out}
          ${indexHide ? styles$h.Backlog_main_out_IndexHide : ""}
          `,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$h.backlog_top, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: styles$h.backlog_top_icon,
                onClick: () => {
                  playSeClick();
                  dispatch(setVisibility({ component: "showBacklog", visibility: false }));
                  dispatch(setVisibility({ component: "showTextBox", visibility: true }));
                },
                onMouseEnter: playSeEnter
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: styles$h.backlog_title,
                onClick: () => {
                  logger.info("Rua! Testing");
                }
              }
            )
          ] }),
          GUIStore.showBacklog && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${styles$h.backlog_content} ${isDisableScroll ? styles$h.Backlog_main_DisableScroll : ""}`, children: backlogList })
        ]
      }
    )
  });
};
function mergeStringsAndKeepObjects(arr) {
  let result = [];
  let currentString = "";
  for (let i2 = 0; i2 < arr.length; i2++) {
    const currentItem = arr[i2];
    if (typeof currentItem === "string") {
      currentString += currentItem;
    } else {
      if (currentString !== "") {
        result.push(currentString);
        currentString = "";
      }
      result.push(currentItem);
    }
  }
  if (currentString !== "") {
    result.push(currentString);
  }
  return result;
}
const extra = "_extra_1lvbj_2";
const extra_top = "_extra_top_1lvbj_13";
const backIcon$1 = "_backIcon_1lvbj_19";
const backTitle$1 = "_backTitle_1lvbj_23";
const mainContainer = "_mainContainer_1lvbj_37";
const mainTab = "_mainTab_1lvbj_43";
const mainTab_bg = "_mainTab_bg_1lvbj_53";
const mainTab_item1 = "_mainTab_item1_1lvbj_62";
const mainTab_item2 = "_mainTab_item2_1lvbj_70";
const mainTab_bgmunselect = "_mainTab_bgmunselect_1lvbj_78";
const mainTab_unselect = "_mainTab_unselect_1lvbj_82";
const mainTab_choose = "_mainTab_choose_1lvbj_87";
const mainTab_choose_bgm = "_mainTab_choose_bgm_1lvbj_93";
const mainTab_choose_cg = "_mainTab_choose_cg_1lvbj_99";
const bgmContainer = "_bgmContainer_1lvbj_104";
const bgmListContainer = "_bgmListContainer_1lvbj_109";
const bgmElement = "_bgmElement_1lvbj_116";
const bgmStar = "_bgmStar_1lvbj_125";
const bgmName = "_bgmName_1lvbj_129";
const bgm_item_name = "_bgm_item_name_1lvbj_140";
const bgmNameActive = "_bgmNameActive_1lvbj_148";
const soundChoose$1 = "_soundChoose_1lvbj_170";
const soundunselect$1 = "_soundunselect_1lvbj_174";
const unlockBgm$1 = "_unlockBgm_1lvbj_185";
const footer = "_footer_1lvbj_189";
const footerButton = "_footerButton_1lvbj_199";
const footer_page_container = "_footer_page_container_1lvbj_205";
const footerPageIcon = "_footerPageIcon_1lvbj_210";
const cgMain = "_cgMain_1lvbj_222";
const cgContainer = "_cgContainer_1lvbj_227";
const cgElement = "_cgElement_1lvbj_233";
const cgUnLock$1 = "_cgUnLock_1lvbj_251";
const cgShowDiv = "_cgShowDiv_1lvbj_260";
const cgShowDivWarpper = "_cgShowDivWarpper_1lvbj_269";
const cgNav = "_cgNav_1lvbj_278";
const cgNav_active = "_cgNav_active_1lvbj_297";
const showFullContainer = "_showFullContainer_1lvbj_307";
const showFullCgMain = "_showFullCgMain_1lvbj_320";
const fullCgIn = "_fullCgIn_1lvbj_1";
const extra_icon_softin = "_extra_icon_softin_1lvbj_1";
const bgmElement_In = "_bgmElement_In_1lvbj_1";
const styles$6 = {
  extra,
  extra_top,
  backIcon: backIcon$1,
  backTitle: backTitle$1,
  mainContainer,
  mainTab,
  mainTab_bg,
  mainTab_item1,
  mainTab_item2,
  mainTab_bgmunselect,
  mainTab_unselect,
  mainTab_choose,
  mainTab_choose_bgm,
  mainTab_choose_cg,
  bgmContainer,
  bgmListContainer,
  bgmElement,
  bgmStar,
  bgmName,
  bgm_item_name,
  bgmNameActive,
  soundChoose: soundChoose$1,
  soundunselect: soundunselect$1,
  unlockBgm: unlockBgm$1,
  footer,
  footerButton,
  footer_page_container,
  footerPageIcon,
  cgMain,
  cgContainer,
  cgElement,
  cgUnLock: cgUnLock$1,
  cgShowDiv,
  cgShowDivWarpper,
  cgNav,
  cgNav_active,
  showFullContainer,
  showFullCgMain,
  fullCgIn,
  extra_icon_softin,
  bgmElement_In
};
const bgmstar = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAlCAMAAAAdgrsPAAAAilBMVEUAAADMoW7MoW7MoW7MoW7Mom7MoW7LoG7NomzMoW7Mom7MoW3SnnDMoW7MoW7Nom7Mom/Mn23MoW/MoW7MoW7NoW7Nom3MoW7MoW7MoW7MoW7MoG7Mom/Lo27QqGvMoW7NoG7MoW7MoW7Mn2zMoW7MoW7MoW7NoW7NoG7MoW3Nn23No23MoW3MoW4dJKs/AAAALXRSTlMA9+Rn7r8mIRf78TQG9blxHRHqs5qSMNrEo3ZdVEEM0ql+bgrIlotrYUk4Kq0q5+dsAAABYUlEQVQ4y4WS2ZKCMBREQwiRZVBEcEcZl9FxvP//e9M3KlHWfgip5NTppIJoZOOLwWi5HmRGahG4A8wf3cWWJv0eZ4bRpT6XJjDIlS7dnnjMZK9LB+wp4qyHSozn5hB943uha7cHDKgOV6I8jPOQ6EVNaFM/c/DqspRba/QfHkVV1g1X4rAniok+qcsb5adLfhFFH5kY17byeNZTcx2eLl8aT0qNHLC+Nq4kNZ6wgdjGnUhPmO0cas3WNHoilzchvmatjBwB8k6ozWmO6biFSXljKb8E8kMjuMp2T7kwDFyOZm2NCSMszuTRIMaFheP4k+GuPTxVctKgTu9MwXJZMdZlG+PIemwyPv10/2ScX76w3Ila8mAOavlgCnv3uivBQy7ABOzJUniaOQc+KDQys1KtDDbCKX5kz2WPwrQ9WaifOJjOlGjkYoVPd1aOxhDD05e7ivIwEQM5k4RnKGXRWPoH9XpDC76aFakAAAAASUVORK5CYII=";
const soundunselect = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAApCAMAAACfvvDEAAAARVBMVEUAAACjn5KkoJKjn5KhoZajoJKjn5Kkn5KjoJKjn5KjoJOkn5CinpOonZOjn5KjoJKkoJKkn5Kkn5KhoZSjn5Kjn5Kjn5IsEpImAAAAFnRSTlMAxUXuCM1kstZqTCIyDopbvJN6F+SmE1gEQwAAANhJREFUOMvV1NkKwyAQBdCJW4zZt/n/T20phFGvhkKhtPdxOI5cHySMObUO6WhsFWF6z8xNetYyO4BK8zM2hw0s7fiVJoMtbJwYZBGalkUmELuIBAhdRArELiCLcGKUYwr31XpvPaM0PoUHX4GdGy8kObkuKZhI6jtJ9A9yVEFdCcOdHOKJ/Vzi7b/7Sl+Q/m0538jebzHdqtIc2XfUz87NTqOkmYVG3qMkVaSmBVmjNIGs0g5klSotEij0EgkUeokU2plKL0tAqdxrTUeB151KdFmGbORGegBEuzvRbRli8wAAAABJRU5ErkJggg==";
const soundChoose = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAfCAMAAADHso01AAAAflBMVEUAAADMo2/MoW7MoW7Nom7Mom7LoW/JomzNom7MoW7NoW7LoW7MoW7MoW7NoW7NoW7MoW7MoW7Mom7MoW7Mom7MoW/MoW/MoW7NoG7Nom7Mom/MoW7Oom/QoG/MoW7MoW3MoW7MoW3MoW7MoG7NoW7Ko27LnW/MoG3Mom7MoW5Q7m+KAAAAKXRSTlMAGOfHqzANBZBgVjXj0b+g8+7dzZmJdk5HPjgoIRrq4tm6tJaFHRNpaOe5EZ4AAADhSURBVCjPpdHZboMwFARQHMAGzB72Jc3ezv//YCuE8b0NUlVl3sZHo/tgh+dRtbbIUfziBpkt2mu4ZsBhWzxjJBSnI4DTY21jiawnOhSAXYsDKrr9BAj7HwioBqD85CpTUJ4T1KuosLrdXVAW8bbtPQOWlXt11lzwwj+uDCevTOP+n6X2lwzjLkemJLusU29JWv9x+00+vsVNucPBfXN9ictzznguEJHPlk6fs3WXI2Q3/DO7PQARc3Wl7EQwe5Pa8q6HC89ra4EvyVyfgGIyrQNcvhcpfWnjzOGZbp0tSshvs8g5Z5pFnYwAAAAASUVORK5CYII=";
const unlockBgm = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATIAAAAlCAMAAAD2vJVgAAAAZlBMVEUAAACjl3Sjl3Skl3SgkXGkmHSll3WllXWnl3ekl3OkmHSkl3OklnSjlnOlmHWkmHSkl3Skm3mkl3SkmHSkl3Skl3Skl3SkmHSjl3Skl3Skl3SkmHOkl3Skl3Sll3Skl3SkmHSkl3R6q9AEAAAAIXRSTlMAQIC/D/BgMCDgz59xUK+P6Qj3NrZnJ20c2ZgWw6hYyUapiqt7AAADg0lEQVRo3u2Z227qMBREfbdzJQTKpdAW//9PHjaOzlbqxK4t85b1AKhbGibjcWJU4nH7JhtptMOJbKTwYa/SkI2EjtmO9HbrWUrHPp6vx3Hr2d8TU/C29SyxY6etZ4mJfY4PyOw9PRMdYy1dHRvFmNKrY8oYoyJTW7eMdSainWhM2fPzlVk7Hp7vfLyQ0ujevpDNovWuduOKLVkXjXTjnmZos8qNa0UStAPGsGMMRiN9S8+URVp/3OBU+s61xHEjErVFjdPaJGgHjanXN7XT5NUzeSmeGLJbMoZ0C1eF1GnakBgiTYJ2wJjCjgHj4dUzU3JX2jn094FwhhTzi67mY5ak3c+nnMS148a+p47hREPPhoI94053R2m/sJrCrXTV0q7+3RRcy6aj0yeRoE2npBRVEpsS1I4bU/Y8T6z8M4BOK4GrvuC7Fv9XnS/4VrjqNEGbu0iwjiyiHTXmdwwd3IcbKUPjNPES57u+csbQZeXfqhR5gZ//pm2mxDC+JqIdNuZ1DJFFe6bpE03WIqOAISuRGQqQpcuKawsKCC+ygHbMmOvY2XoMcMr4gZ4VZmeB1XGN/V+gswDN0zYSpixHG42J5cSwZ/fsZ0DYWB++6DZ40TJTu7aAztFGY3d7dt+0xChePSNF0TK4lso/ZPhHLJan3eAhI1kbjZ1/QOEk7RJfe0IO1e4diTXhA68KXlUtkrUxMakj2lFj++oOwQzWB/p9swUTw2f6LnwWUcHDHRdZ2swClY5px43trz/Qs8HvGCQ2lEsMjckuGGitgxfN8rSpq4HI0kZjU2bH5+tBWv93hRk/SVHo+v0XH+Mi6LvN1OZu48S148Ygs6uf2RG2K5S8KI1/r/EOjir4w77K1DYWMHnavrF9BZWi0iJwgzvZT1IYGTz46PCBrYcpy9RuYcpj2nFj2LMaejbirizfMVxqElxqHl5qmq6NHWQR7RRjYoD72cNl5p60pnzHiObAemQwXV8nDuhM7R1MVUQ7ydi+qjEzeNJenoltePg96yCxq3hGODSkPIICq2MD08C/SwCRqa1haiLaicb2A4fM3K4UkFh5aPh+w8L3MgvQTG0OUxbRTjUmBji8nrmB+PAAs0WGxpb3JiAkdmyLLGjsJnv3KOjxb1tkYWNCcrdB34RhwHqiMFXriQImU1vBlEa0c4xdZHOojmQjAVFt57FUHl9kI8Q/jBHBgXl48ZQAAAAASUVORK5CYII=";
const footerLeft = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC8AAAAcCAMAAADGFxadAAAAb1BMVEUAAAC6qnC4m3S9pHi+oXTCnnm/oXS3mnO6nXXAoXS3mnTarXS3mnS6m3TKqHS8nHTGonO6nXTkzXy2mXTYsnTpz3jmvXXXrXS6nHS3mnTDoXS+nnTPqHTivXXmyHncsXTp0Ifp1nXmtHTozXXr14yTubLtAAAAGHRSTlMACc8gihVcNUbvvfvxffrgs6KC+W7heJj6ex09AAABO0lEQVQ4y5WTW26DMBBFbWwICYSElqR+m0f2v8aOPaWxIlWdnA8E6NzrsRHsBS4OmVaw/+HyVPU6UwmCftI7F4peKZVcpVRVU9pBRJ3ajtDbgTfbrbXkdtQvnNKuUTdWMtK5o23spRwm3/PmnGkSbQtvRLXr5ezNF8dQpRGVkFDw1IuTmbruynHWQq84q/dhnEEhS/cY43CtX30Yp9UadfDZjljX6KwaCx8sfB416p1zvwE+RWdU3zIg+UiPu5NZj37tnHxu19hj1gu/YYi0g3M+rLFz0zNwPcAVdnT6BHpgZDvnwcWwpQW8YK+kH04A5ZeRg98Wv7r4uHFGQfpl8THOj4UY+FiWsM6PedtuNTEQQA9b8AMxsIEegnfmKGiBOfikAy0t4D3qxjakwL0bjhlLW0FM8ofxrwW+AdIuJZ+t8/IQAAAAAElFTkSuQmCC";
const footerRight = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC8AAAAcCAMAAADGFxadAAAAb1BMVEUAAAC6qnC4m3S+oXS3n3jCnnm/oXS3mnO6nXXAoXS3mnTarXS2mXS3mnS6m3TKqHS8nHTGonO6nXTkzXzYsnTpz3jmvXXoyXzXrXS5m3TDoXS+nnTPqHTivXXmyHncsXTp0Ifp1nXmtHTozXXr14wBxdtKAAAAGXRSTlMACc+KIBVcNUbvvfv58X364LOigm7heCGYcWESUwAAATJJREFUOMvVktlyhCAQRV3AdRyXODNRGlDx/78xDShMkkrJa45PwLmXaovoD7IhPRhJFEAxs9LQ1s8ohIzNGuCcfwQFCqsLLpawACm1LsSyq7AAbblQqC9iDQw8lEJ9E2tgIH6s+yIlX1eeBgZ2CRtfFW/fA5QgeZ6TX4EXh3rjSkho725zaJAbUmEjrvM+c2cj1HITHKBl5w3ZdJLYP1+y2QdSfYEEmNlkA7T57hfNNIMc4zPQA9Rax/NBbw5GveE3JXbNQG7bK3KB2epIgXWTw/q0b6WUT9cfo3/oFY3i5HBdPwp1Pfpn0eHLY64und77qW389OPSxOtET1dkmrshM/0Y8rpvr+LompSh7We7IO4YQz20nSaoh7eTzqjh7Sj+03ZytDdJlaJ+7Re5gfyUvwByHCYG+3PjrAAAAABJRU5ErkJggg==";
const footerChecked = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAArCAMAAADWg4HyAAAAVFBMVEUAAADWzKvRzajPzafPzajRzajRzajQzKfSzaXRzajRzKfPzKfRzKfRzKfRzKfQzKfQzKfQzKfQzajQzKfQzafQzKfQzajRzafQzKbQzKjQzKfQzKc7tqF2AAAAG3RSTlMABwwSHCMxKRdBRjo3z5/26sJw4LmUXVDYinxg3KdKAAABSUlEQVQ4y+XUy3KEIBAF0BgRacD3axz+/z/TjU7EuZaVbWruwtWpWw0CX/8+2Z4/wO/fAAeZc4yR762O0iilioI/5k5nItmVMeJZC76mIrX2znmvdVkos2OkRrF0RFZCTusEI9WebD8OTdNW9UKOqwVfLIupo7kKe5rJMo7NUBtbnyFJx7hQbGECnpX6EABLMdbSMoRzJuIpwBpVeluHt7TLVpxaGUG7vj3UURwnhhGgVib2JVpeWYe2vbbeVmgb6/h/YO+NxXlHtMM2A9oJ7bhvMOzZ/AC7vvYMNmJ9pw/r4lHDf+xgdU+oFZwbKZ7bE63Jc+31QfM0Dyk9nUk8wLZuXrP2JNRc2ny7bss6VlVX95b8mSLeLicRyzKhiE3UWm48y+QaI5a7rIr4mhRRHhSwVAuXGJGnAbCaOQfevvtHNUOJYSTus/IDOXEre+Hq+EwAAAAASUVORK5CYII=";
const footerUncheck = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAMAAAC7IEhfAAAATlBMVEUAAAA5LkQ5LUQ5LUQ6KUo5LUM5LkM4LUQ4LUM5LUQ4LkQ5LkQ5LEU7MEU5LkQ5L0Q5LkQ5LkQ4LkQ4LkQ5LUQ4LkM5L0MxMUU5LUM5LkTE65YzAAAAGXRSTlMA97x3B/DftaJuZkkpGObb0MqUelk9Mw2uOnfYlQAAAIpJREFUOMvt0kkOgzAMQFFnBpKWqUB9/4uyQGKyHdgi8ddPcWQZ3p5SMkUIXbQXbNS45PosLXGr/cjO4L5alAMe0xJs8NSPdxHPtTwskMT/siZOmK0oNCzEu/BLYcXCQGFiYUWcB7aJzO6J4Z/0lhB25WoEKfvfORezB+nW00mQbSq1V6rpBnh7SDMrbRzSDw53wwAAAABJRU5ErkJggg==";
function ExtraBgm() {
  const { playSeClick, playSeEnter } = useSoundEffect();
  const [page, setPage] = reactExports.useState(1);
  const [list, setList] = reactExports.useState([]);
  const currentBgmSrc = useSelector((state) => state.GUI.titleBgm);
  const extraState = useSelector((state) => state.userData.appreciationData);
  const initName = "Title_BGM";
  let foundCurrentBgmName = initName;
  const bgmListLen = extraState.bgm.length;
  extraState.bgm.forEach((e2, i2) => {
    if (e2.url === currentBgmSrc) {
      foundCurrentBgmName = e2.name;
    }
  });
  const currentPlayingBgmName = useValue("");
  if (foundCurrentBgmName !== initName && foundCurrentBgmName !== currentPlayingBgmName.value) {
    currentPlayingBgmName.set(foundCurrentBgmName);
  }
  const dispatch = useDispatch();
  reactExports.useEffect(() => {
    setList(extraState.bgm.slice((page - 1) * 8, page * 8) || []);
  }, [extraState.bgm, page]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.bgmContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.bgmListContainer, children: [
      list.map((e2, i2) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            onClick: () => {
              playSeClick();
              currentPlayingBgmName.set(e2.name);
              dispatch(setGuiAsset({ asset: "titleBgm", value: e2.url }));
            },
            className: styles$6.bgmElement,
            onMouseEnter: playSeEnter,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: bgmstar, alt: "", className: styles$6.bgmStar }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${styles$6.bgmName} ${e2.name === currentPlayingBgmName.value ? styles$6.bgmNameActive : ""}`, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.bgm_item_name, children: e2.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    src: e2.name === currentPlayingBgmName.value ? soundChoose : soundunselect,
                    alt: "",
                    className: e2.name === currentPlayingBgmName.value ? styles$6.soundChoose : styles$6.soundunselect
                  }
                )
              ] })
            ]
          },
          e2.name
        );
      }),
      Array.from({ length: 8 - list.length }).map((e2, i2) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.bgmElement, style: { cursor: "default" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: unlockBgm, alt: "", className: styles$6.unlockBgm }) });
      })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.footer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: footerLeft,
          alt: "",
          className: styles$6.footerButton,
          onClick: () => {
            playSeClick();
            if (page > 1) {
              setPage(page - 1);
            }
          },
          onMouseEnter: playSeEnter
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.footer_page_container, children: Array.from({ length: Math.ceil(bgmListLen / 8) }).map((e2, i2) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: i2 + 1 === page ? footerChecked : footerUncheck, alt: "", className: styles$6.footerPageIcon });
      }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: footerRight,
          alt: "",
          className: styles$6.footerButton,
          onClick: () => {
            playSeClick();
            if (page === Math.ceil(bgmListLen / 8)) {
              return;
            }
            setPage(page + 1);
          },
          onMouseEnter: playSeEnter
        }
      )
    ] })
  ] });
}
const extraCG_animation_List = "";
const cgUnLock = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWEAAADHBAMAAAA64/+jAAAAJFBMVEUAAADt3Mj////58un7+PT////////58uv////58uz38Oj69O7JqzR4AAAACHRSTlMATgdQRxsyiwdvgToAAARdSURBVHja7d09rtNAEMBxyxXtalZCQGNZygFGa4l6tVYO8KTkBEl6qtdi+RW5AkeAUzL7Ea/j5cFDslFGzP+Zgib6aTQbDBRbXW811QNXT8yvHMUVq96JeJmIRbxlWfxdzdNd57re9L3rQ6eL73jw7dpYXa1VXddtaLc7+M4X3+m071NWLfv4tfqRf2etAw3Oud50XR/a7/deHMhPwdyE1gHTTxPET09PB+p4PHowkcmsbawQ5xkbMLMInad8Pgcy1a4fYXfRGyZM2JRzaNDAqzMGBTCZadD3Mz6HGe/aidy8rbb+9VOgqXPcin0yO+3BiFDMeJ51QNauv1uKM43Yg9tUtVZNgtMkMvl06YPZ+sXQQVWK36OitNbgdOdir+xxGu464Hz0DmmPbydvb3sdNlnPzLAUKzSYVjgUtjiucdzjvBO1h9fVn5/fcOkD2iaOmIrnLi4FgXuK0GRWOWJmcfAuS1NO32/BvMXRo++JWJpwf6uLjCyeZvz8/Izq+tgNkclO/GW2FQzEfiu4iXESg2IhhjxjxUOsuIp/sBPzm7GIYyIWcZmIRVwm4rn4m4hTshUiLpI9Zj1jfmLZipiIRVwmYvmuKBMxb7HscUzEvMX89ljEMRGLuEzEIi4TMW8xv/cKEadkj0VcJGLeJ4+fmN9WiDgmYhGXiVjEZSIWcZmIRVwmYhGXiVjEZSK+DshOzG/GIl4mYjl5ZSLmKJY9XiZiEf+DRuAm5jdjEReJ+DogchPzmzFb8Qc24pHfuxsAsxnz2wqGYuQmHlH2eJGIOe6xAeAlZrgVIt68kd3Jkzeh7RssN/EI7MQKkZdY9nj7Bs1NPKKyzMQgJ6/sf99jft8Vo5E93roBLTcxuxmPxuh7MV4fuxHkb/9bN1g5eVs3GkR+Jw9YzZjhe4XWgfmJjXgAFcV89tgYA7xmrBS3rejY7bGyCzFcHzu/x7xmPCIqRE7iQbHbY600MzFwmzG/P0HC/5kiMhIPyjLbihfQzE7eiMDw3c0Arxlze3d7UR2zPX7R3GYc9hijmMf9eaMBBYhBzOOOwheF9jMqTmIkZhLHSywfXUx77JlJ/JnB7aBRnPdYpfredMZ0fW5/8R1CbaypVqyN7X55a6wzU9Yq/f5+j5XWGhE743pCT5c1n/Ldx1RL1dQ62jqUb8Q+Hs8eTCUwPc6RyDlLj52JIfwCNDlS53vH0+XHu2hONW395+f1+4bDJ/jyTcKHdL90HyOoyaFRZhJTiMQFMyd3JoDnNwnvqHatMpcGHLocg/c24c4sA8jiECp0Jq1EKntnlzXT5NbaiuzOl3if8iLP0Mt/KaS00ugsTbYLRTBF4HS9dJpvtdrRow+aLmyON0x78HwtCENa4mgNOotTFhXSfA39+GZrfE5kb17t8NUErqk44giO5DzkjijEDSCL1t6Jwdznirvot7qMnrRhkW/eacLLLTZxxte3TmSj/nLH3nkxq0S8ZVl8q6keuHpiMhT/BGRleakIgNalAAAAAElFTkSuQmCC";
function ExtraCgElement(props) {
  const showFull = useValue(false);
  const { playSeEnter, playSeClick } = useSoundEffect();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    showFull.value && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        onClick: () => {
          showFull.set(!showFull.value);
          playSeClick();
        },
        className: styles$6.showFullContainer,
        onMouseEnter: playSeEnter,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.showFullCgMain, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              backgroundImage: `url('${props.imgUrl}')`,
              backgroundSize: `cover`,
              backgroundPosition: "center",
              width: "100%",
              height: "100%"
            }
          }
        ) })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        onClick: () => {
          showFull.set(!showFull.value);
          playSeClick();
        },
        onMouseEnter: playSeEnter,
        className: styles$6.cgElement,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: cgUnLock, alt: "", style: { width: "100%" } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                background: `url('${props.imgUrl}') no-repeat center center`,
                backgroundSize: `cover`
              },
              className: styles$6.cgUnLock
            }
          )
        ]
      },
      props.name
    )
  ] });
}
const cgLock = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAT0AAACpBAMAAACrNfdPAAAAKlBMVEX////19fP////39/Xp6efs7Oz7+fkxMTH19fT9/f3Pz8/y8vGampr///8xCmXKAAAADXRSTlN1dHx8dHyvGp7UOo0r/OH0tQAADP9JREFUeNrtnd+L60QUx5MWRBEhQxNRfAkpiCJC0rm5KD4FU1F8im1kZV8U3dJwueCbr/7asssi+LNskX0XQVBR8bIIPgu++CAusv+L58wkM5Ok1c1kNVH8JM2d9PbHl5mTM2fOTLPGT5/3mdeNLy77zI//6/uP6/tsHveX70Hft1NJWkDTjpjO06kE9d2Ic6bTm0eJncyTJEnvfOs4CZKGafri4SppBtHDnoOmeF6uP346/QYe6+c+jjl7cMp45ht4fHr8btyMKLbhsf2gnqnlCrOSvmdfi+PnQd8z37w2vXVCjuZPLw/jm0dxdhKT+0GfnUMiFVuFyBIhpSp0dpyI10lsoe9I2F88n8b7h2m6v37pk5dOX33pkyzMDu4crPfXeyfZYUhfPM0OZzk0DSU0nClQpRjSEjOFcBepBG3wCA6i/r5bLQ+h/h784MEPyIOfZEn21p2Dg4fWhGRfOWR/uQwIJ4FNkDjls2RXvaivQ7uWr0oTp26EKOj55eJoLtt3/7tb36C+b8ACH/wgI8dv3VkS1Hf8FcH2fUs0r9LABIgkon3rdkDK71LKaBWSWDA9X52r9vf8u2h/78bPfUByfa/sPbR23kJ9L4I+wkhQoCAC8qfZ9/CqivJN4sAr1XKkfoItyrbNnhHXLjyeQPtDzzLdO0D7S2dPfkSf/GhNs1ePPzp9YvPkO9mK0idPs1dDOhuFAZ1RXsBD9YTOWBEPlbOdJ2CmoShyy0xnKTBP50fz+VzU33wKRuGsSLp/kD6w/JZkrzywCMjqVfLwLUJeuHUT6y/JLz0s4KFygg9HvMqRZ2hxyon8H/72ougAoCwBHPCCcSr8iwBMiHCgQbvBlh6mrI8Awk6g/kgnRLgDlf435VDBYkw7Y5Yy5nPp/xCbSB4ISKdE9faN4ry7Ih1iM2RXvJfHL/MkRRyHBHQU+HQ0hEeLTQsfD0EQJHn7FvYnYr4yY/3Np9pIA5yCE1TaF7uA3mDX7Q/7z14ojKCLI7Zqf7n5Oc4IGHaFTw3fp0MKGhyH+Zey/c0US/UN35i02NyBxk4LQm6AZfsjvcKu2h+xZedmERN2oo9p6eyqE4wioS+cTx1s3gRcj4+4rLYB19PcB54eho8W6NMg5B6G6buB8Q+ENTNwqwGlQ4MO26Jlf2PUxj20g6NaZ5pOlfZVsNpC2mOr9qdGVpbRJdIJosTcv0jnMpkMxmNvAts/Dn4rfLfwMimS119EJCPT90fGyAyGlv7BbH75WrBbpVCm5F9wVCWAFxuGaWgf9GzENIkl+7iS/8u1mczvGYAFm2noHlBi092y4G1E8YOxEl+Fuf35Xue4aozF/B9UHjhoQgIKWD64oo523wAgPCABz4jYsn0jIjGNdui1r4lmW78+pP/LtXWNKR2gtL/c/LzuGYMjpAzp/wgjKXqPodEWHeMzXGM4NP0RAevLUfyfEtobHWGBCZpqkJ/bX0Aguk/SEcYuA4BXQCt0Ll94wBGAzAVE+CmQONX+d+B1z7De/8Zl99IZ0L4S2b/x9GsPoitEhPjSvwCU4Xp9QGlgUX+kF9EpQiRK/AJ07V+Q7f4lRVjaqfAvbhfkX4z+hTro8xKn0r8ZXvdM3Kr98eC58/4DMdU0USl+ZgpNggfA6AIcf5hCnS3yB0kKQFiIDgbxumVc6T8CwgUGMHovxv4t8XTI0yrDIaYQHIcl/Gr9m2X1xf6IOn4rpunMlva32mw2bxsawT2O+xjy6ojy+cEbOB2WYnQKY+vBgEc7hg7e7Uvk1NAaHeGB+b8hjJBIghPDNrs+lOQ9KvO0QXnIp542BhggRcJd8ZVpAYYOj14WvKxle4yd9me3jf8Gl4Lf2sZ/NiLzByFltMtaQfUJ3vbakGfJZf6Am2MQEAPQHf2fga6L5VGG+n7RTSJgJY5IAHqwFqei/1Xsz9TLP92F8r6Ej2cFrf7NNHf1v8qiBUOT+8R18R6U3jR0kekDNX8wax3f34Za46VHQN+Hnj7jXfH9aASeRRM0v/e5FWEF/q7fxW3PHxCBvndx8/I9l5e/6opTza/e/5biP1aXVykidykXxd1QbvgJ0j9bsBFcbBaV5qcrCawB4LnAXxf58WGoMw/KHqQgHoO69LwGnzBgZUY9f3ADqg5iLTA/JX3qigMPGP60iAdo099YGZ0Y6OPvvuInSA84HFqgAh0yKhLtaxOJ3jWC+tRrxb22+O9GLNfDcVPvTp/UmGCVVfKnY7dV7/ubOAF9ni4whVXuf+fYvJHqXjpt30CGMNXxJWJqxlcPXoc+E6jlN27wRZfYfQzZldS6/ga6+vgAjgbBiKRJCnUo5o+K/Maka/ubTGr508r0jLb9/aK2b/v8aRTX82um5vjj3vM70H+cF4B/Pjl3G4sr5+/r/s8ihRU0r7w6F282Nz6us9Bjy/lLPf8n7a0O2mNTXLQ/f0KBWbhj/lwrtN/KhY7/M7fYHxDp+j/ZvHWux/5CJwUCiriuoZGAenyHvoHXFO7/igmkZC7yf+EMl+cMhwNfwwbv26HPawSrl4E/hizfn88fAV20L0K259ciHGAKeRpDy+1A5N5kBwzV/tT4PtQaX9YzG6dHt/XsTwINjKSzIr7H8CBNWHw/8vNYW6/+cNjmSX0aqRKsxiBA/+zI9RFtHaC0v/fh7Add+7Nq+TXpXxL0L5Ac10pwy/r7utTabjO8gevm+cliBaCwv1bzR9L/la3R08LNE6hhLb5q377ls+vN3+v7P9m+b5bOrDbzR9HW/IEWskUxbXW7ZfuOr5I/aBS4yRq7cNVgxnAbx39jzB8w/5LiEK5l/qDev7lwcu32F4HUNtP7Sv2VgsFm89xSo8XzBzJ+nuWLT7229nfhQSKrnf1Nxt6kkj8gJCIJm1CCWVbfHzTsl8r9272t2jcYiV+QlvIHdkv/J/UZLfSZZmkBqtSX/zrRRHmWtv3xtPOZnj5pfGaRgJHzR+3tTw7ZVPtr6wH5+Lc6fwTo+D9kscjU+KoBBuL6vg/ZlxHqUfxfVJ6/NDsYv9XzG3Z5fVhr/1enzQTStvVhE0PX/tqP3+oJrOvLH9z397Sv3a/8AWIC158/eGRH/sVrRN4J5+sPUFSSMn18fNkif+Buz1/94mmA+QMM7lvnD1TuPru4rO1rjfVXu/IHiJB3TevttT5mx/pniF4wdKFs+qz5+m+IeMp4uLmN8dj6HJ8Oef7KmVbX5xj4ovaAOC3y/BXwV/bXAfC1f5m/MvFxPd8G9t5sr9tfZX3EsBfrT73xmIoEAr8+cDFgQkYUEOvX2oKf4159zye2Mf3C8ruELU+cSvvr3frY0vjStvuyfHxbfCUGmL438bqH/rvX33cpkVT8i/R/xCb57zQN2LvBVAeYEbFF/Ccs0MdhlNcZYwz/8vT9jv4NghyTzUe0wtKkMnxT14cxA+QvYJ1TKwwd8MtNMXlpo8A9kT9NlCWoLmz/OHi7AIQyRinC+w+sOBCYJ1At32d9zT+9w2Ns+DgMCkie0CVTpX1LWB1AypR/vx/Zdg+6X3Qvu3+/j4whvPG6A1JoE8pR1x8QhRFi+l3smLhCHMIQ7YvY/bg5DccG4lL+Pr/vWED5T2i6YQzfTYOAi0lkfMWhBf5w3AmuAd8tjQ9R8kN9uj0SIaX2BUQPRyzYTAt7mn/+YCk/rqjeP0LGf3joRGAZMb6cV+6PNGEM/uENqd4ibqr4F9IrAyzdHyQnIhjld02EqPcnDON4muRNPBrRTgkgsgpSjlPomwIOS3KkszAMAt070LUXF2DiFGQgzly5P2u/btFlC0WqPmj14hasHcKszxb6xP1PUyRJnYDi5kM3fMXHn2+Bv7y1Wb3j08q2Oj5dLE5XFLm5WBx/enO1Gt/aHJ/eXAH7UEoPXryzlvc/fYjd4ZRpTByyA/gf9I+PPXYOnJwc5SyXy8VONuvLs3X92bOLzeZiw8rZZnP2KxwW8MoL+JeXFuvs9mWm3F/5St2wQxxQ+PU5E5grXIJAlLjapQ9kVMnONqAvU/VloOo2/pttsIT6LhbF/bPTvQMWMzhIuosZQOlTXN3R90cMVMal7dS3rf425frLVf1arb88vvpusX5VqEDoLp566hya93uAqVsBoK65PmzfbGv7ZkLfhWjf6bPvFnEMb2B7K5hqDWfQwLyFc40ok7G8avsuN6J9a/XHSxvRvuL+ypIIsEl95yNlVocAVCE3wELbErZVZUd92WnladDE6w/fUrW/jWJ/GfMvyP5h0cmFzIE7qZPUdtSG4pATteoWGvbX5PrN4U3L439nK2kqrhApccUukh0i12uomRpZBk/nsrFJ19kiWxRPweuxNqGhub4mRLIvtAuHFEdQbAh7M4klRPn8ev8m+YsYy4baxUN+83D11RFQH0ds78TwkBf5mY37X/x9g7Q3QOwyB9Lv+//3Ifr+9zX+19dO38+XfeZ1441e03t9fwALCC2fVBSQDgAAAABJRU5ErkJggg==";
function ExtraCg() {
  const extraState = useSelector((state) => state.userData.appreciationData);
  const { playSeEnter, playSeClick } = useSoundEffect();
  const [page, setPage] = reactExports.useState(1);
  const [list, setList] = reactExports.useState([]);
  const cgLen = extraState.cg.length;
  reactExports.useEffect(() => {
    setList(extraState.cg.slice((page - 1) * 6, page * 6) || []);
  }, [extraState.cg, page]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.cgMain, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.cgContainer, children: [
      list.map((e2, i2) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ExtraCgElement, { name: e2.name, imgUrl: e2.url }, i2.toString() + e2.url);
      }),
      Array.from({ length: 6 - list.length }).map((e2, i2) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.cgElement, style: { cursor: "default" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: cgLock, alt: "", style: { width: "100%" } }) }, i2);
      })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.footer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: footerLeft,
          alt: "",
          className: styles$6.footerButton,
          onClick: () => {
            playSeClick();
            if (page > 1) {
              setPage(page - 1);
            }
          },
          onMouseEnter: playSeEnter
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.footer_page_container, children: Array.from({ length: Math.ceil(cgLen / 6) }).map((e2, i2) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: i2 + 1 === page ? footerChecked : footerUncheck,
            alt: "",
            className: styles$6.footerPageIcon
          },
          i2
        );
      }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: footerRight,
          alt: "",
          className: styles$6.footerButton,
          onClick: () => {
            playSeClick();
            if (page === Math.ceil(cgLen / 6)) {
              return;
            }
            setPage(page + 1);
          },
          onMouseEnter: playSeEnter
        }
      )
    ] })
  ] });
}
const background = "" + new URL("background-520ec879.png", import.meta.url).href;
const backTitle = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAW0AAACFCAMAAACnv1lLAAAAQlBMVEUAAADQr4C9pm3Xune/pmyvl3aql3S1mnWwmXOol3SvmHKqmXSym3OwmXSvmnSsmHSrl3TGpnTs2aHr2KPfsnTjynrp9/WvAAAAFnRSTlMACBsPKDbKU2TnQ3WHmLvYqqsbJ8GZ7ntA7QAADu1JREFUeNrsmuGSojAQhNPfDE/g+7/rKRsYYzCJd96fTbp2y6EIWn40nYGY/oskO6RDaenbEvwwDs7K8JUe5YL+LTuDGU0bS7Jl82+QZpTjSpZ/0A9pq+mdQIEr5CtV/g51YdSzPhi7++bKw9OTlsM/Zv1qarlyZewv+EO5pnqHBXxIEgSqYIaN0NYC/oFEsC45QkUbv1GeCVEYnMW7w9pUBkhFW+Q9t/B2kTIhmS3eLda9AAnphJ1QjM6KwywtVRKOSsZ1JJeqgxnVkbL8fd2GxCaewtIf6PkkhdZ8Wapq+dzeWnqIHOWoNV+GBKi86iG9kbmDWxIAx+PA6uzFRbPiu1BMjpwTn1wN3I5yC3gXebsYU0cKy945RFLA9s2qGbDGve90kh4lTuOyiRLS7CI8J9/VZ+JOtr+c1KQNK71PCUwpaN/uf33aOBlkpm1Na0e0aOr0FhRbe5LQP8x3W2uAtuKd99LmxX2mCMoUt4CN2uaG1Kcd44+40aRpIqLf89dWEKdNT65h2gIHt4lxFyni1E1eD1/6wNuAc4yaMLwFVq4VBGscnHY0uII2Gk+SKcPbXhBBlL7lRrpxuBOv9LOBuAHSfLjrG2k9W9t6wS0Y9nZ5s5SPmwm3wXU/BmeKeyuNDWfU2+jlAybDbed3LokaGxlJx9wAo942J+p7ORlugyARoOSbe9ButRpGjhLbQ4fhZQpSmgx3MUESuGXkxg86LTfKew3rJwkQZCfDbSVEyq0dN6SmuY3H/wjt6OvnxG1esalwW7R3l8JSZgzWe5J6bWybArcCdmNphtS6fTfOXwFal7bB+wexv3y98uyTaQxxJ5fO+5ZOY7QhiNatye9ejv/DvhnuOAgCQTgzA9Go9/6ve2A2VmwOd/8ZvPnVJiDpx3RYFUgcHHtpoo65yc+1RBhtd47YXL8A9+m33+CmYSG+SBVZRBAk64fQEtlq3Ohu2NGD+9vckESj/hE6I74Ut4iGW8+RTIQTF6ouVZ1vW9rIK6VltUeEDLcSY4MQgRwBhsVNwk+7liZWVkuh/497RGs85nk0Ee6YpI4dr00q+3pWed6w12kcFLcMGhO8zFgkP2vAgsRpbWnc6CabGrovsnme5JNgBP93bosMrJYy2iFeaq0NV+chs6S9TZGPNhQaAucaE00EvawMZGL0tWVQPIIkfgmNZe5o1axrhoC64bH+zLlpBK+3hWw9owKfeOoBBo8kwrljsSDhhva2bety9raLIEqrnHOK84ZIPvCpluVIqlIoRcXkRLHttNfA/Bx3+tqHoCLuSaXLI1mbVZvDuw6PMy/TPC/ZKHhpg6mQ+APEwvY76iDTtOzo6MvEPBXl9Njyslr7oG2bJdFtP60lGOall/ZXbr/M3NtyozAMBmAk2djxAQxJ3v9VVzICQoI3mZ3JTnTVdgphPv+R7bpt8Cmz9jo+5/fPQ/FmZXM+pugtQmc/0mbnmFJ09qd/bVOirdpXXLSx5WgYrQw5OvsuOqVPZv9M6Or40L6ZOtXmmrwJMXMlseu4VLuJCMYnHqhSsrvO1+vc/XCttLD1bTRouueyPuW+L8lvucdAf9G+XC5DNB3ZKiHSEuhd+8w7s/U0TC44A+5BOzS1TfAyRNkHDHV8vMPrlb/zRwMu0X46cYSnswSOWn8ZCyf6OEzRO0tt7ZGvsX3JpTjgqrOrY0cdYiR61Z7EuxKHTRuCC/ZFm3T4c9Rb+jzd+QrfdcIdrPlFcDR4tmUzDxQMHczrLtNG7x1zYCvb41iIamJLtPX24PgKix1JVgnOsr1q79mmEGq469PN26uPOTnLjWN9pjTdRRs74WZta37PG/D8bxnpdKK0Q2VDW6ewGKu2tUitbKthKWXXDizR0r6x923PdnLyhKpdp1aaHzaYbA37K95F23aiHYy8xu8tTNBg6wd8Z9p9P5TEdjlnQs326Wo4Xmq4xTgPwk2qLeGGzrT69nC73fdsJ1eXgKp95O4011pmEm1HdWUaQx3SX/sLTIn2kXbbgSGdajOIMaydOoxx10Z41R5ZGwF81c4xkGbbdtDSnm5cD9mOwSCGXVuQF27ixUdO++bUMfYk7zdncb6CYH+mXaeU//N/r8jgSryH3bTOCVS7E+1ctX1TW7M95iAdvsgVyWm2OzLmVFus75Ozfl0CLvAhbHKabrhKsDM/ThRwDF4aiQ8+yaTJ2h9ne+Y7HUn4C1/SRqSns5tD6e4aw4n222yPVXvsC9st2r571IZz7ekme1TjRDs6WFaAqg3KrSK5lxo6fqbkKlGoOyhecv9du22r4/iVInxekFReACJ6IA+XMbuDdvk428KRAqaDNppTifutcjt5gGVN4o/aWssWRrXleYAnV4erdrTwsTbbzu2sfyHazQLtKOhErk9GtPvPO8l4qdnuB99BKpt2+Lv2NDng0lmS4KBdsyDYM4j2WLn5o2HiDuQX7cgPumr/Uh+BdwexWOcMCsuU5/8x270H1n7ONjW1PcC2JoGjtr7VZyYnzbZqT1OJi3aKqNoG3wGI7d+z3v2/UwQlsUKn2v2Ldmhnu0i2q3Y8aBu+BM61p0Eyyto6SwIaltM+r8km7d65r7Vol6pd249q27fa87MtfaePfHiMi6Da42u2Tdq0TSPbpZFtcw5xr9iDE1Tt29J59KfVyjHPKxCUh05SqjZfFVU7vM82MTa8Zv07BYjvv+Uv2f5AW/s2hnyYJc9jB6zN2LJzNzZWbYuw7QKWZO/Y0rdHzfY0iDbNLsVF273Ntr5NXrP+pSKktweERKrN2Y6HbJONMX6iLdfkXI7ajb49SQN2Xu6/aD/7zH/IOxNmOUEgCNMMHsFjdfPy//9qGMBFHJTNZrcqR1euRTCVj04zir6X3OhXSRbRfXZapn7gMZF23dvuXMccyRs+ESR0uR+pUfQ203jQbk5oc24z7kGrPEmgi1c3Zgj3ABvTR9qDzvk4QWW0Y26zt6fedjvaNW+DT3ZokKX2J+610nkvImTebudlYdraMO3+0tvDtkruaPeO9laUSOluWrtQnfPVjTH7rRhyfEgVaS8ht+0v0BZss5T6AG31hDba3x7eNk1aJXtcebtEu7ugDSel+2kNF+49qXBjhc+PLLSFt+dEe6jQTlN37XX19tiui5DldrurSThJAEFbels9aA/B2+bE23A/RhfdzHtsgtkjOKe7vuNAmxfh4O067Qpb11AD8vkHtn1us2RN4nMbF95uOLevaEs1K2tax26LObPRDjjwHm9TYiu8nvT5IJEqe1uPMbcts6CSt5vg7XWal5z22e1QPa6Bdh+PemDa0zZ3E90oK8B5lt62V7TBsD+fIy88ZJp7u/W0F0f7sUoWabMUe/vra7J8s2WcEu2TErDjCpD1o7vHFtddb1+dhwGd0p4j7fEZ2qA7QXr9cyJNb/O2TJLZz49SDJuTZHE/m26jjSJtM81zpM37MCbQ5mXSkKJC0bjkFeBIZti8HdL+lDY55fgPDe+njWdf/7RlbyfacsN1CeW2crBvX67TsFhujrSpQJuGtmXaVjNtp++RNnPTDOiuIbx922h73qFsrNNmax/xvz9H5P5j2jKoJcmlt03R24NSX5F2tyzNRtsqLWl3M5974JSJtJG83ejcjtLbTHvUuyRh3PY7Tq0N6fWCQOC+76HNAjTq3uZ6eyh7u7i93TJtq/B1u/kk0W6EPqfdcHkxdr5pCLR7ldEGiKAuvL3MIx600Qdvg4eIkXgyR0CIR0tzBZDTxWlwJ6otknVvyySRtL+xHN4bA+mZzDI5Gn2ibXYj6LYONn5GCpKMNqvibaVsSBICW9sPC3Tq1kaZtaQdJw/Ih8k4wu6wcHQtt4W3TaLdFGm3ake7d+HTb7SbRFvIxlVS7WjbRFt4W9AeB4NHbkNau96Q2iTtOHkoDCOnkykkjVe8nWhP43Dubc0jpkC79Uky8gjLtPsz2ggI13VxtO9P0F487EQ77vg8cjvSBipPMBBIJQnCOVQI2MLLMlZIq1e9zU9RdparYNslb8sR9uFtO4bLm3Db0PKicaSNbWbndeF6Wx1oqytvI3k70k5JIoaBDi0kumSDcIQNdRHnZfaM55e9bTztfWGly7R7HqCit31l10/T9t/Bin/D7o/jzN4eUaKtCt6+OdrYeXs6eBtVa6MEmyT49BF5u5xE4XxNL3hbkR1dkmQqJskQgiR622+7DwxijN6Wto6yM2/DrFrVaKe7Ui0UDrRJb7QlynoDt1RhS9o57Cyd8JK3WdjB0qaxXaQtym2++TTevP1m6zg6ELoP3j4VFkdtXayStCWVh7cVQgUYdzP93+Fpmzrb8nzUe0vYhNOzQiMwJ+B5byfB2M7Fgr+ohha0bxwkZv52Y7ns8dfl7tca7Z73JZdePUk75jait7uBXzfprCbvBEf7EmUdP6DOjl3FkfyoEVuJnvT2t0hb83Pq/JT6Pr8PtZDr33uHe9gmBkaVdjM72gxb0vbCSW43DDu8AYHsAu7lHJFAUT5WzhUC9gNxLDmfq0m6gd8H8KArA25sZ+/thXY4+yvaWGeHe1BntM+83bYMWisp4LwBl/ghkQjYFWsngcRHKeTebh25sW+gauJFsvO/O9zToRK357TH+WteD0epCbSDIGg73NSQPFpvOIUtQIupER0uYKOAt3jpevD22KiK8LhLssTV8jbKTvostPlxEl18CVIXeTVjy7Qv2KLaUMNfPpagnxUuB7ricorOR+huSqtkXfpbG09vOvW0uvaL94t/Tc0wtxm7CstS1NRVDuukc9go0ka23voBuRGomxLtapAY2ViHPY9avSBzzvqFZJFN9UNl9tLbB0cDb3kVwpoXBmmr3i28dUx1HmQ3ZLTJK8NdRv1vfJkcVFoqrM9p1zom2iDs19z/6XvbQ72mOuw6bbD+fIN+WPjE1GCjDZCMEPzPvH/b22Xam7k32H9PAP9tAuW1IfBXrXd/mYST/7Ly4u/Sz/buIAVAEAigaN7/0kHRqphFZMw47x3hMyi60FvtwzYs2TM83nxdtVX/mD1xir5f9yRyznark+ML2U6tNHz2Nzu1A2qXpnbMNlmY2gG1S1P7V0P0gNmuTG5WZbZZluFmWYYbsJIAAEBOO1kjtd38r4R2AAAAAElFTkSuQmCC";
const backIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEQAAABECAMAAAAPzWOAAAAAV1BMVEWWk4wAAADr2aa+tJjXyKC4nHatpZPs2Kjt1qa0mnfs2aifloealorq2Kbp26jDo3bauHmvmXrgy3qhlYWomYC5m3TBoHTMpHTUq3Toynfnv3XfsnTr1oKkvZAXAAAAFXRSTlNmAGRmZuJmEkXaNXVtViPj3Lbdf493eQ/tAAACVklEQVRYw7XYi3KrIBAAUK6gGBQwJvGV/P933l1rQgURhXQ7mel06pld2PCQ/PMGV6KUMsOQpVDc/58+RJXwOGOUFkVBKWUMqFKdQXgJAC3IKgoKkOABxBAgkM0Ap+QexCYK4o0CmRAiDOFnxC7CZUZJMGgmuR9RJo1QMsqHCJNGKNYlkSgDSxIuggaUEqeQCMMoFqKwlrOKWiMcjfMKXyGSkYhg0iBmQE5GkQmDmGJiClqQkpHIYOUb4fvF1LsFcUR8iVw/cQumQrYTqS+Pd+Q1CaVCMJFdowqOCiIZjTdwghBRWbyBAc1P3Grq3DJC9QAiqS+PbjGC9RCYm8g8zPwQlW3n0Zk8goNCBPMZ9dHWF6RkG0YHxonvD/k9rlW+GIhccq11nuumafAXO+5mZCUgW3ngp8ef5zQ9h6GHv6zjUv1GMoMYAwmItzEAYRmrOSafGb79GPg4GhjDNE7Pp2U4k1/YCBqYwccAxDUe93W32eV0PWTf9/h5ji9AwHCQq9Wyq4HNZwOeM8a0NahW30trijt8GJW+adq2gdAXJyobsZttGcx+aE80m932GquATMZXe7ztnS9ggwhIr7E9/AV0l4IWkAmMcWwOLwXuotSO42xMgz62KG0uj+1idN0RhZXbC3ULDYLGISVTni2jQWOOg1sG1uMq2Khz6ODm5d9G9Sw8UAlto/4Nvb7mP6H1PZDI3tGiWuJWhRJJP+R86biVfvD76hE0uiCW8W8fy9MvCEahEcaXL01GiTDSL5LpV9r0y3X6NT/9hUPqqw8g/vIlTPrroP+Vsz066apbWQAAAABJRU5ErkJggg==";
const cgbgmBg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABIgAAAADBAMAAAAKOin4AAAAKlBMVEWkl3Skl3Sll3SklnOkmHSkl3Sll3Wkl3SlmHWklXOomXWhlHmZmWakl3TbXMa2AAAADXRSTlPy+qySedtgxEo1IxMF/4no4gAAANxJREFUOMvt1LEJhDAUxvFY2J8rxCK9cQPF2kZuARFrQdxAdAPjBsYNjBuYFW6X+14QTm4E8de+8v35mLWHMWbVWs9KqWkaoK6gLFNIEglRxEGIDt4F8RljXvC4DfzT9wtoO2gaDmEoIY5jhJBlGaKo6wEmlDLPSAbl7Lu1FNFhtk3rZcFpvCYE0uFOR9pfQZ/HrQQvjzoi/x25jMq0OjMax1GpBRWtqzHWRbRfl8hl1Pd9BVlKEklCThrXUUsl5Tl73Mm5QzREQghOIkmSFLBDlyGCBcVsKOc4rP0CSvY7SZiQHi8AAAAASUVORK5CYII=";
const cgunselect = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEMAAAAbCAMAAAAQycLbAAAClFBMVEUAAACvrp+yqaS5rKOyqqWvqaO+sKW5q6K4rqa1qqPIuauzqqazqKe2q560rajCsabEtaS0qqWvqaS8tKmyqqOup6K7s6u5sKW0qaW1raS7s6jBr6W0qqjHs6ezqqXDsqvMtqayqaWxqaa3rqe3q6Oup6O3raaup6PKuqu2p563q6W8rKH99cfPt6WzqKKup6KxqKG0q6mxqaLQtajVwqvHtarFt6m+s6XAraHBtKyrpqTNuKnOvqz/88ftv6XAtajwz7/KuarVvajgwqSyqaTVsqPiu5//5rb/8qjYwKeup5+1qZ24qp/u6sTg4rvj667exqvSyqryuKrKtqrAsKi/wqfXt6e0sqbYzL3Nw7O4sK3IuKjVs6aqpqO7rKL83bXXxajkvKDd1MLCtqbLrabPr6H0+M/Prab89MX/15rm4tb14sLiyamspqP347P/06f65L/fup//56f/35+xqaOxqaSvp6KyqqWxqqWxqaWzqqSup6Guqaa0qaOvqqOup6O1qKHKuKnGtqnEsqjEsafIs6Syp6K3rajZvqfNt6bPt6X/4rT63rPjxq6zravJs6mtp6e2q6bEtaW0qqXKs6TFsaOxp6Kvpp/S08T+3rrAvbf/7Lbx0LL857Dry7C7s7D+3q++uq/zz6zHtaz61arMu6nQtanmxqiyp6jowqfVuaf52KbfwqbHtqbat6S2qqSvp6TfvKPOr6OxqKO4qqLLtKHiwJ7JsJ26qJ3/98D/8L/Gwbz98bX95bP517P/27H41LHg2rD5zq/tx67w2a37163Jr6364av2zqvyyKvLt6vevqrqzKnRvqnWuKn//Kj/zKizpajSsabsyKS3paT74KDPt57WsZ7PtJ2tqp3cu5zWtJxEy27lAAAAdHRSTlMAEICAv4BAQICAQDAgIICAgGBgQEBAgICAgGBQQBDv39/fz7+/v5+fgIBwMCAg7++/r6+fj4+AgIBwcGBQQEAwEO/v7+/v79/f39/fz7+/v7+/v7+/v7+/r6+vr6+vr5+fn4+Pj4BwcGBgUFBQUEBAMDAgEGUnpQsAAALXSURBVDjLfdRlcxpBHAbwhRAgBEiQpGncPWncre7u7u7tHXYQnABxd3d3qbu725fpNWQKXOb2eXW3z8zv/rczu8A2FKEwIiLNJc2LEQXIEsPKCk9xTXVPFwhyiR07Iy4WWZUQ4cWiMxiRDqGhRyLpgJDc5J1q9fKDrl50gUDg6e5+IDSe6/y/dYvr+6TayAe2ifKye/VJ99OWlvpn2rPeXIrlgROC1apUNAqAhO6nra7qSfQhqS8vE4kMc5ughKtWN/vnzR6y2g0TiSYVU1FQorN09ver/hiSmoJPUaOQxcMIlvr5xEzX4+NkfRgmqjWMlvNhhn/VRO+DZ/3XSWqOEhMZVOVfORAi8/OPL4VFvSvJ+gwl/icKwxyA5NBIR2Hb2+JtZP1hrMagQH9thxlrnjYWvnxSnETWh2AiFFG2b4YZRbebBztajK5kPYaJ5MqSui0Q4sqtxsGupqFpF0CSWkwulzfU7YYY2XdftN0vNlUvGGyHhSzBw+RyhWCDUi4vudOwF2JENxfVt5h1WuIcDCZzKR4hCFGWyVvbC4IAJPfqmwb0Oh3R4AUFB9NoND4IKysraS2YCoYZax+OT1dodanEOZycPKhUqhvgj/UVFIyqVDDj6NDP4Qq9fhdhWYgT8wZlrLJcJpNI2RDj0neTpsKs9yMsOylkCIIijvh5kUjy8/NRHvS8vNZoeqqqYwiGTIZaDIovghsIDXpuOzXq9yb9aftVqky8MAdgKCZRqRR1hiHJGrXRPLzahzCHWCJB5g3Ai5VKpeJACgw52W00d48k2q15/DNQiwGcA3FjMRKdfdH6krXC9G584NhNWwMn5uewhB8gFot9ebbKhTPnrtnd6+HrZ4yP1p3Ps+4HikpRJMG6Cc5Umm9lZRCXSafTU8L37zuRFw2IyUna+uHbxx2nPCkcNpvHDgigObotulq9vSOZTHdPFguQ5sbVnLOeHIY3x/r5v4D4125/VEGTAAAAAElFTkSuQmCC";
const bgmunselect = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGsAAAAbCAMAAABMQ4H/AAAAgVBMVEUAAACrpaCpo6G6raSvp6e3taXDt6espqOspqK1qqWyqKTSt6e4rqS1raW5qqWsp6THtae4raWyqaW2rKbJqqOyqabcxau2rKTFs6fv5ci9r6j96bfo38jq2LX/sKrh2seqpaKvqaSoop+6r6W3q6S4s6u0r6rCs6bHuKnWwKvvs6tOJ9zBAAAAIHRSTlMAQICAIBBAv+8wcP2/YK+fgO/fUP6Pg8+9+p+A4Ei/nyyGfrgAAAK8SURBVEjHndWLUqMwFIDhhCQtpFwKFHpZ3SUGC/X9H3BPDsohBWn1H2ecIcDXg5iyX8Rdkv08GYwJIfC35uq7k3V6tHlcCSiN01RsGLUX2PxDJAEmv6yvM6Ika6CjXuB4bK09lYyK9IXO696h6/Uy+4DNEPctLDq6lVDfXxK3QGk2jyzEOPPLRktxbDqGCnGtYtOi3FGCrVjpYMX3Y2XzuaiqaQz8RDPqyFay4jJgpT9WwdcsXDRGTEYt2hawct2SOVqFP1byQ0u0rpytW0ygddXTsUI2WIYz/uYCdJJGavoMc0fZ9JGlCsRyNRkr8C3Is45oJXSgbA1QVjyyWDIMJiZjqVVLu6WiZP4jBIs/tNgRLSPHVzoY/yQLlkxhJU3YtBipZ6zNYGVsKAjV3NIcC4J0G2i6J1kW2jy2WGydZTiNtWRhSZCGzTYN+IpV7+s/rhp3wPHMFi15vbbGmC2N9Wk1G7Tw5R9TOoSlsJITC6nOn0vulyxWXY2rxLEqhhZiYDkJLSoKDZQnd1bvW9EJiuPkzlI5WoUbq5FktZ/Wm2+x0j3fd9omLs7q+qfmYsJgGsbKGFkWrIYsqjCmtbRP6NZRvf9yqg3EuSSLLoZCBWORZSz/xtqC1dLOIdHq9t45m77vOmvFzCrRaioYi6wWLZCauYWNR2Owuv7kW91u13XdnUVXN40ky9jhnV+0WgPRbmw7sG7KnwusHQ1LFh+ojE0s0zgLmllh66yMDlRo1b512wG3YLHMuJvLueW6s/ThAFYoGZXCu3F7Uc9Z0kDb8Z9ji0WL+zw/QKaIPP/S325nwDzrdtvVvkXvPX/Cii4fH4dDIfC2/hzn8/n13npdslRIY41fx6MVyEAmPMi24eHjbyrGmTzt38v5/FKXblFJ3ffHGqW5xRLD59YPk6/1/lQliZCbKGIrIeX3HzudZ1rtJGLnAAAAAElFTkSuQmCC";
const tabchoose = "" + new URL("tab-choose-b1fd3807.png", import.meta.url).href;
const cgchoose = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEMAAAAbCAMAAAAQycLbAAAAmVBMVEUAAACbflajgFSphFaafVWtiFCfgFiafVWfgFWZfFWgf1WifVSafVW/i1WxhVWYe1Wxhlaif1aafFXEllSthVXjt1jfv1jNuFWyilW/mlW1ilXhvVi8j1bmvFXWslzVn1XYiFXirVWXfFWcfFWvhVW1iFXlr1WrgVXDjlXLlFXfplXcn1XTmVWyf1XkuVWojFW9hFXmxVW9pVWMtpJYAAAAInRSTlMAgECAvxAgYDDvn3Cv79/fj1DPl2BAIL+/uq9lUN9QML+fID6uvAAAAdVJREFUOMt91WmTojAQBmDSuTi9dTxmZndDwile///HbZJxS8VNvx8siw4PqYaG6DkcgBBK6RziKBQBn9Qlg/dFImOJSnIyB5uMpGmewXhNPNtqU+ypX7OiNE9z8oCAqbKcytcz5q+bzCa11pPVKwuE3/fAlCUYj5DApK61SUNr5omyxgIlaF0Pl2YbvIJyRBmjhNZDc2xFoMwTT+QYAXoYmq5fhuqpJ0qJGZNhaKuu/RUoC/VjCIRYXS7HqjoWoXrmCVVGSPaX3hLtLlTPnaHUDjOK7lT1x3YWqjPlcv7AjOp66vpjQ0N15XPDjPX1VHV9o3HjfNuiRmVviqnvhiD/Qqn7hWjq+nE+M8TYnGxHTW2N8az4gO9HfS4xI7IdNfrdkMxH3h8x3PjqGq2RfUhLuGDGn9ZoGxYyuCOUUgIxPh1h9GR0mPgTFXHz4oPPi3FGLUIGT7zB8LnV+mI0HRvqbkTw8zfGkJk2jdEFDxmR9DtZcBSxhmnSoBHFi/8im/X3U18LY5klfzbUw7CR7nFN5POK78Ph5Z3DadE2t68DHxn5owkxYUlZMkIAgNL9bsk3761dflyr/vdMciGEFNMpI/D2anVfJ0JXAMjwrCGTAkA8Lv8X9dQ2O6GxL7kAAAAASUVORK5CYII=";
const bgmchoose = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGsAAAAbCAMAAABMQ4H/AAABtlBMVEUAAACTgFyUgFyZgFyZgGCog1yPgGCVf1yphVyVf1yzjFyaf1yvhlymg1yfgFyRgFyrilyPgGCkhWCcgFyshVymiFyigVyXgF2fgFyYf1yggFyUf1uXgFudgFydgFqUgFqshWDEmVydf1upg1y6jlyviFquhluYf1uXf12qhlusil2Xf1uWf1yjhFyWf1ynhV2ggVuTgFuriFzVumWkh1ykgVzOqFvgx2akhly4jVyYf1yggFucf1vBml2Zf13mv1zmsFy3hFymhl3br2DBlVyrg1y/gly6l1umiFuqf1vWw2+0kFyphFzqhlywjFyoiVypiFzNf1zMr2Dp0V7XoVzPslzPmVznv1zTq1zDo1zKlVqUf1yYf1yWf1ySf1yaf1yggFyjglyliFybf1yRf1ycf1yigVyif1yih1yhhlykhVyeglysiFyghVyyjlyvi1ynhlymhFyfg1ykgFyff1y8k1y9jVyqh1ynhFylgly4ilyxilylhFycgFywf1y0kFyqhFyfgVzCk1yoiVyuhVy6hFy1g1yof1zdxGjQrF/MlFy+iFzUhVzetlzKoVzDm1zkkFzFjVxW31aNAAAAW3RSTlMAQIBAIEAQv4DvQL+AgICAQCAQgL+AgGDv77+fcFAwMCCA36+AMJ+fj3Bg38+/r49wcFAQ7+/n38+/r5+fj4+AgIBgIO/v79/f38/Pz7+vr6+vn4CAUFBAQEAwmXwOLQAABARJREFUSMed1ndf2kAYwPEjCYJsgwq0YFm12r333nvvJCQhDbRsW4aKq0O71zvuc4HES0Rs+/tHLsDnyxMuEfQf2XFx9O8N+f1Ut+CoT/u7zzaAehefTN1cujS8x+t1OlPDqZQnQDw5Ao36fAyyFqK0GN3SX7EltJmDdkZ7cPZdM0tLw/uJI1snx1lj8T6bzRZeFU8gSwzHCRyXydjAokgLczvhSSEStb5lkzwzvTSJrFms8mvacnyzZnFgDdi0yDEGBgVB4PnTiGwsnJPnppyoj3Unm335slzeZB0LMByNhvSTSTShWeKYiZJysnwU9ak2Mg4YDBYzj7XDZlj+tRbdsYLIiE3mJcD297fiBwErv06axwptbImkFZSwdQj1a9qJRjSruJccaxB1LIFGthcZ2COcDRFFOWypxDkM5/Nvc3KqrwVfJnsVn8RimCXGoroWr1k4k7UTz6WEkFFMyuclecq7kYXOg/XqdTFIjDVAWjiTFRWgJPkN+yQpDzve3t/CH+WoZs0zxpamEFgZOIVqxzLNxewG6XgIkW3CG6OwgTWDLTsMBta27jEKxurOpWhWBtpn06Ko3Q4qSiPIYsmFv7LQrpflYlERaWMssDL4YubtYGUMCwpRuwcFx3GKtlg5sFquziqRTpx5cObs2Ydpj8fpNT7AG81iYG/MK6LbGAtbAlhCACwOVHIfDkQjPM9HJhjSkuVCDSyyCwmP2RpFuNPFeVFRlJg21gQy5hJdYAk8aeG2YIw/uN1kzdWqZuv5sWHceYvFhlUF2oHH4piuBfPkelsoBpRYKBhb8QTcC+dKFbMVx2M5nda5UFDF8VEYazPSLLiABbEWgAeCsMZCO3hFkqWwvtwLVqtahUGJ2IDLhf9pWi2UVBRR5CMsJTCrVr1GIxpPtcZy8Gq+rhp3DiY3M12qltKIzFWdnf3wIetdY8VEiOcnBrch3eIESV7PcvPKvMKLxm7cNVUrlarHzFYbrJXSiL7OjxrvBgoSmFVLzNXBAqqHpdZVeL2xtk+1wGocQESBdrPZXl7x6GvJpz+iOxaMZVhqnV/POvTxjaQqJ5HRnlapWmkkTFblXbP9dfmcvn5rWOgkj8Nj6Xte5YGgsZSxWHsXFj7m62GGOHS31V5sHD5gsRZ/f033sBhMuY1LyOFwux2OLYBmOOt93n55GazkmMkfryz+/Hz9AGk1mo0vzUQPCwXBoknLoVkvrNbY+LdvKwvXfCwy57ry4/OnI09Ia/bdl4uP9HWdsNjI6lj4Z0aQ8vuHYC4tGzVEMSGa2uaOLPy6de/cVtSjZ/ePfPp++NR+/CQbn6ws3jj1GBlJQeKlodWxEEPhwPrHLjxNpG/v2b7dGQ9sBXL9gLL2B3cOMOZ3CKY9AAAAAElFTkSuQmCC";
function Extra() {
  const { playSeClick, playSeEnter } = useSoundEffect();
  const showExtra = useSelector((state) => state.GUI.showExtra);
  const dispatch = useDispatch();
  const [checked, setCheked] = reactExports.useState("bgm");
  reactExports.useEffect(() => {
    const bgmControl = document.getElementById("currentBgm");
    bgmControl.pause();
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: showExtra && /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: styles$6.extra,
      style: {
        background: `url(${background}) no-repeat center center`,
        backgroundSize: "cover"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: styles$6.extra_top,
            onClick: () => {
              dispatch(setVisibility({ component: "showExtra", visibility: false }));
              playSeClick();
            },
            onMouseEnter: playSeEnter,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: styles$6.backIcon, src: backIcon }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: styles$6.backTitle, src: backTitle, alt: "" })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.mainContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.mainTab, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: cgbgmBg, alt: "", className: styles$6.mainTab_bg }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.mainTab_item1, children: checked === "bgm" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: tabchoose, alt: "", className: styles$6.mainTab_choose }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: bgmchoose, alt: "", className: styles$6.mainTab_choose_bgm })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: bgmunselect,
                alt: "",
                className: `${styles$6.mainTab_unselect} ${styles$6.mainTab_bgmunselect}`,
                onClick: () => {
                  setCheked("bgm");
                  playSeClick();
                },
                onMouseEnter: playSeEnter
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$6.mainTab_item2, children: checked === "cg" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: tabchoose, alt: "", className: styles$6.mainTab_choose }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: cgchoose, alt: "", className: styles$6.mainTab_choose_cg })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: cgunselect,
                alt: "",
                className: styles$6.mainTab_unselect,
                onClick: () => {
                  setCheked("cg");
                  playSeClick();
                },
                onMouseEnter: playSeEnter
              }
            ) })
          ] }),
          checked === "bgm" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ExtraBgm, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(ExtraCg, {})
        ] })
      ]
    }
  ) });
}
const tag = "_tag_yghix_2";
const container = "_container_yghix_17";
const showContainer = "_showContainer_yghix_1";
const singleButton = "_singleButton_yghix_33";
const button_text = "_button_text_yghix_37";
const styles$5 = {
  tag,
  container,
  showContainer,
  singleButton,
  button_text
};
const BottomControlPanelFilm = () => {
  const showPanel = useValue(false);
  const stageState = useSelector((state) => state.stage);
  const dispatch = useDispatch();
  const setComponentVisibility = (component, visibility) => {
    dispatch(setVisibility({ component, visibility }));
  };
  const setMenuPanel = (menuPanel) => {
    dispatch(setMenuPanelTag(menuPanel));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: stageState.enableFilm !== "" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: styles$5.tag,
        onClick: () => {
          showPanel.set(!showPanel.value);
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(HamburgerButton, { theme: "outline", size: "32", fill: "#fff" })
      }
    ),
    showPanel.value && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.container, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: styles$5.singleButton,
          onClick: () => {
            setComponentVisibility("showBacklog", true);
            setComponentVisibility("showTextBox", false);
            showPanel.set(!showPanel.value);
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.button_text, children: " / BACKLOG" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: styles$5.singleButton,
          onClick: () => {
            showPanel.set(!showPanel.value);
            let VocalControl = document.getElementById("currentVocal");
            if (VocalControl !== null) {
              VocalControl.currentTime = 0;
              VocalControl.pause();
              VocalControl == null ? void 0 : VocalControl.play();
            }
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.button_text, children: " / REPLAY VOICE" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          id: "Button_ControlPanel_auto",
          className: styles$5.singleButton,
          onClick: () => {
            switchAuto();
            showPanel.set(!showPanel.value);
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.button_text, children: " / AUTO" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          id: "Button_ControlPanel_fast",
          className: styles$5.singleButton,
          onClick: () => {
            switchFast();
            showPanel.set(!showPanel.value);
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.button_text, children: " / FAST" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: styles$5.singleButton,
          onClick: () => {
            showPanel.set(!showPanel.value);
            setMenuPanel(MenuPanelTag.Save);
            setComponentVisibility("showMenuPanel", true);
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.button_text, children: " / SAVE" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: styles$5.singleButton,
          onClick: () => {
            showPanel.set(!showPanel.value);
            setMenuPanel(MenuPanelTag.Load);
            setComponentVisibility("showMenuPanel", true);
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.button_text, children: " / LOAD" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: styles$5.singleButton,
          onClick: () => {
            showPanel.set(!showPanel.value);
            setMenuPanel(MenuPanelTag.Option);
            setComponentVisibility("showMenuPanel", true);
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.button_text, children: " / OPTIONS" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: styles$5.singleButton,
          onClick: () => {
            showPanel.set(!showPanel.value);
            backToTitle();
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.button_text, children: " / TITLE" })
        }
      )
    ] })
  ] }) });
};
const devPanelMain = "_devPanelMain_11x6i_1";
const devPanelOpener = "_devPanelOpener_11x6i_13";
const styles$4 = {
  devPanelMain,
  devPanelOpener
};
function getPixiSscreenshot() {
  const canvas = document.getElementById("pixiCanvas");
  canvas.toBlob((b2) => {
    if (b2) {
      const a2 = document.createElement("a");
      document.body.append(a2);
      a2.download = "screenshot";
      a2.href = URL.createObjectURL(b2);
      a2.click();
      a2.remove();
    }
  }, "image/png");
}
function DevPanel() {
  function isShowDevPanel() {
    const hash22 = window.location.hash;
    return !!hash22.match(/dev/);
  }
  const isOpenDevPanel = useValue(false);
  const hash2 = useValue(window.location.hash);
  const stageState = useSelector((state) => state.stage);
  reactExports.useEffect(() => {
    window.onhashchange = () => {
      hash2.set(window.location.hash);
    };
  }, []);
  const isShow = isShowDevPanel();
  const { t: t2, i18n } = useTranslation();
  const devMainArea = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => getPixiSscreenshot(), children: "Save PIXI Screenshot" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      "Current Language:",
      i18n.language
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => {
      var _a2;
      return (_a2 = WebGAL.gameplay.pixiStage) == null ? void 0 : _a2.removeAnimation("snow-Ticker");
    }, children: "Remove Snow Ticker" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Stage State" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: JSON.stringify(stageState, null, "  ") })
  ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    isShow && isOpenDevPanel.value && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$4.devPanelMain, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            onClick: () => isOpenDevPanel.set(false),
            style: { fontSize: "150%", padding: "0 0 0 15px", cursor: "pointer" },
            children: ""
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { padding: "0 0 0 15px", fontSize: "115%" }, children: "WebGAL DEV PANEL" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { padding: "10px 10px 10px 10px", overflow: "auto" }, children: devMainArea })
    ] }),
    !isOpenDevPanel.value && isShow && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => isOpenDevPanel.set(true), className: styles$4.devPanelOpener, children: "Open Dev Panel" })
  ] });
}
function getLanguageName(lang2) {
  return language[lang2];
}
function useLanguage() {
  const { i18n } = useTranslation();
  const userDataRef = useGenSyncRef((state) => state.userData);
  const dispatch = useDispatch();
  return (_lang, isSyncStorage = true) => {
    var _a2;
    const lang2 = _lang ?? ((_a2 = userDataRef.current) == null ? void 0 : _a2.optionData.language) ?? language.zhCn;
    const languageName = getLanguageName(lang2);
    i18n.changeLanguage(languageName);
    dispatch(setOptionData({ key: "language", value: lang2 }));
    logger.info(": " + languageName);
    window == null ? void 0 : window.localStorage.setItem("lang", lang2.toString());
    if (isSyncStorage) {
      setStorage();
    }
  };
}
const trans = "_trans_8uz61_2";
const langWrapper = "_langWrapper_8uz61_10";
const lang = "_lang_8uz61_10";
const langSelect = "_langSelect_8uz61_29";
const langSelectButton = "_langSelectButton_8uz61_35";
const s = {
  trans,
  langWrapper,
  lang,
  langSelect,
  langSelectButton
};
function Translation() {
  const setLanguage = useLanguage();
  const [isShowSelectLanguage, setIsShowSelectLanguage] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const lang2 = window == null ? void 0 : window.localStorage.getItem("lang");
    if (!lang2) {
      setIsShowSelectLanguage(true);
    } else {
      setLanguage(Number(window == null ? void 0 : window.localStorage.getItem("lang")), false);
    }
  }, []);
  const setLang = (langId) => {
    setIsShowSelectLanguage(false);
    setLanguage(langId);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: isShowSelectLanguage && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s.trans, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: s.langWrapper, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s.lang, children: "LANGUAGE SELECT" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: s.langSelect, children: Object.keys(languages).map((key) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: s.langSelectButton,
        onClick: () => setLang(language[key]),
        children: languages[key]
      },
      key
    )) })
  ] }) }) });
}
const panic_overlay_main = "_panic_overlay_main_1ysz4_1";
const styles$3 = {
  panic_overlay_main
};
const yoozle_blue = "_yoozle_blue_1r48o_1";
const yoozle_red = "_yoozle_red_1r48o_5";
const yoozle_yellow = "_yoozle_yellow_1r48o_9";
const yoozle_green = "_yoozle_green_1r48o_13";
const yoozle_e_rotate = "_yoozle_e_rotate_1r48o_17";
const yoozle_container = "_yoozle_container_1r48o_22";
const yoozle_title = "_yoozle_title_1r48o_28";
const yoozle_search = "_yoozle_search_1r48o_37";
const yoozle_search_bar = "_yoozle_search_bar_1r48o_44";
const yoozle_search_buttons = "_yoozle_search_buttons_1r48o_51";
const yoozle_button = "_yoozle_button_1r48o_55";
const styles$2 = {
  yoozle_blue,
  yoozle_red,
  yoozle_yellow,
  yoozle_green,
  yoozle_e_rotate,
  yoozle_container,
  yoozle_title,
  yoozle_search,
  yoozle_search_bar,
  yoozle_search_buttons,
  yoozle_button
};
const PanicYoozle = () => {
  reactExports.useEffect(() => {
    const panicTitle = "Yoozle Search";
    const originalTitle = document.title;
    document.title = panicTitle;
    return () => {
      document.title = originalTitle;
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2.yoozle_container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$2.yoozle_title, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$2.yoozle_blue, style: { marginRight: "1px" }, children: "Y" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$2.yoozle_red, children: "o" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$2.yoozle_yellow, children: "o" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$2.yoozle_blue, children: "z" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$2.yoozle_green, children: "l" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${styles$2.yoozle_red} ${styles$2.yoozle_e_rotate}`, children: "e" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2.yoozle_search, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("input", { className: styles$2.yoozle_search_bar, type: "text", defaultValue: "" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2.yoozle_search_buttons, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("input", { className: styles$2.yoozle_button, type: "submit", value: "Yoozle Search" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("input", { className: styles$2.yoozle_button, type: "submit", value: "Feeling Lucky" })
      ] })
    ] })
  ] });
};
const PanicOverlay = () => {
  const GUIStore = useSelector((state) => state.GUI);
  const [showOverlay, setShowOverlay] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setShowOverlay(GUIStore.showPanicOverlay);
  }, [GUIStore.showPanicOverlay]);
  return ReactDOM.createPortal(
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: showOverlay ? styles$3.panic_overlay_main : "", children: showOverlay && /* @__PURE__ */ jsxRuntimeExports.jsx(PanicYoozle, {}) }),
    document.querySelector("div#panic-overlay")
  );
};
function useFullScreen() {
  const userDataState = useSelector((state) => state.userData);
  const GUIState = useSelector((state) => state.GUI);
  useDispatch();
  const fullScreen = userDataState.optionData.fullScreen;
  const isEnterGame = GUIState.isEnterGame;
  reactExports.useEffect(() => {
    switch (fullScreen) {
      case fullScreenOption.on: {
        if (isEnterGame) {
          document.documentElement.requestFullscreen();
          if (keyboard)
            keyboard.lock(["Escape", "F11"]);
        }
        break;
      }
      case fullScreenOption.off: {
        if (document.fullscreenElement) {
          document.exitFullscreen();
          if (keyboard)
            keyboard.unlock();
        }
        break;
      }
    }
  }, [fullScreen]);
}
const gameMenuPanelWrapper = "_gameMenuPanelWrapper_wndxb_1";
const gameMenuPanel = "_gameMenuPanel_wndxb_1";
const menuButton = "_menuButton_wndxb_12";
const gameMenuPanelContentWrapper = "_gameMenuPanelContentWrapper_wndxb_26";
const mask = "_mask_wndxb_34";
const gameMenuPanelContent = "_gameMenuPanelContent_wndxb_26";
const buttonswrapper = "_buttonswrapper_wndxb_53";
const button = "_button_wndxb_53";
const styles$1 = {
  gameMenuPanelWrapper,
  gameMenuPanel,
  menuButton,
  gameMenuPanelContentWrapper,
  mask,
  gameMenuPanelContent,
  buttonswrapper,
  button
};
const GameMenuPanel = () => {
  const t2 = useTrans("gaming.");
  const { playSeEnter, playSeClick, playSeDialogOpen } = useSoundEffect();
  const GUIStore = useSelector((state) => state.GUI);
  const [show, setShow] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setShow(GUIStore.isShowGameMenu);
  }, [GUIStore.isShowGameMenu]);
  const dispatch = useDispatch();
  const setComponentVisibility = (component, visibility) => {
    dispatch(setVisibility({ component, visibility }));
  };
  const setMenuPanel = (menuPanel) => {
    dispatch(setMenuPanelTag(menuPanel));
  };
  const handleShowGameMenuPanel = () => {
    playSeClick();
    setComponentVisibility("isShowGameMenu", true);
  };
  const handleBackToGame = () => {
    playSeClick();
    setComponentVisibility("isShowGameMenu", false);
  };
  const handleSave = () => {
    playSeClick();
  };
  const handleRead = () => {
    setMenuPanel(MenuPanelTag.Save);
    setComponentVisibility("isShowGameMenu", false);
    setComponentVisibility("showMenuPanel", true);
    playSeClick();
  };
  const handleSetting = () => {
    setMenuPanel(MenuPanelTag.Option);
    setComponentVisibility("isShowGameMenu", false);
    setComponentVisibility("showMenuPanel", true);
    playSeClick();
  };
  const handleBackToTitle = () => {
    playSeDialogOpen();
    showGlogalDialog({
      title: t2("buttons.quitTips"),
      leftText: t2("$common.confirm"),
      rightText: t2("$common.cancel"),
      leftFunc: () => {
        setComponentVisibility("isShowGameMenu", false);
        backToTitle();
      },
      rightFunc: () => {
      }
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1.gameMenuPanel, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1.menuButton, onClick: handleShowGameMenuPanel, onMouseEnter: playSeEnter }) }),
    show && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1.gameMenuPanelContentWrapper, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1.mask }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$1.gameMenuPanelContent, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1.buttonswrapper, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$1.button, onMouseEnter: playSeEnter, onClick: handleBackToGame, children: t2("buttons.backToGame") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$1.button, onMouseEnter: playSeEnter, onClick: handleSave, children: t2("buttons.preserve") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$1.button, onMouseEnter: playSeEnter, onClick: handleRead, children: t2("buttons.read") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$1.button, onMouseEnter: playSeEnter, onClick: handleSetting, children: t2("buttons.setting") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$1.button, onMouseEnter: playSeEnter, onClick: handleBackToTitle, children: t2("buttons.backToTitle") })
      ] }) })
    ] })
  ] });
};
const Loading_container = "_Loading_container_4mfnk_2";
const spin = "_spin_4mfnk_1";
const styles = {
  Loading_container,
  spin
};
function Loading() {
  const [loading, setLoading] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const dispose = window.pubsub.subscribe("loading", ({ loading: loading2 }) => {
      setLoading(loading2);
    });
    return dispose;
  }, []);
  if (!loading)
    return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles.Loading_container, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "116", height: "116", viewBox: "0 0 116 116", fill: "none", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { filter: "url(#filter0_f_84_2)", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M58 33V43", stroke: "white", strokeWidth: "5", strokeLinecap: "round", strokeLinejoin: "round" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M58 73V83", stroke: "white", strokeWidth: "5", strokeLinecap: "round", strokeLinejoin: "round" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M83 58H73", stroke: "white", strokeWidth: "5", strokeLinecap: "round", strokeLinejoin: "round" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M43 58H33", stroke: "white", strokeWidth: "5", strokeLinecap: "round", strokeLinejoin: "round" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M40.3224 40.3224L47.3934 47.3934",
          stroke: "white",
          strokeWidth: "5",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M68.6067 68.6067L75.6777 75.6777",
          stroke: "white",
          strokeWidth: "5",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M75.6777 40.3224L68.6067 47.3934",
          stroke: "white",
          strokeWidth: "5",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M47.3934 68.6067L40.3224 75.6777",
          stroke: "white",
          strokeWidth: "5",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M58 33V43", stroke: "white", strokeWidth: "5", strokeLinecap: "round", strokeLinejoin: "round" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M58 73V83", stroke: "white", strokeWidth: "5", strokeLinecap: "round", strokeLinejoin: "round" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M83 58H73", stroke: "white", strokeWidth: "5", strokeLinecap: "round", strokeLinejoin: "round" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M43 58H33", stroke: "white", strokeWidth: "5", strokeLinecap: "round", strokeLinejoin: "round" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M40.3224 40.3224L47.3934 47.3934",
        stroke: "white",
        strokeWidth: "5",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M68.6067 68.6067L75.6777 75.6777",
        stroke: "white",
        strokeWidth: "5",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M75.6777 40.3224L68.6067 47.3934",
        stroke: "white",
        strokeWidth: "5",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M47.3934 68.6067L40.3224 75.6777",
        stroke: "white",
        strokeWidth: "5",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "filter",
      {
        id: "filter0_f_84_2",
        x: "0.5",
        y: "0.5",
        width: "115",
        height: "115",
        filterUnits: "userSpaceOnUse",
        colorInterpolationFilters: "sRGB",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feBlend", { mode: "normal", in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feGaussianBlur", { stdDeviation: "15", result: "effect1_foregroundBlur_84_2" })
        ]
      }
    ) })
  ] }) });
}
function App() {
  reactExports.useEffect(() => {
    initializeScript();
  }, []);
  useFullScreen();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "App", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Loading, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Translation, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Stage, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(GameMenuPanel, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BottomControlPanel, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BottomControlPanelFilm, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Backlog, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Title, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Extra, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Menu, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalDialog, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PanicOverlay, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DevPanel, {})
  ] });
}
const animation = "";
const reset_min = "";
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _setPrototypeOf(o2, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p2) {
    o3.__proto__ = p2;
    return o3;
  };
  return _setPrototypeOf(o2, p);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _possibleConstructorReturn(self2, call2) {
  if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}
function ownKeys$6(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$6(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$6(Object(source), true).forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var consoleLogger = {
  type: "logger",
  log: function log(args) {
    this.output("log", args);
  },
  warn: function warn2(args) {
    this.output("warn", args);
  },
  error: function error(args) {
    this.output("error", args);
  },
  output: function output(type2, args) {
    if (console && console[type2])
      console[type2].apply(console, args);
  }
};
var Logger = function() {
  function Logger2(concreteLogger) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Logger2);
    this.init(concreteLogger, options);
  }
  _createClass(Logger2, [{
    key: "init",
    value: function init3(concreteLogger) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = options.prefix || "i18next:";
      this.logger = concreteLogger || consoleLogger;
      this.options = options;
      this.debug = options.debug;
    }
  }, {
    key: "setDebug",
    value: function setDebug(bool) {
      this.debug = bool;
    }
  }, {
    key: "log",
    value: function log3() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.forward(args, "log", "", true);
    }
  }, {
    key: "warn",
    value: function warn3() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.forward(args, "warn", "", true);
    }
  }, {
    key: "error",
    value: function error2() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.forward(args, "error", "");
    }
  }, {
    key: "deprecate",
    value: function deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
    }
  }, {
    key: "forward",
    value: function forward(args, lvl, prefix2, debugOnly) {
      if (debugOnly && !this.debug)
        return null;
      if (typeof args[0] === "string")
        args[0] = "".concat(prefix2).concat(this.prefix, " ").concat(args[0]);
      return this.logger[lvl](args);
    }
  }, {
    key: "create",
    value: function create(moduleName) {
      return new Logger2(this.logger, _objectSpread$6(_objectSpread$6({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }), this.options));
    }
  }, {
    key: "clone",
    value: function clone(options) {
      options = options || this.options;
      options.prefix = options.prefix || this.prefix;
      return new Logger2(this.logger, options);
    }
  }]);
  return Logger2;
}();
var baseLogger = new Logger();
var EventEmitter = function() {
  function EventEmitter2() {
    _classCallCheck(this, EventEmitter2);
    this.observers = {};
  }
  _createClass(EventEmitter2, [{
    key: "on",
    value: function on2(events, listener) {
      var _this = this;
      events.split(" ").forEach(function(event) {
        _this.observers[event] = _this.observers[event] || [];
        _this.observers[event].push(listener);
      });
      return this;
    }
  }, {
    key: "off",
    value: function off(event, listener) {
      if (!this.observers[event])
        return;
      if (!listener) {
        delete this.observers[event];
        return;
      }
      this.observers[event] = this.observers[event].filter(function(l2) {
        return l2 !== listener;
      });
    }
  }, {
    key: "emit",
    value: function emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (this.observers[event]) {
        var cloned = [].concat(this.observers[event]);
        cloned.forEach(function(observer) {
          observer.apply(void 0, args);
        });
      }
      if (this.observers["*"]) {
        var _cloned = [].concat(this.observers["*"]);
        _cloned.forEach(function(observer) {
          observer.apply(observer, [event].concat(args));
        });
      }
    }
  }]);
  return EventEmitter2;
}();
function defer() {
  var res;
  var rej;
  var promise2 = new Promise(function(resolve2, reject2) {
    res = resolve2;
    rej = reject2;
  });
  promise2.resolve = res;
  promise2.reject = rej;
  return promise2;
}
function makeString(object) {
  if (object == null)
    return "";
  return "" + object;
}
function copy(a2, s2, t2) {
  a2.forEach(function(m2) {
    if (s2[m2])
      t2[m2] = s2[m2];
  });
}
function getLastOfPath(object, path, Empty) {
  function cleanKey(key2) {
    return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
  }
  function canNotTraverseDeeper() {
    return !object || typeof object === "string";
  }
  var stack = typeof path !== "string" ? [].concat(path) : path.split(".");
  while (stack.length > 1) {
    if (canNotTraverseDeeper())
      return {};
    var key = cleanKey(stack.shift());
    if (!object[key] && Empty)
      object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
  }
  if (canNotTraverseDeeper())
    return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}
function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object), obj = _getLastOfPath.obj, k2 = _getLastOfPath.k;
  obj[k2] = newValue;
}
function pushPath(object, path, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object, path, Object), obj = _getLastOfPath2.obj, k2 = _getLastOfPath2.k;
  obj[k2] = obj[k2] || [];
  if (concat)
    obj[k2] = obj[k2].concat(newValue);
  if (!concat)
    obj[k2].push(newValue);
}
function getPath(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path), obj = _getLastOfPath3.obj, k2 = _getLastOfPath3.k;
  if (!obj)
    return void 0;
  return obj[k2];
}
function getPathWithDefaults(data2, defaultData, key) {
  var value = getPath(data2, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
}
function deepExtend(target, source, overwrite) {
  for (var prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
          if (overwrite)
            target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape$1(data2) {
  if (typeof data2 === "string") {
    return data2.replace(/[&<>"'\/]/g, function(s2) {
      return _entityMap[s2];
    });
  }
  return data2;
}
var isIE10 = typeof window !== "undefined" && window.navigator && typeof window.navigator.userAgentData === "undefined" && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1;
var chars = [" ", ",", "?", "!", ";"];
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  var possibleChars = chars.filter(function(c2) {
    return nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0;
  });
  if (possibleChars.length === 0)
    return true;
  var r2 = new RegExp("(".concat(possibleChars.map(function(c2) {
    return c2 === "?" ? "\\?" : c2;
  }).join("|"), ")"));
  var matched = !r2.test(key);
  if (!matched) {
    var ki2 = key.indexOf(keySeparator);
    if (ki2 > 0 && !r2.test(key.substring(0, ki2))) {
      matched = true;
    }
  }
  return matched;
}
function deepFind(obj, path) {
  var keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj)
    return void 0;
  if (obj[path])
    return obj[path];
  var paths = path.split(keySeparator);
  var current = obj;
  for (var i2 = 0; i2 < paths.length; ++i2) {
    if (!current)
      return void 0;
    if (typeof current[paths[i2]] === "string" && i2 + 1 < paths.length) {
      return void 0;
    }
    if (current[paths[i2]] === void 0) {
      var j2 = 2;
      var p = paths.slice(i2, i2 + j2).join(keySeparator);
      var mix2 = current[p];
      while (mix2 === void 0 && paths.length > i2 + j2) {
        j2++;
        p = paths.slice(i2, i2 + j2).join(keySeparator);
        mix2 = current[p];
      }
      if (mix2 === void 0)
        return void 0;
      if (mix2 === null)
        return null;
      if (path.endsWith(p)) {
        if (typeof mix2 === "string")
          return mix2;
        if (p && typeof mix2[p] === "string")
          return mix2[p];
      }
      var joinedPath = paths.slice(i2 + j2).join(keySeparator);
      if (joinedPath)
        return deepFind(mix2, joinedPath, keySeparator);
      return void 0;
    }
    current = current[paths[i2]];
  }
  return current;
}
function ownKeys$5(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$5(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$5(Object(source), true).forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var ResourceStore = function(_EventEmitter) {
  _inherits(ResourceStore2, _EventEmitter);
  var _super = _createSuper$3(ResourceStore2);
  function ResourceStore2(data2) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    _classCallCheck(this, ResourceStore2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.data = data2 || {};
    _this.options = options;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    if (_this.options.ignoreJSONStructure === void 0) {
      _this.options.ignoreJSONStructure = true;
    }
    return _this;
  }
  _createClass(ResourceStore2, [{
    key: "addNamespaces",
    value: function addNamespaces(ns) {
      if (this.options.ns.indexOf(ns) < 0) {
        this.options.ns.push(ns);
      }
    }
  }, {
    key: "removeNamespaces",
    value: function removeNamespaces(ns) {
      var index2 = this.options.ns.indexOf(ns);
      if (index2 > -1) {
        this.options.ns.splice(index2, 1);
      }
    }
  }, {
    key: "getResource",
    value: function getResource(lng, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
      var path = [lng, ns];
      if (key && typeof key !== "string")
        path = path.concat(key);
      if (key && typeof key === "string")
        path = path.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
      }
      var result = getPath(this.data, path);
      if (result || !ignoreJSONStructure || typeof key !== "string")
        return result;
      return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
    }
  }, {
    key: "addResource",
    value: function addResource(lng, ns, key, value) {
      var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: false
      };
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var path = [lng, ns];
      if (key)
        path = path.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
        value = ns;
        ns = path[1];
      }
      this.addNamespaces(ns);
      setPath(this.data, path, value);
      if (!options.silent)
        this.emit("added", lng, ns, key, value);
    }
  }, {
    key: "addResources",
    value: function addResources(lng, ns, resources2) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: false
      };
      for (var m2 in resources2) {
        if (typeof resources2[m2] === "string" || Object.prototype.toString.apply(resources2[m2]) === "[object Array]")
          this.addResource(lng, ns, m2, resources2[m2], {
            silent: true
          });
      }
      if (!options.silent)
        this.emit("added", lng, ns, resources2);
    }
  }, {
    key: "addResourceBundle",
    value: function addResourceBundle(lng, ns, resources2, deep, overwrite) {
      var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: false
      };
      var path = [lng, ns];
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
        deep = resources2;
        resources2 = ns;
        ns = path[1];
      }
      this.addNamespaces(ns);
      var pack = getPath(this.data, path) || {};
      if (deep) {
        deepExtend(pack, resources2, overwrite);
      } else {
        pack = _objectSpread$5(_objectSpread$5({}, pack), resources2);
      }
      setPath(this.data, path, pack);
      if (!options.silent)
        this.emit("added", lng, ns, resources2);
    }
  }, {
    key: "removeResourceBundle",
    value: function removeResourceBundle(lng, ns) {
      if (this.hasResourceBundle(lng, ns)) {
        delete this.data[lng][ns];
      }
      this.removeNamespaces(ns);
      this.emit("removed", lng, ns);
    }
  }, {
    key: "hasResourceBundle",
    value: function hasResourceBundle(lng, ns) {
      return this.getResource(lng, ns) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function getResourceBundle(lng, ns) {
      if (!ns)
        ns = this.options.defaultNS;
      if (this.options.compatibilityAPI === "v1")
        return _objectSpread$5(_objectSpread$5({}, {}), this.getResource(lng, ns));
      return this.getResource(lng, ns);
    }
  }, {
    key: "getDataByLanguage",
    value: function getDataByLanguage(lng) {
      return this.data[lng];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function hasLanguageSomeTranslations(lng) {
      var data2 = this.getDataByLanguage(lng);
      var n2 = data2 && Object.keys(data2) || [];
      return !!n2.find(function(v2) {
        return data2[v2] && Object.keys(data2[v2]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON2() {
      return this.data;
    }
  }]);
  return ResourceStore2;
}(EventEmitter);
var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle: function handle2(processors, value, key, options, translator) {
    var _this = this;
    processors.forEach(function(processor) {
      if (_this.processors[processor])
        value = _this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};
function ownKeys$4(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$4(Object(source), true).forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var checkedLoadedFor = {};
var Translator = function(_EventEmitter) {
  _inherits(Translator2, _EventEmitter);
  var _super = _createSuper$2(Translator2);
  function Translator2(services) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Translator2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized(_this));
    _this.options = options;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    _this.logger = baseLogger.create("translator");
    return _this;
  }
  _createClass(Translator2, [{
    key: "changeLanguage",
    value: function changeLanguage(lng) {
      if (lng)
        this.language = lng;
    }
  }, {
    key: "exists",
    value: function exists(key) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (key === void 0 || key === null) {
        return false;
      }
      var resolved = this.resolve(key, options);
      return resolved && resolved.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function extractFromKey(key, options) {
      var nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
      if (nsSeparator === void 0)
        nsSeparator = ":";
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var namespaces = options.ns || this.options.defaultNS || [];
      var wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
      var seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
      if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
        var m2 = key.match(this.interpolator.nestingRegexp);
        if (m2 && m2.length > 0) {
          return {
            key,
            namespaces
          };
        }
        var parts = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
          namespaces = parts.shift();
        key = parts.join(keySeparator);
      }
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      return {
        key,
        namespaces
      };
    }
  }, {
    key: "translate",
    value: function translate(keys2, options, lastKey) {
      var _this2 = this;
      if (_typeof(options) !== "object" && this.options.overloadTranslationOptionHandler) {
        options = this.options.overloadTranslationOptionHandler(arguments);
      }
      if (_typeof(options) === "object")
        options = _objectSpread$4({}, options);
      if (!options)
        options = {};
      if (keys2 === void 0 || keys2 === null)
        return "";
      if (!Array.isArray(keys2))
        keys2 = [String(keys2)];
      var returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var _this$extractFromKey = this.extractFromKey(keys2[keys2.length - 1], options), key = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces;
      var namespace = namespaces[namespaces.length - 1];
      var lng = options.lng || this.language;
      var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (lng && lng.toLowerCase() === "cimode") {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options.nsSeparator || this.options.nsSeparator;
          if (returnDetails) {
            return {
              res: "".concat(namespace).concat(nsSeparator).concat(key),
              usedKey: key,
              exactUsedKey: key,
              usedLng: lng,
              usedNS: namespace
            };
          }
          return "".concat(namespace).concat(nsSeparator).concat(key);
        }
        if (returnDetails) {
          return {
            res: key,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace
          };
        }
        return key;
      }
      var resolved = this.resolve(keys2, options);
      var res = resolved && resolved.res;
      var resUsedKey = resolved && resolved.usedKey || key;
      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
      var resType = Object.prototype.toString.apply(res);
      var noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
      var joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      var handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
        if (!options.returnObjects && !this.options.returnObjects) {
          if (!this.options.returnedObjectHandler) {
            this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          }
          var r2 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$4(_objectSpread$4({}, options), {}, {
            ns: namespaces
          })) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
          if (returnDetails) {
            resolved.res = r2;
            return resolved;
          }
          return r2;
        }
        if (keySeparator) {
          var resTypeIsArray = resType === "[object Array]";
          var copy2 = resTypeIsArray ? [] : {};
          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
          for (var m2 in res) {
            if (Object.prototype.hasOwnProperty.call(res, m2)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m2);
              copy2[m2] = this.translate(deepKey, _objectSpread$4(_objectSpread$4({}, options), {
                joinArrays: false,
                ns: namespaces
              }));
              if (copy2[m2] === deepKey)
                copy2[m2] = res[m2];
            }
          }
          res = copy2;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
        res = res.join(joinArrays);
        if (res)
          res = this.extendTranslation(res, keys2, options, lastKey);
      } else {
        var usedDefault = false;
        var usedKey = false;
        var needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        var hasDefaultValue = Translator2.hasDefaultValue(options);
        var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
        var defaultValue2 = options["defaultValue".concat(defaultValueSuffix)] || options.defaultValue;
        if (!this.isValidLookup(res) && hasDefaultValue) {
          usedDefault = true;
          res = defaultValue2;
        }
        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        }
        var missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
        var resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
        var updateMissing = hasDefaultValue && defaultValue2 !== res && this.options.updateMissing;
        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue2 : res);
          if (keySeparator) {
            var fk2 = this.resolve(key, _objectSpread$4(_objectSpread$4({}, options), {}, {
              keySeparator: false
            }));
            if (fk2 && fk2.res)
              this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var lngs = [];
          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
            for (var i2 = 0; i2 < fallbackLngs.length; i2++) {
              lngs.push(fallbackLngs[i2]);
            }
          } else if (this.options.saveMissingTo === "all") {
            lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
          } else {
            lngs.push(options.lng || this.language);
          }
          var send = function send2(l2, k2, specificDefaultValue) {
            var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
            if (_this2.options.missingKeyHandler) {
              _this2.options.missingKeyHandler(l2, namespace, k2, defaultForMissing, updateMissing, options);
            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
              _this2.backendConnector.saveMissing(l2, namespace, k2, defaultForMissing, updateMissing, options);
            }
            _this2.emit("missingKey", l2, namespace, k2, res);
          };
          if (this.options.saveMissing) {
            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach(function(language2) {
                _this2.pluralResolver.getSuffixes(language2, options).forEach(function(suffix) {
                  send([language2], key + suffix, options["defaultValue".concat(suffix)] || defaultValue2);
                });
              });
            } else {
              send(lngs, key, defaultValue2);
            }
          }
        }
        res = this.extendTranslation(res, keys2, options, resolved, lastKey);
        if (usedKey && res === key && this.options.appendNamespaceToMissingKey)
          res = "".concat(namespace, ":").concat(key);
        if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
          if (this.options.compatibilityAPI !== "v1") {
            res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(namespace, ":").concat(key) : key, usedDefault ? res : void 0);
          } else {
            res = this.options.parseMissingKeyHandler(res);
          }
        }
      }
      if (returnDetails) {
        resolved.res = res;
        return resolved;
      }
      return res;
    }
  }, {
    key: "extendTranslation",
    value: function extendTranslation(res, key, options, resolved, lastKey) {
      var _this3 = this;
      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, _objectSpread$4(_objectSpread$4({}, this.options.interpolation.defaultVariables), options), resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved
        });
      } else if (!options.skipInterpolation) {
        if (options.interpolation)
          this.interpolator.init(_objectSpread$4(_objectSpread$4({}, options), {
            interpolation: _objectSpread$4(_objectSpread$4({}, this.options.interpolation), options.interpolation)
          }));
        var skipOnVariables = typeof res === "string" && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
        var nestBef;
        if (skipOnVariables) {
          var nb2 = res.match(this.interpolator.nestingRegexp);
          nestBef = nb2 && nb2.length;
        }
        var data2 = options.replace && typeof options.replace !== "string" ? options.replace : options;
        if (this.options.interpolation.defaultVariables)
          data2 = _objectSpread$4(_objectSpread$4({}, this.options.interpolation.defaultVariables), data2);
        res = this.interpolator.interpolate(res, data2, options.lng || this.language, options);
        if (skipOnVariables) {
          var na2 = res.match(this.interpolator.nestingRegexp);
          var nestAft = na2 && na2.length;
          if (nestBef < nestAft)
            options.nest = false;
        }
        if (!options.lng && this.options.compatibilityAPI !== "v1" && resolved && resolved.res)
          options.lng = resolved.usedLng;
        if (options.nest !== false)
          res = this.interpolator.nest(res, function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (lastKey && lastKey[0] === args[0] && !options.context) {
              _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
              return null;
            }
            return _this3.translate.apply(_this3, args.concat([key]));
          }, options);
        if (options.interpolation)
          this.interpolator.reset();
      }
      var postProcess = options.postProcess || this.options.postProcess;
      var postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
      if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread$4({
          i18nResolved: resolved
        }, options) : options, this);
      }
      return res;
    }
  }, {
    key: "resolve",
    value: function resolve2(keys2) {
      var _this4 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var found;
      var usedKey;
      var exactUsedKey;
      var usedLng;
      var usedNS;
      if (typeof keys2 === "string")
        keys2 = [keys2];
      keys2.forEach(function(k2) {
        if (_this4.isValidLookup(found))
          return;
        var extracted = _this4.extractFromKey(k2, options);
        var key = extracted.key;
        usedKey = key;
        var namespaces = extracted.namespaces;
        if (_this4.options.fallbackNS)
          namespaces = namespaces.concat(_this4.options.fallbackNS);
        var needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        var needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && _this4.pluralResolver.shouldUseIntlApi();
        var needsContextHandling = options.context !== void 0 && (typeof options.context === "string" || typeof options.context === "number") && options.context !== "";
        var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
        namespaces.forEach(function(ns) {
          if (_this4.isValidLookup(found))
            return;
          usedNS = ns;
          if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;
            _this4.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes.join(", "), `" won't get resolved as namespace "`).concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          }
          codes.forEach(function(code) {
            if (_this4.isValidLookup(found))
              return;
            usedLng = code;
            var finalKeys = [key];
            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
              _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
            } else {
              var pluralSuffix;
              if (needsPluralHandling)
                pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count, options);
              var zeroSuffix = "".concat(_this4.options.pluralSeparator, "zero");
              if (needsPluralHandling) {
                finalKeys.push(key + pluralSuffix);
                if (needsZeroSuffixLookup) {
                  finalKeys.push(key + zeroSuffix);
                }
              }
              if (needsContextHandling) {
                var contextKey = "".concat(key).concat(_this4.options.contextSeparator).concat(options.context);
                finalKeys.push(contextKey);
                if (needsPluralHandling) {
                  finalKeys.push(contextKey + pluralSuffix);
                  if (needsZeroSuffixLookup) {
                    finalKeys.push(contextKey + zeroSuffix);
                  }
                }
              }
            }
            var possibleKey;
            while (possibleKey = finalKeys.pop()) {
              if (!_this4.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = _this4.getResource(code, ns, possibleKey, options);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey,
        exactUsedKey,
        usedLng,
        usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function isValidLookup(res) {
      return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }
  }, {
    key: "getResource",
    value: function getResource(code, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource)
        return this.i18nFormat.getResource(code, ns, key, options);
      return this.resourceStore.getResource(code, ns, key, options);
    }
  }], [{
    key: "hasDefaultValue",
    value: function hasDefaultValue(options) {
      var prefix2 = "defaultValue";
      for (var option in options) {
        if (Object.prototype.hasOwnProperty.call(options, option) && prefix2 === option.substring(0, prefix2.length) && void 0 !== options[option]) {
          return true;
        }
      }
      return false;
    }
  }]);
  return Translator2;
}(EventEmitter);
function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
var LanguageUtil = function() {
  function LanguageUtil2(options) {
    _classCallCheck(this, LanguageUtil2);
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  _createClass(LanguageUtil2, [{
    key: "getScriptPartFromCode",
    value: function getScriptPartFromCode(code) {
      if (!code || code.indexOf("-") < 0)
        return null;
      var p = code.split("-");
      if (p.length === 2)
        return null;
      p.pop();
      if (p[p.length - 1].toLowerCase() === "x")
        return null;
      return this.formatLanguageCode(p.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function getLanguagePartFromCode(code) {
      if (!code || code.indexOf("-") < 0)
        return code;
      var p = code.split("-");
      return this.formatLanguageCode(p[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function formatLanguageCode(code) {
      if (typeof code === "string" && code.indexOf("-") > -1) {
        var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
        var p = code.split("-");
        if (this.options.lowerCaseLng) {
          p = p.map(function(part) {
            return part.toLowerCase();
          });
        } else if (p.length === 2) {
          p[0] = p[0].toLowerCase();
          p[1] = p[1].toUpperCase();
          if (specialCases.indexOf(p[1].toLowerCase()) > -1)
            p[1] = capitalize(p[1].toLowerCase());
        } else if (p.length === 3) {
          p[0] = p[0].toLowerCase();
          if (p[1].length === 2)
            p[1] = p[1].toUpperCase();
          if (p[0] !== "sgn" && p[2].length === 2)
            p[2] = p[2].toUpperCase();
          if (specialCases.indexOf(p[1].toLowerCase()) > -1)
            p[1] = capitalize(p[1].toLowerCase());
          if (specialCases.indexOf(p[2].toLowerCase()) > -1)
            p[2] = capitalize(p[2].toLowerCase());
        }
        return p.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
  }, {
    key: "isSupportedCode",
    value: function isSupportedCode(code) {
      if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
        code = this.getLanguagePartFromCode(code);
      }
      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function getBestMatchFromCodes(codes) {
      var _this = this;
      if (!codes)
        return null;
      var found;
      codes.forEach(function(code) {
        if (found)
          return;
        var cleanedLng = _this.formatLanguageCode(code);
        if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng))
          found = cleanedLng;
      });
      if (!found && this.options.supportedLngs) {
        codes.forEach(function(code) {
          if (found)
            return;
          var lngOnly = _this.getLanguagePartFromCode(code);
          if (_this.isSupportedCode(lngOnly))
            return found = lngOnly;
          found = _this.options.supportedLngs.find(function(supportedLng) {
            if (supportedLng === lngOnly)
              return supportedLng;
            if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0)
              return;
            if (supportedLng.indexOf(lngOnly) === 0)
              return supportedLng;
          });
        });
      }
      if (!found)
        found = this.getFallbackCodes(this.options.fallbackLng)[0];
      return found;
    }
  }, {
    key: "getFallbackCodes",
    value: function getFallbackCodes(fallbacks, code) {
      if (!fallbacks)
        return [];
      if (typeof fallbacks === "function")
        fallbacks = fallbacks(code);
      if (typeof fallbacks === "string")
        fallbacks = [fallbacks];
      if (Object.prototype.toString.apply(fallbacks) === "[object Array]")
        return fallbacks;
      if (!code)
        return fallbacks["default"] || [];
      var found = fallbacks[code];
      if (!found)
        found = fallbacks[this.getScriptPartFromCode(code)];
      if (!found)
        found = fallbacks[this.formatLanguageCode(code)];
      if (!found)
        found = fallbacks[this.getLanguagePartFromCode(code)];
      if (!found)
        found = fallbacks["default"];
      return found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function toResolveHierarchy(code, fallbackCode) {
      var _this2 = this;
      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
      var codes = [];
      var addCode = function addCode2(c2) {
        if (!c2)
          return;
        if (_this2.isSupportedCode(c2)) {
          codes.push(c2);
        } else {
          _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c2));
        }
      };
      if (typeof code === "string" && code.indexOf("-") > -1) {
        if (this.options.load !== "languageOnly")
          addCode(this.formatLanguageCode(code));
        if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
          addCode(this.getScriptPartFromCode(code));
        if (this.options.load !== "currentOnly")
          addCode(this.getLanguagePartFromCode(code));
      } else if (typeof code === "string") {
        addCode(this.formatLanguageCode(code));
      }
      fallbackCodes.forEach(function(fc2) {
        if (codes.indexOf(fc2) < 0)
          addCode(_this2.formatLanguageCode(fc2));
      });
      return codes;
    }
  }]);
  return LanguageUtil2;
}();
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _2(n2) {
    return Number(n2 > 1);
  },
  2: function _3(n2) {
    return Number(n2 != 1);
  },
  3: function _4(n2) {
    return 0;
  },
  4: function _5(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  5: function _6(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5);
  },
  6: function _7(n2) {
    return Number(n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2);
  },
  7: function _8(n2) {
    return Number(n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  8: function _9(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3);
  },
  9: function _10(n2) {
    return Number(n2 >= 2);
  },
  10: function _11(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4);
  },
  11: function _12(n2) {
    return Number(n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3);
  },
  12: function _13(n2) {
    return Number(n2 % 10 != 1 || n2 % 100 == 11);
  },
  13: function _14(n2) {
    return Number(n2 !== 0);
  },
  14: function _15(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3);
  },
  15: function _16(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  16: function _17(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2);
  },
  17: function _18(n2) {
    return Number(n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1);
  },
  18: function _19(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : 2);
  },
  19: function _20(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3);
  },
  20: function _21(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2);
  },
  21: function _22(n2) {
    return Number(n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0);
  },
  22: function _23(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3);
  }
};
var deprecatedJsonVersions = ["v1", "v2", "v3"];
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function createRules() {
  var rules = {};
  sets.forEach(function(set) {
    set.lngs.forEach(function(l2) {
      rules[l2] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
}
var PluralResolver = function() {
  function PluralResolver2(languageUtils) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, PluralResolver2);
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
  }
  _createClass(PluralResolver2, [{
    key: "addRule",
    value: function addRule(lng, obj) {
      this.rules[lng] = obj;
    }
  }, {
    key: "getRule",
    value: function getRule(code) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi()) {
        try {
          return new Intl.PluralRules(code, {
            type: options.ordinal ? "ordinal" : "cardinal"
          });
        } catch (_unused) {
          return;
        }
      }
      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
    }
  }, {
    key: "needsPlural",
    value: function needsPlural(code) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code, options);
      if (this.shouldUseIntlApi()) {
        return rule && rule.resolvedOptions().pluralCategories.length > 1;
      }
      return rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function getPluralFormsOfKey(code, key) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(code, options).map(function(suffix) {
        return "".concat(key).concat(suffix);
      });
    }
  }, {
    key: "getSuffixes",
    value: function getSuffixes(code) {
      var _this = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code, options);
      if (!rule) {
        return [];
      }
      if (this.shouldUseIntlApi()) {
        return rule.resolvedOptions().pluralCategories.sort(function(pluralCategory1, pluralCategory2) {
          return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];
        }).map(function(pluralCategory) {
          return "".concat(_this.options.prepend).concat(pluralCategory);
        });
      }
      return rule.numbers.map(function(number2) {
        return _this.getSuffix(code, number2, options);
      });
    }
  }, {
    key: "getSuffix",
    value: function getSuffix(code, count) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var rule = this.getRule(code, options);
      if (rule) {
        if (this.shouldUseIntlApi()) {
          return "".concat(this.options.prepend).concat(rule.select(count));
        }
        return this.getSuffixRetroCompatible(rule, count);
      }
      this.logger.warn("no plural rule found for: ".concat(code));
      return "";
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function getSuffixRetroCompatible(rule, count) {
      var _this2 = this;
      var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
      var suffix = rule.numbers[idx];
      if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        if (suffix === 2) {
          suffix = "plural";
        } else if (suffix === 1) {
          suffix = "";
        }
      }
      var returnSuffix = function returnSuffix2() {
        return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
      };
      if (this.options.compatibilityJSON === "v1") {
        if (suffix === 1)
          return "";
        if (typeof suffix === "number")
          return "_plural_".concat(suffix.toString());
        return returnSuffix();
      } else if (this.options.compatibilityJSON === "v2") {
        return returnSuffix();
      } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        return returnSuffix();
      }
      return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function shouldUseIntlApi() {
      return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);
    }
  }]);
  return PluralResolver2;
}();
function ownKeys$3(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$3(Object(source), true).forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function deepFindWithDefaults(data2, defaultData, key) {
  var keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
  var ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  var path = getPathWithDefaults(data2, defaultData, key);
  if (!path && ignoreJSONStructure && typeof key === "string") {
    path = deepFind(data2, key, keySeparator);
    if (path === void 0)
      path = deepFind(defaultData, key, keySeparator);
  }
  return path;
}
var Interpolator = function() {
  function Interpolator2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Interpolator2);
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || function(value) {
      return value;
    };
    this.init(options);
  }
  _createClass(Interpolator2, [{
    key: "init",
    value: function init3() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!options.interpolation)
        options.interpolation = {
          escapeValue: true
        };
      var iOpts = options.interpolation;
      this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape$1;
      this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
      this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
      this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
      this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
      this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
      this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.options)
        this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function resetRegExp() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, "g");
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
    }
  }, {
    key: "interpolate",
    value: function interpolate2(str, data2, lng, options) {
      var _this = this;
      var match2;
      var value;
      var replaces;
      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function regexSafe(val) {
        return val.replace(/\$/g, "$$$$");
      }
      var handleFormat = function handleFormat2(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          var path = deepFindWithDefaults(data2, defaultData, key, _this.options.keySeparator, _this.options.ignoreJSONStructure);
          return _this.alwaysFormat ? _this.format(path, void 0, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data2), {}, {
            interpolationkey: key
          })) : path;
        }
        var p = key.split(_this.formatSeparator);
        var k2 = p.shift().trim();
        var f2 = p.join(_this.formatSeparator).trim();
        return _this.format(deepFindWithDefaults(data2, defaultData, k2, _this.options.keySeparator, _this.options.ignoreJSONStructure), f2, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data2), {}, {
          interpolationkey: k2
        }));
      };
      this.resetRegExp();
      var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
      var skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
      var todos = [{
        regex: this.regexpUnescape,
        safeValue: function safeValue(val) {
          return regexSafe(val);
        }
      }, {
        regex: this.regexp,
        safeValue: function safeValue(val) {
          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
        }
      }];
      todos.forEach(function(todo) {
        replaces = 0;
        while (match2 = todo.regex.exec(str)) {
          var matchedVar = match2[1].trim();
          value = handleFormat(matchedVar);
          if (value === void 0) {
            if (typeof missingInterpolationHandler === "function") {
              var temp2 = missingInterpolationHandler(str, match2, options);
              value = typeof temp2 === "string" ? temp2 : "";
            } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
              value = "";
            } else if (skipOnVariables) {
              value = match2[0];
              continue;
            } else {
              _this.logger.warn("missed to pass in variable ".concat(matchedVar, " for interpolating ").concat(str));
              value = "";
            }
          } else if (typeof value !== "string" && !_this.useRawValueToEscape) {
            value = makeString(value);
          }
          var safeValue = todo.safeValue(value);
          str = str.replace(match2[0], safeValue);
          if (skipOnVariables) {
            todo.regex.lastIndex += value.length;
            todo.regex.lastIndex -= match2[0].length;
          } else {
            todo.regex.lastIndex = 0;
          }
          replaces++;
          if (replaces >= _this.maxReplaces) {
            break;
          }
        }
      });
      return str;
    }
  }, {
    key: "nest",
    value: function nest(str, fc2) {
      var _this2 = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var match2;
      var value;
      var clonedOptions;
      function handleHasOptions(key, inheritedOptions) {
        var sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0)
          return key;
        var c2 = key.split(new RegExp("".concat(sep, "[ ]*{")));
        var optionsString = "{".concat(c2[1]);
        key = c2[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        var matchedSingleQuotes = optionsString.match(/'/g);
        var matchedDoubleQuotes = optionsString.match(/"/g);
        if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
          optionsString = optionsString.replace(/'/g, '"');
        }
        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions)
            clonedOptions = _objectSpread$3(_objectSpread$3({}, inheritedOptions), clonedOptions);
        } catch (e2) {
          this.logger.warn("failed parsing options string in nesting for key ".concat(key), e2);
          return "".concat(key).concat(sep).concat(optionsString);
        }
        delete clonedOptions.defaultValue;
        return key;
      }
      while (match2 = this.nestingRegexp.exec(str)) {
        var formatters = [];
        clonedOptions = _objectSpread$3({}, options);
        clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== "string" ? clonedOptions.replace : clonedOptions;
        clonedOptions.applyPostProcessor = false;
        delete clonedOptions.defaultValue;
        var doReduce = false;
        if (match2[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match2[1])) {
          var r2 = match2[1].split(this.formatSeparator).map(function(elem) {
            return elem.trim();
          });
          match2[1] = r2.shift();
          formatters = r2;
          doReduce = true;
        }
        value = fc2(handleHasOptions.call(this, match2[1].trim(), clonedOptions), clonedOptions);
        if (value && match2[0] === str && typeof value !== "string")
          return value;
        if (typeof value !== "string")
          value = makeString(value);
        if (!value) {
          this.logger.warn("missed to resolve ".concat(match2[1], " for nesting ").concat(str));
          value = "";
        }
        if (doReduce) {
          value = formatters.reduce(function(v2, f2) {
            return _this2.format(v2, f2, options.lng, _objectSpread$3(_objectSpread$3({}, options), {}, {
              interpolationkey: match2[1].trim()
            }));
          }, value.trim());
        }
        str = str.replace(match2[0], value);
        this.regexp.lastIndex = 0;
      }
      return str;
    }
  }]);
  return Interpolator2;
}();
function ownKeys$2(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function parseFormatStr(formatStr) {
  var formatName = formatStr.toLowerCase().trim();
  var formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    var p = formatStr.split("(");
    formatName = p[0].toLowerCase().trim();
    var optStr = p[1].substring(0, p[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency)
        formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range)
        formatOptions.range = optStr.trim();
    } else {
      var opts = optStr.split(";");
      opts.forEach(function(opt) {
        if (!opt)
          return;
        var _opt$split = opt.split(":"), _opt$split2 = _toArray(_opt$split), key = _opt$split2[0], rest = _opt$split2.slice(1);
        var val = rest.join(":").trim().replace(/^'+|'+$/g, "");
        if (!formatOptions[key.trim()])
          formatOptions[key.trim()] = val;
        if (val === "false")
          formatOptions[key.trim()] = false;
        if (val === "true")
          formatOptions[key.trim()] = true;
        if (!isNaN(val))
          formatOptions[key.trim()] = parseInt(val, 10);
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}
function createCachedFormatter(fn2) {
  var cache = {};
  return function invokeFormatter(val, lng, options) {
    var key = lng + JSON.stringify(options);
    var formatter = cache[key];
    if (!formatter) {
      formatter = fn2(lng, options);
      cache[key] = formatter;
    }
    return formatter(val);
  };
}
var Formatter = function() {
  function Formatter2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Formatter2);
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: createCachedFormatter(function(lng, opt) {
        var formatter = new Intl.NumberFormat(lng, _objectSpread$2({}, opt));
        return function(val) {
          return formatter.format(val);
        };
      }),
      currency: createCachedFormatter(function(lng, opt) {
        var formatter = new Intl.NumberFormat(lng, _objectSpread$2(_objectSpread$2({}, opt), {}, {
          style: "currency"
        }));
        return function(val) {
          return formatter.format(val);
        };
      }),
      datetime: createCachedFormatter(function(lng, opt) {
        var formatter = new Intl.DateTimeFormat(lng, _objectSpread$2({}, opt));
        return function(val) {
          return formatter.format(val);
        };
      }),
      relativetime: createCachedFormatter(function(lng, opt) {
        var formatter = new Intl.RelativeTimeFormat(lng, _objectSpread$2({}, opt));
        return function(val) {
          return formatter.format(val, opt.range || "day");
        };
      }),
      list: createCachedFormatter(function(lng, opt) {
        var formatter = new Intl.ListFormat(lng, _objectSpread$2({}, opt));
        return function(val) {
          return formatter.format(val);
        };
      })
    };
    this.init(options);
  }
  _createClass(Formatter2, [{
    key: "init",
    value: function init3(services) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      var iOpts = options.interpolation;
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
    }
  }, {
    key: "add",
    value: function add2(name, fc2) {
      this.formats[name.toLowerCase().trim()] = fc2;
    }
  }, {
    key: "addCached",
    value: function addCached(name, fc2) {
      this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc2);
    }
  }, {
    key: "format",
    value: function format2(value, _format, lng) {
      var _this = this;
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var formats2 = _format.split(this.formatSeparator);
      var result = formats2.reduce(function(mem, f2) {
        var _parseFormatStr = parseFormatStr(f2), formatName = _parseFormatStr.formatName, formatOptions = _parseFormatStr.formatOptions;
        if (_this.formats[formatName]) {
          var formatted = mem;
          try {
            var valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
            var l2 = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
            formatted = _this.formats[formatName](mem, l2, _objectSpread$2(_objectSpread$2(_objectSpread$2({}, formatOptions), options), valOptions));
          } catch (error2) {
            _this.logger.warn(error2);
          }
          return formatted;
        } else {
          _this.logger.warn("there was no format function for ".concat(formatName));
        }
        return mem;
      }, value);
      return result;
    }
  }]);
  return Formatter2;
}();
function ownKeys$1(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function removePending(q2, name) {
  if (q2.pending[name] !== void 0) {
    delete q2.pending[name];
    q2.pendingCount--;
  }
}
var Connector = function(_EventEmitter) {
  _inherits(Connector2, _EventEmitter);
  var _super = _createSuper$1(Connector2);
  function Connector2(backend, store, services) {
    var _this;
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    _classCallCheck(this, Connector2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.backend = backend;
    _this.store = store;
    _this.services = services;
    _this.languageUtils = services.languageUtils;
    _this.options = options;
    _this.logger = baseLogger.create("backendConnector");
    _this.waitingReads = [];
    _this.maxParallelReads = options.maxParallelReads || 10;
    _this.readingCalls = 0;
    _this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    _this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    _this.state = {};
    _this.queue = [];
    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options.backend, options);
    }
    return _this;
  }
  _createClass(Connector2, [{
    key: "queueLoad",
    value: function queueLoad(languages2, namespaces, options, callback) {
      var _this2 = this;
      var toLoad = {};
      var pending = {};
      var toLoadLanguages = {};
      var toLoadNamespaces = {};
      languages2.forEach(function(lng) {
        var hasAllNamespaces = true;
        namespaces.forEach(function(ns) {
          var name = "".concat(lng, "|").concat(ns);
          if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
            _this2.state[name] = 2;
          } else if (_this2.state[name] < 0)
            ;
          else if (_this2.state[name] === 1) {
            if (pending[name] === void 0)
              pending[name] = true;
          } else {
            _this2.state[name] = 1;
            hasAllNamespaces = false;
            if (pending[name] === void 0)
              pending[name] = true;
            if (toLoad[name] === void 0)
              toLoad[name] = true;
            if (toLoadNamespaces[ns] === void 0)
              toLoadNamespaces[ns] = true;
          }
        });
        if (!hasAllNamespaces)
          toLoadLanguages[lng] = true;
      });
      if (Object.keys(toLoad).length || Object.keys(pending).length) {
        this.queue.push({
          pending,
          pendingCount: Object.keys(pending).length,
          loaded: {},
          errors: [],
          callback
        });
      }
      return {
        toLoad: Object.keys(toLoad),
        pending: Object.keys(pending),
        toLoadLanguages: Object.keys(toLoadLanguages),
        toLoadNamespaces: Object.keys(toLoadNamespaces)
      };
    }
  }, {
    key: "loaded",
    value: function loaded(name, err, data2) {
      var s2 = name.split("|");
      var lng = s2[0];
      var ns = s2[1];
      if (err)
        this.emit("failedLoading", lng, ns, err);
      if (data2) {
        this.store.addResourceBundle(lng, ns, data2);
      }
      this.state[name] = err ? -1 : 2;
      var loaded2 = {};
      this.queue.forEach(function(q2) {
        pushPath(q2.loaded, [lng], ns);
        removePending(q2, name);
        if (err)
          q2.errors.push(err);
        if (q2.pendingCount === 0 && !q2.done) {
          Object.keys(q2.loaded).forEach(function(l2) {
            if (!loaded2[l2])
              loaded2[l2] = {};
            var loadedKeys = q2.loaded[l2];
            if (loadedKeys.length) {
              loadedKeys.forEach(function(n2) {
                if (loaded2[l2][n2] === void 0)
                  loaded2[l2][n2] = true;
              });
            }
          });
          q2.done = true;
          if (q2.errors.length) {
            q2.callback(q2.errors);
          } else {
            q2.callback();
          }
        }
      });
      this.emit("loaded", loaded2);
      this.queue = this.queue.filter(function(q2) {
        return !q2.done;
      });
    }
  }, {
    key: "read",
    value: function read(lng, ns, fcName) {
      var _this3 = this;
      var tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
      var callback = arguments.length > 5 ? arguments[5] : void 0;
      if (!lng.length)
        return callback(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng,
          ns,
          fcName,
          tried,
          wait,
          callback
        });
        return;
      }
      this.readingCalls++;
      var resolver2 = function resolver3(err, data2) {
        _this3.readingCalls--;
        if (_this3.waitingReads.length > 0) {
          var next2 = _this3.waitingReads.shift();
          _this3.read(next2.lng, next2.ns, next2.fcName, next2.tried, next2.wait, next2.callback);
        }
        if (err && data2 && tried < _this3.maxRetries) {
          setTimeout(function() {
            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
          }, wait);
          return;
        }
        callback(err, data2);
      };
      var fc2 = this.backend[fcName].bind(this.backend);
      if (fc2.length === 2) {
        try {
          var r2 = fc2(lng, ns);
          if (r2 && typeof r2.then === "function") {
            r2.then(function(data2) {
              return resolver2(null, data2);
            })["catch"](resolver2);
          } else {
            resolver2(null, r2);
          }
        } catch (err) {
          resolver2(err);
        }
        return;
      }
      return fc2(lng, ns, resolver2);
    }
  }, {
    key: "prepareLoading",
    value: function prepareLoading(languages2, namespaces) {
      var _this4 = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var callback = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend) {
        this.logger.warn("No backend was added via i18next.use. Will not load resources.");
        return callback && callback();
      }
      if (typeof languages2 === "string")
        languages2 = this.languageUtils.toResolveHierarchy(languages2);
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      var toLoad = this.queueLoad(languages2, namespaces, options, callback);
      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length)
          callback();
        return null;
      }
      toLoad.toLoad.forEach(function(name) {
        _this4.loadOne(name);
      });
    }
  }, {
    key: "load",
    value: function load(languages2, namespaces, callback) {
      this.prepareLoading(languages2, namespaces, {}, callback);
    }
  }, {
    key: "reload",
    value: function reload(languages2, namespaces, callback) {
      this.prepareLoading(languages2, namespaces, {
        reload: true
      }, callback);
    }
  }, {
    key: "loadOne",
    value: function loadOne(name) {
      var _this5 = this;
      var prefix2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var s2 = name.split("|");
      var lng = s2[0];
      var ns = s2[1];
      this.read(lng, ns, "read", void 0, void 0, function(err, data2) {
        if (err)
          _this5.logger.warn("".concat(prefix2, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
        if (!err && data2)
          _this5.logger.log("".concat(prefix2, "loaded namespace ").concat(ns, " for language ").concat(lng), data2);
        _this5.loaded(name, err, data2);
      });
    }
  }, {
    key: "saveMissing",
    value: function saveMissing(languages2, namespace, key, fallbackValue, isUpdate) {
      var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      var clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : function() {
      };
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn('did not save key "'.concat(key, '" as the namespace "').concat(namespace, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (key === void 0 || key === null || key === "")
        return;
      if (this.backend && this.backend.create) {
        var opts = _objectSpread$1(_objectSpread$1({}, options), {}, {
          isUpdate
        });
        var fc2 = this.backend.create.bind(this.backend);
        if (fc2.length < 6) {
          try {
            var r2;
            if (fc2.length === 5) {
              r2 = fc2(languages2, namespace, key, fallbackValue, opts);
            } else {
              r2 = fc2(languages2, namespace, key, fallbackValue);
            }
            if (r2 && typeof r2.then === "function") {
              r2.then(function(data2) {
                return clb(null, data2);
              })["catch"](clb);
            } else {
              clb(null, r2);
            }
          } catch (err) {
            clb(err);
          }
        } else {
          fc2(languages2, namespace, key, fallbackValue, clb, opts);
        }
      }
      if (!languages2 || !languages2[0])
        return;
      this.store.addResource(languages2[0], namespace, key, fallbackValue);
    }
  }]);
  return Connector2;
}(EventEmitter);
function get() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: true,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle3(args) {
      var ret = {};
      if (_typeof(args[1]) === "object")
        ret = args[1];
      if (typeof args[1] === "string")
        ret.defaultValue = args[1];
      if (typeof args[2] === "string")
        ret.tDescription = args[2];
      if (_typeof(args[2]) === "object" || _typeof(args[3]) === "object") {
        var options = args[3] || args[2];
        Object.keys(options).forEach(function(key) {
          ret[key] = options[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format2(value, _format, lng, options) {
        return value;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: true
    }
  };
}
function transformOptions(options) {
  if (typeof options.ns === "string")
    options.ns = [options.ns];
  if (typeof options.fallbackLng === "string")
    options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === "string")
    options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
}
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function noop() {
}
function bindMemberFunctions(inst) {
  var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach(function(mem) {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}
var I18n = function(_EventEmitter) {
  _inherits(I18n2, _EventEmitter);
  var _super = _createSuper(I18n2);
  function I18n2() {
    var _this;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var callback = arguments.length > 1 ? arguments[1] : void 0;
    _classCallCheck(this, I18n2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.options = transformOptions(options);
    _this.services = {};
    _this.logger = baseLogger;
    _this.modules = {
      external: []
    };
    bindMemberFunctions(_assertThisInitialized(_this));
    if (callback && !_this.isInitialized && !options.isClone) {
      if (!_this.options.initImmediate) {
        _this.init(options, callback);
        return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
      }
      setTimeout(function() {
        _this.init(options, callback);
      }, 0);
    }
    return _this;
  }
  _createClass(I18n2, [{
    key: "init",
    value: function init3() {
      var _this2 = this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : void 0;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (!options.defaultNS && options.defaultNS !== false && options.ns) {
        if (typeof options.ns === "string") {
          options.defaultNS = options.ns;
        } else if (options.ns.indexOf("translation") < 0) {
          options.defaultNS = options.ns[0];
        }
      }
      var defOpts = get();
      this.options = _objectSpread(_objectSpread(_objectSpread({}, defOpts), this.options), transformOptions(options));
      if (this.options.compatibilityAPI !== "v1") {
        this.options.interpolation = _objectSpread(_objectSpread({}, defOpts.interpolation), this.options.interpolation);
      }
      if (options.keySeparator !== void 0) {
        this.options.userDefinedKeySeparator = options.keySeparator;
      }
      if (options.nsSeparator !== void 0) {
        this.options.userDefinedNsSeparator = options.nsSeparator;
      }
      function createClassOnDemand(ClassOrObject) {
        if (!ClassOrObject)
          return null;
        if (typeof ClassOrObject === "function")
          return new ClassOrObject();
        return ClassOrObject;
      }
      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }
        var formatter;
        if (this.modules.formatter) {
          formatter = this.modules.formatter;
        } else if (typeof Intl !== "undefined") {
          formatter = Formatter;
        }
        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s2 = this.services;
        s2.logger = baseLogger;
        s2.resourceStore = this.store;
        s2.languageUtils = lu;
        s2.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });
        if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
          s2.formatter = createClassOnDemand(formatter);
          s2.formatter.init(s2, this.options);
          this.options.interpolation.format = s2.formatter.format.bind(s2.formatter);
        }
        s2.interpolator = new Interpolator(this.options);
        s2.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s2.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s2.resourceStore, s2, this.options);
        s2.backendConnector.on("*", function(event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        if (this.modules.languageDetector) {
          s2.languageDetector = createClassOnDemand(this.modules.languageDetector);
          if (s2.languageDetector.init)
            s2.languageDetector.init(s2, this.options.detection, this.options);
        }
        if (this.modules.i18nFormat) {
          s2.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s2.i18nFormat.init)
            s2.i18nFormat.init(this);
        }
        this.translator = new Translator(this.services, this.options);
        this.translator.on("*", function(event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        this.modules.external.forEach(function(m2) {
          if (m2.init)
            m2.init(_this2);
        });
      }
      this.format = this.options.interpolation.format;
      if (!callback)
        callback = noop;
      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        if (codes.length > 0 && codes[0] !== "dev")
          this.options.lng = codes[0];
      }
      if (!this.services.languageDetector && !this.options.lng) {
        this.logger.warn("init: no languageDetector is used and no lng is defined");
      }
      var storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      storeApi.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store;
          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      storeApiChained.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store2;
          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);
          return _this2;
        };
      });
      var deferred = defer();
      var load = function load2() {
        var finish = function finish2(err, t2) {
          if (_this2.isInitialized && !_this2.initializedStoreOnce)
            _this2.logger.warn("init: i18next is already initialized. You should call init just once!");
          _this2.isInitialized = true;
          if (!_this2.options.isClone)
            _this2.logger.log("initialized", _this2.options);
          _this2.emit("initialized", _this2.options);
          deferred.resolve(t2);
          callback(err, t2);
        };
        if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized)
          return finish(null, _this2.t.bind(_this2));
        _this2.changeLanguage(_this2.options.lng, finish);
      };
      if (this.options.resources || !this.options.initImmediate) {
        load();
      } else {
        setTimeout(load, 0);
      }
      return deferred;
    }
  }, {
    key: "loadResources",
    value: function loadResources(language2) {
      var _this3 = this;
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
      var usedCallback = callback;
      var usedLng = typeof language2 === "string" ? language2 : this.language;
      if (typeof language2 === "function")
        usedCallback = language2;
      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === "cimode")
          return usedCallback();
        var toLoad = [];
        var append3 = function append4(lng) {
          if (!lng)
            return;
          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
          lngs.forEach(function(l2) {
            if (toLoad.indexOf(l2) < 0)
              toLoad.push(l2);
          });
        };
        if (!usedLng) {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function(l2) {
            return append3(l2);
          });
        } else {
          append3(usedLng);
        }
        if (this.options.preload) {
          this.options.preload.forEach(function(l2) {
            return append3(l2);
          });
        }
        this.services.backendConnector.load(toLoad, this.options.ns, function(e2) {
          if (!e2 && !_this3.resolvedLanguage && _this3.language)
            _this3.setResolvedLanguage(_this3.language);
          usedCallback(e2);
        });
      } else {
        usedCallback(null);
      }
    }
  }, {
    key: "reloadResources",
    value: function reloadResources(lngs, ns, callback) {
      var deferred = defer();
      if (!lngs)
        lngs = this.languages;
      if (!ns)
        ns = this.options.ns;
      if (!callback)
        callback = noop;
      this.services.backendConnector.reload(lngs, ns, function(err) {
        deferred.resolve();
        callback(err);
      });
      return deferred;
    }
  }, {
    key: "use",
    value: function use3(module) {
      if (!module)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!module.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      if (module.type === "backend") {
        this.modules.backend = module;
      }
      if (module.type === "logger" || module.log && module.warn && module.error) {
        this.modules.logger = module;
      }
      if (module.type === "languageDetector") {
        this.modules.languageDetector = module;
      }
      if (module.type === "i18nFormat") {
        this.modules.i18nFormat = module;
      }
      if (module.type === "postProcessor") {
        postProcessor.addPostProcessor(module);
      }
      if (module.type === "formatter") {
        this.modules.formatter = module;
      }
      if (module.type === "3rdParty") {
        this.modules.external.push(module);
      }
      return this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function setResolvedLanguage(l2) {
      if (!l2 || !this.languages)
        return;
      if (["cimode", "dev"].indexOf(l2) > -1)
        return;
      for (var li2 = 0; li2 < this.languages.length; li2++) {
        var lngInLngs = this.languages[li2];
        if (["cimode", "dev"].indexOf(lngInLngs) > -1)
          continue;
        if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
          this.resolvedLanguage = lngInLngs;
          break;
        }
      }
    }
  }, {
    key: "changeLanguage",
    value: function changeLanguage(lng, callback) {
      var _this4 = this;
      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit("languageChanging", lng);
      var setLngProps = function setLngProps2(l2) {
        _this4.language = l2;
        _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l2);
        _this4.resolvedLanguage = void 0;
        _this4.setResolvedLanguage(l2);
      };
      var done = function done2(err, l2) {
        if (l2) {
          setLngProps(l2);
          _this4.translator.changeLanguage(l2);
          _this4.isLanguageChangingTo = void 0;
          _this4.emit("languageChanged", l2);
          _this4.logger.log("languageChanged", l2);
        } else {
          _this4.isLanguageChangingTo = void 0;
        }
        deferred.resolve(function() {
          return _this4.t.apply(_this4, arguments);
        });
        if (callback)
          callback(err, function() {
            return _this4.t.apply(_this4, arguments);
          });
      };
      var setLng = function setLng2(lngs) {
        if (!lng && !lngs && _this4.services.languageDetector)
          lngs = [];
        var l2 = typeof lngs === "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
        if (l2) {
          if (!_this4.language) {
            setLngProps(l2);
          }
          if (!_this4.translator.language)
            _this4.translator.changeLanguage(l2);
          if (_this4.services.languageDetector && _this4.services.languageDetector.cacheUserLanguage)
            _this4.services.languageDetector.cacheUserLanguage(l2);
        }
        _this4.loadResources(l2, function(err) {
          done(err, l2);
        });
      };
      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        if (this.services.languageDetector.detect.length === 0) {
          this.services.languageDetector.detect().then(setLng);
        } else {
          this.services.languageDetector.detect(setLng);
        }
      } else {
        setLng(lng);
      }
      return deferred;
    }
  }, {
    key: "getFixedT",
    value: function getFixedT(lng, ns, keyPrefix) {
      var _this5 = this;
      var fixedT = function fixedT2(key, opts) {
        var options;
        if (_typeof(opts) !== "object") {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }
          options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else {
          options = _objectSpread({}, opts);
        }
        options.lng = options.lng || fixedT2.lng;
        options.lngs = options.lngs || fixedT2.lngs;
        options.ns = options.ns || fixedT2.ns;
        options.keyPrefix = options.keyPrefix || keyPrefix || fixedT2.keyPrefix;
        var keySeparator = _this5.options.keySeparator || ".";
        var resultKey;
        if (options.keyPrefix && Array.isArray(key)) {
          resultKey = key.map(function(k2) {
            return "".concat(options.keyPrefix).concat(keySeparator).concat(k2);
          });
        } else {
          resultKey = options.keyPrefix ? "".concat(options.keyPrefix).concat(keySeparator).concat(key) : key;
        }
        return _this5.t(resultKey, options);
      };
      if (typeof lng === "string") {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }
      fixedT.ns = ns;
      fixedT.keyPrefix = keyPrefix;
      return fixedT;
    }
  }, {
    key: "t",
    value: function t2() {
      var _this$translator;
      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function exists() {
      var _this$translator2;
      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function setDefaultNamespace(ns) {
      this.options.defaultNS = ns;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function hasLoadedNamespace2(ns) {
      var _this6 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized) {
        this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
        return false;
      }
      if (!this.languages || !this.languages.length) {
        this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
        return false;
      }
      var lng = options.lng || this.resolvedLanguage || this.languages[0];
      var fallbackLng = this.options ? this.options.fallbackLng : false;
      var lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === "cimode")
        return true;
      var loadNotPending = function loadNotPending2(l2, n2) {
        var loadState = _this6.services.backendConnector.state["".concat(l2, "|").concat(n2)];
        return loadState === -1 || loadState === 2;
      };
      if (options.precheck) {
        var preResult = options.precheck(this, loadNotPending);
        if (preResult !== void 0)
          return preResult;
      }
      if (this.hasResourceBundle(lng, ns))
        return true;
      if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages)
        return true;
      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
        return true;
      return false;
    }
  }, {
    key: "loadNamespaces",
    value: function loadNamespaces2(ns, callback) {
      var _this7 = this;
      var deferred = defer();
      if (!this.options.ns) {
        if (callback)
          callback();
        return Promise.resolve();
      }
      if (typeof ns === "string")
        ns = [ns];
      ns.forEach(function(n2) {
        if (_this7.options.ns.indexOf(n2) < 0)
          _this7.options.ns.push(n2);
      });
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback)
          callback(err);
      });
      return deferred;
    }
  }, {
    key: "loadLanguages",
    value: function loadLanguages2(lngs, callback) {
      var deferred = defer();
      if (typeof lngs === "string")
        lngs = [lngs];
      var preloaded = this.options.preload || [];
      var newLngs = lngs.filter(function(lng) {
        return preloaded.indexOf(lng) < 0;
      });
      if (!newLngs.length) {
        if (callback)
          callback();
        return Promise.resolve();
      }
      this.options.preload = preloaded.concat(newLngs);
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback)
          callback(err);
      });
      return deferred;
    }
  }, {
    key: "dir",
    value: function dir(lng) {
      if (!lng)
        lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
      if (!lng)
        return "rtl";
      var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
      var languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());
      return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
  }, {
    key: "cloneInstance",
    value: function cloneInstance() {
      var _this8 = this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
      var mergedOptions = _objectSpread(_objectSpread(_objectSpread({}, this.options), options), {
        isClone: true
      });
      var clone = new I18n2(mergedOptions);
      if (options.debug !== void 0 || options.prefix !== void 0) {
        clone.logger = clone.logger.clone(options);
      }
      var membersToCopy = ["store", "services", "language"];
      membersToCopy.forEach(function(m2) {
        clone[m2] = _this8[m2];
      });
      clone.services = _objectSpread({}, this.services);
      clone.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      };
      clone.translator = new Translator(clone.services, clone.options);
      clone.translator.on("*", function(event) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        clone.emit.apply(clone, [event].concat(args));
      });
      clone.init(mergedOptions, callback);
      clone.translator.options = clone.options;
      clone.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      };
      return clone;
    }
  }, {
    key: "toJSON",
    value: function toJSON2() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]);
  return I18n2;
}(EventEmitter);
_defineProperty$2(I18n, "createInstance", function() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var callback = arguments.length > 1 ? arguments[1] : void 0;
  return new I18n(options, callback);
});
var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.dir;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
instance.use(initReactI18next).init({
  // the translations
  // (tip move them in a JSON file and import them,
  // or even better, manage them via a UI: https://react.i18next.com/guides/multiple-translation-files#manage-your-translations-with-a-management-gui)
  resources: i18nTranslationResources || {},
  lng: language[defaultLanguage] || "zhCn",
  // if you're using a language detector, do not define the lng option
  fallbackLng: "zhCn",
  interpolation: {
    escapeValue: false
    // react already safes from xss => https://www.i18next.com/translation-function/interpolation#unescape
  }
}).then(() => console.log("IdolTime i18n Ready!"));
ReactDOM.render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trans, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Provider, { store: webgalStore, children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) }) }) }),
  document.getElementById("root")
);
export {
  Container$1 as C,
  Sprite as S,
  Texture as T,
  WebGAL as W,
  SCREEN_CONSTANTS as a,
  registerPerform as r
};
